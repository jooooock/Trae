var yc = function (t, e) {
  return (
    (yc =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (s, i) {
          s.__proto__ = i;
        }) ||
      function (s, i) {
        for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (s[n] = i[n]);
      }),
    yc(t, e)
  );
};
export function __extends(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  yc(t, e);
  function s() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : ((s.prototype = e.prototype), new s());
}
export var __assign = function () {
  return (
    (__assign =
      Object.assign ||
      function (e) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var r in s) Object.prototype.hasOwnProperty.call(s, r) && (e[r] = s[r]);
        }
        return e;
      }),
    __assign.apply(this, arguments)
  );
};
export function __rest(t, e) {
  var s = {};
  for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (s[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var n = 0, i = Object.getOwnPropertySymbols(t); n < i.length; n++) e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[n]) && (s[i[n]] = t[i[n]]);
  return s;
}
export function __decorate(t, e, s, i) {
  var n = arguments.length,
    r = n < 3 ? e : i === null ? (i = Object.getOwnPropertyDescriptor(e, s)) : i,
    o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(t, e, s, i);
  else for (var a = t.length - 1; a >= 0; a--) (o = t[a]) && (r = (n < 3 ? o(r) : n > 3 ? o(e, s, r) : o(e, s)) || r);
  return n > 3 && r && Object.defineProperty(e, s, r), r;
}
export function __param(t, e) {
  return function (s, i) {
    e(s, i, t);
  };
}
export function __esDecorate(t, e, s, i, n, r) {
  function o(v) {
    if (v !== void 0 && typeof v != "function") throw new TypeError("Function expected");
    return v;
  }
  for (
    var a = i.kind, c = a === "getter" ? "get" : a === "setter" ? "set" : "value", l = !e && t ? (i.static ? t : t.prototype) : null, h = e || (l ? Object.getOwnPropertyDescriptor(l, i.name) : {}), u, f = !1, d = s.length - 1;
    d >= 0;
    d--
  ) {
    var p = {};
    for (var g in i) p[g] = g === "access" ? {} : i[g];
    for (var g in i.access) p.access[g] = i.access[g];
    p.addInitializer = function (v) {
      if (f) throw new TypeError("Cannot add initializers after decoration has completed");
      r.push(o(v || null));
    };
    var m = (0, s[d])(a === "accessor" ? { get: h.get, set: h.set } : h[c], p);
    if (a === "accessor") {
      if (m === void 0) continue;
      if (m === null || typeof m != "object") throw new TypeError("Object expected");
      (u = o(m.get)) && (h.get = u), (u = o(m.set)) && (h.set = u), (u = o(m.init)) && n.unshift(u);
    } else (u = o(m)) && (a === "field" ? n.unshift(u) : (h[c] = u));
  }
  l && Object.defineProperty(l, i.name, h), (f = !0);
}
export function __runInitializers(t, e, s) {
  for (var i = arguments.length > 2, n = 0; n < e.length; n++) s = i ? e[n].call(t, s) : e[n].call(t);
  return i ? s : void 0;
}
export function __propKey(t) {
  return typeof t == "symbol" ? t : "".concat(t);
}
export function __setFunctionName(t, e, s) {
  return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: s ? "".concat(s, " ", e) : e });
}
export function __metadata(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
export function __awaiter(t, e, s, i) {
  function n(r) {
    return r instanceof s
      ? r
      : new s(function (o) {
          o(r);
        });
  }
  return new (s || (s = Promise))(function (r, o) {
    function a(h) {
      try {
        l(i.next(h));
      } catch (u) {
        o(u);
      }
    }
    function c(h) {
      try {
        l(i.throw(h));
      } catch (u) {
        o(u);
      }
    }
    function l(h) {
      h.done ? r(h.value) : n(h.value).then(a, c);
    }
    l((i = i.apply(t, e || [])).next());
  });
}
export function __generator(t, e) {
  var s = {
      label: 0,
      sent: function () {
        if (r[0] & 1) throw r[1];
        return r[1];
      },
      trys: [],
      ops: [],
    },
    i,
    n,
    r,
    o;
  return (
    (o = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(l) {
    return function (h) {
      return c([l, h]);
    };
  }
  function c(l) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; o && ((o = 0), l[0] && (s = 0)), s; )
      try {
        if (((i = 1), n && (r = l[0] & 2 ? n.return : l[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, l[1])).done)) return r;
        switch (((n = 0), r && (l = [l[0] & 2, r.value]), l[0])) {
          case 0:
          case 1:
            r = l;
            break;
          case 4:
            return s.label++, { value: l[1], done: !1 };
          case 5:
            s.label++, (n = l[1]), (l = [0]);
            continue;
          case 7:
            (l = s.ops.pop()), s.trys.pop();
            continue;
          default:
            if (((r = s.trys), !(r = r.length > 0 && r[r.length - 1]) && (l[0] === 6 || l[0] === 2))) {
              s = 0;
              continue;
            }
            if (l[0] === 3 && (!r || (l[1] > r[0] && l[1] < r[3]))) {
              s.label = l[1];
              break;
            }
            if (l[0] === 6 && s.label < r[1]) {
              (s.label = r[1]), (r = l);
              break;
            }
            if (r && s.label < r[2]) {
              (s.label = r[2]), s.ops.push(l);
              break;
            }
            r[2] && s.ops.pop(), s.trys.pop();
            continue;
        }
        l = e.call(t, s);
      } catch (h) {
        (l = [6, h]), (n = 0);
      } finally {
        i = r = 0;
      }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
export var __createBinding = Object.create
  ? function (t, e, s, i) {
      i === void 0 && (i = s);
      var n = Object.getOwnPropertyDescriptor(e, s);
      (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) &&
        (n = {
          enumerable: !0,
          get: function () {
            return e[s];
          },
        }),
        Object.defineProperty(t, i, n);
    }
  : function (t, e, s, i) {
      i === void 0 && (i = s), (t[i] = e[s]);
    };
export function __exportStar(t, e) {
  for (var s in t) s !== "default" && !Object.prototype.hasOwnProperty.call(e, s) && __createBinding(e, t, s);
}
export function __values(t) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    s = e && t[e],
    i = 0;
  if (s) return s.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function () {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      },
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
export function __read(t, e) {
  var s = typeof Symbol == "function" && t[Symbol.iterator];
  if (!s) return t;
  var i = s.call(t),
    n,
    r = [],
    o;
  try {
    for (; (e === void 0 || e-- > 0) && !(n = i.next()).done; ) r.push(n.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      n && !n.done && (s = i.return) && s.call(i);
    } finally {
      if (o) throw o.error;
    }
  }
  return r;
}
export function __spread() {
  for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(__read(arguments[e]));
  return t;
}
export function __spreadArrays() {
  for (var t = 0, e = 0, s = arguments.length; e < s; e++) t += arguments[e].length;
  for (var i = Array(t), n = 0, e = 0; e < s; e++) for (var r = arguments[e], o = 0, a = r.length; o < a; o++, n++) i[n] = r[o];
  return i;
}
export function __spreadArray(t, e, s) {
  if (s || arguments.length === 2) for (var i = 0, n = e.length, r; i < n; i++) (r || !(i in e)) && (r || (r = Array.prototype.slice.call(e, 0, i)), (r[i] = e[i]));
  return t.concat(r || Array.prototype.slice.call(e));
}
export function __await(t) {
  return this instanceof __await ? ((this.v = t), this) : new __await(t);
}
export function __asyncGenerator(t, e, s) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = s.apply(t, e || []),
    n,
    r = [];
  return (
    (n = {}),
    a("next"),
    a("throw"),
    a("return", o),
    (n[Symbol.asyncIterator] = function () {
      return this;
    }),
    n
  );
  function o(d) {
    return function (p) {
      return Promise.resolve(p).then(d, u);
    };
  }
  function a(d, p) {
    i[d] &&
      ((n[d] = function (g) {
        return new Promise(function (m, v) {
          r.push([d, g, m, v]) > 1 || c(d, g);
        });
      }),
      p && (n[d] = p(n[d])));
  }
  function c(d, p) {
    try {
      l(i[d](p));
    } catch (g) {
      f(r[0][3], g);
    }
  }
  function l(d) {
    d.value instanceof __await ? Promise.resolve(d.value.v).then(h, u) : f(r[0][2], d);
  }
  function h(d) {
    c("next", d);
  }
  function u(d) {
    c("throw", d);
  }
  function f(d, p) {
    d(p), r.shift(), r.length && c(r[0][0], r[0][1]);
  }
}
export function __asyncDelegator(t) {
  var e, s;
  return (
    (e = {}),
    i("next"),
    i("throw", function (n) {
      throw n;
    }),
    i("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function i(n, r) {
    e[n] = t[n]
      ? function (o) {
          return (s = !s) ? { value: __await(t[n](o)), done: !1 } : r ? r(o) : o;
        }
      : r;
  }
}
export function __asyncValues(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator],
    s;
  return e
    ? e.call(t)
    : ((t = typeof __values == "function" ? __values(t) : t[Symbol.iterator]()),
      (s = {}),
      i("next"),
      i("throw"),
      i("return"),
      (s[Symbol.asyncIterator] = function () {
        return this;
      }),
      s);
  function i(r) {
    s[r] =
      t[r] &&
      function (o) {
        return new Promise(function (a, c) {
          (o = t[r](o)), n(a, c, o.done, o.value);
        });
      };
  }
  function n(r, o, a, c) {
    Promise.resolve(c).then(function (l) {
      r({ value: l, done: a });
    }, o);
  }
}
export function __makeTemplateObject(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : (t.raw = e), t;
}
var mw = Object.create
  ? function (t, e) {
      Object.defineProperty(t, "default", { enumerable: !0, value: e });
    }
  : function (t, e) {
      t.default = e;
    };
export function __importStar(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var s in t) s !== "default" && Object.prototype.hasOwnProperty.call(t, s) && __createBinding(e, t, s);
  return mw(e, t), e;
}
export function __importDefault(t) {
  return t && t.__esModule ? t : { default: t };
}
export function __classPrivateFieldGet(t, e, s, i) {
  if (s === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return s === "m" ? i : s === "a" ? i.call(t) : i ? i.value : e.get(t);
}
export function __classPrivateFieldSet(t, e, s, i, n) {
  if (i === "m") throw new TypeError("Private method is not writable");
  if (i === "a" && !n) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? n.call(t, s) : n ? (n.value = s) : e.set(t, s), s;
}
export function __classPrivateFieldIn(t, e) {
  if (e === null || (typeof e != "object" && typeof e != "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof t == "function" ? e === t : t.has(e);
}
export function __addDisposableResource(t, e, s) {
  if (e != null) {
    if (typeof e != "object" && typeof e != "function") throw new TypeError("Object expected.");
    var i, n;
    if (s) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      i = e[Symbol.asyncDispose];
    }
    if (i === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      (i = e[Symbol.dispose]), s && (n = i);
    }
    if (typeof i != "function") throw new TypeError("Object not disposable.");
    n &&
      (i = function () {
        try {
          n.call(this);
        } catch (r) {
          return Promise.reject(r);
        }
      }),
      t.stack.push({ value: e, dispose: i, async: s });
  } else s && t.stack.push({ async: !0 });
  return e;
}
var ww =
  typeof SuppressedError == "function"
    ? SuppressedError
    : function (t, e, s) {
        var i = new Error(s);
        return (i.name = "SuppressedError"), (i.error = t), (i.suppressed = e), i;
      };
export function __disposeResources(t) {
  function e(i) {
    (t.error = t.hasError ? new ww(i, t.error, "An error was suppressed during disposal.") : i), (t.hasError = !0);
  }
  function s() {
    for (; t.stack.length; ) {
      var i = t.stack.pop();
      try {
        var n = i.dispose && i.dispose.call(i.value);
        if (i.async)
          return Promise.resolve(n).then(s, function (r) {
            return e(r), s();
          });
      } catch (r) {
        e(r);
      }
    }
    if (t.hasError) throw t.error;
  }
  return s();
}
export default {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
};
var vw = Object.create,
  Uf = Object.defineProperty,
  yw = Object.getOwnPropertyDescriptor,
  _f = Object.getOwnPropertyNames,
  bw = Object.getPrototypeOf,
  Ew = Object.prototype.hasOwnProperty,
  bc = ((t) => (typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(t, { get: (e, s) => (typeof require < "u" ? require : e)[s] }) : t))(function (t) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + t + '" is not supported');
  }),
  Sw = (t, e) =>
    function () {
      return e || (0, t[_f(t)[0]])((e = { exports: {} }).exports, e), e.exports;
    },
  $w = (t, e, s, i) => {
    if ((e && typeof e == "object") || typeof e == "function") for (let n of _f(e)) !Ew.call(t, n) && n !== s && Uf(t, n, { get: () => e[n], enumerable: !(i = yw(e, n)) || i.enumerable });
    return t;
  },
  xw = (t, e, s) => ((s = t != null ? vw(bw(t)) : {}), $w(e || !t || !t.__esModule ? Uf(s, "default", { value: t, enumerable: !0 }) : s, t)),
  Cw = Sw({
    "node_modules/minimist/index.js"(t, e) {
      "use strict";
      function s(r, o) {
        var a = r;
        o.slice(0, -1).forEach(function (l) {
          a = a[l] || {};
        });
        var c = o[o.length - 1];
        return c in a;
      }
      function i(r) {
        return typeof r == "number" || /^0x[0-9a-f]+$/i.test(r) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(r);
      }
      function n(r, o) {
        return (o === "constructor" && typeof r[o] == "function") || o === "__proto__";
      }
      e.exports = function (r, o) {
        o || (o = {});
        var a = { bools: {}, strings: {}, unknownFn: null };
        typeof o.unknown == "function" && (a.unknownFn = o.unknown),
          typeof o.boolean == "boolean" && o.boolean
            ? (a.allBools = !0)
            : []
                .concat(o.boolean)
                .filter(Boolean)
                .forEach(function (I) {
                  a.bools[I] = !0;
                });
        var c = {};
        function l(I) {
          return c[I].some(function (H) {
            return a.bools[H];
          });
        }
        Object.keys(o.alias || {}).forEach(function (I) {
          (c[I] = [].concat(o.alias[I])),
            c[I].forEach(function (H) {
              c[H] = [I].concat(
                c[I].filter(function (B) {
                  return H !== B;
                }),
              );
            });
        }),
          []
            .concat(o.string)
            .filter(Boolean)
            .forEach(function (I) {
              (a.strings[I] = !0),
                c[I] &&
                  [].concat(c[I]).forEach(function (H) {
                    a.strings[H] = !0;
                  });
            });
        var h = o.default || {},
          u = { _: [] };
        function f(I, H) {
          return (a.allBools && /^--[^=]+$/.test(H)) || a.strings[I] || a.bools[I] || c[I];
        }
        function d(I, H, B) {
          for (var j = I, Z = 0; Z < H.length - 1; Z++) {
            var A = H[Z];
            if (n(j, A)) return;
            j[A] === void 0 && (j[A] = {}), (j[A] === Object.prototype || j[A] === Number.prototype || j[A] === String.prototype) && (j[A] = {}), j[A] === Array.prototype && (j[A] = []), (j = j[A]);
          }
          var R = H[H.length - 1];
          n(j, R) ||
            ((j === Object.prototype || j === Number.prototype || j === String.prototype) && (j = {}),
            j === Array.prototype && (j = []),
            j[R] === void 0 || a.bools[R] || typeof j[R] == "boolean" ? (j[R] = B) : Array.isArray(j[R]) ? j[R].push(B) : (j[R] = [j[R], B]));
        }
        function p(I, H, B) {
          if (!(B && a.unknownFn && !f(I, B) && a.unknownFn(B) === !1)) {
            var j = !a.strings[I] && i(H) ? Number(H) : H;
            d(u, I.split("."), j),
              (c[I] || []).forEach(function (Z) {
                d(u, Z.split("."), j);
              });
          }
        }
        Object.keys(a.bools).forEach(function (I) {
          p(I, h[I] === void 0 ? !1 : h[I]);
        });
        var g = [];
        r.indexOf("--") !== -1 && ((g = r.slice(r.indexOf("--") + 1)), (r = r.slice(0, r.indexOf("--"))));
        for (var m = 0; m < r.length; m++) {
          var v = r[m],
            b,
            E;
          if (/^--.+=/.test(v)) {
            var $ = v.match(/^--([^=]+)=([\s\S]*)$/);
            b = $[1];
            var P = $[2];
            a.bools[b] && (P = P !== "false"), p(b, P, v);
          } else if (/^--no-.+/.test(v)) (b = v.match(/^--no-(.+)/)[1]), p(b, !1, v);
          else if (/^--.+/.test(v))
            (b = v.match(/^--(.+)/)[1]),
              (E = r[m + 1]),
              E !== void 0 && !/^(-|--)[^-]/.test(E) && !a.bools[b] && !a.allBools && (!c[b] || !l(b)) ? (p(b, E, v), (m += 1)) : /^(true|false)$/.test(E) ? (p(b, E === "true", v), (m += 1)) : p(b, a.strings[b] ? "" : !0, v);
          else if (/^-[^-]+/.test(v)) {
            for (var U = v.slice(1, -1).split(""), Q = !1, k = 0; k < U.length; k++) {
              if (((E = v.slice(k + 2)), E === "-")) {
                p(U[k], E, v);
                continue;
              }
              if (/[A-Za-z]/.test(U[k]) && E[0] === "=") {
                p(U[k], E.slice(1), v), (Q = !0);
                break;
              }
              if (/[A-Za-z]/.test(U[k]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(E)) {
                p(U[k], E, v), (Q = !0);
                break;
              }
              if (U[k + 1] && U[k + 1].match(/\W/)) {
                p(U[k], v.slice(k + 2), v), (Q = !0);
                break;
              } else p(U[k], a.strings[U[k]] ? "" : !0, v);
            }
            (b = v.slice(-1)[0]),
              !Q &&
                b !== "-" &&
                (r[m + 1] && !/^(-|--)[^-]/.test(r[m + 1]) && !a.bools[b] && (!c[b] || !l(b))
                  ? (p(b, r[m + 1], v), (m += 1))
                  : r[m + 1] && /^(true|false)$/.test(r[m + 1])
                    ? (p(b, r[m + 1] === "true", v), (m += 1))
                    : p(b, a.strings[b] ? "" : !0, v));
          } else if (((!a.unknownFn || a.unknownFn(v) !== !1) && u._.push(a.strings._ || !i(v) ? v : Number(v)), o.stopEarly)) {
            u._.push.apply(u._, r.slice(m + 1));
            break;
          }
        }
        return (
          Object.keys(h).forEach(function (I) {
            s(u, I.split(".")) ||
              (d(u, I.split("."), h[I]),
              (c[I] || []).forEach(function (H) {
                d(u, H.split("."), h[I]);
              }));
          }),
          o["--"]
            ? (u["--"] = g.slice())
            : g.forEach(function (I) {
                u._.push(I);
              }),
          u
        );
      };
    },
  });
import { hostname as kw, release as Dw } from "os";
function Iw(t, e, s = 0, i = t.length) {
  let n = s,
    r = i;
  for (; n < r; ) {
    const o = Math.floor((n + r) / 2);
    e(t[o]) ? (n = o + 1) : (r = o);
  }
  return n - 1;
}
var _6 = class _m {
    static {
      this.assertInvariants = !1;
    }
    constructor(e) {
      (this.e = e), (this.c = 0);
    }
    findLastMonotonous(e) {
      if (_m.assertInvariants) {
        if (this.d) {
          for (const i of this.e) if (this.d(i) && !e(i)) throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
        }
        this.d = e;
      }
      const s = Iw(this.e, e, this.c);
      return (this.c = s + 1), s === -1 ? void 0 : this.e[s];
    }
  },
  Rw = class {
    constructor() {
      (this.b = []),
        (this.a = function (t) {
          setTimeout(() => {
            throw t.stack
              ? Si.isErrorNoTelemetry(t)
                ? new Si(
                    t.message +
                      `

` +
                      t.stack,
                  )
                : new Error(
                    t.message +
                      `

` +
                      t.stack,
                  )
              : t;
          }, 0);
        });
    }
    addListener(t) {
      return (
        this.b.push(t),
        () => {
          this.d(t);
        }
      );
    }
    c(t) {
      this.b.forEach((e) => {
        e(t);
      });
    }
    d(t) {
      this.b.splice(this.b.indexOf(t), 1);
    }
    setUnexpectedErrorHandler(t) {
      this.a = t;
    }
    getUnexpectedErrorHandler() {
      return this.a;
    }
    onUnexpectedError(t) {
      this.a(t), this.c(t);
    }
    onUnexpectedExternalError(t) {
      this.a(t);
    }
  },
  Bf = new Rw();
function Pw(t) {
  Bf.setUnexpectedErrorHandler(t);
}
function rt(t) {
  Fs(t) || Bf.onUnexpectedError(t);
}
var ho = "Canceled";
function Fs(t) {
  return t instanceof ot ? !0 : t instanceof Error && t.name === ho && t.message === ho;
}
var ot = class extends Error {
  constructor() {
    super(ho), (this.name = this.message);
  }
};
function uo() {
  const t = new Error(ho);
  return (t.name = t.message), t;
}
function zf(t) {
  return t ? new Error(`Illegal state: ${t}`) : new Error("Illegal state");
}
function ve(t) {
  return t
    ? t.message
      ? t.message
      : t.stack
        ? t.stack.split(`
`)[0]
        : String(t)
    : "Error";
}
var Si = class If extends Error {
  constructor(e) {
    super(e), (this.name = "CodeExpectedError");
  }
  static fromError(e) {
    if (e instanceof If) return e;
    const s = new If();
    return (s.message = e.message), (s.stack = e.stack), s;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
};
function _t(t, e, s = (i, n) => i === n) {
  if (t === e) return !0;
  if (!t || !e || t.length !== e.length) return !1;
  for (let i = 0, n = t.length; i < n; i++) if (!s(t[i], e[i])) return !1;
  return !0;
}
function nn(t) {
  return t.filter((e) => !!e);
}
function Xn(t) {
  return Array.isArray(t) && t.length > 0;
}
function Bt(t, e = (s) => s) {
  const s = new Set();
  return t.filter((i) => {
    const n = e(i);
    return s.has(n) ? !1 : (s.add(n), !0);
  });
}
function qf(t, e) {
  return t.push(e), () => Aw(t, e);
}
function Aw(t, e) {
  const s = t.indexOf(e);
  if (s > -1) return t.splice(s, 1), e;
}
function Vf(t, e) {
  let s;
  if (typeof e == "number") {
    let i = e;
    s = () => {
      const n = Math.sin(i++) * 179426549;
      return n - Math.floor(n);
    };
  } else s = Math.random;
  for (let i = t.length - 1; i > 0; i -= 1) {
    const n = Math.floor(s() * (i + 1)),
      r = t[i];
    (t[i] = t[n]), (t[n] = r);
  }
}
function Ow(t) {
  return t[Math.floor(Math.random() * t.length)];
}
var Ec;
(function (t) {
  function e(r) {
    return r < 0;
  }
  t.isLessThan = e;
  function s(r) {
    return r <= 0;
  }
  t.isLessThanOrEqual = s;
  function i(r) {
    return r > 0;
  }
  t.isGreaterThan = i;
  function n(r) {
    return r === 0;
  }
  (t.isNeitherLessOrGreaterThan = n), (t.greaterThan = 1), (t.lessThan = -1), (t.neitherLessOrGreaterThan = 0);
})(Ec || (Ec = {}));
function Lw(t, e) {
  return (s, i) => e(t(s), t(i));
}
var Nw = (t, e) => t - e,
  B6 = class ac {
    static {
      this.empty = new ac((e) => {});
    }
    constructor(e) {
      this.iterate = e;
    }
    forEach(e) {
      this.iterate((s) => (e(s), !0));
    }
    toArray() {
      const e = [];
      return this.iterate((s) => (e.push(s), !0)), e;
    }
    filter(e) {
      return new ac((s) => this.iterate((i) => (e(i) ? s(i) : !0)));
    }
    map(e) {
      return new ac((s) => this.iterate((i) => s(e(i))));
    }
    some(e) {
      let s = !1;
      return this.iterate((i) => ((s = e(i)), !s)), s;
    }
    findFirst(e) {
      let s;
      return this.iterate((i) => (e(i) ? ((s = i), !1) : !0)), s;
    }
    findLast(e) {
      let s;
      return this.iterate((i) => (e(i) && (s = i), !0)), s;
    }
    findLastMaxBy(e) {
      let s,
        i = !0;
      return this.iterate((n) => ((i || Ec.isGreaterThan(e(n, s))) && ((i = !1), (s = n)), !0)), s;
    }
  };
function _e(t) {
  return typeof t == "string";
}
function Ke(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date);
}
function Tw(t) {
  const e = Object.getPrototypeOf(Uint8Array);
  return typeof t == "object" && t instanceof e;
}
function Sc(t) {
  return typeof t == "number" && !isNaN(t);
}
function Ms(t) {
  return t === !0 || t === !1;
}
function Ct(t) {
  return typeof t > "u";
}
function mt(t) {
  return Ct(t) || t === null;
}
function jw(t, e) {
  if (!t) throw new Error(e ? `Unexpected type, expected '${e}'` : "Unexpected type");
}
function ls(t) {
  if (mt(t)) throw new Error("Assertion Failed: argument is undefined or null");
  return t;
}
var Fw = Object.prototype.hasOwnProperty;
function $c(t) {
  if (!Ke(t)) return !1;
  for (const e in t) if (Fw.call(t, e)) return !1;
  return !0;
}
function xc(t) {
  return typeof t == "function";
}
function Mw(t, e) {
  const s = Math.min(t.length, e.length);
  for (let i = 0; i < s; i++) Uw(t[i], e[i]);
}
function Uw(t, e) {
  if (_e(e)) {
    if (typeof t !== e) throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (xc(e)) {
    try {
      if (t instanceof e) return;
    } catch {}
    if ((!mt(t) && t.constructor === e) || (e.length === 1 && e.call(void 0, t) === !0)) return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
function _w() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function Wf() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
var Bw = Wf() === "pseudo" || (typeof document < "u" && document.location && typeof document.location.hash == "string" && document.location.hash.indexOf("pseudo=true") >= 0);
function fo(t, e) {
  let s;
  return (
    e.length === 0
      ? (s = t)
      : (s = t.replace(/\{(\d+)\}/g, (i, n) => {
          const r = n[0],
            o = e[r];
          let a = i;
          return typeof o == "string" ? (a = o) : (typeof o == "number" || typeof o == "boolean" || o === void 0 || o === null) && (a = String(o)), a;
        })),
    Bw && (s = "\uFF3B" + s.replace(/[aouei]/g, "$&$&") + "\uFF3D"),
    s
  );
}
function w(t, e, ...s) {
  return fo(typeof t == "number" ? Hf(t, e) : e, s);
}
function Hf(t, e) {
  const s = _w()?.[t];
  if (typeof s != "string") {
    if (typeof e == "string") return e;
    throw new Error(`!!! NLS MISSING: ${t} !!!`);
  }
  return s;
}
function Gf(t, e, ...s) {
  let i;
  typeof t == "number" ? (i = Hf(t, e)) : (i = e);
  const n = fo(i, s);
  return { value: n, original: e === i ? n : fo(e, s) };
}
function Cc(t, e) {
  return e && (t.stack || t.stacktrace) ? w(112, null, Kf(t), Jf(t.stack) || Jf(t.stacktrace)) : Kf(t);
}
function Jf(t) {
  return Array.isArray(t)
    ? t.join(`
`)
    : t;
}
function Kf(t) {
  return t.code === "ERR_UNC_HOST_NOT_ALLOWED"
    ? `${t.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`
    : typeof t.code == "string" && typeof t.errno == "number" && typeof t.syscall == "string"
      ? w(113, null, t.message)
      : t.message || w(114, null);
}
function Xe(t = null, e = !1) {
  if (!t) return w(115, null);
  if (Array.isArray(t)) {
    const s = nn(t),
      i = Xe(s[0], e);
    return s.length > 1 ? w(116, null, i, s.length) : i;
  }
  if (_e(t)) return t;
  if (t.detail) {
    const s = t.detail;
    if (s.error) return Cc(s.error, e);
    if (s.exception) return Cc(s.exception, e);
  }
  return t.stack ? Cc(t, e) : t.message ? t.message : w(117, null);
}
var Xf;
function zw(t, e) {
  const s = Object.create(null);
  for (const i of t) {
    const n = e(i);
    let r = s[n];
    r || (r = s[n] = []), r.push(i);
  }
  return s;
}
var z6 = class {
    static {
      Xf = Symbol.toStringTag;
    }
    constructor(t, e) {
      (this.b = e), (this.a = new Map()), (this[Xf] = "SetWithKey");
      for (const s of t) this.add(s);
    }
    get size() {
      return this.a.size;
    }
    add(t) {
      const e = this.b(t);
      return this.a.set(e, t), this;
    }
    delete(t) {
      return this.a.delete(this.b(t));
    }
    has(t) {
      return this.a.has(this.b(t));
    }
    *entries() {
      for (const t of this.a.values()) yield [t, t];
    }
    keys() {
      return this.values();
    }
    *values() {
      for (const t of this.a.values()) yield t;
    }
    clear() {
      this.a.clear();
    }
    forEach(t, e) {
      this.a.forEach((s) => t.call(e, s, s, this));
    }
    [Symbol.iterator]() {
      return this.values();
    }
  },
  Qf,
  Yf,
  Zf,
  qw = class {
    constructor(t, e) {
      (this.uri = t), (this.value = e);
    }
  };
function Vw(t) {
  return Array.isArray(t);
}
var kt = class Xr {
    static {
      this.c = (e) => e.toString();
    }
    constructor(e, s) {
      if (((this[Qf] = "ResourceMap"), e instanceof Xr)) (this.d = new Map(e.d)), (this.e = s ?? Xr.c);
      else if (Vw(e)) {
        (this.d = new Map()), (this.e = s ?? Xr.c);
        for (const [i, n] of e) this.set(i, n);
      } else (this.d = new Map()), (this.e = e ?? Xr.c);
    }
    set(e, s) {
      return this.d.set(this.e(e), new qw(e, s)), this;
    }
    get(e) {
      return this.d.get(this.e(e))?.value;
    }
    has(e) {
      return this.d.has(this.e(e));
    }
    get size() {
      return this.d.size;
    }
    clear() {
      this.d.clear();
    }
    delete(e) {
      return this.d.delete(this.e(e));
    }
    forEach(e, s) {
      typeof s < "u" && (e = e.bind(s));
      for (const [i, n] of this.d) e(n.value, n.uri, this);
    }
    *values() {
      for (const e of this.d.values()) yield e.value;
    }
    *keys() {
      for (const e of this.d.values()) yield e.uri;
    }
    *entries() {
      for (const e of this.d.values()) yield [e.uri, e.value];
    }
    *[((Qf = Symbol.toStringTag), Symbol.iterator)]() {
      for (const [, e] of this.d) yield [e.uri, e.value];
    }
  },
  kc = class {
    constructor(t, e) {
      (this[Yf] = "ResourceSet"), !t || typeof t == "function" ? (this.c = new kt(t)) : ((this.c = new kt(e)), t.forEach(this.add, this));
    }
    get size() {
      return this.c.size;
    }
    add(t) {
      return this.c.set(t, t), this;
    }
    clear() {
      this.c.clear();
    }
    delete(t) {
      return this.c.delete(t);
    }
    forEach(t, e) {
      this.c.forEach((s, i) => t.call(e, i, i, this));
    }
    has(t) {
      return this.c.has(t);
    }
    entries() {
      return this.c.entries();
    }
    keys() {
      return this.c.keys();
    }
    values() {
      return this.c.keys();
    }
    [((Yf = Symbol.toStringTag), Symbol.iterator)]() {
      return this.keys();
    }
  },
  ed;
(function (t) {
  (t[(t.None = 0)] = "None"), (t[(t.AsOld = 1)] = "AsOld"), (t[(t.AsNew = 2)] = "AsNew");
})(ed || (ed = {}));
var Ww = class {
    constructor() {
      (this[Zf] = "LinkedMap"), (this.c = new Map()), (this.d = void 0), (this.e = void 0), (this.f = 0), (this.g = 0);
    }
    clear() {
      this.c.clear(), (this.d = void 0), (this.e = void 0), (this.f = 0), this.g++;
    }
    isEmpty() {
      return !this.d && !this.e;
    }
    get size() {
      return this.f;
    }
    get first() {
      return this.d?.value;
    }
    get last() {
      return this.e?.value;
    }
    has(t) {
      return this.c.has(t);
    }
    get(t, e = 0) {
      const s = this.c.get(t);
      if (s) return e !== 0 && this.m(s, e), s.value;
    }
    set(t, e, s = 0) {
      let i = this.c.get(t);
      if (i) (i.value = e), s !== 0 && this.m(i, s);
      else {
        switch (((i = { key: t, value: e, next: void 0, previous: void 0 }), s)) {
          case 0:
            this.k(i);
            break;
          case 1:
            this.j(i);
            break;
          case 2:
            this.k(i);
            break;
          default:
            this.k(i);
            break;
        }
        this.c.set(t, i), this.f++;
      }
      return this;
    }
    delete(t) {
      return !!this.remove(t);
    }
    remove(t) {
      const e = this.c.get(t);
      if (e) return this.c.delete(t), this.l(e), this.f--, e.value;
    }
    shift() {
      if (!this.d && !this.e) return;
      if (!this.d || !this.e) throw new Error("Invalid list");
      const t = this.d;
      return this.c.delete(t.key), this.l(t), this.f--, t.value;
    }
    forEach(t, e) {
      const s = this.g;
      let i = this.d;
      for (; i; ) {
        if ((e ? t.bind(e)(i.value, i.key, this) : t(i.value, i.key, this), this.g !== s)) throw new Error("LinkedMap got modified during iteration.");
        i = i.next;
      }
    }
    keys() {
      const t = this,
        e = this.g;
      let s = this.d;
      const i = {
        [Symbol.iterator]() {
          return i;
        },
        next() {
          if (t.g !== e) throw new Error("LinkedMap got modified during iteration.");
          if (s) {
            const n = { value: s.key, done: !1 };
            return (s = s.next), n;
          } else return { value: void 0, done: !0 };
        },
      };
      return i;
    }
    values() {
      const t = this,
        e = this.g;
      let s = this.d;
      const i = {
        [Symbol.iterator]() {
          return i;
        },
        next() {
          if (t.g !== e) throw new Error("LinkedMap got modified during iteration.");
          if (s) {
            const n = { value: s.value, done: !1 };
            return (s = s.next), n;
          } else return { value: void 0, done: !0 };
        },
      };
      return i;
    }
    entries() {
      const t = this,
        e = this.g;
      let s = this.d;
      const i = {
        [Symbol.iterator]() {
          return i;
        },
        next() {
          if (t.g !== e) throw new Error("LinkedMap got modified during iteration.");
          if (s) {
            const n = { value: [s.key, s.value], done: !1 };
            return (s = s.next), n;
          } else return { value: void 0, done: !0 };
        },
      };
      return i;
    }
    [((Zf = Symbol.toStringTag), Symbol.iterator)]() {
      return this.entries();
    }
    h(t) {
      if (t >= this.size) return;
      if (t === 0) {
        this.clear();
        return;
      }
      let e = this.d,
        s = this.size;
      for (; e && s > t; ) this.c.delete(e.key), (e = e.next), s--;
      (this.d = e), (this.f = s), e && (e.previous = void 0), this.g++;
    }
    i(t) {
      if (t >= this.size) return;
      if (t === 0) {
        this.clear();
        return;
      }
      let e = this.e,
        s = this.size;
      for (; e && s > t; ) this.c.delete(e.key), (e = e.previous), s--;
      (this.e = e), (this.f = s), e && (e.next = void 0), this.g++;
    }
    j(t) {
      if (!this.d && !this.e) this.e = t;
      else if (this.d) (t.next = this.d), (this.d.previous = t);
      else throw new Error("Invalid list");
      (this.d = t), this.g++;
    }
    k(t) {
      if (!this.d && !this.e) this.d = t;
      else if (this.e) (t.previous = this.e), (this.e.next = t);
      else throw new Error("Invalid list");
      (this.e = t), this.g++;
    }
    l(t) {
      if (t === this.d && t === this.e) (this.d = void 0), (this.e = void 0);
      else if (t === this.d) {
        if (!t.next) throw new Error("Invalid list");
        (t.next.previous = void 0), (this.d = t.next);
      } else if (t === this.e) {
        if (!t.previous) throw new Error("Invalid list");
        (t.previous.next = void 0), (this.e = t.previous);
      } else {
        const e = t.next,
          s = t.previous;
        if (!e || !s) throw new Error("Invalid list");
        (e.previous = s), (s.next = e);
      }
      (t.next = void 0), (t.previous = void 0), this.g++;
    }
    m(t, e) {
      if (!this.d || !this.e) throw new Error("Invalid list");
      if (!(e !== 1 && e !== 2)) {
        if (e === 1) {
          if (t === this.d) return;
          const s = t.next,
            i = t.previous;
          t === this.e ? ((i.next = void 0), (this.e = i)) : ((s.previous = i), (i.next = s)), (t.previous = void 0), (t.next = this.d), (this.d.previous = t), (this.d = t), this.g++;
        } else if (e === 2) {
          if (t === this.e) return;
          const s = t.next,
            i = t.previous;
          t === this.d ? ((s.previous = void 0), (this.d = s)) : ((s.previous = i), (i.next = s)), (t.next = void 0), (t.previous = this.e), (this.e.next = t), (this.e = t), this.g++;
        }
      }
    }
    toJSON() {
      const t = [];
      return (
        this.forEach((e, s) => {
          t.push([s, e]);
        }),
        t
      );
    }
    fromJSON(t) {
      this.clear();
      for (const [e, s] of t) this.set(e, s);
    }
  },
  Hw = class extends Ww {
    constructor(t, e = 1) {
      super(), (this.n = t), (this.o = Math.min(Math.max(0, e), 1));
    }
    get limit() {
      return this.n;
    }
    set limit(t) {
      (this.n = t), this.p();
    }
    get ratio() {
      return this.o;
    }
    set ratio(t) {
      (this.o = Math.min(Math.max(0, t), 1)), this.p();
    }
    get(t, e = 2) {
      return super.get(t, e);
    }
    peek(t) {
      return super.get(t, 0);
    }
    set(t, e) {
      return super.set(t, e, 2), this;
    }
    p() {
      this.size > this.n && this.q(Math.round(this.n * this.o));
    }
  },
  Dc = class extends Hw {
    constructor(t, e = 1) {
      super(t, e);
    }
    q(t) {
      this.h(t);
    }
    set(t, e) {
      return super.set(t, e), this.p(), this;
    }
  },
  Gw = class {
    constructor() {
      this.c = new Map();
    }
    add(t, e) {
      let s = this.c.get(t);
      s || ((s = new Set()), this.c.set(t, s)), s.add(e);
    }
    delete(t, e) {
      const s = this.c.get(t);
      s && (s.delete(e), s.size === 0 && this.c.delete(t));
    }
    forEach(t, e) {
      const s = this.c.get(t);
      s && s.forEach(e);
    }
    get(t) {
      const e = this.c.get(t);
      return e || new Set();
    }
  };
function Ic(t, e) {
  const s = this;
  let i = !1,
    n;
  return function () {
    if (i) return n;
    if (((i = !0), e))
      try {
        n = t.apply(s, arguments);
      } finally {
        e();
      }
    else n = t.apply(s, arguments);
    return n;
  };
}
var $i;
(function (t) {
  function e($) {
    return $ && typeof $ == "object" && typeof $[Symbol.iterator] == "function";
  }
  t.is = e;
  const s = Object.freeze([]);
  function i() {
    return s;
  }
  t.empty = i;
  function* n($) {
    yield $;
  }
  t.single = n;
  function r($) {
    return e($) ? $ : n($);
  }
  t.wrap = r;
  function o($) {
    return $ || s;
  }
  t.from = o;
  function* a($) {
    for (let P = $.length - 1; P >= 0; P--) yield $[P];
  }
  t.reverse = a;
  function c($) {
    return !$ || $[Symbol.iterator]().next().done === !0;
  }
  t.isEmpty = c;
  function l($) {
    return $[Symbol.iterator]().next().value;
  }
  t.first = l;
  function h($, P) {
    let U = 0;
    for (const Q of $) if (P(Q, U++)) return !0;
    return !1;
  }
  t.some = h;
  function u($, P) {
    for (const U of $) if (P(U)) return U;
  }
  t.find = u;
  function* f($, P) {
    for (const U of $) P(U) && (yield U);
  }
  t.filter = f;
  function* d($, P) {
    let U = 0;
    for (const Q of $) yield P(Q, U++);
  }
  t.map = d;
  function* p($, P) {
    let U = 0;
    for (const Q of $) yield* P(Q, U++);
  }
  t.flatMap = p;
  function* g(...$) {
    for (const P of $) yield* P;
  }
  t.concat = g;
  function m($, P, U) {
    let Q = U;
    for (const k of $) Q = P(Q, k);
    return Q;
  }
  t.reduce = m;
  function* v($, P, U = $.length) {
    for (P < -$.length && (P = 0), P < 0 && (P += $.length), U < 0 ? (U += $.length) : U > $.length && (U = $.length); P < U; P++) yield $[P];
  }
  t.slice = v;
  function b($, P = Number.POSITIVE_INFINITY) {
    const U = [];
    if (P === 0) return [U, $];
    const Q = $[Symbol.iterator]();
    for (let k = 0; k < P; k++) {
      const I = Q.next();
      if (I.done) return [U, t.empty()];
      U.push(I.value);
    }
    return [
      U,
      {
        [Symbol.iterator]() {
          return Q;
        },
      },
    ];
  }
  t.consume = b;
  async function E($) {
    const P = [];
    for await (const U of $) P.push(U);
    return Promise.resolve(P);
  }
  t.asyncToArray = E;
})($i || ($i = {}));
var Jw = !1,
  rn = null,
  q6 = class Bm {
    constructor() {
      this.b = new Map();
    }
    static {
      this.a = 0;
    }
    c(e) {
      let s = this.b.get(e);
      return s || ((s = { parent: null, source: null, isSingleton: !1, value: e, idx: Bm.a++ }), this.b.set(e, s)), s;
    }
    trackDisposable(e) {
      const s = this.c(e);
      s.source || (s.source = new Error().stack);
    }
    setParent(e, s) {
      const i = this.c(e);
      i.parent = s;
    }
    markAsDisposed(e) {
      this.b.delete(e);
    }
    markAsSingleton(e) {
      this.c(e).isSingleton = !0;
    }
    f(e, s) {
      const i = s.get(e);
      if (i) return i;
      const n = e.parent ? this.f(this.c(e.parent), s) : e;
      return s.set(e, n), n;
    }
    getTrackedDisposables() {
      const e = new Map();
      return [...this.b.entries()].filter(([, i]) => i.source !== null && !this.f(i, e).isSingleton).flatMap(([i]) => i);
    }
    computeLeakingDisposables(e = 10, s) {
      let i;
      if (s) i = s;
      else {
        const c = new Map(),
          l = [...this.b.values()].filter((u) => u.source !== null && !this.f(u, c).isSingleton);
        if (l.length === 0) return;
        const h = new Set(l.map((u) => u.value));
        if (((i = l.filter((u) => !(u.parent && h.has(u.parent)))), i.length === 0)) throw new Error("There are cyclic diposable chains!");
      }
      if (!i) return;
      function n(c) {
        function l(u, f) {
          for (; u.length > 0 && f.some((d) => (typeof d == "string" ? d === u[0] : u[0].match(d))); ) u.shift();
        }
        const h = c.source
          .split(
            `
`,
          )
          .map((u) => u.trim().replace("at ", ""))
          .filter((u) => u !== "");
        return l(h, ["Error", /^trackDisposable \(.*\)$/, /^DisposableTracker.trackDisposable \(.*\)$/]), h.reverse();
      }
      const r = new Gw();
      for (const c of i) {
        const l = n(c);
        for (let h = 0; h <= l.length; h++)
          r.add(
            l.slice(0, h).join(`
`),
            c,
          );
      }
      i.sort(Lw((c) => c.idx, Nw));
      let o = "",
        a = 0;
      for (const c of i.slice(0, e)) {
        a++;
        const l = n(c),
          h = [];
        for (let u = 0; u < l.length; u++) {
          let f = l[u];
          f = `(shared with ${
            r.get(
              l.slice(0, u + 1).join(`
`),
            ).size
          }/${i.length} leaks) at ${f}`;
          const p = r.get(
              l.slice(0, u).join(`
`),
            ),
            g = zw(
              [...p].map((m) => n(m)[u]),
              (m) => m,
            );
          delete g[l[u]];
          for (const [m, v] of Object.entries(g)) h.unshift(`    - stacktraces of ${v.length} other leaks continue with ${m}`);
          h.unshift(f);
        }
        o += `


==================== Leaking disposable ${a}/${i.length}: ${c.value.constructor.name} ====================
${h.join(`
`)}
============================================================

`;
      }
      return (
        i.length > e &&
          (o += `


... and ${i.length - e} more leaking disposables

`),
        { leaks: i, details: o }
      );
    }
  };
function Kw(t) {
  rn = t;
}
if (Jw) {
  const t = "__is_disposable_tracked__";
  Kw(
    new (class {
      trackDisposable(e) {
        const s = new Error("Potentially leaked disposable").stack;
        setTimeout(() => {
          e[t] || console.log(s);
        }, 3e3);
      }
      setParent(e, s) {
        if (e && e !== O.None)
          try {
            e[t] = !0;
          } catch {}
      }
      markAsDisposed(e) {
        if (e && e !== O.None)
          try {
            e[t] = !0;
          } catch {}
      }
      markAsSingleton(e) {}
    })(),
  );
}
function Qn(t) {
  return rn?.trackDisposable(t), t;
}
function Yn(t) {
  rn?.markAsDisposed(t);
}
function Zn(t, e) {
  rn?.setParent(t, e);
}
function Xw(t, e) {
  if (rn) for (const s of t) rn.setParent(s, e);
}
function td(t) {
  return typeof t == "object" && t !== null && typeof t.dispose == "function" && t.dispose.length === 0;
}
function Xt(t) {
  if ($i.is(t)) {
    const e = [];
    for (const s of t)
      if (s)
        try {
          s.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1) throw e[0];
    if (e.length > 1) throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(t) ? [] : t;
  } else if (t) return t.dispose(), t;
}
function Rc(...t) {
  const e = ue(() => Xt(t));
  return Xw(t, e), e;
}
function ue(t) {
  const e = Qn({
    dispose: Ic(() => {
      Yn(e), t();
    }),
  });
  return e;
}
var ye = class zm {
    static {
      this.DISABLE_DISPOSED_WARNING = !1;
    }
    constructor() {
      (this.f = new Set()), (this.g = !1), Qn(this);
    }
    dispose() {
      this.g || (Yn(this), (this.g = !0), this.clear());
    }
    get isDisposed() {
      return this.g;
    }
    clear() {
      if (this.f.size !== 0)
        try {
          Xt(this.f);
        } finally {
          this.f.clear();
        }
    }
    add(e) {
      if (!e) return e;
      if (e === this) throw new Error("Cannot register a disposable on itself!");
      return Zn(e, this), this.g ? zm.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this.f.add(e), e;
    }
    delete(e) {
      if (e) {
        if (e === this) throw new Error("Cannot dispose a disposable on itself!");
        this.f.delete(e), e.dispose();
      }
    }
    deleteAndLeak(e) {
      e && this.f.has(e) && (this.f.delete(e), Zn(e, null));
    }
  },
  O = class {
    static {
      this.None = Object.freeze({ dispose() {} });
    }
    constructor() {
      (this.q = new ye()), Qn(this), Zn(this.q, this);
    }
    dispose() {
      Yn(this), this.q.dispose();
    }
    B(t) {
      if (t === this) throw new Error("Cannot register a disposable on itself!");
      return this.q.add(t);
    }
  },
  Es = class {
    constructor() {
      (this.b = !1), Qn(this);
    }
    get value() {
      return this.b ? void 0 : this.a;
    }
    set value(t) {
      this.b || t === this.a || (this.a?.dispose(), t && Zn(t, this), (this.a = t));
    }
    clear() {
      this.value = void 0;
    }
    dispose() {
      (this.b = !0), Yn(this), this.a?.dispose(), (this.a = void 0);
    }
    clearAndLeak() {
      const t = this.a;
      return (this.a = void 0), t && Zn(t, null), t;
    }
  },
  po = class {
    constructor() {
      (this.a = new Map()), (this.b = !1), Qn(this);
    }
    dispose() {
      Yn(this), (this.b = !0), this.clearAndDisposeAll();
    }
    clearAndDisposeAll() {
      if (this.a.size)
        try {
          Xt(this.a.values());
        } finally {
          this.a.clear();
        }
    }
    has(t) {
      return this.a.has(t);
    }
    get size() {
      return this.a.size;
    }
    get(t) {
      return this.a.get(t);
    }
    set(t, e, s = !1) {
      this.b && console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack), s || this.a.get(t)?.dispose(), this.a.set(t, e);
    }
    deleteAndDispose(t) {
      this.a.get(t)?.dispose(), this.a.delete(t);
    }
    deleteAndLeak(t) {
      const e = this.a.get(t);
      return this.a.delete(t), e;
    }
    keys() {
      return this.a.keys();
    }
    values() {
      return this.a.values();
    }
    [Symbol.iterator]() {
      return this.a[Symbol.iterator]();
    }
  },
  sd;
(function (t) {
  (t[(t.PRO = 0)] = "PRO"), (t[(t.LITE = 1)] = "LITE"), (t[(t.UX_SIMPLE = 2)] = "UX_SIMPLE");
})(sd || (sd = {}));
var xi;
(function (t) {
  (t.YINLI = "Yinli"), (t.SPRING = "Spring");
})(xi || (xi = {}));
var id;
(function (t) {
  (t.CN = "cn"), (t.I18N = "i18n");
})(id || (id = {}));
var nd;
(function (t) {
  (t.Yinli = "Yinli"), (t.Spring = "Spring");
})(nd || (nd = {}));
var Qw = "ByteIDEClientFlag",
  on = "en",
  an = !1,
  cn = !1,
  er = !1,
  rd = !1,
  od = !1,
  Pc = !1,
  Yw = !1,
  Ac = !1,
  Zw = !1,
  ev = !1,
  go = void 0,
  mo = on,
  ad = on,
  cd = void 0,
  Us = void 0,
  tv = !1,
  _s = globalThis,
  Qt = void 0;
typeof _s.vscode < "u" && typeof _s.vscode.process < "u" ? (Qt = _s.vscode.process) : typeof process < "u" && typeof process?.versions?.node == "string" && (Qt = process);
var ld = typeof Qt?.versions?.electron == "string",
  sv = ld && Qt?.type === "renderer";
if (typeof Qt == "object") {
  (an = Qt.platform === "win32"),
    (cn = Qt.platform === "darwin"),
    (er = Qt.platform === "linux"),
    (rd = er && !!Qt.env.SNAP && !!Qt.env.SNAP_REVISION),
    (Yw = ld),
    (Zw = !!Qt.env.CI || !!Qt.env.BUILD_ARTIFACTSTAGINGDIRECTORY),
    (go = on),
    (mo = on);
  const t = Qt.env.VSCODE_NLS_CONFIG;
  if (t)
    try {
      const e = JSON.parse(t);
      (go = e.userLocale), (ad = e.osLocale), (mo = e.resolvedLanguage || on), (cd = e.languagePack?.translationsConfigFile);
    } catch {}
  od = !0;
} else
  typeof navigator == "object" && !sv
    ? ((Us = navigator.userAgent),
      (an = Us.indexOf("Windows") >= 0),
      (cn = Us.indexOf("Macintosh") >= 0),
      (Ac = (Us.indexOf("Macintosh") >= 0 || Us.indexOf("iPad") >= 0 || Us.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0),
      (er = Us.indexOf("Linux") >= 0),
      (ev = Us?.indexOf("Mobi") >= 0),
      (Pc = !0),
      (tv = Qw in globalThis),
      (mo = Wf() || on),
      (go = navigator.language.toLowerCase()),
      (ad = go))
    : console.error("Unable to resolve platform.");
var hd;
(function (t) {
  (t[(t.Web = 0)] = "Web"), (t[(t.Mac = 1)] = "Mac"), (t[(t.Linux = 2)] = "Linux"), (t[(t.Windows = 3)] = "Windows");
})(hd || (hd = {}));
function Oc(t) {
  switch (t) {
    case 1:
      return "Mac";
    case 2:
      return "Linux";
    case 3:
      return "Windows";
    case 0:
    default:
      return "Web";
  }
}
var wo = 0;
cn ? (wo = 1) : an ? (wo = 3) : er && (wo = 2);
var Be = an,
  Ss = cn,
  ht = er,
  iv = rd,
  nv = od,
  Qe = Pc,
  rv = Pc && typeof _s.importScripts == "function",
  ov = rv ? _s.origin : void 0,
  ln = wo,
  $s = Us,
  hs = mo,
  ud;
(function (t) {
  function e() {
    return hs;
  }
  t.value = e;
  function s() {
    return hs.length === 2 ? hs === "en" : hs.length >= 3 ? hs[0] === "e" && hs[1] === "n" && hs[2] === "-" : !1;
  }
  t.isDefaultVariant = s;
  function i() {
    return hs === "en";
  }
  t.isDefault = i;
})(ud || (ud = {}));
var fd = cd,
  av = typeof _s.postMessage == "function" && !_s.importScripts,
  cv = (() => {
    if (av) {
      const t = [];
      _s.addEventListener("message", (s) => {
        if (s.data && s.data.vscodeScheduleAsyncWork)
          for (let i = 0, n = t.length; i < n; i++) {
            const r = t[i];
            if (r.id === s.data.vscodeScheduleAsyncWork) {
              t.splice(i, 1), r.callback();
              return;
            }
          }
      });
      let e = 0;
      return (s) => {
        const i = ++e;
        t.push({ id: i, callback: s }), _s.postMessage({ vscodeScheduleAsyncWork: i }, "*");
      };
    }
    return (t) => setTimeout(t);
  })(),
  dd;
(function (t) {
  (t[(t.Windows = 1)] = "Windows"), (t[(t.Macintosh = 2)] = "Macintosh"), (t[(t.Linux = 3)] = "Linux");
})(dd || (dd = {}));
var pd;
(function (t) {
  (t.Windows = "Win"), (t.Macintosh = "Mac"), (t.Linux = "Linux");
})(pd || (pd = {}));
var hn = cn || Ac ? 2 : an ? 1 : 3,
  gd = cn || Ac ? "Mac" : an ? "Win" : "Linux",
  Lc = !!($s && $s.indexOf("Chrome") >= 0),
  md = !!($s && $s.indexOf("Firefox") >= 0),
  wd = !!(!Lc && $s && $s.indexOf("Safari") >= 0),
  vd = !!($s && $s.indexOf("Edg/") >= 0),
  lv = !!($s && $s.indexOf("Android") >= 0),
  ze = class cc {
    static {
      this.Undefined = new cc(void 0);
    }
    constructor(e) {
      (this.element = e), (this.next = cc.Undefined), (this.prev = cc.Undefined);
    }
  },
  Nc = class {
    constructor() {
      (this.a = ze.Undefined), (this.b = ze.Undefined), (this.c = 0);
    }
    get size() {
      return this.c;
    }
    isEmpty() {
      return this.a === ze.Undefined;
    }
    clear() {
      let t = this.a;
      for (; t !== ze.Undefined; ) {
        const e = t.next;
        (t.prev = ze.Undefined), (t.next = ze.Undefined), (t = e);
      }
      (this.a = ze.Undefined), (this.b = ze.Undefined), (this.c = 0);
    }
    unshift(t) {
      return this.d(t, !1);
    }
    push(t) {
      return this.d(t, !0);
    }
    d(t, e) {
      const s = new ze(t);
      if (this.a === ze.Undefined) (this.a = s), (this.b = s);
      else if (e) {
        const n = this.b;
        (this.b = s), (s.prev = n), (n.next = s);
      } else {
        const n = this.a;
        (this.a = s), (s.next = n), (n.prev = s);
      }
      this.c += 1;
      let i = !1;
      return () => {
        i || ((i = !0), this.e(s));
      };
    }
    shift() {
      if (this.a !== ze.Undefined) {
        const t = this.a.element;
        return this.e(this.a), t;
      }
    }
    pop() {
      if (this.b !== ze.Undefined) {
        const t = this.b.element;
        return this.e(this.b), t;
      }
    }
    e(t) {
      if (t.prev !== ze.Undefined && t.next !== ze.Undefined) {
        const e = t.prev;
        (e.next = t.next), (t.next.prev = e);
      } else
        t.prev === ze.Undefined && t.next === ze.Undefined
          ? ((this.a = ze.Undefined), (this.b = ze.Undefined))
          : t.next === ze.Undefined
            ? ((this.b = this.b.prev), (this.b.next = ze.Undefined))
            : t.prev === ze.Undefined && ((this.a = this.a.next), (this.a.prev = ze.Undefined));
      this.c -= 1;
    }
    *[Symbol.iterator]() {
      let t = this.a;
      for (; t !== ze.Undefined; ) yield t.element, (t = t.next);
    }
  },
  hv = globalThis.performance && typeof globalThis.performance.now == "function",
  un = class qm {
    static create(e) {
      return new qm(e);
    }
    constructor(e) {
      (this.c = hv && e === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance)), (this.a = this.c()), (this.b = -1);
    }
    stop() {
      this.b = this.c();
    }
    reset() {
      (this.a = this.c()), (this.b = -1);
    }
    elapsed() {
      return this.b !== -1 ? this.b - this.a : this.c() - this.a;
    }
  },
  uv = !1,
  yd = !1,
  fv = !1,
  T;
(function (t) {
  t.None = () => O.None;
  function e(A) {
    if (fv) {
      const { onDidAddListener: R } = A,
        F = Tc.create();
      let N = 0;
      A.onDidAddListener = () => {
        ++N === 2 && (console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here"), F.print()), R?.();
      };
    }
  }
  function s(A, R) {
    return d(A, () => {}, 0, void 0, !0, void 0, R);
  }
  t.defer = s;
  function i(A) {
    return (R, F = null, N) => {
      let W = !1,
        se;
      return (
        (se = A(
          (pe) => {
            if (!W) return se ? se.dispose() : (W = !0), R.call(F, pe);
          },
          null,
          N,
        )),
        W && se.dispose(),
        se
      );
    };
  }
  t.once = i;
  function n(A, R) {
    return t.once(t.filter(A, R));
  }
  t.onceIf = n;
  function r(A, R, F) {
    return u((N, W = null, se) => A((pe) => N.call(W, R(pe)), null, se), F);
  }
  t.map = r;
  function o(A, R, F) {
    return u(
      (N, W = null, se) =>
        A(
          (pe) => {
            R(pe), N.call(W, pe);
          },
          null,
          se,
        ),
      F,
    );
  }
  t.forEach = o;
  function a(A, R, F) {
    return u((N, W = null, se) => A((pe) => R(pe) && N.call(W, pe), null, se), F);
  }
  t.filter = a;
  function c(A) {
    return A;
  }
  t.signal = c;
  function l(...A) {
    return (R, F = null, N) => {
      const W = Rc(...A.map((se) => se((pe) => R.call(F, pe))));
      return f(W, N);
    };
  }
  t.any = l;
  function h(A, R, F, N) {
    let W = F;
    return r(A, (se) => ((W = R(W, se)), W), N);
  }
  t.reduce = h;
  function u(A, R) {
    let F;
    const N = {
      onWillAddFirstListener() {
        F = A(W.fire, W);
      },
      onDidRemoveLastListener() {
        F?.dispose();
      },
    };
    R || e(N);
    const W = new D(N);
    return R?.add(W), W.event;
  }
  function f(A, R) {
    return R instanceof Array ? R.push(A) : R && R.add(A), A;
  }
  function d(A, R, F = 100, N = !1, W = !1, se, pe) {
    let Ue,
      He,
      Ns,
      yi = 0,
      Ts;
    const tn = {
      leakWarningThreshold: se,
      onWillAddFirstListener() {
        Ue = A((no) => {
          yi++,
            (He = R(He, no)),
            N && !Ns && (ys.fire(He), (He = void 0)),
            (Ts = () => {
              const ro = He;
              (He = void 0), (Ns = void 0), (!N || yi > 1) && ys.fire(ro), (yi = 0);
            }),
            typeof F == "number" ? (clearTimeout(Ns), (Ns = setTimeout(Ts, F))) : Ns === void 0 && ((Ns = 0), queueMicrotask(Ts));
        });
      },
      onWillRemoveListener() {
        W && yi > 0 && Ts?.();
      },
      onDidRemoveLastListener() {
        (Ts = void 0), Ue.dispose();
      },
    };
    pe || e(tn);
    const ys = new D(tn);
    return pe?.add(ys), ys.event;
  }
  t.debounce = d;
  function p(A, R = 0, F) {
    return t.debounce(A, (N, W) => (N ? (N.push(W), N) : [W]), R, void 0, !0, void 0, F);
  }
  t.accumulate = p;
  function g(A, R = (N, W) => N === W, F) {
    let N = !0,
      W;
    return a(
      A,
      (se) => {
        const pe = N || !R(se, W);
        return (N = !1), (W = se), pe;
      },
      F,
    );
  }
  t.latch = g;
  function m(A, R, F) {
    return [t.filter(A, R, F), t.filter(A, (N) => !R(N), F)];
  }
  t.split = m;
  function v(A, R = !1, F = [], N) {
    let W = F.slice(),
      se = A((He) => {
        W ? W.push(He) : Ue.fire(He);
      });
    N && N.add(se);
    const pe = () => {
        W?.forEach((He) => Ue.fire(He)), (W = null);
      },
      Ue = new D({
        onWillAddFirstListener() {
          se || ((se = A((He) => Ue.fire(He))), N && N.add(se));
        },
        onDidAddFirstListener() {
          W && (R ? setTimeout(pe) : pe());
        },
        onDidRemoveLastListener() {
          se && se.dispose(), (se = null);
        },
      });
    return N && N.add(Ue), Ue.event;
  }
  t.buffer = v;
  function b(A, R) {
    return (N, W, se) => {
      const pe = R(new $());
      return A(
        function (Ue) {
          const He = pe.evaluate(Ue);
          He !== E && N.call(W, He);
        },
        void 0,
        se,
      );
    };
  }
  t.chain = b;
  const E = Symbol("HaltChainable");
  class $ {
    constructor() {
      this.f = [];
    }
    map(R) {
      return this.f.push(R), this;
    }
    forEach(R) {
      return this.f.push((F) => (R(F), F)), this;
    }
    filter(R) {
      return this.f.push((F) => (R(F) ? F : E)), this;
    }
    reduce(R, F) {
      let N = F;
      return this.f.push((W) => ((N = R(N, W)), N)), this;
    }
    latch(R = (F, N) => F === N) {
      let F = !0,
        N;
      return (
        this.f.push((W) => {
          const se = F || !R(W, N);
          return (F = !1), (N = W), se ? W : E;
        }),
        this
      );
    }
    evaluate(R) {
      for (const F of this.f) if (((R = F(R)), R === E)) break;
      return R;
    }
  }
  function P(A, R, F = (N) => N) {
    const N = (...Ue) => pe.fire(F(...Ue)),
      W = () => A.on(R, N),
      se = () => A.removeListener(R, N),
      pe = new D({ onWillAddFirstListener: W, onDidRemoveLastListener: se });
    return pe.event;
  }
  t.fromNodeEventEmitter = P;
  function U(A, R, F = (N) => N) {
    const N = (...Ue) => pe.fire(F(...Ue)),
      W = () => A.addEventListener(R, N),
      se = () => A.removeEventListener(R, N),
      pe = new D({ onWillAddFirstListener: W, onDidRemoveLastListener: se });
    return pe.event;
  }
  t.fromDOMEventEmitter = U;
  function Q(A) {
    return new Promise((R) => i(A)(R));
  }
  t.toPromise = Q;
  function k(A) {
    const R = new D();
    return (
      A.then(
        (F) => {
          R.fire(F);
        },
        () => {
          R.fire(void 0);
        },
      ).finally(() => {
        R.dispose();
      }),
      R.event
    );
  }
  t.fromPromise = k;
  function I(A, R) {
    return A((F) => R.fire(F));
  }
  t.forward = I;
  function H(A, R, F) {
    return R(F), A((N) => R(N));
  }
  t.runAndSubscribe = H;
  class B {
    constructor(R, F) {
      (this._observable = R), (this.f = 0), (this.g = !1);
      const N = {
        onWillAddFirstListener: () => {
          R.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          R.removeObserver(this);
        },
      };
      F || e(N), (this.emitter = new D(N)), F && F.add(this.emitter);
    }
    beginUpdate(R) {
      this.f++;
    }
    handlePossibleChange(R) {}
    handleChange(R, F) {
      this.g = !0;
    }
    endUpdate(R) {
      this.f--, this.f === 0 && (this._observable.reportChanges(), this.g && ((this.g = !1), this.emitter.fire(this._observable.get())));
    }
  }
  function j(A, R) {
    return new B(A, R).emitter.event;
  }
  t.fromObservable = j;
  function Z(A) {
    return (R, F, N) => {
      let W = 0,
        se = !1;
      const pe = {
        beginUpdate() {
          W++;
        },
        endUpdate() {
          W--, W === 0 && (A.reportChanges(), se && ((se = !1), R.call(F)));
        },
        handlePossibleChange() {},
        handleChange() {
          se = !0;
        },
      };
      A.addObserver(pe), A.reportChanges();
      const Ue = {
        dispose() {
          A.removeObserver(pe);
        },
      };
      return N instanceof ye ? N.add(Ue) : Array.isArray(N) && N.push(Ue), Ue;
    };
  }
  t.fromObservableLight = Z;
})(T || (T = {}));
var dv = class Rf {
    static {
      this.all = new Set();
    }
    static {
      this.f = 0;
    }
    constructor(e) {
      (this.listenerCount = 0), (this.invocationCount = 0), (this.elapsedOverall = 0), (this.durations = []), (this.name = `${e}_${Rf.f++}`), Rf.all.add(this);
    }
    start(e) {
      (this.g = new un()), (this.listenerCount = e);
    }
    stop() {
      if (this.g) {
        const e = this.g.elapsed();
        this.durations.push(e), (this.elapsedOverall += e), (this.invocationCount += 1), (this.g = void 0);
      }
    }
  },
  bd = -1,
  pv = class Vm {
    static {
      this.f = 1;
    }
    constructor(e, s, i = (Vm.f++).toString(16).padStart(3, "0")) {
      (this.j = e), (this.threshold = s), (this.name = i), (this.h = 0);
    }
    dispose() {
      this.g?.clear();
    }
    check(e, s) {
      const i = this.threshold;
      if (i <= 0 || s < i) return;
      this.g || (this.g = new Map());
      const n = this.g.get(e.value) || 0;
      if ((this.g.set(e.value, n + 1), (this.h -= 1), this.h <= 0)) {
        this.h = i * 0.5;
        const [r, o] = this.getMostFrequentStack(),
          a = `[${this.name}] potential listener LEAK detected, having ${s} listeners already. MOST frequent listener (${o}):`;
        console.warn(a), console.warn(r);
        const c = new gv(a, r);
        this.j(c);
      }
      return () => {
        const r = this.g.get(e.value) || 0;
        this.g.set(e.value, r - 1);
      };
    }
    getMostFrequentStack() {
      if (!this.g) return;
      let e,
        s = 0;
      for (const [i, n] of this.g) (!e || s < n) && ((e = [i, n]), (s = n));
      return e;
    }
  },
  Tc = class Wm {
    static create() {
      const e = new Error();
      return new Wm(e.stack ?? "");
    }
    constructor(e) {
      this.value = e;
    }
    print() {
      console.warn(
        this.value
          .split(
            `
`,
          )
          .slice(2).join(`
`),
      );
    }
  },
  gv = class extends Error {
    constructor(t, e) {
      super(t), (this.name = "ListenerLeakError"), (this.stack = e);
    }
  },
  mv = class extends Error {
    constructor(t, e) {
      super(t), (this.name = "ListenerRefusalError"), (this.stack = e);
    }
  },
  wv = 0,
  vo = class {
    constructor(t) {
      (this.value = t), (this.id = wv++);
    }
  },
  vv = 2,
  yv = (t, e) => {
    if (t instanceof vo) e(t);
    else
      for (let s = 0; s < t.length; s++) {
        const i = t[s];
        i && e(i);
      }
  },
  yo;
if (uv) {
  const t = [];
  setInterval(() => {
    t.length !== 0 &&
      (console.warn("[LEAKING LISTENERS] GC'ed these listeners that were NOT yet disposed:"),
      console.warn(
        t.join(`
`),
      ),
      (t.length = 0));
  }, 3e3),
    (yo = new FinalizationRegistry((e) => {
      typeof e == "string" && t.push(e);
    }));
}
var D = class {
    constructor(t) {
      (this.z = 0),
        (this.f = t),
        (this.g = bd > 0 || this.f?.leakWarningThreshold ? new pv(t?.onListenerError ?? rt, this.f?.leakWarningThreshold ?? bd) : void 0),
        (this.j = this.f?._profName ? new dv(this.f._profName) : void 0),
        (this.w = this.f?.deliveryQueue);
    }
    dispose() {
      if (!this.m) {
        if (((this.m = !0), this.w?.current === this && this.w.reset(), this.u)) {
          if (yd) {
            const t = this.u;
            queueMicrotask(() => {
              yv(t, (e) => e.stack?.print());
            });
          }
          (this.u = void 0), (this.z = 0);
        }
        this.f?.onDidRemoveLastListener?.(), this.g?.dispose();
      }
    }
    get event() {
      return (
        (this.q ??= (t, e, s) => {
          if (this.g && this.z > this.g.threshold ** 2) {
            const a = `[${this.g.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this.z} vs ${this.g.threshold})`;
            console.warn(a);
            const c = this.g.getMostFrequentStack() ?? ["UNKNOWN stack", -1],
              l = new mv(`${a}. HINT: Stack shows most frequent listener (${c[1]}-times)`, c[0]);
            return (this.f?.onListenerError || rt)(l), O.None;
          }
          if (this.m) return O.None;
          e && (t = t.bind(e));
          const i = new vo(t);
          let n, r;
          this.g && this.z >= Math.ceil(this.g.threshold * 0.2) && ((i.stack = Tc.create()), (n = this.g.check(i.stack, this.z + 1))),
            yd && (i.stack = r ?? Tc.create()),
            this.u ? (this.u instanceof vo ? ((this.w ??= new bv()), (this.u = [this.u, i])) : this.u.push(i)) : (this.f?.onWillAddFirstListener?.(this), (this.u = i), this.f?.onDidAddFirstListener?.(this)),
            this.f?.onDidAddListener?.(this),
            this.z++;
          const o = ue(() => {
            yo?.unregister(o), n?.(), this.A(i);
          });
          if ((s instanceof ye ? s.add(o) : Array.isArray(s) && s.push(o), yo)) {
            const a = new Error().stack
                .split(
                  `
`,
                )
                .slice(2, 3)
                .join(
                  `
`,
                )
                .trim(),
              c = /(file:|vscode-file:\/\/vscode-app)?(\/[^:]*:\d+:\d+)/.exec(a);
            yo.register(o, c?.[2] ?? a, o);
          }
          return o;
        }),
        this.q
      );
    }
    A(t) {
      if ((this.f?.onWillRemoveListener?.(this), !this.u)) return;
      if (this.z === 1) {
        (this.u = void 0), this.f?.onDidRemoveLastListener?.(this), (this.z = 0);
        return;
      }
      const e = this.u,
        s = e.indexOf(t);
      if (s === -1) throw (console.log("disposed?", this.m), console.log("size?", this.z), console.log("arr?", JSON.stringify(this.u)), new Error("Attempted to dispose unknown listener"));
      this.z--, (e[s] = void 0);
      const i = this.w.current === this;
      if (this.z * vv <= e.length) {
        let n = 0;
        for (let r = 0; r < e.length; r++) e[r] ? (e[n++] = e[r]) : i && n < this.w.end && (this.w.end--, n < this.w.i && this.w.i--);
        e.length = n;
      }
    }
    B(t, e) {
      if (!t) return;
      const s = this.f?.onListenerError || rt;
      if (!s) {
        t.value(e);
        return;
      }
      try {
        t.value(e);
      } catch (i) {
        s(i);
      }
    }
    C(t) {
      const e = t.current.u;
      for (; t.i < t.end; ) this.B(e[t.i++], t.value);
      t.reset();
    }
    fire(t) {
      if ((this.w?.current && (this.C(this.w), this.j?.stop()), this.j?.start(this.z), this.u))
        if (this.u instanceof vo) this.B(this.u, t);
        else {
          const e = this.w;
          e.enqueue(this, t, this.u.length), this.C(e);
        }
      this.j?.stop();
    }
    hasListeners() {
      return this.z > 0;
    }
  },
  bv = class {
    constructor() {
      (this.i = -1), (this.end = 0);
    }
    enqueue(t, e, s) {
      (this.i = 0), (this.end = s), (this.current = t), (this.value = e);
    }
    reset() {
      (this.i = this.end), (this.current = void 0), (this.value = void 0);
    }
  },
  jc = class extends D {
    get isPaused() {
      return this.h !== 0;
    }
    constructor(t) {
      super(t), (this.h = 0), (this.s = new Nc()), (this.t = t?.merge);
    }
    pause() {
      this.h++;
    }
    resume() {
      if (this.h !== 0 && --this.h === 0)
        if (this.t) {
          if (this.s.size > 0) {
            const t = Array.from(this.s);
            this.s.clear(), super.fire(this.t(t));
          }
        } else for (; !this.h && this.s.size !== 0; ) super.fire(this.s.shift());
    }
    fire(t) {
      this.z && (this.h !== 0 ? this.s.push(t) : super.fire(t));
    }
  },
  Ev = class {
    constructor() {
      (this.g = !1), (this.h = []), (this.f = new D({ onWillAddFirstListener: () => this.j(), onDidRemoveLastListener: () => this.k() }));
    }
    get event() {
      return this.f.event;
    }
    add(t) {
      const e = { event: t, listener: null };
      return (
        this.h.push(e),
        this.g && this.m(e),
        ue(
          Ic(() => {
            this.g && this.o(e);
            const i = this.h.indexOf(e);
            this.h.splice(i, 1);
          }),
        )
      );
    }
    j() {
      (this.g = !0), this.h.forEach((t) => this.m(t));
    }
    k() {
      (this.g = !1), this.h.forEach((t) => this.o(t));
    }
    m(t) {
      t.listener = t.event((e) => this.f.fire(e));
    }
    o(t) {
      t.listener?.dispose(), (t.listener = null);
    }
    dispose() {
      this.f.dispose();
      for (const t of this.h) t.listener?.dispose();
      this.h = [];
    }
  },
  Ed = class {
    constructor() {
      (this.f = !1),
        (this.g = T.None),
        (this.h = O.None),
        (this.j = new D({
          onDidAddFirstListener: () => {
            (this.f = !0), (this.h = this.g(this.j.fire, this.j));
          },
          onDidRemoveLastListener: () => {
            (this.f = !1), this.h.dispose();
          },
        })),
        (this.event = this.j.event);
    }
    set input(t) {
      (this.g = t), this.f && (this.h.dispose(), (this.h = t(this.j.fire, this.j)));
    }
    dispose() {
      this.h.dispose(), this.j.dispose();
    }
  },
  Sd = Object.freeze(function (t, e) {
    const s = setTimeout(t.bind(e), 0);
    return {
      dispose() {
        clearTimeout(s);
      },
    };
  }),
  J;
(function (t) {
  function e(s) {
    return s === t.None || s === t.Cancelled || s instanceof bo ? !0 : !s || typeof s != "object" ? !1 : typeof s.isCancellationRequested == "boolean" && typeof s.onCancellationRequested == "function";
  }
  (t.isCancellationToken = e), (t.None = Object.freeze({ isCancellationRequested: !1, onCancellationRequested: T.None })), (t.Cancelled = Object.freeze({ isCancellationRequested: !0, onCancellationRequested: Sd }));
})(J || (J = {}));
var bo = class {
    constructor() {
      (this.a = !1), (this.b = null);
    }
    cancel() {
      this.a || ((this.a = !0), this.b && (this.b.fire(void 0), this.dispose()));
    }
    get isCancellationRequested() {
      return this.a;
    }
    get onCancellationRequested() {
      return this.a ? Sd : (this.b || (this.b = new D()), this.b.event);
    }
    dispose() {
      this.b && (this.b.dispose(), (this.b = null));
    }
  },
  xs = class {
    constructor(t) {
      (this.f = void 0), (this.g = void 0), (this.g = t && t.onCancellationRequested(this.cancel, this));
    }
    get token() {
      return this.f || (this.f = new bo()), this.f;
    }
    cancel() {
      this.f ? this.f instanceof bo && this.f.cancel() : (this.f = J.Cancelled);
    }
    dispose(t = !1) {
      t && this.cancel(), this.g?.dispose(), this.f ? this.f instanceof bo && this.f.dispose() : (this.f = J.None);
    }
  };
function Sv(t) {
  return t;
}
var $v = class {
    constructor(t, e) {
      (this.a = void 0), (this.b = void 0), typeof t == "function" ? ((this.c = t), (this.d = Sv)) : ((this.c = e), (this.d = t.getCacheKey));
    }
    get(t) {
      const e = this.d(t);
      return this.b !== e && ((this.b = e), (this.a = this.c(t))), this.a;
    }
  },
  fn = class {
    constructor(t) {
      (this.d = t), (this.a = !1);
    }
    get hasValue() {
      return this.a;
    }
    get value() {
      if (!this.a)
        try {
          this.b = this.d();
        } catch (t) {
          this.c = t;
        } finally {
          this.a = !0;
        }
      if (this.c) throw this.c;
      return this.b;
    }
    get rawValue() {
      return this.b;
    }
  };
function xv(t) {
  return !t || typeof t != "string" ? !0 : t.trim().length === 0;
}
function dn(t) {
  return t.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function Cv(t, e = " ") {
  const s = $d(t, e);
  return Fc(s, e);
}
function $d(t, e) {
  if (!t || !e) return t;
  const s = e.length;
  if (s === 0 || t.length === 0) return t;
  let i = 0;
  for (; t.indexOf(e, i) === i; ) i = i + s;
  return t.substring(i);
}
function Fc(t, e) {
  if (!t || !e) return t;
  const s = e.length,
    i = t.length;
  if (s === 0 || i === 0) return t;
  let n = i,
    r = -1;
  for (; (r = t.lastIndexOf(e, n - 1)), !(r === -1 || r + s !== n); ) {
    if (r === 0) return "";
    n = r;
  }
  return t.substring(0, n);
}
function Eo(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Mc(t, e, s = 0, i = t.length, n = 0, r = e.length) {
  for (; s < i && n < r; s++, n++) {
    const c = t.charCodeAt(s),
      l = e.charCodeAt(n);
    if (c < l) return -1;
    if (c > l) return 1;
  }
  const o = i - s,
    a = r - n;
  return o < a ? -1 : o > a ? 1 : 0;
}
function Uc(t, e) {
  return tr(t, e, 0, t.length, 0, e.length);
}
function tr(t, e, s = 0, i = t.length, n = 0, r = e.length) {
  for (; s < i && n < r; s++, n++) {
    let c = t.charCodeAt(s),
      l = e.charCodeAt(n);
    if (c === l) continue;
    if (c >= 128 || l >= 128) return Mc(t.toLowerCase(), e.toLowerCase(), s, i, n, r);
    xd(c) && (c -= 32), xd(l) && (l -= 32);
    const h = c - l;
    if (h !== 0) return h;
  }
  const o = i - s,
    a = r - n;
  return o < a ? -1 : o > a ? 1 : 0;
}
function xd(t) {
  return t >= 97 && t <= 122;
}
function Cd(t) {
  return t >= 65 && t <= 90;
}
function Ci(t, e) {
  return t.length === e.length && tr(t, e) === 0;
}
function kd(t, e) {
  const s = e.length;
  return e.length > t.length ? !1 : tr(t, e, 0, s) === 0;
}
function kv(t) {
  return 55296 <= t && t <= 56319;
}
function Dd(t) {
  return 56320 <= t && t <= 57343;
}
function Dv(t, e) {
  return ((t - 55296) << 10) + (e - 56320) + 65536;
}
var V6 = "\uFEFF";
function Iv(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
var Id;
(function (t) {
  (t[(t.Other = 0)] = "Other"),
    (t[(t.Prepend = 1)] = "Prepend"),
    (t[(t.CR = 2)] = "CR"),
    (t[(t.LF = 3)] = "LF"),
    (t[(t.Control = 4)] = "Control"),
    (t[(t.Extend = 5)] = "Extend"),
    (t[(t.Regional_Indicator = 6)] = "Regional_Indicator"),
    (t[(t.SpacingMark = 7)] = "SpacingMark"),
    (t[(t.L = 8)] = "L"),
    (t[(t.V = 9)] = "V"),
    (t[(t.T = 10)] = "T"),
    (t[(t.LV = 11)] = "LV"),
    (t[(t.LVT = 12)] = "LVT"),
    (t[(t.ZWJ = 13)] = "ZWJ"),
    (t[(t.Extended_Pictographic = 14)] = "Extended_Pictographic");
})(Id || (Id = {}));
var W6 = class Qr {
  static {
    this.c = null;
  }
  static getInstance() {
    return Qr.c || (Qr.c = new Qr()), Qr.c;
  }
  constructor() {
    this.d = Rv();
  }
  getGraphemeBreakType(e) {
    if (e < 32) return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127) return 0;
    const s = this.d,
      i = s.length / 3;
    let n = 1;
    for (; n <= i; )
      if (e < s[3 * n]) n = 2 * n;
      else if (e > s[3 * n + 1]) n = 2 * n + 1;
      else return s[3 * n + 2];
    return 0;
  }
};
function Rv() {
  return JSON.parse(
    "[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]",
  );
}
var Rd;
(function (t) {
  (t[(t.zwj = 8205)] = "zwj"), (t[(t.emojiVariantSelector = 65039)] = "emojiVariantSelector"), (t[(t.enclosingKeyCap = 8419)] = "enclosingKeyCap");
})(Rd || (Rd = {}));
var H6 = class Yr {
    static {
      this.c = new fn(() =>
        JSON.parse(
          '{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}',
        ),
      );
    }
    static {
      this.d = new $v({ getCacheKey: JSON.stringify }, (e) => {
        function s(h) {
          const u = new Map();
          for (let f = 0; f < h.length; f += 2) u.set(h[f], h[f + 1]);
          return u;
        }
        function i(h, u) {
          const f = new Map(h);
          for (const [d, p] of u) f.set(d, p);
          return f;
        }
        function n(h, u) {
          if (!h) return u;
          const f = new Map();
          for (const [d, p] of h) u.has(d) && f.set(d, p);
          return f;
        }
        const r = this.c.value;
        let o = e.filter((h) => !h.startsWith("_") && h in r);
        o.length === 0 && (o = ["_default"]);
        let a;
        for (const h of o) {
          const u = s(r[h]);
          a = n(a, u);
        }
        const c = s(r._common),
          l = i(c, a);
        return new Yr(l);
      });
    }
    static getInstance(e) {
      return Yr.d.get(Array.from(e));
    }
    static {
      this.e = new fn(() => Object.keys(Yr.c.value).filter((e) => !e.startsWith("_")));
    }
    static getLocales() {
      return Yr.e.value;
    }
    constructor(e) {
      this.f = e;
    }
    isAmbiguous(e) {
      return this.f.has(e);
    }
    containsAmbiguousCharacter(e) {
      for (let s = 0; s < e.length; s++) {
        const i = e.codePointAt(s);
        if (typeof i == "number" && this.isAmbiguous(i)) return !0;
      }
      return !1;
    }
    getPrimaryConfusable(e) {
      return this.f.get(e);
    }
    getConfusableCodePoints() {
      return new Set(this.f.keys());
    }
  },
  G6 = class Zr {
    static c() {
      return JSON.parse(
        "[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]",
      );
    }
    static {
      this.d = void 0;
    }
    static e() {
      return this.d || (this.d = new Set(Zr.c())), this.d;
    }
    static isInvisibleCharacter(e) {
      return Zr.e().has(e);
    }
    static containsInvisibleCharacter(e) {
      for (let s = 0; s < e.length; s++) {
        const i = e.codePointAt(s);
        if (typeof i == "number" && Zr.isInvisibleCharacter(i)) return !0;
      }
      return !1;
    }
    static get codePoints() {
      return Zr.e();
    }
  },
  ki,
  _c = globalThis.vscode;
if (typeof _c < "u" && typeof _c.process < "u") {
  const t = _c.process;
  ki = {
    get platform() {
      return t.platform;
    },
    get arch() {
      return t.arch;
    },
    get env() {
      return t.env;
    },
    cwd() {
      return t.cwd();
    },
  };
} else
  typeof process < "u" && typeof process?.versions?.node == "string"
    ? (ki = {
        get platform() {
          return process.platform;
        },
        get arch() {
          return process.arch;
        },
        get env() {
          return process.env;
        },
        cwd() {
          return process.env.VSCODE_CWD || process.cwd();
        },
      })
    : (ki = {
        get platform() {
          return Be ? "win32" : Ss ? "darwin" : "linux";
        },
        get arch() {},
        get env() {
          return {};
        },
        cwd() {
          return "/";
        },
      });
var sr = ki.cwd,
  Y = ki.env,
  So = ki.platform,
  Bc = ki.arch,
  Pv = 65,
  Av = 97,
  Ov = 90,
  Lv = 122,
  Zs = 46,
  ut = 47,
  zt = 92,
  ei = 58,
  Nv = 63,
  Pd = class extends Error {
    constructor(t, e, s) {
      let i;
      typeof e == "string" && e.indexOf("not ") === 0 ? ((i = "must not be"), (e = e.replace(/^not /, ""))) : (i = "must be");
      const n = t.indexOf(".") !== -1 ? "property" : "argument";
      let r = `The "${t}" ${n} ${i} of type ${e}`;
      (r += `. Received type ${typeof s}`), super(r), (this.code = "ERR_INVALID_ARG_TYPE");
    }
  };
function Tv(t, e) {
  if (t === null || typeof t != "object") throw new Pd(e, "Object", t);
}
function Ve(t, e) {
  if (typeof t != "string") throw new Pd(e, "string", t);
}
var qt = So === "win32";
function re(t) {
  return t === ut || t === zt;
}
function zc(t) {
  return t === ut;
}
function ti(t) {
  return (t >= Pv && t <= Ov) || (t >= Av && t <= Lv);
}
function $o(t, e, s, i) {
  let n = "",
    r = 0,
    o = -1,
    a = 0,
    c = 0;
  for (let l = 0; l <= t.length; ++l) {
    if (l < t.length) c = t.charCodeAt(l);
    else {
      if (i(c)) break;
      c = ut;
    }
    if (i(c)) {
      if (!(o === l - 1 || a === 1))
        if (a === 2) {
          if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== Zs || n.charCodeAt(n.length - 2) !== Zs) {
            if (n.length > 2) {
              const h = n.lastIndexOf(s);
              h === -1 ? ((n = ""), (r = 0)) : ((n = n.slice(0, h)), (r = n.length - 1 - n.lastIndexOf(s))), (o = l), (a = 0);
              continue;
            } else if (n.length !== 0) {
              (n = ""), (r = 0), (o = l), (a = 0);
              continue;
            }
          }
          e && ((n += n.length > 0 ? `${s}..` : ".."), (r = 2));
        } else n.length > 0 ? (n += `${s}${t.slice(o + 1, l)}`) : (n = t.slice(o + 1, l)), (r = l - o - 1);
      (o = l), (a = 0);
    } else c === Zs && a !== -1 ? ++a : (a = -1);
  }
  return n;
}
function jv(t) {
  return t ? `${t[0] === "." ? "" : "."}${t}` : "";
}
function Ad(t, e) {
  Tv(e, "pathObject");
  const s = e.dir || e.root,
    i = e.base || `${e.name || ""}${jv(e.ext)}`;
  return s ? (s === e.root ? `${s}${i}` : `${s}${t}${i}`) : i;
}
var Ye = {
    resolve(...t) {
      let e = "",
        s = "",
        i = !1;
      for (let n = t.length - 1; n >= -1; n--) {
        let r;
        if (n >= 0) {
          if (((r = t[n]), Ve(r, `paths[${n}]`), r.length === 0)) continue;
        } else e.length === 0 ? (r = sr()) : ((r = Y[`=${e}`] || sr()), (r === void 0 || (r.slice(0, 2).toLowerCase() !== e.toLowerCase() && r.charCodeAt(2) === zt)) && (r = `${e}\\`));
        const o = r.length;
        let a = 0,
          c = "",
          l = !1;
        const h = r.charCodeAt(0);
        if (o === 1) re(h) && ((a = 1), (l = !0));
        else if (re(h))
          if (((l = !0), re(r.charCodeAt(1)))) {
            let u = 2,
              f = u;
            for (; u < o && !re(r.charCodeAt(u)); ) u++;
            if (u < o && u !== f) {
              const d = r.slice(f, u);
              for (f = u; u < o && re(r.charCodeAt(u)); ) u++;
              if (u < o && u !== f) {
                for (f = u; u < o && !re(r.charCodeAt(u)); ) u++;
                (u === o || u !== f) && ((c = `\\\\${d}\\${r.slice(f, u)}`), (a = u));
              }
            }
          } else a = 1;
        else ti(h) && r.charCodeAt(1) === ei && ((c = r.slice(0, 2)), (a = 2), o > 2 && re(r.charCodeAt(2)) && ((l = !0), (a = 3)));
        if (c.length > 0)
          if (e.length > 0) {
            if (c.toLowerCase() !== e.toLowerCase()) continue;
          } else e = c;
        if (i) {
          if (e.length > 0) break;
        } else if (((s = `${r.slice(a)}\\${s}`), (i = l), l && e.length > 0)) break;
      }
      return (s = $o(s, !i, "\\", re)), i ? `${e}\\${s}` : `${e}${s}` || ".";
    },
    normalize(t) {
      Ve(t, "path");
      const e = t.length;
      if (e === 0) return ".";
      let s = 0,
        i,
        n = !1;
      const r = t.charCodeAt(0);
      if (e === 1) return zc(r) ? "\\" : t;
      if (re(r))
        if (((n = !0), re(t.charCodeAt(1)))) {
          let a = 2,
            c = a;
          for (; a < e && !re(t.charCodeAt(a)); ) a++;
          if (a < e && a !== c) {
            const l = t.slice(c, a);
            for (c = a; a < e && re(t.charCodeAt(a)); ) a++;
            if (a < e && a !== c) {
              for (c = a; a < e && !re(t.charCodeAt(a)); ) a++;
              if (a === e) return `\\\\${l}\\${t.slice(c)}\\`;
              a !== c && ((i = `\\\\${l}\\${t.slice(c, a)}`), (s = a));
            }
          }
        } else s = 1;
      else ti(r) && t.charCodeAt(1) === ei && ((i = t.slice(0, 2)), (s = 2), e > 2 && re(t.charCodeAt(2)) && ((n = !0), (s = 3)));
      let o = s < e ? $o(t.slice(s), !n, "\\", re) : "";
      return o.length === 0 && !n && (o = "."), o.length > 0 && re(t.charCodeAt(e - 1)) && (o += "\\"), i === void 0 ? (n ? `\\${o}` : o) : n ? `${i}\\${o}` : `${i}${o}`;
    },
    isAbsolute(t) {
      Ve(t, "path");
      const e = t.length;
      if (e === 0) return !1;
      const s = t.charCodeAt(0);
      return re(s) || (e > 2 && ti(s) && t.charCodeAt(1) === ei && re(t.charCodeAt(2)));
    },
    join(...t) {
      if (t.length === 0) return ".";
      let e, s;
      for (let r = 0; r < t.length; ++r) {
        const o = t[r];
        Ve(o, "path"), o.length > 0 && (e === void 0 ? (e = s = o) : (e += `\\${o}`));
      }
      if (e === void 0) return ".";
      let i = !0,
        n = 0;
      if (typeof s == "string" && re(s.charCodeAt(0))) {
        ++n;
        const r = s.length;
        r > 1 && re(s.charCodeAt(1)) && (++n, r > 2 && (re(s.charCodeAt(2)) ? ++n : (i = !1)));
      }
      if (i) {
        for (; n < e.length && re(e.charCodeAt(n)); ) n++;
        n >= 2 && (e = `\\${e.slice(n)}`);
      }
      return Ye.normalize(e);
    },
    relative(t, e) {
      if ((Ve(t, "from"), Ve(e, "to"), t === e)) return "";
      const s = Ye.resolve(t),
        i = Ye.resolve(e);
      if (s === i || ((t = s.toLowerCase()), (e = i.toLowerCase()), t === e)) return "";
      let n = 0;
      for (; n < t.length && t.charCodeAt(n) === zt; ) n++;
      let r = t.length;
      for (; r - 1 > n && t.charCodeAt(r - 1) === zt; ) r--;
      const o = r - n;
      let a = 0;
      for (; a < e.length && e.charCodeAt(a) === zt; ) a++;
      let c = e.length;
      for (; c - 1 > a && e.charCodeAt(c - 1) === zt; ) c--;
      const l = c - a,
        h = o < l ? o : l;
      let u = -1,
        f = 0;
      for (; f < h; f++) {
        const p = t.charCodeAt(n + f);
        if (p !== e.charCodeAt(a + f)) break;
        p === zt && (u = f);
      }
      if (f !== h) {
        if (u === -1) return i;
      } else {
        if (l > h) {
          if (e.charCodeAt(a + f) === zt) return i.slice(a + f + 1);
          if (f === 2) return i.slice(a + f);
        }
        o > h && (t.charCodeAt(n + f) === zt ? (u = f) : f === 2 && (u = 3)), u === -1 && (u = 0);
      }
      let d = "";
      for (f = n + u + 1; f <= r; ++f) (f === r || t.charCodeAt(f) === zt) && (d += d.length === 0 ? ".." : "\\..");
      return (a += u), d.length > 0 ? `${d}${i.slice(a, c)}` : (i.charCodeAt(a) === zt && ++a, i.slice(a, c));
    },
    toNamespacedPath(t) {
      if (typeof t != "string" || t.length === 0) return t;
      const e = Ye.resolve(t);
      if (e.length <= 2) return t;
      if (e.charCodeAt(0) === zt) {
        if (e.charCodeAt(1) === zt) {
          const s = e.charCodeAt(2);
          if (s !== Nv && s !== Zs) return `\\\\?\\UNC\\${e.slice(2)}`;
        }
      } else if (ti(e.charCodeAt(0)) && e.charCodeAt(1) === ei && e.charCodeAt(2) === zt) return `\\\\?\\${e}`;
      return t;
    },
    dirname(t) {
      Ve(t, "path");
      const e = t.length;
      if (e === 0) return ".";
      let s = -1,
        i = 0;
      const n = t.charCodeAt(0);
      if (e === 1) return re(n) ? t : ".";
      if (re(n)) {
        if (((s = i = 1), re(t.charCodeAt(1)))) {
          let a = 2,
            c = a;
          for (; a < e && !re(t.charCodeAt(a)); ) a++;
          if (a < e && a !== c) {
            for (c = a; a < e && re(t.charCodeAt(a)); ) a++;
            if (a < e && a !== c) {
              for (c = a; a < e && !re(t.charCodeAt(a)); ) a++;
              if (a === e) return t;
              a !== c && (s = i = a + 1);
            }
          }
        }
      } else ti(n) && t.charCodeAt(1) === ei && ((s = e > 2 && re(t.charCodeAt(2)) ? 3 : 2), (i = s));
      let r = -1,
        o = !0;
      for (let a = e - 1; a >= i; --a)
        if (re(t.charCodeAt(a))) {
          if (!o) {
            r = a;
            break;
          }
        } else o = !1;
      if (r === -1) {
        if (s === -1) return ".";
        r = s;
      }
      return t.slice(0, r);
    },
    basename(t, e) {
      e !== void 0 && Ve(e, "suffix"), Ve(t, "path");
      let s = 0,
        i = -1,
        n = !0,
        r;
      if ((t.length >= 2 && ti(t.charCodeAt(0)) && t.charCodeAt(1) === ei && (s = 2), e !== void 0 && e.length > 0 && e.length <= t.length)) {
        if (e === t) return "";
        let o = e.length - 1,
          a = -1;
        for (r = t.length - 1; r >= s; --r) {
          const c = t.charCodeAt(r);
          if (re(c)) {
            if (!n) {
              s = r + 1;
              break;
            }
          } else a === -1 && ((n = !1), (a = r + 1)), o >= 0 && (c === e.charCodeAt(o) ? --o === -1 && (i = r) : ((o = -1), (i = a)));
        }
        return s === i ? (i = a) : i === -1 && (i = t.length), t.slice(s, i);
      }
      for (r = t.length - 1; r >= s; --r)
        if (re(t.charCodeAt(r))) {
          if (!n) {
            s = r + 1;
            break;
          }
        } else i === -1 && ((n = !1), (i = r + 1));
      return i === -1 ? "" : t.slice(s, i);
    },
    extname(t) {
      Ve(t, "path");
      let e = 0,
        s = -1,
        i = 0,
        n = -1,
        r = !0,
        o = 0;
      t.length >= 2 && t.charCodeAt(1) === ei && ti(t.charCodeAt(0)) && (e = i = 2);
      for (let a = t.length - 1; a >= e; --a) {
        const c = t.charCodeAt(a);
        if (re(c)) {
          if (!r) {
            i = a + 1;
            break;
          }
          continue;
        }
        n === -1 && ((r = !1), (n = a + 1)), c === Zs ? (s === -1 ? (s = a) : o !== 1 && (o = 1)) : s !== -1 && (o = -1);
      }
      return s === -1 || n === -1 || o === 0 || (o === 1 && s === n - 1 && s === i + 1) ? "" : t.slice(s, n);
    },
    format: Ad.bind(null, "\\"),
    parse(t) {
      Ve(t, "path");
      const e = { root: "", dir: "", base: "", ext: "", name: "" };
      if (t.length === 0) return e;
      const s = t.length;
      let i = 0,
        n = t.charCodeAt(0);
      if (s === 1) return re(n) ? ((e.root = e.dir = t), e) : ((e.base = e.name = t), e);
      if (re(n)) {
        if (((i = 1), re(t.charCodeAt(1)))) {
          let u = 2,
            f = u;
          for (; u < s && !re(t.charCodeAt(u)); ) u++;
          if (u < s && u !== f) {
            for (f = u; u < s && re(t.charCodeAt(u)); ) u++;
            if (u < s && u !== f) {
              for (f = u; u < s && !re(t.charCodeAt(u)); ) u++;
              u === s ? (i = u) : u !== f && (i = u + 1);
            }
          }
        }
      } else if (ti(n) && t.charCodeAt(1) === ei) {
        if (s <= 2) return (e.root = e.dir = t), e;
        if (((i = 2), re(t.charCodeAt(2)))) {
          if (s === 3) return (e.root = e.dir = t), e;
          i = 3;
        }
      }
      i > 0 && (e.root = t.slice(0, i));
      let r = -1,
        o = i,
        a = -1,
        c = !0,
        l = t.length - 1,
        h = 0;
      for (; l >= i; --l) {
        if (((n = t.charCodeAt(l)), re(n))) {
          if (!c) {
            o = l + 1;
            break;
          }
          continue;
        }
        a === -1 && ((c = !1), (a = l + 1)), n === Zs ? (r === -1 ? (r = l) : h !== 1 && (h = 1)) : r !== -1 && (h = -1);
      }
      return (
        a !== -1 && (r === -1 || h === 0 || (h === 1 && r === a - 1 && r === o + 1) ? (e.base = e.name = t.slice(o, a)) : ((e.name = t.slice(o, r)), (e.base = t.slice(o, a)), (e.ext = t.slice(r, a)))),
        o > 0 && o !== i ? (e.dir = t.slice(0, o - 1)) : (e.dir = e.root),
        e
      );
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null,
  },
  Fv = (() => {
    if (qt) {
      const t = /\\/g;
      return () => {
        const e = sr().replace(t, "/");
        return e.slice(e.indexOf("/"));
      };
    }
    return () => sr();
  })(),
  be = {
    resolve(...t) {
      let e = "",
        s = !1;
      for (let i = t.length - 1; i >= -1 && !s; i--) {
        const n = i >= 0 ? t[i] : Fv();
        Ve(n, `paths[${i}]`), n.length !== 0 && ((e = `${n}/${e}`), (s = n.charCodeAt(0) === ut));
      }
      return (e = $o(e, !s, "/", zc)), s ? `/${e}` : e.length > 0 ? e : ".";
    },
    normalize(t) {
      if ((Ve(t, "path"), t.length === 0)) return ".";
      const e = t.charCodeAt(0) === ut,
        s = t.charCodeAt(t.length - 1) === ut;
      return (t = $o(t, !e, "/", zc)), t.length === 0 ? (e ? "/" : s ? "./" : ".") : (s && (t += "/"), e ? `/${t}` : t);
    },
    isAbsolute(t) {
      return Ve(t, "path"), t.length > 0 && t.charCodeAt(0) === ut;
    },
    join(...t) {
      if (t.length === 0) return ".";
      let e;
      for (let s = 0; s < t.length; ++s) {
        const i = t[s];
        Ve(i, "path"), i.length > 0 && (e === void 0 ? (e = i) : (e += `/${i}`));
      }
      return e === void 0 ? "." : be.normalize(e);
    },
    relative(t, e) {
      if ((Ve(t, "from"), Ve(e, "to"), t === e || ((t = be.resolve(t)), (e = be.resolve(e)), t === e))) return "";
      const s = 1,
        i = t.length,
        n = i - s,
        r = 1,
        o = e.length - r,
        a = n < o ? n : o;
      let c = -1,
        l = 0;
      for (; l < a; l++) {
        const u = t.charCodeAt(s + l);
        if (u !== e.charCodeAt(r + l)) break;
        u === ut && (c = l);
      }
      if (l === a)
        if (o > a) {
          if (e.charCodeAt(r + l) === ut) return e.slice(r + l + 1);
          if (l === 0) return e.slice(r + l);
        } else n > a && (t.charCodeAt(s + l) === ut ? (c = l) : l === 0 && (c = 0));
      let h = "";
      for (l = s + c + 1; l <= i; ++l) (l === i || t.charCodeAt(l) === ut) && (h += h.length === 0 ? ".." : "/..");
      return `${h}${e.slice(r + c)}`;
    },
    toNamespacedPath(t) {
      return t;
    },
    dirname(t) {
      if ((Ve(t, "path"), t.length === 0)) return ".";
      const e = t.charCodeAt(0) === ut;
      let s = -1,
        i = !0;
      for (let n = t.length - 1; n >= 1; --n)
        if (t.charCodeAt(n) === ut) {
          if (!i) {
            s = n;
            break;
          }
        } else i = !1;
      return s === -1 ? (e ? "/" : ".") : e && s === 1 ? "//" : t.slice(0, s);
    },
    basename(t, e) {
      e !== void 0 && Ve(e, "ext"), Ve(t, "path");
      let s = 0,
        i = -1,
        n = !0,
        r;
      if (e !== void 0 && e.length > 0 && e.length <= t.length) {
        if (e === t) return "";
        let o = e.length - 1,
          a = -1;
        for (r = t.length - 1; r >= 0; --r) {
          const c = t.charCodeAt(r);
          if (c === ut) {
            if (!n) {
              s = r + 1;
              break;
            }
          } else a === -1 && ((n = !1), (a = r + 1)), o >= 0 && (c === e.charCodeAt(o) ? --o === -1 && (i = r) : ((o = -1), (i = a)));
        }
        return s === i ? (i = a) : i === -1 && (i = t.length), t.slice(s, i);
      }
      for (r = t.length - 1; r >= 0; --r)
        if (t.charCodeAt(r) === ut) {
          if (!n) {
            s = r + 1;
            break;
          }
        } else i === -1 && ((n = !1), (i = r + 1));
      return i === -1 ? "" : t.slice(s, i);
    },
    extname(t) {
      Ve(t, "path");
      let e = -1,
        s = 0,
        i = -1,
        n = !0,
        r = 0;
      for (let o = t.length - 1; o >= 0; --o) {
        const a = t.charCodeAt(o);
        if (a === ut) {
          if (!n) {
            s = o + 1;
            break;
          }
          continue;
        }
        i === -1 && ((n = !1), (i = o + 1)), a === Zs ? (e === -1 ? (e = o) : r !== 1 && (r = 1)) : e !== -1 && (r = -1);
      }
      return e === -1 || i === -1 || r === 0 || (r === 1 && e === i - 1 && e === s + 1) ? "" : t.slice(e, i);
    },
    format: Ad.bind(null, "/"),
    parse(t) {
      Ve(t, "path");
      const e = { root: "", dir: "", base: "", ext: "", name: "" };
      if (t.length === 0) return e;
      const s = t.charCodeAt(0) === ut;
      let i;
      s ? ((e.root = "/"), (i = 1)) : (i = 0);
      let n = -1,
        r = 0,
        o = -1,
        a = !0,
        c = t.length - 1,
        l = 0;
      for (; c >= i; --c) {
        const h = t.charCodeAt(c);
        if (h === ut) {
          if (!a) {
            r = c + 1;
            break;
          }
          continue;
        }
        o === -1 && ((a = !1), (o = c + 1)), h === Zs ? (n === -1 ? (n = c) : l !== 1 && (l = 1)) : n !== -1 && (l = -1);
      }
      if (o !== -1) {
        const h = r === 0 && s ? 1 : r;
        n === -1 || l === 0 || (l === 1 && n === o - 1 && n === r + 1) ? (e.base = e.name = t.slice(h, o)) : ((e.name = t.slice(h, n)), (e.base = t.slice(h, o)), (e.ext = t.slice(n, o)));
      }
      return r > 0 ? (e.dir = t.slice(0, r - 1)) : s && (e.dir = "/"), e;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null,
  };
(be.win32 = Ye.win32 = Ye), (be.posix = Ye.posix = be);
var Di = qt ? Ye.normalize : be.normalize,
  xo = qt ? Ye.isAbsolute : be.isAbsolute,
  V = qt ? Ye.join : be.join,
  Ii = qt ? Ye.resolve : be.resolve,
  Od = qt ? Ye.relative : be.relative,
  Yt = qt ? Ye.dirname : be.dirname,
  Ot = qt ? Ye.basename : be.basename,
  Mv = qt ? Ye.extname : be.extname,
  J6 = qt ? Ye.format : be.format,
  K6 = qt ? Ye.parse : be.parse,
  X6 = qt ? Ye.toNamespacedPath : be.toNamespacedPath,
  Vt = qt ? Ye.sep : be.sep,
  Uv = qt ? Ye.delimiter : be.delimiter,
  _v = /^\w[\w\d+.-]*$/,
  Bv = /^\//,
  zv = /^\/\//;
function qv(t, e) {
  if (!t.scheme && e) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
  if (t.scheme && !_v.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
  if (t.path) {
    if (t.authority) {
      if (!Bv.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (zv.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function Vv(t, e) {
  return !t && !e ? "file" : t;
}
function Wv(t, e) {
  switch (t) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== us && (e = us + e) : (e = us);
      break;
  }
  return e;
}
var Oe = "",
  us = "/",
  Hv = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
  C = class lc {
    static isUri(e) {
      return e instanceof lc
        ? !0
        : e
          ? typeof e.authority == "string" &&
            typeof e.fragment == "string" &&
            typeof e.path == "string" &&
            typeof e.query == "string" &&
            typeof e.scheme == "string" &&
            typeof e.fsPath == "string" &&
            typeof e.with == "function" &&
            typeof e.toString == "function"
          : !1;
    }
    constructor(e, s, i, n, r, o = !1) {
      typeof e == "object"
        ? ((this.scheme = e.scheme || Oe), (this.authority = e.authority || Oe), (this.path = e.path || Oe), (this.query = e.query || Oe), (this.fragment = e.fragment || Oe))
        : ((this.scheme = Vv(e, o)), (this.authority = s || Oe), (this.path = Wv(this.scheme, i || Oe)), (this.query = n || Oe), (this.fragment = r || Oe), qv(this, o));
    }
    get fsPath() {
      return Co(this, !1);
    }
    with(e) {
      if (!e) return this;
      let { scheme: s, authority: i, path: n, query: r, fragment: o } = e;
      return (
        s === void 0 ? (s = this.scheme) : s === null && (s = Oe),
        i === void 0 ? (i = this.authority) : i === null && (i = Oe),
        n === void 0 ? (n = this.path) : n === null && (n = Oe),
        r === void 0 ? (r = this.query) : r === null && (r = Oe),
        o === void 0 ? (o = this.fragment) : o === null && (o = Oe),
        s === this.scheme && i === this.authority && n === this.path && r === this.query && o === this.fragment ? this : new pn(s, i, n, r, o)
      );
    }
    static parse(e, s = !1) {
      const i = Hv.exec(e);
      return i ? new pn(i[2] || Oe, ko(i[4] || Oe), ko(i[5] || Oe), ko(i[7] || Oe), ko(i[9] || Oe), s) : new pn(Oe, Oe, Oe, Oe, Oe);
    }
    static file(e) {
      let s = Oe;
      if ((Be && (e = e.replace(/\\/g, us)), e[0] === us && e[1] === us)) {
        const i = e.indexOf(us, 2);
        i === -1 ? ((s = e.substring(2)), (e = us)) : ((s = e.substring(2, i)), (e = e.substring(i) || us));
      }
      return new pn("file", s, e, Oe, Oe);
    }
    static from(e, s) {
      return new pn(e.scheme, e.authority, e.path, e.query, e.fragment, s);
    }
    static joinPath(e, ...s) {
      if (!e.path) throw new Error("[UriError]: cannot call joinPath on URI without path");
      let i;
      return Be && e.scheme === "file" ? (i = lc.file(Ye.join(Co(e, !0), ...s)).path) : (i = be.join(e.path, ...s)), e.with({ path: i });
    }
    toString(e = !1) {
      return qc(this, e);
    }
    toJSON() {
      return this;
    }
    static revive(e) {
      if (e) {
        if (e instanceof lc) return e;
        {
          const s = new pn(e);
          return (s._formatted = e.external ?? null), (s._fsPath = e._sep === Ld ? (e.fsPath ?? null) : null), s;
        }
      } else return e;
    }
    [Symbol.for("debug.description")]() {
      return `URI(${this.toString()})`;
    }
  },
  Ld = Be ? 1 : void 0,
  pn = class extends C {
    constructor() {
      super(...arguments), (this._formatted = null), (this._fsPath = null);
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = Co(this, !1)), this._fsPath;
    }
    toString(t = !1) {
      return t ? qc(this, !0) : (this._formatted || (this._formatted = qc(this, !1)), this._formatted);
    }
    toJSON() {
      const t = { $mid: 1 };
      return (
        this._fsPath && ((t.fsPath = this._fsPath), (t._sep = Ld)),
        this._formatted && (t.external = this._formatted),
        this.path && (t.path = this.path),
        this.scheme && (t.scheme = this.scheme),
        this.authority && (t.authority = this.authority),
        this.query && (t.query = this.query),
        this.fragment && (t.fragment = this.fragment),
        t
      );
    }
  },
  Nd = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
function Td(t, e, s) {
  let i,
    n = -1;
  for (let r = 0; r < t.length; r++) {
    const o = t.charCodeAt(r);
    if ((o >= 97 && o <= 122) || (o >= 65 && o <= 90) || (o >= 48 && o <= 57) || o === 45 || o === 46 || o === 95 || o === 126 || (e && o === 47) || (s && o === 91) || (s && o === 93) || (s && o === 58))
      n !== -1 && ((i += encodeURIComponent(t.substring(n, r))), (n = -1)), i !== void 0 && (i += t.charAt(r));
    else {
      i === void 0 && (i = t.substr(0, r));
      const a = Nd[o];
      a !== void 0 ? (n !== -1 && ((i += encodeURIComponent(t.substring(n, r))), (n = -1)), (i += a)) : n === -1 && (n = r);
    }
  }
  return n !== -1 && (i += encodeURIComponent(t.substring(n))), i !== void 0 ? i : t;
}
function Gv(t) {
  let e;
  for (let s = 0; s < t.length; s++) {
    const i = t.charCodeAt(s);
    i === 35 || i === 63 ? (e === void 0 && (e = t.substr(0, s)), (e += Nd[i])) : e !== void 0 && (e += t[s]);
  }
  return e !== void 0 ? e : t;
}
function Co(t, e) {
  let s;
  return (
    t.authority && t.path.length > 1 && t.scheme === "file"
      ? (s = `//${t.authority}${t.path}`)
      : t.path.charCodeAt(0) === 47 && ((t.path.charCodeAt(1) >= 65 && t.path.charCodeAt(1) <= 90) || (t.path.charCodeAt(1) >= 97 && t.path.charCodeAt(1) <= 122)) && t.path.charCodeAt(2) === 58
        ? e
          ? (s = t.path.substr(1))
          : (s = t.path[1].toLowerCase() + t.path.substr(2))
        : (s = t.path),
    Be && (s = s.replace(/\//g, "\\")),
    s
  );
}
function qc(t, e) {
  const s = e ? Gv : Td;
  let i = "",
    { scheme: n, authority: r, path: o, query: a, fragment: c } = t;
  if ((n && ((i += n), (i += ":")), (r || n === "file") && ((i += us), (i += us)), r)) {
    let l = r.indexOf("@");
    if (l !== -1) {
      const h = r.substr(0, l);
      (r = r.substr(l + 1)), (l = h.lastIndexOf(":")), l === -1 ? (i += s(h, !1, !1)) : ((i += s(h.substr(0, l), !1, !1)), (i += ":"), (i += s(h.substr(l + 1), !1, !0))), (i += "@");
    }
    (r = r.toLowerCase()), (l = r.lastIndexOf(":")), l === -1 ? (i += s(r, !1, !0)) : ((i += s(r.substr(0, l), !1, !0)), (i += r.substr(l)));
  }
  if (o) {
    if (o.length >= 3 && o.charCodeAt(0) === 47 && o.charCodeAt(2) === 58) {
      const l = o.charCodeAt(1);
      l >= 65 && l <= 90 && (o = `/${String.fromCharCode(l + 32)}:${o.substr(3)}`);
    } else if (o.length >= 2 && o.charCodeAt(1) === 58) {
      const l = o.charCodeAt(0);
      l >= 65 && l <= 90 && (o = `${String.fromCharCode(l + 32)}:${o.substr(2)}`);
    }
    i += s(o, !0, !1);
  }
  return a && ((i += "?"), (i += s(a, !1, !1))), c && ((i += "#"), (i += e ? c : Td(c, !1, !1))), i;
}
function jd(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    return t.length > 3 ? t.substr(0, 3) + jd(t.substr(3)) : t;
  }
}
var Fd = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function ko(t) {
  return t.match(Fd) ? t.replace(Fd, (e) => jd(e)) : t;
}
var oe;
(function (t) {
  (t.inMemory = "inmemory"),
    (t.vscode = "vscode"),
    (t.internal = "private"),
    (t.walkThrough = "walkThrough"),
    (t.walkThroughSnippet = "walkThroughSnippet"),
    (t.http = "http"),
    (t.https = "https"),
    (t.file = "file"),
    (t.mailto = "mailto"),
    (t.untitled = "untitled"),
    (t.data = "data"),
    (t.command = "command"),
    (t.vscodeRemote = "vscode-remote"),
    (t.vscodeRemoteDownload = "vscode-remote-download"),
    (t.vscodeRemoteResource = "vscode-remote-resource"),
    (t.vscodeManagedRemoteResource = "vscode-managed-remote-resource"),
    (t.vscodeUserData = "vscode-userdata"),
    (t.vscodeCustomEditor = "vscode-custom-editor"),
    (t.vscodeNotebookCell = "vscode-notebook-cell"),
    (t.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata"),
    (t.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff"),
    (t.vscodeNotebookCellOutput = "vscode-notebook-cell-output"),
    (t.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff"),
    (t.vscodeNotebookMetadata = "vscode-notebook-metadata"),
    (t.vscodeInteractiveInput = "vscode-interactive-input"),
    (t.vscodeSettings = "vscode-settings"),
    (t.vscodeWorkspaceTrust = "vscode-workspace-trust"),
    (t.vscodeTerminal = "vscode-terminal"),
    (t.vscodeChatCodeBlock = "vscode-chat-code-block"),
    (t.icubeChatCodeBlock = "icube-chat-code-block"),
    (t.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block"),
    (t.vscodeChatSesssion = "vscode-chat-editor"),
    (t.vscodeComponent = "vscode-component-editor"),
    (t.vscodeIcubeChatSession = "vscode-icube-chat-editor"),
    (t.webviewPanel = "webview-panel"),
    (t.vscodeWebview = "vscode-webview"),
    (t.extension = "extension"),
    (t.vscodeFileResource = "vscode-file"),
    (t.tmp = "tmp"),
    (t.vsls = "vsls"),
    (t.vscodeSourceControl = "vscode-scm"),
    (t.commentsInput = "comment"),
    (t.codeSetting = "code-setting"),
    (t.outputChannel = "output"),
    (t.accessibleView = "accessible-view");
})(oe || (oe = {}));
var Jv = "tkn",
  Kv = class {
    constructor() {
      (this.a = Object.create(null)), (this.b = Object.create(null)), (this.c = Object.create(null)), (this.d = "http"), (this.e = null), (this.f = "/");
    }
    setPreferredWebSchema(t) {
      this.d = t;
    }
    setDelegate(t) {
      this.e = t;
    }
    setServerRootPath(t, e) {
      this.f = Xv(t, e);
    }
    getServerRootPath() {
      return this.f;
    }
    get g() {
      return be.join(this.f, oe.vscodeRemoteResource);
    }
    set(t, e, s) {
      (this.a[t] = e), (this.b[t] = s);
    }
    setConnectionToken(t, e) {
      this.c[t] = e;
    }
    getPreferredWebSchema() {
      return this.d;
    }
    rewrite(t) {
      if (this.e)
        try {
          return this.e(t);
        } catch (o) {
          return rt(o), t;
        }
      const e = t.authority;
      let s = this.a[e];
      s && s.indexOf(":") !== -1 && s.indexOf("[") === -1 && (s = `[${s}]`);
      const i = this.b[e],
        n = this.c[e];
      let r = `path=${encodeURIComponent(t.path)}`;
      return typeof n == "string" && (r += `&${Jv}=${encodeURIComponent(n)}`), C.from({ scheme: Qe ? this.d : oe.vscodeRemoteResource, authority: `${s}:${i}`, path: this.g, query: r });
    }
  },
  Md = new Kv();
function Xv(t, e) {
  return be.join(e ?? "/", `${t.quality ?? "oss"}-${t.commit ?? "dev"}`);
}
var Qv = "vs/../../node_modules",
  Yv = "vs/../../node_modules.asar",
  Ud = "vscode-app",
  Zv = class hc {
    static {
      this.a = Ud;
    }
    asBrowserUri(e) {
      const s = this.b(e);
      return this.uriToBrowserUri(s);
    }
    uriToBrowserUri(e) {
      return e.scheme === oe.vscodeRemote
        ? Md.rewrite(e)
        : e.scheme === oe.file && (nv || ov === `${oe.vscodeFileResource}://${hc.a}`)
          ? e.with({ scheme: oe.vscodeFileResource, authority: e.authority || hc.a, query: null, fragment: null })
          : e;
    }
    asFileUri(e) {
      const s = this.b(e);
      return this.uriToFileUri(s);
    }
    uriToFileUri(e) {
      return e.scheme === oe.vscodeFileResource ? e.with({ scheme: oe.file, authority: e.authority !== hc.a ? e.authority : null, query: null, fragment: null }) : e;
    }
    b(e, s) {
      if (C.isUri(e)) return e;
      if (globalThis._VSCODE_FILE_ROOT) {
        const i = globalThis._VSCODE_FILE_ROOT;
        if (/^\w[\w\d+.-]*:\/\//.test(i)) return C.joinPath(C.parse(i, !0), e);
        const n = V(i, e);
        return C.file(n);
      }
      return C.parse(s.toUrl(e));
    }
  },
  Cs = new Zv(),
  _d;
(function (t) {
  const e = new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }],
  ]);
  t.CoopAndCoep = Object.freeze(e.get("3"));
  const s = "vscode-coi";
  function i(r) {
    let o;
    typeof r == "string" ? (o = new URL(r).searchParams) : r instanceof URL ? (o = r.searchParams) : C.isUri(r) && (o = new URL(r.toString(!0)).searchParams);
    const a = o?.get(s);
    if (a) return e.get(a);
  }
  t.getHeadersFromQuery = i;
  function n(r, o, a) {
    if (!globalThis.crossOriginIsolated) return;
    const c = o && a ? "3" : a ? "2" : "1";
    r instanceof URLSearchParams ? r.set(s, c) : (r[s] = c);
  }
  t.addSearchParam = n;
})(_d || (_d = {}));
function si(t) {
  return t === 47 || t === 92;
}
function Bd(t) {
  return t.replace(/[\\/]/g, be.sep);
}
function ey(t) {
  return t.indexOf("/") === -1 && (t = Bd(t)), /^[a-zA-Z]:(\/|$)/.test(t) && (t = "/" + t), t;
}
function zd(t, e = be.sep) {
  if (!t) return "";
  const s = t.length,
    i = t.charCodeAt(0);
  if (si(i)) {
    if (si(t.charCodeAt(1)) && !si(t.charCodeAt(2))) {
      let r = 3;
      const o = r;
      for (; r < s && !si(t.charCodeAt(r)); r++);
      if (o !== r && !si(t.charCodeAt(r + 1))) {
        for (r += 1; r < s; r++) if (si(t.charCodeAt(r))) return t.slice(0, r + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (qd(i) && t.charCodeAt(1) === 58) return si(t.charCodeAt(2)) ? t.slice(0, 2) + e : t.slice(0, 2);
  let n = t.indexOf("://");
  if (n !== -1) {
    for (n += 3; n < s; n++) if (si(t.charCodeAt(n))) return t.slice(0, n + 1);
  }
  return "";
}
function Vc(t, e, s) {
  const i = t === e;
  return !s || i ? i : !t || !e ? !1 : Ci(t, e);
}
function ir(t, e, s, i = Vt) {
  if (t === e) return !0;
  if (!t || !e || e.length > t.length) return !1;
  if (s) {
    if (!kd(t, e)) return !1;
    if (e.length === t.length) return !0;
    let r = e.length;
    return e.charAt(e.length - 1) === i && r--, t.charAt(r) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), t.indexOf(e) === 0;
}
function qd(t) {
  return (t >= 65 && t <= 90) || (t >= 97 && t <= 122);
}
function ty(t) {
  return Be ? ((t = Fc(t, Vt)), t.endsWith(":") && (t += Vt)) : ((t = Fc(t, Vt)), t || (t = Vt)), t;
}
function sy(t) {
  const e = Di(t);
  return Be ? (t.length > 3 ? !1 : iy(e) && (t.length === 2 || e.charCodeAt(2) === 92)) : e === be.sep;
}
function iy(t, e = Be) {
  return e ? qd(t.charCodeAt(0)) && t.charCodeAt(1) === 58 : !1;
}
var ny = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  ry = "BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789";
function oy(t, e, s = 8) {
  let i = "";
  for (let r = 0; r < s; r++) {
    let o;
    r === 0 && Be && !e && (s === 3 || s === 4) ? (o = ry) : (o = ny), (i += o.charAt(Math.floor(Math.random() * o.length)));
  }
  let n;
  return e ? (n = `${e}-${i}`) : (n = i), t ? V(t, n) : n;
}
function Bs(t) {
  return Co(t, !0);
}
var Do = class {
    constructor(t) {
      this.a = t;
    }
    compare(t, e, s = !1) {
      return t === e ? 0 : Eo(this.getComparisonKey(t, s), this.getComparisonKey(e, s));
    }
    isEqual(t, e, s = !1) {
      return t === e ? !0 : !t || !e ? !1 : this.getComparisonKey(t, s) === this.getComparisonKey(e, s);
    }
    getComparisonKey(t, e = !1) {
      return t.with({ path: this.a(t) ? t.path.toLowerCase() : void 0, fragment: e ? null : void 0 }).toString();
    }
    ignorePathCasing(t) {
      return this.a(t);
    }
    isEqualOrParent(t, e, s = !1) {
      if (t.scheme === e.scheme) {
        if (t.scheme === oe.file) return ir(Bs(t), Bs(e), this.a(t)) && t.query === e.query && (s || t.fragment === e.fragment);
        if (Hd(t.authority, e.authority)) return ir(t.path, e.path, this.a(t), "/") && t.query === e.query && (s || t.fragment === e.fragment);
      }
      return !1;
    }
    joinPath(t, ...e) {
      return C.joinPath(t, ...e);
    }
    basenameOrAuthority(t) {
      return nr(t) || t.authority;
    }
    basename(t) {
      return be.basename(t.path);
    }
    extname(t) {
      return be.extname(t.path);
    }
    dirname(t) {
      if (t.path.length === 0) return t;
      let e;
      return (
        t.scheme === oe.file ? (e = C.file(Yt(Bs(t))).path) : ((e = be.dirname(t.path)), t.authority && e.length && e.charCodeAt(0) !== 47 && (console.error(`dirname("${t.toString})) resulted in a relative path`), (e = "/"))),
        t.with({ path: e })
      );
    }
    normalizePath(t) {
      if (!t.path.length) return t;
      let e;
      return t.scheme === oe.file ? (e = C.file(Di(Bs(t))).path) : (e = be.normalize(t.path)), t.with({ path: e });
    }
    relativePath(t, e) {
      if (t.scheme !== e.scheme || !Hd(t.authority, e.authority)) return;
      if (t.scheme === oe.file) {
        const n = Od(Bs(t), Bs(e));
        return Be ? Bd(n) : n;
      }
      let s = t.path || "/";
      const i = e.path || "/";
      if (this.a(t)) {
        let n = 0;
        for (const r = Math.min(s.length, i.length); n < r && !(s.charCodeAt(n) !== i.charCodeAt(n) && s.charAt(n).toLowerCase() !== i.charAt(n).toLowerCase()); n++);
        s = i.substr(0, n) + s.substr(n);
      }
      return be.relative(s, i);
    }
    resolvePath(t, e) {
      if (t.scheme === oe.file) {
        const s = C.file(Ii(Bs(t), e));
        return t.with({ authority: s.authority, path: s.path });
      }
      return (e = ey(e)), t.with({ path: be.resolve(t.path, e) });
    }
    isAbsolutePath(t) {
      return !!t.path && t.path[0] === "/";
    }
    isEqualAuthority(t, e) {
      return t === e || (t !== void 0 && e !== void 0 && Ci(t, e));
    }
    hasTrailingPathSeparator(t, e = Vt) {
      if (t.scheme === oe.file) {
        const s = Bs(t);
        return s.length > zd(s).length && s[s.length - 1] === e;
      } else {
        const s = t.path;
        return s.length > 1 && s.charCodeAt(s.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(t.fsPath);
      }
    }
    removeTrailingPathSeparator(t, e = Vt) {
      return Gd(t, e) ? t.with({ path: t.path.substr(0, t.path.length - 1) }) : t;
    }
    addTrailingPathSeparator(t, e = Vt) {
      let s = !1;
      if (t.scheme === oe.file) {
        const i = Bs(t);
        s = i !== void 0 && i.length === zd(i).length && i[i.length - 1] === e;
      } else {
        e = "/";
        const i = t.path;
        s = i.length === 1 && i.charCodeAt(i.length - 1) === 47;
      }
      return !s && !Gd(t, e) ? t.with({ path: t.path + "/" }) : t;
    }
  },
  ge = new Do(() => !1),
  Wc = new Do((t) => (t.scheme === oe.file ? !ht : !0)),
  ay = new Do((t) => !0),
  zs = ge.isEqual.bind(ge),
  Vd = ge.isEqualOrParent.bind(ge),
  Q6 = ge.getComparisonKey.bind(ge),
  Y6 = ge.basenameOrAuthority.bind(ge),
  nr = ge.basename.bind(ge),
  Z6 = ge.extname.bind(ge),
  Wd = ge.dirname.bind(ge),
  M = ge.joinPath.bind(ge),
  cy = ge.normalizePath.bind(ge),
  ly = ge.relativePath.bind(ge),
  e3 = ge.resolvePath.bind(ge),
  hy = ge.isAbsolutePath.bind(ge),
  Hd = ge.isEqualAuthority.bind(ge),
  Gd = ge.hasTrailingPathSeparator.bind(ge),
  t3 = ge.removeTrailingPathSeparator.bind(ge),
  s3 = ge.addTrailingPathSeparator.bind(ge),
  Jd;
(function (t) {
  (t.META_DATA_LABEL = "label"), (t.META_DATA_DESCRIPTION = "description"), (t.META_DATA_SIZE = "size"), (t.META_DATA_MIME = "mime");
  function e(s) {
    const i = new Map();
    s.path
      .substring(s.path.indexOf(";") + 1, s.path.lastIndexOf(";"))
      .split(";")
      .forEach((o) => {
        const [a, c] = o.split(":");
        a && c && i.set(a, c);
      });
    const r = s.path.substring(0, s.path.indexOf(";"));
    return r && i.set(t.META_DATA_MIME, r), i;
  }
  t.parseMetaData = e;
})(Jd || (Jd = {}));
var uy = Symbol("MicrotaskDelay");
function Hc(t) {
  return !!t && typeof t.then == "function";
}
function wt(t) {
  const e = new xs(),
    s = t(e.token),
    i = new Promise((n, r) => {
      const o = e.token.onCancellationRequested(() => {
        o.dispose(), r(new ot());
      });
      Promise.resolve(s).then(
        (a) => {
          o.dispose(), e.dispose(), n(a);
        },
        (a) => {
          o.dispose(), e.dispose(), r(a);
        },
      );
    });
  return new (class {
    cancel() {
      e.cancel(), e.dispose();
    }
    then(n, r) {
      return i.then(n, r);
    }
    catch(n) {
      return this.then(void 0, n);
    }
    finally(n) {
      return i.finally(n);
    }
  })();
}
function fy() {
  let t, e;
  return {
    promise: new Promise((i, n) => {
      (t = i), (e = n);
    }),
    resolve: t,
    reject: e,
  };
}
var dy = class {
    constructor() {
      (this.f = !1), (this.a = null), (this.b = null), (this.d = null);
    }
    queue(t) {
      if (this.f) return Promise.reject(new Error("Throttler is disposed"));
      if (this.a) {
        if (((this.d = t), !this.b)) {
          const e = () => {
            if (((this.b = null), this.f)) return;
            const s = this.queue(this.d);
            return (this.d = null), s;
          };
          this.b = new Promise((s) => {
            this.a.then(e, e).then(s);
          });
        }
        return new Promise((e, s) => {
          this.b.then(e, s);
        });
      }
      return (
        (this.a = t()),
        new Promise((e, s) => {
          this.a.then(
            (i) => {
              (this.a = null), e(i);
            },
            (i) => {
              (this.a = null), s(i);
            },
          );
        })
      );
    }
    dispose() {
      this.f = !0;
    }
  },
  py = class {
    constructor() {
      this.a = Promise.resolve(null);
    }
    queue(t) {
      return (this.a = this.a.then(
        () => t(),
        () => t(),
      ));
    }
  },
  gy = (t, e) => {
    let s = !0;
    const i = setTimeout(() => {
      (s = !1), e();
    }, t);
    return {
      isTriggered: () => s,
      dispose: () => {
        clearTimeout(i), (s = !1);
      },
    };
  },
  my = (t) => {
    let e = !0;
    return (
      queueMicrotask(() => {
        e && ((e = !1), t());
      }),
      {
        isTriggered: () => e,
        dispose: () => {
          e = !1;
        },
      }
    );
  },
  Gc = class {
    constructor(t) {
      (this.defaultDelay = t), (this.a = null), (this.b = null), (this.d = null), (this.f = null), (this.g = null);
    }
    trigger(t, e = this.defaultDelay) {
      (this.g = t),
        this.h(),
        this.b ||
          (this.b = new Promise((i, n) => {
            (this.d = i), (this.f = n);
          }).then(() => {
            if (((this.b = null), (this.d = null), this.g)) {
              const i = this.g;
              return (this.g = null), i();
            }
          }));
      const s = () => {
        (this.a = null), this.d?.(null);
      };
      return (this.a = e === uy ? my(s) : gy(e, s)), this.b;
    }
    isTriggered() {
      return !!this.a?.isTriggered();
    }
    cancel() {
      this.h(), this.b && (this.f?.(new ot()), (this.b = null));
    }
    h() {
      this.a?.dispose(), (this.a = null);
    }
    dispose() {
      this.cancel();
    }
  },
  Ri = class {
    constructor(t) {
      (this.a = new Gc(t)), (this.b = new dy());
    }
    trigger(t, e) {
      return this.a.trigger(() => this.b.queue(t), e);
    }
    isTriggered() {
      return this.a.isTriggered();
    }
    cancel() {
      this.a.cancel();
    }
    dispose() {
      this.a.dispose(), this.b.dispose();
    }
  },
  Jc = class {
    constructor() {
      (this.a = !1),
        (this.b = new Promise((t, e) => {
          this.d = t;
        }));
    }
    isOpen() {
      return this.a;
    }
    open() {
      (this.a = !0), this.d(!0);
    }
    wait() {
      return this.b;
    }
  };
function Pi(t, e) {
  return e
    ? new Promise((s, i) => {
        const n = setTimeout(() => {
            r.dispose(), s();
          }, t),
          r = e.onCancellationRequested(() => {
            clearTimeout(n), r.dispose(), i(new ot());
          });
      })
    : wt((s) => Pi(t, s));
}
function gn(t, e = 0, s) {
  const i = setTimeout(() => {
      t(), s && n.dispose();
    }, e),
    n = ue(() => {
      clearTimeout(i), s?.deleteAndLeak(n);
    });
  return s?.add(n), n;
}
var Kd = class {
    constructor(t) {
      (this.a = 0), (this.b = !1), (this.f = t), (this.g = []), (this.d = 0), (this.h = new D());
    }
    whenIdle() {
      return this.size > 0 ? T.toPromise(this.onDrained) : Promise.resolve();
    }
    get onDrained() {
      return this.h.event;
    }
    get size() {
      return this.a;
    }
    queue(t) {
      if (this.b) throw new Error("Object has been disposed");
      return (
        this.a++,
        new Promise((e, s) => {
          this.g.push({ factory: t, c: e, e: s }), this.j();
        })
      );
    }
    j() {
      for (; this.g.length && this.d < this.f; ) {
        const t = this.g.shift();
        this.d++;
        const e = t.factory();
        e.then(t.c, t.e),
          e.then(
            () => this.k(),
            () => this.k(),
          );
      }
    }
    k() {
      this.b || (this.d--, --this.a === 0 && this.h.fire(), this.g.length > 0 && this.j());
    }
    clear() {
      if (this.b) throw new Error("Object has been disposed");
      (this.g.length = 0), (this.a = this.d);
    }
    dispose() {
      (this.b = !0), (this.g.length = 0), (this.a = 0), this.h.dispose();
    }
  },
  rr = class extends Kd {
    constructor() {
      super(1);
    }
  },
  Xd = class {
    constructor() {
      (this.a = new Map()), (this.b = new Set()), (this.d = void 0), (this.f = 0);
    }
    async whenDrained() {
      if (this.g()) return;
      const t = new Ro();
      return this.b.add(t), t.p;
    }
    g() {
      for (const [, t] of this.a) if (t.size > 0) return !1;
      return !0;
    }
    queueSize(t, e = ge) {
      const s = e.getComparisonKey(t);
      return this.a.get(s)?.size ?? 0;
    }
    queueFor(t, e, s = ge) {
      const i = s.getComparisonKey(t);
      let n = this.a.get(i);
      if (!n) {
        n = new rr();
        const r = this.f++,
          o = T.once(n.onDrained)(() => {
            n?.dispose(), this.a.delete(i), this.h(), this.d?.deleteAndDispose(r), this.d?.size === 0 && (this.d.dispose(), (this.d = void 0));
          });
        this.d || (this.d = new po()), this.d.set(r, o), this.a.set(i, n);
      }
      return n.queue(e);
    }
    h() {
      this.g() && this.j();
    }
    j() {
      for (const t of this.b) t.complete();
      this.b.clear();
    }
    dispose() {
      for (const [, t] of this.a) t.dispose();
      this.a.clear(), this.j(), this.d?.dispose();
    }
  },
  ks = class {
    constructor(t, e) {
      (this.b = -1), (this.a = t), (this.d = e), (this.f = this.g.bind(this));
    }
    dispose() {
      this.cancel(), (this.a = null);
    }
    cancel() {
      this.isScheduled() && (clearTimeout(this.b), (this.b = -1));
    }
    schedule(t = this.d) {
      this.cancel(), (this.b = setTimeout(this.f, t));
    }
    get delay() {
      return this.d;
    }
    set delay(t) {
      this.d = t;
    }
    isScheduled() {
      return this.b !== -1;
    }
    flush() {
      this.isScheduled() && (this.cancel(), this.h());
    }
    g() {
      (this.b = -1), this.a && this.h();
    }
    h() {
      this.a?.();
    }
  },
  wy = class extends ks {
    constructor(t, e) {
      super(t, e), (this.j = []);
    }
    work(t) {
      this.j.push(t), this.isScheduled() || this.schedule();
    }
    h() {
      const t = this.j;
      (this.j = []), this.a?.(t);
    }
    dispose() {
      (this.j = []), super.dispose();
    }
  },
  vy = class extends O {
    constructor(t, e) {
      super(), (this.h = t), (this.j = e), (this.a = []), (this.b = this.B(new Es())), (this.f = !1), (this.g = 0);
    }
    get pending() {
      return this.a.length;
    }
    work(t) {
      if (this.f) return !1;
      if (typeof this.h.maxBufferedWork == "number") {
        if (this.b.value) {
          if (this.pending + t.length > this.h.maxBufferedWork) return !1;
        } else if (this.pending + t.length - this.h.maxWorkChunkSize > this.h.maxBufferedWork) return !1;
      }
      for (const s of t) this.a.push(s);
      const e = Date.now() - this.g;
      return !this.b.value && (!this.h.waitThrottleDelayBetweenWorkUnits || e >= this.h.throttleDelay) ? this.m() : !this.b.value && this.h.waitThrottleDelayBetweenWorkUnits && this.r(Math.max(this.h.throttleDelay - e, 0)), !0;
    }
    m() {
      (this.g = Date.now()), this.j(this.a.splice(0, this.h.maxWorkChunkSize)), this.a.length > 0 && this.r();
    }
    r(t = this.h.throttleDelay) {
      (this.b.value = new ks(() => {
        this.b.clear(), this.m();
      }, t)),
        this.b.value.schedule();
    }
    dispose() {
      super.dispose(), (this.f = !0);
    }
  },
  Qd,
  Io;
(function () {
  typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function"
    ? (Io = (t, e, s) => {
        cv(() => {
          if (i) return;
          const n = Date.now() + 15;
          e(
            Object.freeze({
              didTimeout: !0,
              timeRemaining() {
                return Math.max(0, n - Date.now());
              },
            }),
          );
        });
        let i = !1;
        return {
          dispose() {
            i || (i = !0);
          },
        };
      })
    : (Io = (t, e, s) => {
        const i = t.requestIdleCallback(e, typeof s == "number" ? { timeout: s } : void 0);
        let n = !1;
        return {
          dispose() {
            n || ((n = !0), t.cancelIdleCallback(i));
          },
        };
      }),
    (Qd = (t, e) => Io(globalThis, t, e));
})();
var yy = class {
    constructor(t, e) {
      (this.g = !1),
        (this.d = () => {
          try {
            this.j = e();
          } catch (s) {
            this.l = s;
          } finally {
            this.g = !0;
          }
        }),
        (this.f = Io(t, () => this.d()));
    }
    dispose() {
      this.f.dispose();
    }
    get value() {
      if ((this.g || (this.f.dispose(), this.d()), this.l)) throw this.l;
      return this.j;
    }
    get isInitialized() {
      return this.g;
    }
  },
  by = class extends yy {
    constructor(t) {
      super(globalThis, t);
    }
  };
async function Ey(t, e, s) {
  let i;
  for (let n = 0; n < s; n++)
    try {
      return await t();
    } catch (r) {
      (i = r), await Pi(e);
    }
  throw i;
}
var Yd;
(function (t) {
  (t[(t.Resolved = 0)] = "Resolved"), (t[(t.Rejected = 1)] = "Rejected");
})(Yd || (Yd = {}));
var Ro = class {
    get isRejected() {
      return this.d?.outcome === 1;
    }
    get isResolved() {
      return this.d?.outcome === 0;
    }
    get isSettled() {
      return !!this.d;
    }
    get value() {
      return this.d?.outcome === 0 ? this.d?.value : void 0;
    }
    constructor() {
      this.p = new Promise((t, e) => {
        (this.a = t), (this.b = e);
      });
    }
    complete(t) {
      return new Promise((e) => {
        this.a(t), (this.d = { outcome: 0, value: t }), e();
      });
    }
    error(t) {
      return new Promise((e) => {
        this.b(t), (this.d = { outcome: 1, value: t }), e();
      });
    }
    cancel() {
      return this.error(new ot());
    }
  },
  Ze;
(function (t) {
  async function e(i) {
    let n;
    const r = await Promise.all(
      i.map((o) =>
        o.then(
          (a) => a,
          (a) => {
            n || (n = a);
          },
        ),
      ),
    );
    if (typeof n < "u") throw n;
    return r;
  }
  t.settled = e;
  function s(i) {
    return new Promise(async (n, r) => {
      try {
        await i(n, r);
      } catch (o) {
        r(o);
      }
    });
  }
  t.withAsyncBody = s;
})(Ze || (Ze = {}));
var Zd;
(function (t) {
  (t[(t.Initial = 0)] = "Initial"), (t[(t.DoneOK = 1)] = "DoneOK"), (t[(t.DoneError = 2)] = "DoneError");
})(Zd || (Zd = {}));
var i3 = class ss {
  static fromArray(e) {
    return new ss((s) => {
      s.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new ss(async (s) => {
      s.emitMany(await e);
    });
  }
  static fromPromisesResolveOrder(e) {
    return new ss(async (s) => {
      await Promise.all(e.map(async (i) => s.emitOne(await i)));
    });
  }
  static merge(e) {
    return new ss(async (s) => {
      await Promise.all(
        e.map(async (i) => {
          for await (const n of i) s.emitOne(n);
        }),
      );
    });
  }
  static {
    this.EMPTY = ss.fromArray([]);
  }
  constructor(e, s) {
    (this.a = 0),
      (this.b = []),
      (this.d = null),
      (this.f = s),
      (this.g = new D()),
      queueMicrotask(async () => {
        const i = { emitOne: (n) => this.h(n), emitMany: (n) => this.j(n), reject: (n) => this.l(n) };
        try {
          await Promise.resolve(e(i)), this.k();
        } catch (n) {
          this.l(n);
        } finally {
          (i.emitOne = void 0), (i.emitMany = void 0), (i.reject = void 0);
        }
      });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this.a === 2) throw this.d;
          if (e < this.b.length) return { done: !1, value: this.b[e++] };
          if (this.a === 1) return { done: !0, value: void 0 };
          await T.toPromise(this.g.event);
        } while (!0);
      },
      return: async () => (this.f?.(), { done: !0, value: void 0 }),
    };
  }
  static map(e, s) {
    return new ss(async (i) => {
      for await (const n of e) i.emitOne(s(n));
    });
  }
  map(e) {
    return ss.map(this, e);
  }
  static filter(e, s) {
    return new ss(async (i) => {
      for await (const n of e) s(n) && i.emitOne(n);
    });
  }
  filter(e) {
    return ss.filter(this, e);
  }
  static coalesce(e) {
    return ss.filter(e, (s) => !!s);
  }
  coalesce() {
    return ss.coalesce(this);
  }
  static async toPromise(e) {
    const s = [];
    for await (const i of e) s.push(i);
    return s;
  }
  toPromise() {
    return ss.toPromise(this);
  }
  h(e) {
    this.a === 0 && (this.b.push(e), this.g.fire());
  }
  j(e) {
    this.a === 0 && ((this.b = this.b.concat(e)), this.g.fire());
  }
  k() {
    this.a === 0 && ((this.a = 1), this.g.fire());
  }
  l(e) {
    this.a === 0 && ((this.a = 2), (this.d = e), this.g.fire());
  }
};
function Po(t) {
  const e = t;
  return e ? [e.on, e.pause, e.resume, e.destroy].every((s) => typeof s == "function") : !1;
}
function Kc(t) {
  const e = t;
  return e ? Po(e.stream) && Array.isArray(e.buffer) && typeof e.ended == "boolean" : !1;
}
function or(t, e) {
  return new Sy(t, e);
}
var Sy = class {
  constructor(t, e) {
    (this.e = t), (this.f = e), (this.a = { flowing: !1, ended: !1, destroyed: !1 }), (this.b = { data: [], error: [] }), (this.c = { data: [], error: [], end: [] }), (this.d = []);
  }
  pause() {
    this.a.destroyed || (this.a.flowing = !1);
  }
  resume() {
    this.a.destroyed || this.a.flowing || ((this.a.flowing = !0), this.j(), this.k(), this.l());
  }
  write(t) {
    if (!this.a.destroyed) {
      if (this.a.flowing) this.g(t);
      else if ((this.b.data.push(t), typeof this.f?.highWaterMark == "number" && this.b.data.length > this.f.highWaterMark)) return new Promise((e) => this.d.push(e));
    }
  }
  error(t) {
    this.a.destroyed || (this.a.flowing ? this.h(t) : this.b.error.push(t));
  }
  end(t) {
    this.a.destroyed || (typeof t < "u" && this.write(t), this.a.flowing ? (this.i(), this.destroy()) : (this.a.ended = !0));
  }
  g(t) {
    this.c.data.slice(0).forEach((e) => e(t));
  }
  h(t) {
    this.c.error.length === 0 ? rt(t) : this.c.error.slice(0).forEach((e) => e(t));
  }
  i() {
    this.c.end.slice(0).forEach((t) => t());
  }
  on(t, e) {
    if (!this.a.destroyed)
      switch (t) {
        case "data":
          this.c.data.push(e), this.resume();
          break;
        case "end":
          this.c.end.push(e), this.a.flowing && this.l() && this.destroy();
          break;
        case "error":
          this.c.error.push(e), this.a.flowing && this.k();
          break;
      }
  }
  removeListener(t, e) {
    if (this.a.destroyed) return;
    let s;
    switch (t) {
      case "data":
        s = this.c.data;
        break;
      case "end":
        s = this.c.end;
        break;
      case "error":
        s = this.c.error;
        break;
    }
    if (s) {
      const i = s.indexOf(e);
      i >= 0 && s.splice(i, 1);
    }
  }
  j() {
    if (this.b.data.length > 0) {
      const t = this.e(this.b.data);
      this.g(t), (this.b.data.length = 0);
      const e = [...this.d];
      (this.d.length = 0), e.forEach((s) => s());
    }
  }
  k() {
    if (this.c.error.length > 0) {
      for (const t of this.b.error) this.h(t);
      this.b.error.length = 0;
    }
  }
  l() {
    return this.a.ended ? (this.i(), this.c.end.length > 0) : !1;
  }
  destroy() {
    this.a.destroyed || ((this.a.destroyed = !0), (this.a.ended = !0), (this.b.data.length = 0), (this.b.error.length = 0), (this.c.data.length = 0), (this.c.error.length = 0), (this.c.end.length = 0), (this.d.length = 0));
  }
};
function $y(t, e) {
  const s = [];
  let i;
  for (; (i = t.read()) !== null; ) s.push(i);
  return e(s);
}
function xy(t, e, s) {
  const i = [];
  let n;
  for (; (n = t.read()) !== null && i.length < s; ) i.push(n);
  return n === null && i.length > 0
    ? e(i)
    : {
        read: () => {
          if (i.length > 0) return i.shift();
          if (typeof n < "u") {
            const r = n;
            return (n = void 0), r;
          }
          return t.read();
        },
      };
}
function e1(t, e) {
  return new Promise((s, i) => {
    const n = [];
    Ao(t, {
      onData: (r) => {
        e && n.push(r);
      },
      onError: (r) => {
        e ? i(r) : s(void 0);
      },
      onEnd: () => {
        s(e ? e(n) : void 0);
      },
    });
  });
}
function Ao(t, e, s) {
  t.on("error", (i) => {
    s?.isCancellationRequested || e.onError(i);
  }),
    t.on("end", () => {
      s?.isCancellationRequested || e.onEnd();
    }),
    t.on("data", (i) => {
      s?.isCancellationRequested || e.onData(i);
    });
}
function Cy(t, e) {
  return new Promise((s, i) => {
    const n = new ye(),
      r = [],
      o = (l) => {
        if ((r.push(l), r.length > e)) return n.dispose(), t.pause(), s({ stream: t, buffer: r, ended: !1 });
      },
      a = (l) => (n.dispose(), i(l)),
      c = () => (n.dispose(), s({ stream: t, buffer: r, ended: !0 }));
    n.add(ue(() => t.removeListener("error", a))), t.on("error", a), n.add(ue(() => t.removeListener("end", c))), t.on("end", c), n.add(ue(() => t.removeListener("data", o))), t.on("data", o);
  });
}
function ky(t) {
  let e = !1;
  return { read: () => (e ? null : ((e = !0), t)) };
}
function t1(t, e, s) {
  const i = or(s);
  return Ao(t, { onData: (n) => i.write(e.data(n)), onError: (n) => i.error(e.error ? e.error(n) : n), onEnd: () => i.end() }), i;
}
var Oo = typeof Buffer < "u",
  Dy = new fn(() => new Uint8Array(256)),
  Xc,
  Qc,
  L = class as {
    static alloc(e) {
      return Oo ? new as(Buffer.allocUnsafe(e)) : new as(new Uint8Array(e));
    }
    static wrap(e) {
      return Oo && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new as(e);
    }
    static fromString(e, s) {
      return !(s?.dontUseNodeBuffer || !1) && Oo ? new as(Buffer.from(e)) : (Xc || (Xc = new TextEncoder()), new as(Xc.encode(e)));
    }
    static fromByteArray(e) {
      const s = as.alloc(e.length);
      for (let i = 0, n = e.length; i < n; i++) s.buffer[i] = e[i];
      return s;
    }
    static concat(e, s) {
      if (typeof s > "u") {
        s = 0;
        for (let r = 0, o = e.length; r < o; r++) s += e[r].byteLength;
      }
      const i = as.alloc(s);
      let n = 0;
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        i.set(a, n), (n += a.byteLength);
      }
      return i;
    }
    constructor(e) {
      (this.buffer = e), (this.byteLength = this.buffer.byteLength);
    }
    clone() {
      const e = as.alloc(this.byteLength);
      return e.set(this), e;
    }
    toString() {
      return Oo ? this.buffer.toString() : (Qc || (Qc = new TextDecoder()), Qc.decode(this.buffer));
    }
    slice(e, s) {
      return new as(this.buffer.subarray(e, s));
    }
    set(e, s) {
      if (e instanceof as) this.buffer.set(e.buffer, s);
      else if (e instanceof Uint8Array) this.buffer.set(e, s);
      else if (e instanceof ArrayBuffer) this.buffer.set(new Uint8Array(e), s);
      else if (ArrayBuffer.isView(e)) this.buffer.set(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), s);
      else throw new Error("Unknown argument 'array'");
    }
    readUInt32BE(e) {
      return Iy(this.buffer, e);
    }
    writeUInt32BE(e, s) {
      Ry(this.buffer, e, s);
    }
    readUInt32LE(e) {
      return Py(this.buffer, e);
    }
    writeUInt32LE(e, s) {
      Ay(this.buffer, e, s);
    }
    readUInt8(e) {
      return Oy(this.buffer, e);
    }
    writeUInt8(e, s) {
      Ly(this.buffer, e, s);
    }
    indexOf(e, s = 0) {
      return s1(this.buffer, e instanceof as ? e.buffer : e, s);
    }
  };
function s1(t, e, s = 0) {
  const i = e.byteLength,
    n = t.byteLength;
  if (i === 0) return 0;
  if (i === 1) return t.indexOf(e[0]);
  if (i > n - s) return -1;
  const r = Dy.value;
  r.fill(e.length);
  for (let l = 0; l < e.length; l++) r[e[l]] = e.length - l - 1;
  let o = s + e.length - 1,
    a = o,
    c = -1;
  for (; o < n; )
    if (t[o] === e[a]) {
      if (a === 0) {
        c = o;
        break;
      }
      o--, a--;
    } else (o += Math.max(e.length - a, r[t[o]])), (a = e.length - 1);
  return c;
}
function Iy(t, e) {
  return t[e] * 2 ** 24 + t[e + 1] * 2 ** 16 + t[e + 2] * 2 ** 8 + t[e + 3];
}
function Ry(t, e, s) {
  (t[s + 3] = e), (e = e >>> 8), (t[s + 2] = e), (e = e >>> 8), (t[s + 1] = e), (e = e >>> 8), (t[s] = e);
}
function Py(t, e) {
  return ((t[e + 0] << 0) >>> 0) | ((t[e + 1] << 8) >>> 0) | ((t[e + 2] << 16) >>> 0) | ((t[e + 3] << 24) >>> 0);
}
function Ay(t, e, s) {
  (t[s + 0] = e & 255), (e = e >>> 8), (t[s + 1] = e & 255), (e = e >>> 8), (t[s + 2] = e & 255), (e = e >>> 8), (t[s + 3] = e & 255);
}
function Oy(t, e) {
  return t[e];
}
function Ly(t, e, s) {
  t[s] = e;
}
function Ny(t) {
  return $y(t, (e) => L.concat(e));
}
function Ty(t) {
  return ky(t);
}
function Ai(t) {
  return e1(t, (e) => L.concat(e));
}
async function jy(t) {
  return t.ended ? L.concat(t.buffer) : L.concat([...t.buffer, await Ai(t.stream)]);
}
function Fy(t) {
  return t1(t, { data: (e) => (typeof e == "string" ? L.fromString(e) : L.wrap(e)) }, (e) => L.concat(e));
}
function My(t) {
  return or((e) => L.concat(e), t);
}
var Uy = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  _y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
function By({ buffer: t }, e = !0, s = !1) {
  const i = s ? _y : Uy;
  let n = "";
  const r = t.byteLength % 3;
  let o = 0;
  for (; o < t.byteLength - r; o += 3) {
    const a = t[o + 0],
      c = t[o + 1],
      l = t[o + 2];
    (n += i[a >>> 2]), (n += i[((a << 4) | (c >>> 4)) & 63]), (n += i[((c << 2) | (l >>> 6)) & 63]), (n += i[l & 63]);
  }
  if (r === 1) {
    const a = t[o + 0];
    (n += i[a >>> 2]), (n += i[(a << 4) & 63]), e && (n += "==");
  } else if (r === 2) {
    const a = t[o + 0],
      c = t[o + 1];
    (n += i[a >>> 2]), (n += i[((a << 4) | (c >>> 4)) & 63]), (n += i[(c << 2) & 63]), e && (n += "=");
  }
  return n;
}
function me(t, e, s) {
  let i = null,
    n = null;
  if ((typeof s.value == "function" ? ((i = "value"), (n = s.value), n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof s.get == "function" && ((i = "get"), (n = s.get)), !n))
    throw new Error("not supported");
  const r = `$memoize$${e}`;
  s[i] = function (...o) {
    return this.hasOwnProperty(r) || Object.defineProperty(this, r, { configurable: !1, enumerable: !1, writable: !1, value: n.apply(this, o) }), this[r];
  };
}
function zy(t) {
  return JSON.stringify(t, Vy);
}
function qy(t) {
  let e = JSON.parse(t);
  return (e = mn(e)), e;
}
function Vy(t, e) {
  return e instanceof RegExp ? { $mid: 2, source: e.source, flags: e.flags } : e;
}
function mn(t, e = 0) {
  if (!t || e > 200) return t;
  if (typeof t == "object") {
    switch (t.$mid) {
      case 1:
        return C.revive(t);
      case 2:
        return new RegExp(t.source, t.flags);
      case 17:
        return new Date(t.source);
    }
    if (t instanceof L || t instanceof Uint8Array) return t;
    if (Array.isArray(t)) for (let s = 0; s < t.length; ++s) t[s] = mn(t[s], e + 1);
    else for (const s in t) Object.hasOwnProperty.call(t, s) && (t[s] = mn(t[s], e + 1));
  }
  return t;
}
var i1;
(function (t) {
  (t[(t.Promise = 100)] = "Promise"), (t[(t.PromiseCancel = 101)] = "PromiseCancel"), (t[(t.EventListen = 102)] = "EventListen"), (t[(t.EventDispose = 103)] = "EventDispose");
})(i1 || (i1 = {}));
function wn(t) {
  switch (t) {
    case 100:
      return "req";
    case 101:
      return "cancel";
    case 102:
      return "subscribe";
    case 103:
      return "unsubscribe";
  }
}
var n1;
(function (t) {
  (t[(t.Initialize = 200)] = "Initialize"), (t[(t.PromiseSuccess = 201)] = "PromiseSuccess"), (t[(t.PromiseError = 202)] = "PromiseError"), (t[(t.PromiseErrorObj = 203)] = "PromiseErrorObj"), (t[(t.EventFire = 204)] = "EventFire");
})(n1 || (n1 = {}));
function Lo(t) {
  switch (t) {
    case 200:
      return "init";
    case 201:
      return "reply:";
    case 202:
    case 203:
      return "replyErr:";
    case 204:
      return "event:";
  }
}
var Oi;
(function (t) {
  (t[(t.Uninitialized = 0)] = "Uninitialized"), (t[(t.Idle = 1)] = "Idle");
})(Oi || (Oi = {}));
function vn(t) {
  let e = 0;
  for (let s = 0; ; s += 7) {
    const i = t.read(1);
    if (((e |= (i.buffer[0] & 127) << s), !(i.buffer[0] & 128))) return e;
  }
}
var Wy = ii(0);
function yn(t, e) {
  if (e === 0) {
    t.write(Wy);
    return;
  }
  let s = 0;
  for (let n = e; n !== 0; n = n >>> 7) s++;
  const i = L.alloc(s);
  for (let n = 0; e !== 0; n++) (i.buffer[n] = e & 127), (e = e >>> 7), e > 0 && (i.buffer[n] |= 128);
  t.write(i);
}
var Yc = class {
    constructor(t) {
      (this.b = t), (this.a = 0);
    }
    read(t) {
      const e = this.b.slice(this.a, this.a + t);
      return (this.a += e.byteLength), e;
    }
  },
  r1 = class {
    constructor() {
      this.a = [];
    }
    get buffer() {
      return L.concat(this.a);
    }
    write(t) {
      this.a.push(t);
    }
  },
  Dt;
(function (t) {
  (t[(t.Undefined = 0)] = "Undefined"), (t[(t.String = 1)] = "String"), (t[(t.Buffer = 2)] = "Buffer"), (t[(t.VSBuffer = 3)] = "VSBuffer"), (t[(t.Array = 4)] = "Array"), (t[(t.Object = 5)] = "Object"), (t[(t.Int = 6)] = "Int");
})(Dt || (Dt = {}));
function ii(t) {
  const e = L.alloc(1);
  return e.writeUInt8(t, 0), e;
}
var Li = { Undefined: ii(Dt.Undefined), String: ii(Dt.String), Buffer: ii(Dt.Buffer), VSBuffer: ii(Dt.VSBuffer), Array: ii(Dt.Array), Object: ii(Dt.Object), Uint: ii(Dt.Int) },
  Hy = typeof Buffer < "u";
function ar(t, e) {
  if (typeof e > "u") t.write(Li.Undefined);
  else if (typeof e == "string") {
    const s = L.fromString(e);
    t.write(Li.String), yn(t, s.byteLength), t.write(s);
  } else if (Hy && Buffer.isBuffer(e)) {
    const s = L.wrap(e);
    t.write(Li.Buffer), yn(t, s.byteLength), t.write(s);
  } else if (e instanceof L) t.write(Li.VSBuffer), yn(t, e.byteLength), t.write(e);
  else if (Array.isArray(e)) {
    t.write(Li.Array), yn(t, e.length);
    for (const s of e) ar(t, s);
  } else if (typeof e == "number" && (e | 0) === e) t.write(Li.Uint), yn(t, e);
  else {
    const s = L.fromString(JSON.stringify(e));
    t.write(Li.Object), yn(t, s.byteLength), t.write(s);
  }
}
function bn(t) {
  switch (t.read(1).readUInt8(0)) {
    case Dt.Undefined:
      return;
    case Dt.String:
      return t.read(vn(t)).toString();
    case Dt.Buffer:
      return t.read(vn(t)).buffer;
    case Dt.VSBuffer:
      return t.read(vn(t));
    case Dt.Array: {
      const s = vn(t),
        i = [];
      for (let n = 0; n < s; n++) i.push(bn(t));
      return i;
    }
    case Dt.Object:
      return JSON.parse(t.read(vn(t)).toString());
    case Dt.Int:
      return vn(t);
  }
}
var Gy = class {
    constructor(t, e, s = null, i = 1e3) {
      (this.h = t), (this.j = e), (this.k = s), (this.l = i), (this.b = new Map()), (this.d = new Map()), (this.g = new Map()), (this.f = this.h.onMessage((n) => this.q(n))), this.m({ type: 200 });
    }
    registerChannel(t, e) {
      this.b.set(t, e), setTimeout(() => this.w(t), 0);
    }
    m(t) {
      switch (t.type) {
        case 200: {
          const e = this.o([t.type]);
          this.k?.logOutgoing(e, 0, 1, Lo(t.type));
          return;
        }
        case 201:
        case 202:
        case 204:
        case 203: {
          const e = this.o([t.type, t.id], t.data);
          this.k?.logOutgoing(e, t.id, 1, Lo(t.type), t.data);
          return;
        }
      }
    }
    o(t, e = void 0) {
      const s = new r1();
      return ar(s, t), ar(s, e), this.p(s.buffer);
    }
    p(t) {
      try {
        return this.h.send(t), t.byteLength;
      } catch {
        return 0;
      }
    }
    q(t) {
      const e = new Yc(t),
        s = bn(e),
        i = bn(e),
        n = s[0];
      switch (n) {
        case 100:
          return this.k?.logIncoming(t.byteLength, s[1], 1, `${wn(n)}: ${s[2]}.${s[3]}`, i), this.s({ type: n, id: s[1], channelName: s[2], name: s[3], arg: i });
        case 102:
          return this.k?.logIncoming(t.byteLength, s[1], 1, `${wn(n)}: ${s[2]}.${s[3]}`, i), this.t({ type: n, id: s[1], channelName: s[2], name: s[3], arg: i });
        case 101:
          return this.k?.logIncoming(t.byteLength, s[1], 1, `${wn(n)}`), this.u({ type: n, id: s[1] });
        case 103:
          return this.k?.logIncoming(t.byteLength, s[1], 1, `${wn(n)}`), this.u({ type: n, id: s[1] });
      }
    }
    s(t) {
      const e = this.b.get(t.channelName);
      if (!e) {
        this.v(t);
        return;
      }
      const s = new xs();
      let i;
      try {
        i = e.call(this.j, t.name, t.arg, s.token);
      } catch (o) {
        i = Promise.reject(o);
      }
      const n = t.id;
      i.then(
        (o) => {
          this.m({ id: n, data: o, type: 201 });
        },
        (o) => {
          o instanceof Error
            ? this.m({
                id: n,
                data: {
                  message: o.message,
                  name: o.name,
                  stack: o.stack
                    ? o.stack.split(`
`)
                    : void 0,
                },
                type: 202,
              })
            : this.m({ id: n, data: o, type: 203 });
        },
      ).finally(() => {
        r.dispose(), this.d.delete(t.id);
      });
      const r = ue(() => s.cancel());
      this.d.set(t.id, r);
    }
    t(t) {
      const e = this.b.get(t.channelName);
      if (!e) {
        this.v(t);
        return;
      }
      const s = t.id,
        n = e.listen(this.j, t.name, t.arg)((r) => this.m({ id: s, data: r, type: 204 }));
      this.d.set(t.id, n);
    }
    u(t) {
      const e = this.d.get(t.id);
      e && (e.dispose(), this.d.delete(t.id));
    }
    v(t) {
      let e = this.g.get(t.channelName);
      e || ((e = []), this.g.set(t.channelName, e));
      const s = setTimeout(() => {
        console.error(`Unknown channel: ${t.channelName}`), t.type === 100 && this.m({ id: t.id, data: { name: "Unknown channel", message: `Channel name '${t.channelName}' timed out after ${this.l}ms`, stack: void 0 }, type: 202 });
      }, this.l);
      e.push({ request: t, timeoutTimer: s });
    }
    w(t) {
      const e = this.g.get(t);
      if (e) {
        for (const s of e)
          switch ((clearTimeout(s.timeoutTimer), s.request.type)) {
            case 100:
              this.s(s.request);
              break;
            case 102:
              this.t(s.request);
              break;
          }
        this.g.delete(t);
      }
    }
    dispose() {
      this.f && (this.f.dispose(), (this.f = null)), Xt(this.d.values()), this.d.clear();
    }
  },
  o1;
(function (t) {
  (t[(t.LocalSide = 0)] = "LocalSide"), (t[(t.OtherSide = 1)] = "OtherSide");
})(o1 || (o1 = {}));
var Zc = class {
  constructor(t, e = null) {
    (this.l = t), (this.a = !1), (this.b = Oi.Uninitialized), (this.d = new Set()), (this.f = new Map()), (this.g = 0), (this.k = new D()), (this.onDidInitialize = this.k.event), (this.h = this.l.onMessage((s) => this.s(s))), (this.j = e);
  }
  getChannel(t) {
    const e = this;
    return {
      call(s, i, n) {
        return e.a ? Promise.reject(new ot()) : e.m(t, s, i, n);
      },
      listen(s, i) {
        return e.a ? T.None : e.o(t, s, i);
      },
    };
  }
  m(t, e, s, i = J.None) {
    const n = this.g++,
      o = { id: n, type: 100, channelName: t, name: e, arg: s };
    if (i.isCancellationRequested) return Promise.reject(new ot());
    let a, c;
    return new Promise((h, u) => {
      if (i.isCancellationRequested) return u(new ot());
      const f = () => {
        const g = (m) => {
          switch (m.type) {
            case 201:
              this.f.delete(n), h(m.data);
              break;
            case 202: {
              this.f.delete(n);
              const v = new Error(m.data.message);
              (v.stack = Array.isArray(m.data.stack)
                ? m.data.stack.join(`
`)
                : m.data.stack),
                (v.name = m.data.name),
                u(v);
              break;
            }
            case 203:
              this.f.delete(n), u(m.data);
              break;
          }
        };
        this.f.set(n, g), this.p(o);
      };
      let d = null;
      this.b === Oi.Idle
        ? f()
        : ((d = wt((g) => this.u())),
          d.then(() => {
            (d = null), f();
          }));
      const p = () => {
        d ? (d.cancel(), (d = null)) : this.p({ id: n, type: 101 }), u(new ot());
      };
      (a = i.onCancellationRequested(p)),
        (c = {
          dispose: Ic(() => {
            p(), a.dispose();
          }),
        }),
        this.d.add(c);
    }).finally(() => {
      a.dispose(), this.d.delete(c);
    });
  }
  o(t, e, s) {
    const i = this.g++,
      r = { id: i, type: 102, channelName: t, name: e, arg: s };
    let o = null;
    const a = new D({
        onWillAddFirstListener: () => {
          const l = () => {
            this.d.add(a), this.p(r);
          };
          this.b === Oi.Idle
            ? l()
            : ((o = wt((h) => this.u())),
              o.then(() => {
                (o = null), l();
              }));
        },
        onDidRemoveLastListener: () => {
          o ? (o.cancel(), (o = null)) : (this.d.delete(a), this.p({ id: i, type: 103 }));
        },
      }),
      c = (l) => a.fire(l.data);
    return this.f.set(i, c), a.event;
  }
  p(t) {
    switch (t.type) {
      case 100:
      case 102: {
        const e = this.q([t.type, t.id, t.channelName, t.name], t.arg);
        this.j?.logOutgoing(e, t.id, 0, `${wn(t.type)}: ${t.channelName}.${t.name}`, t.arg);
        return;
      }
      case 101:
      case 103: {
        const e = this.q([t.type, t.id]);
        this.j?.logOutgoing(e, t.id, 0, wn(t.type));
        return;
      }
    }
  }
  q(t, e = void 0) {
    const s = new r1();
    return ar(s, t), ar(s, e), this.r(s.buffer);
  }
  r(t) {
    try {
      return this.l.send(t), t.byteLength;
    } catch {
      return 0;
    }
  }
  s(t) {
    const e = new Yc(t),
      s = bn(e),
      i = bn(e),
      n = s[0];
    switch (n) {
      case 200:
        return this.j?.logIncoming(t.byteLength, 0, 0, Lo(n)), this.t({ type: s[0] });
      case 201:
      case 202:
      case 204:
      case 203:
        return this.j?.logIncoming(t.byteLength, s[1], 0, Lo(n), i), this.t({ type: s[0], id: s[1], data: i });
    }
  }
  t(t) {
    if (t.type === 200) {
      (this.b = Oi.Idle), this.k.fire();
      return;
    }
    this.f.get(t.id)?.(t);
  }
  get onDidInitializePromise() {
    return T.toPromise(this.onDidInitialize);
  }
  u() {
    return this.b === Oi.Idle ? Promise.resolve() : this.onDidInitializePromise;
  }
  dispose() {
    (this.a = !0), this.h && (this.h.dispose(), (this.h = null)), Xt(this.d.values()), this.d.clear();
  }
};
__decorate([me], Zc.prototype, "onDidInitializePromise", null);
var Jy = class {
  get connections() {
    const t = [];
    return this.f.forEach((e) => t.push(e)), t;
  }
  constructor(t, e, s) {
    (this.a = new Map()),
      (this.f = new Set()),
      (this.g = new D()),
      (this.onDidAddConnection = this.g.event),
      (this.h = new D()),
      (this.onDidRemoveConnection = this.h.event),
      (this.j = new ye()),
      this.j.add(
        t(({ protocol: i, onDidClientDisconnect: n }) => {
          const r = T.once(i.onMessage);
          this.j.add(
            r((o) => {
              const a = new Yc(o),
                c = bn(a),
                l = new Gy(i, c, e, s),
                h = new Zc(i, e);
              this.a.forEach((f, d) => l.registerChannel(d, f));
              const u = { channelServer: l, channelClient: h, ctx: c };
              this.f.add(u),
                this.g.fire(u),
                this.j.add(
                  n(() => {
                    l.dispose(), h.dispose(), this.f.delete(u), this.h.fire(u);
                  }),
                );
            }),
          );
        }),
      );
  }
  getChannel(t, e) {
    const s = this;
    return {
      call(i, n, r) {
        let o;
        if (xc(e)) {
          const c = Ow(s.connections.filter(e));
          o = c ? Promise.resolve(c) : T.toPromise(T.filter(s.onDidAddConnection, e));
        } else o = e.routeCall(s, i, n);
        const a = o.then((c) => c.channelClient.getChannel(t));
        return a1(a).call(i, n, r);
      },
      listen(i, n) {
        if (xc(e)) return s.k(t, e, i, n);
        const r = e.routeEvent(s, i, n).then((o) => o.channelClient.getChannel(t));
        return a1(r).listen(i, n);
      },
    };
  }
  k(t, e, s, i) {
    const n = this;
    let r;
    const o = new D({
      onWillAddFirstListener: () => {
        r = new ye();
        const a = new Ev(),
          c = new Map(),
          l = (u) => {
            const d = u.channelClient.getChannel(t).listen(s, i),
              p = a.add(d);
            c.set(u, p);
          },
          h = (u) => {
            const f = c.get(u);
            f && (f.dispose(), c.delete(u));
          };
        n.connections.filter(e).forEach(l), T.filter(n.onDidAddConnection, e)(l, void 0, r), n.onDidRemoveConnection(h, void 0, r), a.event(o.fire, o, r), r.add(a);
      },
      onDidRemoveLastListener: () => {
        r?.dispose(), (r = void 0);
      },
    });
    return n.j.add(o), o.event;
  }
  registerChannel(t, e) {
    this.a.set(t, e);
    for (const s of this.f) s.channelServer.registerChannel(t, e);
  }
  dispose() {
    this.j.dispose();
    for (const t of this.f) t.channelClient.dispose(), t.channelServer.dispose();
    this.f.clear(), this.a.clear(), this.g.dispose(), this.h.dispose();
  }
};
function a1(t) {
  return {
    call(e, s, i) {
      return t.then((n) => n.call(e, s, i));
    },
    listen(e, s) {
      const i = new Ed();
      return t.then((n) => (i.input = n.listen(e, s))), i.event;
    },
  };
}
function Ky(t) {
  let e = !1;
  return {
    call(s, i, n) {
      return e
        ? t.call(s, i, n)
        : Pi(0)
            .then(() => (e = !0))
            .then(() => t.call(s, i, n));
    },
    listen(s, i) {
      if (e) return t.listen(s, i);
      const n = new Ed();
      return (
        Pi(0)
          .then(() => (e = !0))
          .then(() => (n.input = t.listen(s, i))),
        n.event
      );
    },
  };
}
var c1 = class {
    constructor(t) {
      this.a = t;
    }
    routeCall(t) {
      return this.b(t);
    }
    routeEvent(t) {
      return this.b(t);
    }
    async b(t) {
      for (const e of t.connections) if (await Promise.resolve(this.a(e.ctx))) return Promise.resolve(e);
      return await T.toPromise(t.onDidAddConnection), await this.b(t);
    }
  },
  It;
(function (t) {
  function e(r, o, a) {
    const c = r,
      l = a && a.disableMarshalling,
      h = new Map();
    for (const u in c) i(u) && h.set(u, T.buffer(c[u], !0, void 0, o));
    return new (class {
      listen(u, f, d) {
        const p = h.get(f);
        if (p) return p;
        const g = c[f];
        if (typeof g == "function") {
          if (n(f)) return g.call(c, d);
          if (i(f)) return h.set(f, T.buffer(c[f], !0, void 0, o)), h.get(f);
        }
        throw new Si(`Event not found: ${f}`);
      }
      call(u, f, d) {
        const p = c[f];
        if (typeof p == "function") {
          if (!l && Array.isArray(d)) for (let m = 0; m < d.length; m++) d[m] = mn(d[m]);
          let g = p.apply(c, d);
          return g instanceof Promise || (g = Promise.resolve(g)), g;
        }
        throw new Si(`Method not found: ${f}`);
      }
    })();
  }
  t.fromService = e;
  function s(r, o) {
    const a = o && o.disableMarshalling;
    return new Proxy(
      {},
      {
        get(c, l) {
          if (typeof l == "string")
            return o?.properties?.has(l)
              ? o.properties.get(l)
              : n(l)
                ? function (h) {
                    return r.listen(l, h);
                  }
                : i(l)
                  ? r.listen(l)
                  : async function (...h) {
                      let u;
                      o && !mt(o.context) ? (u = [o.context, ...h]) : (u = h);
                      const f = await r.call(l, u);
                      return a ? f : mn(f);
                    };
          throw new Si(`Property not found: ${String(l)}`);
        },
      },
    );
  }
  t.toService = s;
  function i(r) {
    return r[0] === "o" && r[1] === "n" && Cd(r.charCodeAt(2));
  }
  function n(r) {
    return /^onDynamic/.test(r) && Cd(r.charCodeAt(9));
  }
})(It || (It = {}));
function Xy(t) {
  return !!t.parentPort;
}
var Qy = class {
    constructor(t) {
      (this.a = t), (this.onMessage = T.fromNodeEventEmitter(this.a, "message", (e) => (e.data ? L.wrap(e.data) : L.alloc(0)))), t.start();
    }
    send(t) {
      this.a.postMessage(t.buffer);
    }
    disconnect() {
      this.a.close();
    }
  },
  Yy = class Hm extends Jy {
    static b(e) {
      jw(Xy(process), "Electron Utility Process");
      const s = new D();
      return (
        process.parentPort.on("message", (i) => {
          if (e?.handledClientConnection(i)) return;
          const n = i.ports.at(0);
          n && s.fire(n);
        }),
        T.map(s.event, (i) => ({ protocol: new Qy(i), onDidClientDisconnect: T.fromNodeEventEmitter(i, "close") }))
      );
    }
    constructor(e) {
      super(Hm.b(e));
    }
  };
function Zy(t, e, s) {
  const i = (n) => {
    n.data === e && (t.removeListener("message", i), s());
  };
  t.on("message", i);
}
import * as e4 from "fs";
import * as Ie from "fs";
import { tmpdir as t4 } from "os";
import { promisify as No } from "util";
var s4 = new Dc(1e4);
function el(t) {
  return n4(t, "NFC", s4);
}
var o3 = new Dc(1e4),
  i4 = /[^\u0000-\u0080]/;
function n4(t, e, s) {
  if (!t) return t;
  const i = s.get(t);
  if (i) return i;
  let n;
  return i4.test(t) ? (n = t.normalize(e)) : (n = t), s.set(t, n), n;
}
var En;
(function (t) {
  (t[(t.UNLINK = 0)] = "UNLINK"), (t[(t.MOVE = 1)] = "MOVE");
})(En || (En = {}));
async function l1(t, e = En.UNLINK, s) {
  if (sy(t)) throw new Error("rimraf - will refuse to recursively delete root");
  return e === En.UNLINK ? tl(t) : r4(t, s);
}
async function r4(t, e = oy(t4())) {
  try {
    try {
      await Ie.promises.rename(t, e);
    } catch (s) {
      return s.code === "ENOENT" ? void 0 : tl(t);
    }
    tl(e).catch((s) => {});
  } catch (s) {
    if (s.code !== "ENOENT") throw s;
  }
}
async function tl(t) {
  return Ie.promises.rm(t, { recursive: !0, force: !0, maxRetries: 3 });
}
async function To(t, e) {
  return a4(await (e ? o4(t) : Ie.promises.readdir(t)));
}
async function o4(t) {
  try {
    return await Ie.promises.readdir(t, { withFileTypes: !0 });
  } catch (i) {
    console.warn("[node.js fs] readdir with filetypes failed with error: ", i);
  }
  const e = [],
    s = await To(t);
  for (const i of s) {
    let n = !1,
      r = !1,
      o = !1;
    try {
      const a = await Ie.promises.lstat(V(t, i));
      (n = a.isFile()), (r = a.isDirectory()), (o = a.isSymbolicLink());
    } catch (a) {
      console.warn("[node.js fs] unexpected error from lstat after readdir: ", a);
    }
    e.push({ name: i, isFile: () => n, isDirectory: () => r, isSymbolicLink: () => o });
  }
  return e;
}
function a4(t) {
  return t.map((e) => (typeof e == "string" ? (Ss ? el(e) : e) : ((e.name = Ss ? el(e.name) : e.name), e)));
}
async function c4(t) {
  const e = await To(t),
    s = [];
  for (const i of e) (await Wt.existsDirectory(V(t, i))) && s.push(i);
  return s;
}
var Wt;
(function (t) {
  async function e(n) {
    let r;
    try {
      if (((r = await Ie.promises.lstat(n)), !r.isSymbolicLink())) return { stat: r };
    } catch {}
    try {
      return { stat: await Ie.promises.stat(n), symbolicLink: r?.isSymbolicLink() ? { dangling: !1 } : void 0 };
    } catch (o) {
      if (o.code === "ENOENT" && r) return { stat: r, symbolicLink: { dangling: !0 } };
      if (Be && o.code === "EACCES")
        try {
          return { stat: await Ie.promises.stat(await Ie.promises.readlink(n)), symbolicLink: { dangling: !1 } };
        } catch (a) {
          if (a.code === "ENOENT" && r) return { stat: r, symbolicLink: { dangling: !0 } };
          throw a;
        }
      throw o;
    }
  }
  t.stat = e;
  async function s(n) {
    try {
      const { stat: r, symbolicLink: o } = await t.stat(n);
      return r.isFile() && o?.dangling !== !0;
    } catch {}
    return !1;
  }
  t.existsFile = s;
  async function i(n) {
    try {
      const { stat: r, symbolicLink: o } = await t.stat(n);
      return r.isDirectory() && o?.dangling !== !0;
    } catch {}
    return !1;
  }
  t.existsDirectory = i;
})(Wt || (Wt = {}));
var l4 = new Xd();
function h4(t, e, s) {
  return l4.queueFor(
    C.file(t),
    () => {
      const i = d4(s);
      return new Promise((n, r) => f4(t, e, i, (o) => (o ? r(o) : n())));
    },
    Wc,
  );
}
var h1 = !0;
function u4(t) {
  h1 = t;
}
function f4(t, e, s, i) {
  if (!h1) return Ie.writeFile(t, e, { mode: s.mode, flag: s.flag }, i);
  Ie.open(t, s.flag, s.mode, (n, r) => {
    if (n) return i(n);
    Ie.writeFile(r, e, (o) => {
      if (o) return Ie.close(r, () => i(o));
      Ie.fdatasync(r, (a) => (a && (console.warn("[node.js fs] fdatasync is now disabled for this session because it failed: ", a), u4(!1)), Ie.close(r, (c) => i(c))));
    });
  });
}
function d4(t) {
  return t ? { mode: typeof t.mode == "number" ? t.mode : 438, flag: typeof t.flag == "string" ? t.flag : "w" } : { mode: 438, flag: "w" };
}
async function p4(t, e, s = 6e4) {
  if (t !== e)
    try {
      Be && typeof s == "number" ? await u1(t, e, Date.now(), s) : await Ie.promises.rename(t, e);
    } catch (i) {
      if ((t.toLowerCase() !== e.toLowerCase() && i.code === "EXDEV") || t.endsWith(".")) await f1(t, e, { preserveSymlinks: !1 }), await l1(t, En.MOVE);
      else throw i;
    }
}
async function u1(t, e, s, i, n = 0) {
  try {
    return await Ie.promises.rename(t, e);
  } catch (r) {
    if (r.code !== "EACCES" && r.code !== "EPERM" && r.code !== "EBUSY") throw r;
    if (Date.now() - s >= i) throw (console.error(`[node.js fs] rename failed after ${n} retries with error: ${r}`), r);
    if (n === 0) {
      let o = !1;
      try {
        const { stat: a } = await Wt.stat(e);
        a.isFile() || (o = !0);
      } catch {}
      if (o) throw r;
    }
    return await Pi(Math.min(100, n * 10)), u1(t, e, s, i, n + 1);
  }
}
async function f1(t, e, s) {
  return p1(t, e, { root: { source: t, target: e }, options: s, handledSourcePaths: new Set() });
}
var d1 = 511;
async function p1(t, e, s) {
  if (s.handledSourcePaths.has(t)) return;
  s.handledSourcePaths.add(t);
  const { stat: i, symbolicLink: n } = await Wt.stat(t);
  if (n) {
    if (s.options.preserveSymlinks)
      try {
        return await w4(t, e, s);
      } catch {}
    if (n.dangling) return;
  }
  return i.isDirectory() ? g4(t, e, i.mode & d1, s) : m4(t, e, i.mode & d1);
}
async function g4(t, e, s, i) {
  await Ie.promises.mkdir(e, { recursive: !0, mode: s });
  const n = await To(t);
  for (const r of n) await p1(V(t, r), V(e, r), i);
}
async function m4(t, e, s) {
  await Ie.promises.copyFile(t, e), await Ie.promises.chmod(e, s);
}
async function w4(t, e, s) {
  let i = await Ie.promises.readlink(t);
  ir(i, s.root.source, !ht) && (i = V(s.root.target, i.substr(s.root.source.length + 1))), await Ie.promises.symlink(i, e);
}
var he = new (class {
  get read() {
    return (t, e, s, i, n) =>
      new Promise((r, o) => {
        Ie.read(t, e, s, i, n, (a, c, l) => (a ? o(a) : r({ bytesRead: c, buffer: l })));
      });
  }
  get write() {
    return (t, e, s, i, n) =>
      new Promise((r, o) => {
        Ie.write(t, e, s, i, n, (a, c, l) => (a ? o(a) : r({ bytesWritten: c, buffer: l })));
      });
  }
  get fdatasync() {
    return No(Ie.fdatasync);
  }
  get open() {
    return No(Ie.open);
  }
  get close() {
    return No(Ie.close);
  }
  get realpath() {
    return No(Ie.realpath);
  }
  async exists(t) {
    try {
      return await Ie.promises.access(t), !0;
    } catch {
      return !1;
    }
  }
  get readdir() {
    return To;
  }
  get readDirsInDir() {
    return c4;
  }
  get writeFile() {
    return h4;
  }
  get rm() {
    return l1;
  }
  get rename() {
    return p4;
  }
  get copy() {
    return f1;
  }
})();
function Sn(t) {
  return sl(t, 0);
}
function sl(t, e) {
  switch (typeof t) {
    case "object":
      return t === null ? qs(349, e) : Array.isArray(t) ? y4(t, e) : b4(t, e);
    case "string":
      return g1(t, e);
    case "boolean":
      return v4(t, e);
    case "number":
      return qs(t, e);
    case "undefined":
      return qs(937, e);
    default:
      return qs(617, e);
  }
}
function qs(t, e) {
  return ((e << 5) - e + t) | 0;
}
function v4(t, e) {
  return qs(t ? 433 : 863, e);
}
function g1(t, e) {
  e = qs(149417, e);
  for (let s = 0, i = t.length; s < i; s++) e = qs(t.charCodeAt(s), e);
  return e;
}
function y4(t, e) {
  return (e = qs(104579, e)), t.reduce((s, i) => sl(i, s), e);
}
function b4(t, e) {
  return (
    (e = qs(181387, e)),
    Object.keys(t)
      .sort()
      .reduce((s, i) => ((s = g1(i, s)), sl(t[i], s)), e)
  );
}
var m1;
(function (t) {
  (t[(t.BLOCK_SIZE = 64)] = "BLOCK_SIZE"), (t[(t.UNICODE_REPLACEMENT = 65533)] = "UNICODE_REPLACEMENT");
})(m1 || (m1 = {}));
function il(t, e, s = 32) {
  const i = s - e,
    n = ~((1 << i) - 1);
  return ((t << e) | ((n & t) >>> i)) >>> 0;
}
function cr(t, e = 32) {
  return t instanceof ArrayBuffer
    ? Array.from(new Uint8Array(t))
        .map((s) => s.toString(16).padStart(2, "0"))
        .join("")
    : (t >>> 0).toString(16).padStart(e / 4, "0");
}
var a3 = class Gm {
    static {
      this.g = new DataView(new ArrayBuffer(320));
    }
    constructor() {
      (this.h = 1732584193),
        (this.l = 4023233417),
        (this.m = 2562383102),
        (this.n = 271733878),
        (this.o = 3285377520),
        (this.p = new Uint8Array(67)),
        (this.q = new DataView(this.p.buffer)),
        (this.r = 0),
        (this.t = 0),
        (this.u = 0),
        (this.v = !1);
    }
    update(e) {
      const s = e.length;
      if (s === 0) return;
      const i = this.p;
      let n = this.r,
        r = this.u,
        o,
        a;
      for (r !== 0 ? ((o = r), (a = -1), (r = 0)) : ((o = e.charCodeAt(0)), (a = 0)); ; ) {
        let c = o;
        if (kv(o))
          if (a + 1 < s) {
            const l = e.charCodeAt(a + 1);
            Dd(l) ? (a++, (c = Dv(o, l))) : (c = 65533);
          } else {
            r = o;
            break;
          }
        else Dd(o) && (c = 65533);
        if (((n = this.w(i, n, c)), a++, a < s)) o = e.charCodeAt(a);
        else break;
      }
      (this.r = n), (this.u = r);
    }
    w(e, s, i) {
      return (
        i < 128
          ? (e[s++] = i)
          : i < 2048
            ? ((e[s++] = 192 | ((i & 1984) >>> 6)), (e[s++] = 128 | ((i & 63) >>> 0)))
            : i < 65536
              ? ((e[s++] = 224 | ((i & 61440) >>> 12)), (e[s++] = 128 | ((i & 4032) >>> 6)), (e[s++] = 128 | ((i & 63) >>> 0)))
              : ((e[s++] = 240 | ((i & 1835008) >>> 18)), (e[s++] = 128 | ((i & 258048) >>> 12)), (e[s++] = 128 | ((i & 4032) >>> 6)), (e[s++] = 128 | ((i & 63) >>> 0))),
        s >= 64 && (this.y(), (s -= 64), (this.t += 64), (e[0] = e[64]), (e[1] = e[65]), (e[2] = e[66])),
        s
      );
    }
    digest() {
      return this.v || ((this.v = !0), this.u && ((this.u = 0), (this.r = this.w(this.p, this.r, 65533))), (this.t += this.r), this.x()), cr(this.h) + cr(this.l) + cr(this.m) + cr(this.n) + cr(this.o);
    }
    x() {
      (this.p[this.r++] = 128), this.p.subarray(this.r).fill(0), this.r > 56 && (this.y(), this.p.fill(0));
      const e = 8 * this.t;
      this.q.setUint32(56, Math.floor(e / 4294967296), !1), this.q.setUint32(60, e % 4294967296, !1), this.y();
    }
    y() {
      const e = Gm.g,
        s = this.q;
      for (let u = 0; u < 64; u += 4) e.setUint32(u, s.getUint32(u, !1), !1);
      for (let u = 64; u < 320; u += 4) e.setUint32(u, il(e.getUint32(u - 12, !1) ^ e.getUint32(u - 32, !1) ^ e.getUint32(u - 56, !1) ^ e.getUint32(u - 64, !1), 1), !1);
      let i = this.h,
        n = this.l,
        r = this.m,
        o = this.n,
        a = this.o,
        c,
        l,
        h;
      for (let u = 0; u < 80; u++)
        u < 20 ? ((c = (n & r) | (~n & o)), (l = 1518500249)) : u < 40 ? ((c = n ^ r ^ o), (l = 1859775393)) : u < 60 ? ((c = (n & r) | (n & o) | (r & o)), (l = 2400959708)) : ((c = n ^ r ^ o), (l = 3395469782)),
          (h = (il(i, 5) + c + a + l + e.getUint32(u * 4, !1)) & 4294967295),
          (a = o),
          (o = r),
          (r = il(n, 30)),
          (n = i),
          (i = h);
      (this.h = (this.h + i) & 4294967295), (this.l = (this.l + n) & 4294967295), (this.m = (this.m + r) & 4294967295), (this.n = (this.n + o) & 4294967295), (this.o = (this.o + a) & 4294967295);
    }
  },
  w1;
(function (t) {
  (t[(t.LParen = 0)] = "LParen"),
    (t[(t.RParen = 1)] = "RParen"),
    (t[(t.Neg = 2)] = "Neg"),
    (t[(t.Eq = 3)] = "Eq"),
    (t[(t.NotEq = 4)] = "NotEq"),
    (t[(t.Lt = 5)] = "Lt"),
    (t[(t.LtEq = 6)] = "LtEq"),
    (t[(t.Gt = 7)] = "Gt"),
    (t[(t.GtEq = 8)] = "GtEq"),
    (t[(t.RegexOp = 9)] = "RegexOp"),
    (t[(t.RegexStr = 10)] = "RegexStr"),
    (t[(t.True = 11)] = "True"),
    (t[(t.False = 12)] = "False"),
    (t[(t.In = 13)] = "In"),
    (t[(t.Not = 14)] = "Not"),
    (t[(t.And = 15)] = "And"),
    (t[(t.Or = 16)] = "Or"),
    (t[(t.Str = 17)] = "Str"),
    (t[(t.QuotedStr = 18)] = "QuotedStr"),
    (t[(t.Error = 19)] = "Error"),
    (t[(t.EOF = 20)] = "EOF");
})(w1 || (w1 = {}));
function nl(...t) {
  switch (t.length) {
    case 1:
      return w(1729, null, t[0]);
    case 2:
      return w(1730, null, t[0], t[1]);
    case 3:
      return w(1731, null, t[0], t[1], t[2]);
    default:
      return;
  }
}
var E4 = w(1732, null),
  S4 = w(1733, null),
  lr = class Pf {
    constructor() {
      (this.c = ""), (this.d = 0), (this.e = 0), (this.f = []), (this.g = []), (this.m = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy);
    }
    static getLexeme(e) {
      switch (e.type) {
        case 0:
          return "(";
        case 1:
          return ")";
        case 2:
          return "!";
        case 3:
          return e.isTripleEq ? "===" : "==";
        case 4:
          return e.isTripleEq ? "!==" : "!=";
        case 5:
          return "<";
        case 6:
          return "<=";
        case 7:
          return ">=";
        case 8:
          return ">=";
        case 9:
          return "=~";
        case 10:
          return e.lexeme;
        case 11:
          return "true";
        case 12:
          return "false";
        case 13:
          return "in";
        case 14:
          return "not";
        case 15:
          return "&&";
        case 16:
          return "||";
        case 17:
          return e.lexeme;
        case 18:
          return e.lexeme;
        case 19:
          return e.lexeme;
        case 20:
          return "EOF";
        default:
          throw zf(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
      }
    }
    static {
      this.a = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0)));
    }
    static {
      this.b = new Map([
        ["not", 14],
        ["in", 13],
        ["false", 12],
        ["true", 11],
      ]);
    }
    get errors() {
      return this.g;
    }
    reset(e) {
      return (this.c = e), (this.d = 0), (this.e = 0), (this.f = []), (this.g = []), this;
    }
    scan() {
      for (; !this.r(); )
        switch (((this.d = this.e), this.i())) {
          case 40:
            this.k(0);
            break;
          case 41:
            this.k(1);
            break;
          case 33:
            if (this.h(61)) {
              const s = this.h(61);
              this.f.push({ type: 4, offset: this.d, isTripleEq: s });
            } else this.k(2);
            break;
          case 39:
            this.o();
            break;
          case 47:
            this.q();
            break;
          case 61:
            if (this.h(61)) {
              const s = this.h(61);
              this.f.push({ type: 3, offset: this.d, isTripleEq: s });
            } else this.h(126) ? this.k(9) : this.l(nl("==", "=~"));
            break;
          case 60:
            this.k(this.h(61) ? 6 : 5);
            break;
          case 62:
            this.k(this.h(61) ? 8 : 7);
            break;
          case 38:
            this.h(38) ? this.k(15) : this.l(nl("&&"));
            break;
          case 124:
            this.h(124) ? this.k(16) : this.l(nl("||"));
            break;
          case 32:
          case 13:
          case 9:
          case 10:
          case 160:
            break;
          default:
            this.n();
        }
      return (this.d = this.e), this.k(20), Array.from(this.f);
    }
    h(e) {
      return this.r() || this.c.charCodeAt(this.e) !== e ? !1 : (this.e++, !0);
    }
    i() {
      return this.c.charCodeAt(this.e++);
    }
    j() {
      return this.r() ? 0 : this.c.charCodeAt(this.e);
    }
    k(e) {
      this.f.push({ type: e, offset: this.d });
    }
    l(e) {
      const s = this.d,
        i = this.c.substring(this.d, this.e),
        n = { type: 19, offset: this.d, lexeme: i };
      this.g.push({ offset: s, lexeme: i, additionalInfo: e }), this.f.push(n);
    }
    n() {
      this.m.lastIndex = this.d;
      const e = this.m.exec(this.c);
      if (e) {
        this.e = this.d + e[0].length;
        const s = this.c.substring(this.d, this.e),
          i = Pf.b.get(s);
        i ? this.k(i) : this.f.push({ type: 17, lexeme: s, offset: this.d });
      }
    }
    o() {
      for (; this.j() !== 39 && !this.r(); ) this.i();
      if (this.r()) {
        this.l(E4);
        return;
      }
      this.i(), this.f.push({ type: 18, lexeme: this.c.substring(this.d + 1, this.e - 1), offset: this.d + 1 });
    }
    q() {
      let e = this.e,
        s = !1,
        i = !1;
      for (;;) {
        if (e >= this.c.length) {
          (this.e = e), this.l(S4);
          return;
        }
        const r = this.c.charCodeAt(e);
        if (s) s = !1;
        else if (r === 47 && !i) {
          e++;
          break;
        } else r === 91 ? (i = !0) : r === 92 ? (s = !0) : r === 93 && (i = !1);
        e++;
      }
      for (; e < this.c.length && Pf.a.has(this.c.charCodeAt(e)); ) e++;
      this.e = e;
      const n = this.c.substring(this.d, this.e);
      this.f.push({ type: 10, lexeme: n, offset: this.d });
    }
    r() {
      return this.e >= this.c.length;
    }
  },
  fs;
(function (t) {
  (t.serviceIds = new Map()), (t.DI_TARGET = "$di$target"), (t.DI_DEPENDENCIES = "$di$dependencies");
  function e(s) {
    return s[t.DI_DEPENDENCIES] || [];
  }
  t.getServiceDependencies = e;
})(fs || (fs = {}));
var ds = z("instantiationService");
function $4(t, e, s) {
  e[fs.DI_TARGET] === e ? e[fs.DI_DEPENDENCIES].push({ id: t, index: s }) : ((e[fs.DI_DEPENDENCIES] = [{ id: t, index: s }]), (e[fs.DI_TARGET] = e));
}
function z(t) {
  if (fs.serviceIds.has(t)) return fs.serviceIds.get(t);
  const e = function (s, i, n) {
    if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    $4(e, s, n);
  };
  return (e.toString = () => t), fs.serviceIds.set(t, e), e;
}
function c3(t) {
  return t;
}
var at = new Map();
at.set("false", !1),
  at.set("true", !0),
  at.set("isMac", Ss),
  at.set("isLinux", ht),
  at.set("isWindows", Be),
  at.set("isWeb", Qe),
  at.set("isMacNative", Ss && !Qe),
  at.set("isEdge", vd),
  at.set("isFirefox", md),
  at.set("isChrome", Lc),
  at.set("isSafari", wd);
var x4 = Object.prototype.hasOwnProperty,
  v1;
(function (t) {
  (t[(t.False = 0)] = "False"),
    (t[(t.True = 1)] = "True"),
    (t[(t.Defined = 2)] = "Defined"),
    (t[(t.Not = 3)] = "Not"),
    (t[(t.Equals = 4)] = "Equals"),
    (t[(t.NotEquals = 5)] = "NotEquals"),
    (t[(t.And = 6)] = "And"),
    (t[(t.Regex = 7)] = "Regex"),
    (t[(t.NotRegex = 8)] = "NotRegex"),
    (t[(t.Or = 9)] = "Or"),
    (t[(t.In = 10)] = "In"),
    (t[(t.NotIn = 11)] = "NotIn"),
    (t[(t.Greater = 12)] = "Greater"),
    (t[(t.GreaterEquals = 13)] = "GreaterEquals"),
    (t[(t.Smaller = 14)] = "Smaller"),
    (t[(t.SmallerEquals = 15)] = "SmallerEquals");
})(v1 || (v1 = {}));
var C4 = { regexParsingWithErrorRecovery: !0 },
  k4 = w(1707, null),
  D4 = w(1708, null),
  I4 = w(1709, null),
  y1 = w(1710, null),
  R4 = w(1711, null),
  P4 = w(1712, null),
  A4 = w(1713, null),
  O4 = w(1714, null),
  L4 = class eo {
    static {
      this.c = new Error();
    }
    get lexingErrors() {
      return this.d.errors;
    }
    get parsingErrors() {
      return this.h;
    }
    constructor(e = C4) {
      (this.k = e), (this.d = new lr()), (this.f = []), (this.g = 0), (this.h = []), (this.v = /g|y/g);
    }
    parse(e) {
      if (e === "") {
        this.h.push({ message: k4, offset: 0, lexeme: "", additionalInfo: D4 });
        return;
      }
      (this.f = this.d.reset(e).scan()), (this.g = 0), (this.h = []);
      try {
        const s = this.l();
        if (!this.E()) {
          const i = this.D(),
            n = i.type === 17 ? P4 : void 0;
          throw (this.h.push({ message: R4, offset: i.offset, lexeme: lr.getLexeme(i), additionalInfo: n }), eo.c);
        }
        return s;
      } catch (s) {
        if (s !== eo.c) throw s;
        return;
      }
    }
    l() {
      return this.m();
    }
    m() {
      const e = [this.o()];
      for (; this.y(16); ) {
        const s = this.o();
        e.push(s);
      }
      return e.length === 1 ? e[0] : ft.or(...e);
    }
    o() {
      const e = [this.s()];
      for (; this.y(15); ) {
        const s = this.s();
        e.push(s);
      }
      return e.length === 1 ? e[0] : ft.and(...e);
    }
    s() {
      if (this.y(2)) {
        const e = this.D();
        switch (e.type) {
          case 11:
            return this.z(), Lt.INSTANCE;
          case 12:
            return this.z(), Ht.INSTANCE;
          case 0: {
            this.z();
            const s = this.l();
            return this.A(1, y1), s?.negate();
          }
          case 17:
            return this.z(), fr.create(e.lexeme);
          default:
            throw this.B("KEY | true | false | '(' expression ')'", e);
        }
      }
      return this.t();
    }
    t() {
      const e = this.D();
      switch (e.type) {
        case 11:
          return this.z(), ft.true();
        case 12:
          return this.z(), ft.false();
        case 0: {
          this.z();
          const s = this.l();
          return this.A(1, y1), s;
        }
        case 17: {
          const s = e.lexeme;
          if ((this.z(), this.y(9))) {
            const n = this.D();
            if (!this.k.regexParsingWithErrorRecovery) {
              if ((this.z(), n.type !== 10)) throw this.B("REGEX", n);
              const r = n.lexeme,
                o = r.lastIndexOf("/"),
                a = o === r.length - 1 ? void 0 : this.w(r.substring(o + 1));
              let c;
              try {
                c = new RegExp(r.substring(1, o), a);
              } catch {
                throw this.B("REGEX", n);
              }
              return ul.create(s, c);
            }
            switch (n.type) {
              case 10:
              case 19: {
                const r = [n.lexeme];
                this.z();
                let o = this.D(),
                  a = 0;
                for (let f = 0; f < n.lexeme.length; f++) n.lexeme.charCodeAt(f) === 40 ? a++ : n.lexeme.charCodeAt(f) === 41 && a--;
                for (; !this.E() && o.type !== 15 && o.type !== 16; ) {
                  switch (o.type) {
                    case 0:
                      a++;
                      break;
                    case 1:
                      a--;
                      break;
                    case 10:
                    case 18:
                      for (let f = 0; f < o.lexeme.length; f++) o.lexeme.charCodeAt(f) === 40 ? a++ : n.lexeme.charCodeAt(f) === 41 && a--;
                  }
                  if (a < 0) break;
                  r.push(lr.getLexeme(o)), this.z(), (o = this.D());
                }
                const c = r.join(""),
                  l = c.lastIndexOf("/"),
                  h = l === c.length - 1 ? void 0 : this.w(c.substring(l + 1));
                let u;
                try {
                  u = new RegExp(c.substring(1, l), h);
                } catch {
                  throw this.B("REGEX", n);
                }
                return ft.regex(s, u);
              }
              case 18: {
                const r = n.lexeme;
                this.z();
                let o = null;
                if (!xv(r)) {
                  const a = r.indexOf("/"),
                    c = r.lastIndexOf("/");
                  if (a !== c && a >= 0) {
                    const l = r.slice(a + 1, c),
                      h = r[c + 1] === "i" ? "i" : "";
                    try {
                      o = new RegExp(l, h);
                    } catch {
                      throw this.B("REGEX", n);
                    }
                  }
                }
                if (o === null) throw this.B("REGEX", n);
                return ul.create(s, o);
              }
              default:
                throw this.B("REGEX", this.D());
            }
          }
          if (this.y(14)) {
            this.A(13, I4);
            const n = this.u();
            return ft.notIn(s, n);
          }
          switch (this.D().type) {
            case 3: {
              this.z();
              const n = this.u();
              if (this.x().type === 18) return ft.equals(s, n);
              switch (n) {
                case "true":
                  return ft.has(s);
                case "false":
                  return ft.not(s);
                default:
                  return ft.equals(s, n);
              }
            }
            case 4: {
              this.z();
              const n = this.u();
              if (this.x().type === 18) return ft.notEquals(s, n);
              switch (n) {
                case "true":
                  return ft.not(s);
                case "false":
                  return ft.has(s);
                default:
                  return ft.notEquals(s, n);
              }
            }
            case 5:
              return this.z(), ll.create(s, this.u());
            case 6:
              return this.z(), hl.create(s, this.u());
            case 7:
              return this.z(), al.create(s, this.u());
            case 8:
              return this.z(), cl.create(s, this.u());
            case 13:
              return this.z(), ft.in(s, this.u());
            default:
              return ft.has(s);
          }
        }
        case 20:
          throw (this.h.push({ message: A4, offset: e.offset, lexeme: "", additionalInfo: O4 }), eo.c);
        default:
          throw this.B(
            `true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`,
            this.D(),
          );
      }
    }
    u() {
      const e = this.D();
      switch (e.type) {
        case 17:
        case 18:
          return this.z(), e.lexeme;
        case 11:
          return this.z(), "true";
        case 12:
          return this.z(), "false";
        case 13:
          return this.z(), "in";
        default:
          return "";
      }
    }
    w(e) {
      return e.replaceAll(this.v, "");
    }
    x() {
      return this.f[this.g - 1];
    }
    y(e) {
      return this.C(e) ? (this.z(), !0) : !1;
    }
    z() {
      return this.E() || this.g++, this.x();
    }
    A(e, s) {
      if (this.C(e)) return this.z();
      throw this.B(s, this.D());
    }
    B(e, s, i) {
      const n = w(1715, null, e, lr.getLexeme(s)),
        r = s.offset,
        o = lr.getLexeme(s);
      return this.h.push({ message: n, offset: r, lexeme: o, additionalInfo: i }), eo.c;
    }
    C(e) {
      return this.D().type === e;
    }
    D() {
      return this.f[this.g];
    }
    E() {
      return this.D().type === 20;
    }
  },
  ft = class {
    static false() {
      return Lt.INSTANCE;
    }
    static true() {
      return Ht.INSTANCE;
    }
    static has(t) {
      return ur.create(t);
    }
    static equals(t, e) {
      return rl.create(t, e);
    }
    static notEquals(t, e) {
      return ol.create(t, e);
    }
    static regex(t, e) {
      return ul.create(t, e);
    }
    static in(t, e) {
      return b1.create(t, e);
    }
    static notIn(t, e) {
      return E1.create(t, e);
    }
    static not(t) {
      return fr.create(t);
    }
    static and(...t) {
      return $1.create(t, null, !0);
    }
    static or(...t) {
      return fl.create(t, null, !0);
    }
    static greater(t, e) {
      return al.create(t, e);
    }
    static greaterEquals(t, e) {
      return cl.create(t, e);
    }
    static smaller(t, e) {
      return ll.create(t, e);
    }
    static smallerEquals(t, e) {
      return hl.create(t, e);
    }
    static {
      this.c = new L4({ regexParsingWithErrorRecovery: !1 });
    }
    static deserialize(t) {
      return t == null ? void 0 : this.c.parse(t);
    }
  };
function hr(t, e) {
  return t.cmp(e);
}
var Lt = class Jm {
    static {
      this.INSTANCE = new Jm();
    }
    constructor() {
      this.type = 0;
    }
    cmp(e) {
      return this.type - e.type;
    }
    equals(e) {
      return e.type === this.type;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !1;
    }
    serialize() {
      return "false";
    }
    keys() {
      return [];
    }
    map(e) {
      return this;
    }
    negate() {
      return Ht.INSTANCE;
    }
  },
  Ht = class Km {
    static {
      this.INSTANCE = new Km();
    }
    constructor() {
      this.type = 1;
    }
    cmp(e) {
      return this.type - e.type;
    }
    equals(e) {
      return e.type === this.type;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !0;
    }
    serialize() {
      return "true";
    }
    keys() {
      return [];
    }
    map(e) {
      return this;
    }
    negate() {
      return Lt.INSTANCE;
    }
  },
  ur = class Xm {
    static create(e, s = null) {
      const i = at.get(e);
      return typeof i == "boolean" ? (i ? Ht.INSTANCE : Lt.INSTANCE) : new Xm(e, s);
    }
    constructor(e, s) {
      (this.key = e), (this.c = s), (this.type = 2);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : x1(this.key, e.key);
    }
    equals(e) {
      return e.type === this.type ? this.key === e.key : !1;
    }
    substituteConstants() {
      const e = at.get(this.key);
      return typeof e == "boolean" ? (e ? Ht.INSTANCE : Lt.INSTANCE) : this;
    }
    evaluate(e) {
      return !!e.getValue(this.key);
    }
    serialize() {
      return this.key;
    }
    keys() {
      return [this.key];
    }
    map(e) {
      return e.mapDefined(this.key);
    }
    negate() {
      return this.c || (this.c = fr.create(this.key, this)), this.c;
    }
  },
  rl = class Qm {
    static create(e, s, i = null) {
      if (typeof s == "boolean") return s ? ur.create(e, i) : fr.create(e, i);
      const n = at.get(e);
      return typeof n == "boolean" ? (s === (n ? "true" : "false") ? Ht.INSTANCE : Lt.INSTANCE) : new Qm(e, s, i);
    }
    constructor(e, s, i) {
      (this.c = e), (this.d = s), (this.f = i), (this.type = 4);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.c, this.d, e.c, e.d);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c && this.d === e.d : !1;
    }
    substituteConstants() {
      const e = at.get(this.c);
      if (typeof e == "boolean") {
        const s = e ? "true" : "false";
        return this.d === s ? Ht.INSTANCE : Lt.INSTANCE;
      }
      return this;
    }
    evaluate(e) {
      return e.getValue(this.c) == this.d;
    }
    serialize() {
      return `${this.c} == '${this.d}'`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapEquals(this.c, this.d);
    }
    negate() {
      return this.f || (this.f = ol.create(this.c, this.d, this)), this.f;
    }
  },
  b1 = class Ym {
    static create(e, s) {
      return new Ym(e, s);
    }
    constructor(e, s) {
      (this.d = e), (this.f = s), (this.type = 10), (this.c = null);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.d, this.f, e.d, e.f);
    }
    equals(e) {
      return e.type === this.type ? this.d === e.d && this.f === e.f : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      const s = e.getValue(this.f),
        i = e.getValue(this.d);
      return Array.isArray(s) ? s.includes(i) : typeof i == "string" && typeof s == "object" && s !== null ? x4.call(s, i) : !1;
    }
    serialize() {
      return `${this.d} in '${this.f}'`;
    }
    keys() {
      return [this.d, this.f];
    }
    map(e) {
      return e.mapIn(this.d, this.f);
    }
    negate() {
      return this.c || (this.c = E1.create(this.d, this.f)), this.c;
    }
  },
  E1 = class Zm {
    static create(e, s) {
      return new Zm(e, s);
    }
    constructor(e, s) {
      (this.d = e), (this.f = s), (this.type = 11), (this.c = b1.create(e, s));
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : this.c.cmp(e.c);
    }
    equals(e) {
      return e.type === this.type ? this.c.equals(e.c) : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !this.c.evaluate(e);
    }
    serialize() {
      return `${this.d} not in '${this.f}'`;
    }
    keys() {
      return this.c.keys();
    }
    map(e) {
      return e.mapNotIn(this.d, this.f);
    }
    negate() {
      return this.c;
    }
  },
  ol = class ew {
    static create(e, s, i = null) {
      if (typeof s == "boolean") return s ? fr.create(e, i) : ur.create(e, i);
      const n = at.get(e);
      return typeof n == "boolean" ? (s === (n ? "true" : "false") ? Lt.INSTANCE : Ht.INSTANCE) : new ew(e, s, i);
    }
    constructor(e, s, i) {
      (this.c = e), (this.d = s), (this.f = i), (this.type = 5);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.c, this.d, e.c, e.d);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c && this.d === e.d : !1;
    }
    substituteConstants() {
      const e = at.get(this.c);
      if (typeof e == "boolean") {
        const s = e ? "true" : "false";
        return this.d === s ? Lt.INSTANCE : Ht.INSTANCE;
      }
      return this;
    }
    evaluate(e) {
      return e.getValue(this.c) != this.d;
    }
    serialize() {
      return `${this.c} != '${this.d}'`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapNotEquals(this.c, this.d);
    }
    negate() {
      return this.f || (this.f = rl.create(this.c, this.d, this)), this.f;
    }
  },
  fr = class tw {
    static create(e, s = null) {
      const i = at.get(e);
      return typeof i == "boolean" ? (i ? Lt.INSTANCE : Ht.INSTANCE) : new tw(e, s);
    }
    constructor(e, s) {
      (this.c = e), (this.d = s), (this.type = 3);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : x1(this.c, e.c);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c : !1;
    }
    substituteConstants() {
      const e = at.get(this.c);
      return typeof e == "boolean" ? (e ? Lt.INSTANCE : Ht.INSTANCE) : this;
    }
    evaluate(e) {
      return !e.getValue(this.c);
    }
    serialize() {
      return `!${this.c}`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapNot(this.c);
    }
    negate() {
      return this.d || (this.d = ur.create(this.c, this)), this.d;
    }
  };
function jo(t, e) {
  if (typeof t == "string") {
    const s = parseFloat(t);
    isNaN(s) || (t = s);
  }
  return typeof t == "string" || typeof t == "number" ? e(t) : Lt.INSTANCE;
}
var al = class sw {
    static create(e, s, i = null) {
      return jo(s, (n) => new sw(e, n, i));
    }
    constructor(e, s, i) {
      (this.c = e), (this.d = s), (this.f = i), (this.type = 12);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.c, this.d, e.c, e.d);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c && this.d === e.d : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.d == "string" ? !1 : parseFloat(e.getValue(this.c)) > this.d;
    }
    serialize() {
      return `${this.c} > ${this.d}`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapGreater(this.c, this.d);
    }
    negate() {
      return this.f || (this.f = hl.create(this.c, this.d, this)), this.f;
    }
  },
  cl = class iw {
    static create(e, s, i = null) {
      return jo(s, (n) => new iw(e, n, i));
    }
    constructor(e, s, i) {
      (this.c = e), (this.d = s), (this.f = i), (this.type = 13);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.c, this.d, e.c, e.d);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c && this.d === e.d : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.d == "string" ? !1 : parseFloat(e.getValue(this.c)) >= this.d;
    }
    serialize() {
      return `${this.c} >= ${this.d}`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapGreaterEquals(this.c, this.d);
    }
    negate() {
      return this.f || (this.f = ll.create(this.c, this.d, this)), this.f;
    }
  },
  ll = class nw {
    static create(e, s, i = null) {
      return jo(s, (n) => new nw(e, n, i));
    }
    constructor(e, s, i) {
      (this.c = e), (this.d = s), (this.f = i), (this.type = 14);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.c, this.d, e.c, e.d);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c && this.d === e.d : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.d == "string" ? !1 : parseFloat(e.getValue(this.c)) < this.d;
    }
    serialize() {
      return `${this.c} < ${this.d}`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapSmaller(this.c, this.d);
    }
    negate() {
      return this.f || (this.f = cl.create(this.c, this.d, this)), this.f;
    }
  },
  hl = class rw {
    static create(e, s, i = null) {
      return jo(s, (n) => new rw(e, n, i));
    }
    constructor(e, s, i) {
      (this.c = e), (this.d = s), (this.f = i), (this.type = 15);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : Ni(this.c, this.d, e.c, e.d);
    }
    equals(e) {
      return e.type === this.type ? this.c === e.c && this.d === e.d : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return typeof this.d == "string" ? !1 : parseFloat(e.getValue(this.c)) <= this.d;
    }
    serialize() {
      return `${this.c} <= ${this.d}`;
    }
    keys() {
      return [this.c];
    }
    map(e) {
      return e.mapSmallerEquals(this.c, this.d);
    }
    negate() {
      return this.f || (this.f = al.create(this.c, this.d, this)), this.f;
    }
  },
  ul = class ow {
    static create(e, s) {
      return new ow(e, s);
    }
    constructor(e, s) {
      (this.d = e), (this.f = s), (this.type = 7), (this.c = null);
    }
    cmp(e) {
      if (e.type !== this.type) return this.type - e.type;
      if (this.d < e.d) return -1;
      if (this.d > e.d) return 1;
      const s = this.f ? this.f.source : "",
        i = e.f ? e.f.source : "";
      return s < i ? -1 : s > i ? 1 : 0;
    }
    equals(e) {
      if (e.type === this.type) {
        const s = this.f ? this.f.source : "",
          i = e.f ? e.f.source : "";
        return this.d === e.d && s === i;
      }
      return !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      const s = e.getValue(this.d);
      return this.f ? this.f.test(s) : !1;
    }
    serialize() {
      const e = this.f ? `/${this.f.source}/${this.f.flags}` : "/invalid/";
      return `${this.d} =~ ${e}`;
    }
    keys() {
      return [this.d];
    }
    map(e) {
      return e.mapRegex(this.d, this.f);
    }
    negate() {
      return this.c || (this.c = N4.create(this)), this.c;
    }
  },
  N4 = class Af {
    static create(e) {
      return new Af(e);
    }
    constructor(e) {
      (this.c = e), (this.type = 8);
    }
    cmp(e) {
      return e.type !== this.type ? this.type - e.type : this.c.cmp(e.c);
    }
    equals(e) {
      return e.type === this.type ? this.c.equals(e.c) : !1;
    }
    substituteConstants() {
      return this;
    }
    evaluate(e) {
      return !this.c.evaluate(e);
    }
    serialize() {
      return `!(${this.c.serialize()})`;
    }
    keys() {
      return this.c.keys();
    }
    map(e) {
      return new Af(this.c.map(e));
    }
    negate() {
      return this.c;
    }
  };
function S1(t) {
  let e = null;
  for (let s = 0, i = t.length; s < i; s++) {
    const n = t[s].substituteConstants();
    if (t[s] !== n && e === null) {
      e = [];
      for (let r = 0; r < s; r++) e[r] = t[r];
    }
    e !== null && (e[s] = n);
  }
  return e === null ? t : e;
}
var $1 = class Vn {
    static create(e, s, i) {
      return Vn.d(e, s, i);
    }
    constructor(e, s) {
      (this.expr = e), (this.c = s), (this.type = 6);
    }
    cmp(e) {
      if (e.type !== this.type) return this.type - e.type;
      if (this.expr.length < e.expr.length) return -1;
      if (this.expr.length > e.expr.length) return 1;
      for (let s = 0, i = this.expr.length; s < i; s++) {
        const n = hr(this.expr[s], e.expr[s]);
        if (n !== 0) return n;
      }
      return 0;
    }
    equals(e) {
      if (e.type === this.type) {
        if (this.expr.length !== e.expr.length) return !1;
        for (let s = 0, i = this.expr.length; s < i; s++) if (!this.expr[s].equals(e.expr[s])) return !1;
        return !0;
      }
      return !1;
    }
    substituteConstants() {
      const e = S1(this.expr);
      return e === this.expr ? this : Vn.create(e, this.c, !1);
    }
    evaluate(e) {
      for (let s = 0, i = this.expr.length; s < i; s++) if (!this.expr[s].evaluate(e)) return !1;
      return !0;
    }
    static d(e, s, i) {
      const n = [];
      let r = !1;
      for (const o of e)
        if (o) {
          if (o.type === 1) {
            r = !0;
            continue;
          }
          if (o.type === 0) return Lt.INSTANCE;
          if (o.type === 6) {
            n.push(...o.expr);
            continue;
          }
          n.push(o);
        }
      if (n.length === 0 && r) return Ht.INSTANCE;
      if (n.length !== 0) {
        if (n.length === 1) return n[0];
        n.sort(hr);
        for (let o = 1; o < n.length; o++) n[o - 1].equals(n[o]) && (n.splice(o, 1), o--);
        if (n.length === 1) return n[0];
        for (; n.length > 1; ) {
          const o = n[n.length - 1];
          if (o.type !== 9) break;
          n.pop();
          const a = n.pop(),
            c = n.length === 0,
            l = fl.create(
              o.expr.map((h) => Vn.create([h, a], null, i)),
              null,
              c,
            );
          l && (n.push(l), n.sort(hr));
        }
        if (n.length === 1) return n[0];
        if (i) {
          for (let o = 0; o < n.length; o++) for (let a = o + 1; a < n.length; a++) if (n[o].negate().equals(n[a])) return Lt.INSTANCE;
          if (n.length === 1) return n[0];
        }
        return new Vn(n, s);
      }
    }
    serialize() {
      return this.expr.map((e) => e.serialize()).join(" && ");
    }
    keys() {
      const e = [];
      for (const s of this.expr) e.push(...s.keys());
      return e;
    }
    map(e) {
      return new Vn(
        this.expr.map((s) => s.map(e)),
        null,
      );
    }
    negate() {
      if (!this.c) {
        const e = [];
        for (const s of this.expr) e.push(s.negate());
        this.c = fl.create(e, this, !0);
      }
      return this.c;
    }
  },
  fl = class Yi {
    static create(e, s, i) {
      return Yi.d(e, s, i);
    }
    constructor(e, s) {
      (this.expr = e), (this.c = s), (this.type = 9);
    }
    cmp(e) {
      if (e.type !== this.type) return this.type - e.type;
      if (this.expr.length < e.expr.length) return -1;
      if (this.expr.length > e.expr.length) return 1;
      for (let s = 0, i = this.expr.length; s < i; s++) {
        const n = hr(this.expr[s], e.expr[s]);
        if (n !== 0) return n;
      }
      return 0;
    }
    equals(e) {
      if (e.type === this.type) {
        if (this.expr.length !== e.expr.length) return !1;
        for (let s = 0, i = this.expr.length; s < i; s++) if (!this.expr[s].equals(e.expr[s])) return !1;
        return !0;
      }
      return !1;
    }
    substituteConstants() {
      const e = S1(this.expr);
      return e === this.expr ? this : Yi.create(e, this.c, !1);
    }
    evaluate(e) {
      for (let s = 0, i = this.expr.length; s < i; s++) if (this.expr[s].evaluate(e)) return !0;
      return !1;
    }
    static d(e, s, i) {
      let n = [],
        r = !1;
      if (e) {
        for (let o = 0, a = e.length; o < a; o++) {
          const c = e[o];
          if (c) {
            if (c.type === 0) {
              r = !0;
              continue;
            }
            if (c.type === 1) return Ht.INSTANCE;
            if (c.type === 9) {
              n = n.concat(c.expr);
              continue;
            }
            n.push(c);
          }
        }
        if (n.length === 0 && r) return Lt.INSTANCE;
        n.sort(hr);
      }
      if (n.length !== 0) {
        if (n.length === 1) return n[0];
        for (let o = 1; o < n.length; o++) n[o - 1].equals(n[o]) && (n.splice(o, 1), o--);
        if (n.length === 1) return n[0];
        if (i) {
          for (let o = 0; o < n.length; o++) for (let a = o + 1; a < n.length; a++) if (n[o].negate().equals(n[a])) return Ht.INSTANCE;
          if (n.length === 1) return n[0];
        }
        return new Yi(n, s);
      }
    }
    serialize() {
      return this.expr.map((e) => e.serialize()).join(" || ");
    }
    keys() {
      const e = [];
      for (const s of this.expr) e.push(...s.keys());
      return e;
    }
    map(e) {
      return new Yi(
        this.expr.map((s) => s.map(e)),
        null,
      );
    }
    negate() {
      if (!this.c) {
        const e = [];
        for (const s of this.expr) e.push(s.negate());
        for (; e.length > 1; ) {
          const s = e.shift(),
            i = e.shift(),
            n = [];
          for (const r of C1(s)) for (const o of C1(i)) n.push($1.create([r, o], null, !1));
          e.unshift(Yi.create(n, null, !1));
        }
        this.c = Yi.create(e, this, !0);
      }
      return this.c;
    }
  },
  T4 = class uc extends ur {
    static {
      this.d = [];
    }
    static all() {
      return uc.d.values();
    }
    constructor(e, s, i) {
      super(e, null), (this.f = s), typeof i == "object" ? uc.d.push({ ...i, key: e }) : i !== !0 && uc.d.push({ key: e, description: i, type: s != null ? typeof s : void 0 });
    }
    bindTo(e) {
      return e.createKey(this.key, this.f);
    }
    getValue(e) {
      return e.getContextKeyValue(this.key);
    }
    toNegated() {
      return this.negate();
    }
    isEqualTo(e) {
      return rl.create(this.key, e);
    }
    notEqualsTo(e) {
      return ol.create(this.key, e);
    }
  },
  l3 = z("contextKeyService");
function x1(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Ni(t, e, s, i) {
  return t < s ? -1 : t > s ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
function C1(t) {
  return t.type === 9 ? t.expr : [t];
}
var ne = z("logService"),
  $n = z("loggerService");
function j4(t) {
  return Sc(t);
}
var te;
(function (t) {
  (t[(t.Off = 0)] = "Off"), (t[(t.Trace = 1)] = "Trace"), (t[(t.Debug = 2)] = "Debug"), (t[(t.Info = 3)] = "Info"), (t[(t.Warning = 4)] = "Warning"), (t[(t.Error = 5)] = "Error");
})(te || (te = {}));
var dl = te.Info;
function xn(t, e = !1) {
  let s = "";
  for (let i = 0; i < t.length; i++) {
    let n = t[i];
    if ((n instanceof Error && (n = Xe(n, e)), typeof n == "object"))
      try {
        n = JSON.stringify(n);
      } catch {}
    s += (i > 0 ? " " : "") + n;
  }
  return s;
}
var dr = class extends O {
    constructor() {
      super(...arguments), (this.b = dl), (this.c = this.B(new D())), (this.onDidChangeLogLevel = this.c.event);
    }
    setLevel(t) {
      this.b !== t && ((this.b = t), this.c.fire(this.b));
    }
    getLevel() {
      return this.b;
    }
    f(t) {
      return this.b !== te.Off && this.b <= t;
    }
  },
  F4 = class extends dr {
    constructor(t) {
      super(), (this.h = t);
    }
    f(t) {
      return this.h || super.f(t);
    }
    trace(t, ...e) {
      this.f(te.Trace) && this.g(te.Trace, xn([t, ...e], !0));
    }
    debug(t, ...e) {
      this.f(te.Debug) && this.g(te.Debug, xn([t, ...e]));
    }
    info(t, ...e) {
      this.f(te.Info) && this.g(te.Info, xn([t, ...e]));
    }
    warn(t, ...e) {
      this.f(te.Warning) && this.g(te.Warning, xn([t, ...e]));
    }
    error(t, ...e) {
      if (this.f(te.Error))
        if (t instanceof Error) {
          const s = Array.prototype.slice.call(arguments);
          (s[0] = t.stack), this.g(te.Error, xn(s));
        } else this.g(te.Error, xn([t, ...e]));
    }
    flush() {}
  },
  M4 = class extends dr {
    constructor(t = dl, e = !0) {
      super(), (this.g = e), this.setLevel(t);
    }
    trace(t, ...e) {
      this.f(te.Trace) && (this.g ? console.log("%cTRACE", "color: #888", t, ...e) : console.log(t, ...e));
    }
    debug(t, ...e) {
      this.f(te.Debug) && (this.g ? console.log("%cDEBUG", "background: #eee; color: #888", t, ...e) : console.log(t, ...e));
    }
    info(t, ...e) {
      this.f(te.Info) && (this.g ? console.log("%c INFO", "color: #33f", t, ...e) : console.log(t, ...e));
    }
    warn(t, ...e) {
      this.f(te.Warning) && (this.g ? console.log("%c WARN", "color: #993", t, ...e) : console.log(t, ...e));
    }
    error(t, ...e) {
      this.f(te.Error) && (this.g ? console.log("%c  ERR", "color: #f33", t, ...e) : console.error(t, ...e));
    }
    flush() {}
  },
  U4 = class extends dr {
    constructor(t, e = dl) {
      super(), (this.g = t), this.setLevel(e);
    }
    trace(t, ...e) {
      this.f(te.Trace) && this.g.log(te.Trace, [this.h(t), ...e]);
    }
    debug(t, ...e) {
      this.f(te.Debug) && this.g.log(te.Debug, [this.h(t), ...e]);
    }
    info(t, ...e) {
      this.f(te.Info) && this.g.log(te.Info, [this.h(t), ...e]);
    }
    warn(t, ...e) {
      this.f(te.Warning) && this.g.log(te.Warning, [this.h(t), ...e]);
    }
    error(t, ...e) {
      this.f(te.Error) && this.g.log(te.Error, [this.h(t), ...e]);
    }
    h(t) {
      return typeof t == "string" ? t : Xe(t, this.f(te.Trace));
    }
    flush() {}
  },
  _4 = class extends dr {
    constructor(t) {
      super(), (this.g = t), t.length && this.setLevel(t[0].getLevel());
    }
    setLevel(t) {
      for (const e of this.g) e.setLevel(t);
      super.setLevel(t);
    }
    trace(t, ...e) {
      for (const s of this.g) s.trace(t, ...e);
    }
    debug(t, ...e) {
      for (const s of this.g) s.debug(t, ...e);
    }
    info(t, ...e) {
      for (const s of this.g) s.info(t, ...e);
    }
    warn(t, ...e) {
      for (const s of this.g) s.warn(t, ...e);
    }
    error(t, ...e) {
      for (const s of this.g) s.error(t, ...e);
    }
    flush() {
      for (const t of this.g) t.flush();
    }
    dispose() {
      for (const t of this.g) t.dispose();
      super.dispose();
    }
  },
  B4 = class extends O {
    constructor(t, e, s) {
      if (
        (super(),
        (this.h = t),
        (this.j = e),
        (this.b = new kt()),
        (this.c = this.B(new D())),
        (this.onDidChangeLoggers = this.c.event),
        (this.f = this.B(new D())),
        (this.onDidChangeLogLevel = this.f.event),
        (this.g = this.B(new D())),
        (this.onDidChangeVisibility = this.g.event),
        s)
      )
        for (const i of s) this.b.set(i.resource, { logger: void 0, info: i });
    }
    m(t) {
      return _e(t) ? [...this.b.values()].find((e) => e.info.id === t) : this.b.get(t);
    }
    getLogger(t) {
      return this.m(t)?.logger;
    }
    createLogger(t, e) {
      const s = this.n(t),
        i = _e(t) ? t : (e?.id ?? Sn(s.toString()).toString(16));
      let n = this.b.get(s)?.logger;
      const r = e?.logLevel === "always" ? te.Trace : e?.logLevel;
      n || (n = this.s(s, r ?? this.getLogLevel(s) ?? this.h, { ...e, id: i }));
      const o = { logger: n, info: { resource: s, id: i, logLevel: r, name: e?.name, hidden: e?.hidden, extensionId: e?.extensionId, when: e?.when } };
      return this.registerLogger(o.info), this.b.set(s, o), n;
    }
    n(t) {
      return _e(t) ? M(this.j, `${t}.log`) : t;
    }
    setLogLevel(t, e) {
      if (C.isUri(t)) {
        const s = t,
          i = e,
          n = this.b.get(s);
        n && i !== n.info.logLevel && ((n.info.logLevel = i === this.h ? void 0 : i), n.logger?.setLevel(i), this.b.set(n.info.resource, n), this.f.fire([s, i]));
      } else {
        this.h = t;
        for (const [s, i] of this.b.entries()) this.b.get(s)?.info.logLevel === void 0 && i.logger?.setLevel(this.h);
        this.f.fire(this.h);
      }
    }
    setVisibility(t, e) {
      const s = this.m(t);
      s && e !== !s.info.hidden && ((s.info.hidden = !e), this.b.set(s.info.resource, s), this.g.fire([s.info.resource, e]));
    }
    getLogLevel(t) {
      let e;
      return t && (e = this.b.get(t)?.info.logLevel), e ?? this.h;
    }
    registerLogger(t) {
      const e = this.b.get(t.resource);
      e ? e.info.hidden !== t.hidden && this.setVisibility(t.resource, !t.hidden) : (this.b.set(t.resource, { info: t, logger: void 0 }), this.c.fire({ added: [t], removed: [] }));
    }
    deregisterLogger(t) {
      const e = this.b.get(t);
      e && (e.logger && e.logger.dispose(), this.b.delete(t), this.c.fire({ added: [], removed: [e.info] }));
    }
    *getRegisteredLoggers() {
      for (const t of this.b.values()) yield t.info;
    }
    getRegisteredLogger(t) {
      return this.b.get(t)?.info;
    }
    dispose() {
      this.b.forEach((t) => t.logger?.dispose()), this.b.clear(), super.dispose();
    }
  },
  z4 = class {
    constructor() {
      this.onDidChangeLogLevel = new D().event;
    }
    setLevel(t) {}
    getLevel() {
      return te.Info;
    }
    trace(t, ...e) {}
    debug(t, ...e) {}
    info(t, ...e) {}
    warn(t, ...e) {}
    error(t, ...e) {}
    critical(t, ...e) {}
    dispose() {}
    flush() {}
  },
  q4 = class extends z4 {};
function Fo(t) {
  switch (t) {
    case te.Trace:
      return "trace";
    case te.Debug:
      return "debug";
    case te.Info:
      return "info";
    case te.Warning:
      return "warn";
    case te.Error:
      return "error";
    case te.Off:
      return "off";
  }
}
var h3 = new T4("logLevel", Fo(te.Info)),
  Ee = z("productService"),
  pl = class extends O {
    constructor(e, s, i) {
      super(),
        (this.b = s),
        (this.c = i),
        (this.a = this.b.quality !== "stable" ? 1e3 * 60 * 60 * 24 * 7 : 1e3 * 60 * 60 * 24 * 30 * 3),
        e &&
          this.B(
            new ks(() => {
              this.f(e);
            }, 3e4),
          ).schedule();
    }
    async f(e) {
      this.c.trace("[code cache cleanup]: Starting to clean up old code cache folders.");
      try {
        const s = Date.now(),
          i = Yt(e),
          n = Ot(e),
          r = await he.readdir(i);
        await Promise.all(
          r.map(async (o) => {
            if (o === n) return;
            const a = V(i, o),
              c = await e4.promises.stat(a);
            if (c.isDirectory() && s - c.mtime.getTime() > this.a) return this.c.trace(`[code cache cleanup]: Removing code cache folder ${o}.`), he.rm(a);
          }),
        );
      } catch (s) {
        rt(s);
      }
    }
  };
pl = __decorate([__param(1, Ee), __param(2, ne)], pl);
import * as k1 from "fs";
var fe = z("environmentService"),
  Zt = fe,
  gl = class extends O {
    constructor(e, s, i) {
      super(),
        (this.b = e),
        (this.c = s),
        (this.f = i),
        (this.a = this.f.quality !== "stable" ? 1e3 * 60 * 60 * 24 * 7 : 1e3 * 60 * 60 * 24 * 30 * 3),
        this.b.isBuilt &&
          this.B(
            new ks(() => {
              this.g();
            }, 4e4),
          ).schedule();
    }
    async g() {
      this.c.trace("[language pack cache cleanup]: Starting to clean up unused language packs.");
      try {
        const e = Object.create(null),
          s = JSON.parse(await k1.promises.readFile(V(this.b.userDataPath, "languagepacks.json"), "utf8"));
        for (const a of Object.keys(s)) {
          const c = s[a];
          e[`${c.hash}.${a}`] = !0;
        }
        const i = V(this.b.userDataPath, "clp");
        if (!(await he.exists(i))) return;
        const r = await he.readdir(i);
        for (const a of r) {
          if (e[a]) {
            this.c.trace(`[language pack cache cleanup]: Skipping folder ${a}. Language pack still in use.`);
            continue;
          }
          this.c.trace(`[language pack cache cleanup]: Removing unused language pack: ${a}`), await he.rm(V(i, a));
        }
        const o = Date.now();
        for (const a of Object.keys(e)) {
          const c = V(i, a),
            l = await he.readdir(c);
          for (const h of l) {
            if (h === "tcf.json") continue;
            const u = V(c, h),
              f = await k1.promises.stat(u);
            f.isDirectory() && o - f.mtime.getTime() > this.a && (this.c.trace(`[language pack cache cleanup]: Removing language pack cache folder: ${V(a, h)}`), await he.rm(u));
          }
        }
      } catch (e) {
        rt(e);
      }
    }
  };
gl = __decorate([__param(0, Zt), __param(1, ne), __param(2, Ee)], gl);
var D1 = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$",
  d3 = new RegExp(D1),
  V4 = "__web_extension",
  W4 = "skipWalkthrough",
  ml = "extensionInstallSource",
  H4 = "dependecyOrPackExtensionInstall",
  G4 = "clientTargetPlatform",
  I1;
(function (t) {
  (t.COMMAND = "command"), (t.SETTINGS_SYNC = "settingsSync");
})(I1 || (I1 = {}));
function J4(t) {
  switch (t) {
    case "win32-x64":
      return "Windows 64 bit";
    case "win32-arm64":
      return "Windows ARM";
    case "linux-x64":
      return "Linux 64 bit";
    case "linux-arm64":
      return "Linux ARM 64";
    case "linux-armhf":
      return "Linux ARM";
    case "alpine-x64":
      return "Alpine Linux 64 bit";
    case "alpine-arm64":
      return "Alpine ARM 64";
    case "darwin-x64":
      return "Mac";
    case "darwin-arm64":
      return "Mac Silicon";
    case "web":
      return "Web";
    case "universal":
      return "universal";
    case "unknown":
      return "unknown";
    case "undefined":
      return "undefined";
  }
}
function K4(t) {
  switch (t) {
    case "win32-x64":
      return "win32-x64";
    case "win32-arm64":
      return "win32-arm64";
    case "linux-x64":
      return "linux-x64";
    case "linux-arm64":
      return "linux-arm64";
    case "linux-armhf":
      return "linux-armhf";
    case "alpine-x64":
      return "alpine-x64";
    case "alpine-arm64":
      return "alpine-arm64";
    case "darwin-x64":
      return "darwin-x64";
    case "darwin-arm64":
      return "darwin-arm64";
    case "web":
      return "web";
    case "universal":
      return "universal";
    default:
      return "unknown";
  }
}
function R1(t, e) {
  switch (t) {
    case 3:
      return e === "x64" ? "win32-x64" : e === "arm64" ? "win32-arm64" : "unknown";
    case 2:
      return e === "x64" ? "linux-x64" : e === "arm64" ? "linux-arm64" : e === "arm" ? "linux-armhf" : "unknown";
    case "alpine":
      return e === "x64" ? "alpine-x64" : e === "arm64" ? "alpine-arm64" : "unknown";
    case 1:
      return e === "x64" ? "darwin-x64" : e === "arm64" ? "darwin-arm64" : "unknown";
    case 0:
      return "web";
  }
}
function pr(t, e) {
  return e === "web" && !t.includes("web");
}
function wl(t, e, s) {
  return pr(e, s) ? !1 : t === "undefined" || t === "universal" ? !0 : t === "unknown" ? !1 : t === s;
}
function X4(t) {
  return t && typeof t == "object" && typeof t.id == "string" && (!t.uuid || typeof t.uuid == "string");
}
var P1;
(function (t) {
  (t[(t.NoneOrRelevance = 0)] = "NoneOrRelevance"),
    (t[(t.LastUpdatedDate = 1)] = "LastUpdatedDate"),
    (t[(t.Title = 2)] = "Title"),
    (t[(t.PublisherName = 3)] = "PublisherName"),
    (t[(t.InstallCount = 4)] = "InstallCount"),
    (t[(t.PublishedDate = 10)] = "PublishedDate"),
    (t[(t.AverageRating = 6)] = "AverageRating"),
    (t[(t.WeightedRating = 12)] = "WeightedRating");
})(P1 || (P1 = {}));
var A1;
(function (t) {
  (t[(t.Default = 0)] = "Default"), (t[(t.Ascending = 1)] = "Ascending"), (t[(t.Descending = 2)] = "Descending");
})(A1 || (A1 = {}));
var O1;
(function (t) {
  (t.Install = "install"), (t.Uninstall = "uninstall");
})(O1 || (O1 = {}));
var L1;
(function (t) {
  (t[(t.None = 1)] = "None"), (t[(t.Install = 2)] = "Install"), (t[(t.Update = 3)] = "Update"), (t[(t.Migrate = 4)] = "Migrate");
})(L1 || (L1 = {}));
var ps = z("extensionGalleryService"),
  N1;
(function (t) {
  (t.Timeout = "Timeout"), (t.Cancelled = "Cancelled"), (t.Failed = "Failed"), (t.DownloadFailedWriting = "DownloadFailedWriting"), (t.Offline = "Offline");
})(N1 || (N1 = {}));
var Mo = class extends Error {
    constructor(t, e) {
      super(t), (this.code = e), (this.name = e);
    }
  },
  T1;
(function (t) {
  (t.Unsupported = "Unsupported"),
    (t.Deprecated = "Deprecated"),
    (t.Malicious = "Malicious"),
    (t.Incompatible = "Incompatible"),
    (t.IncompatibleApi = "IncompatibleApi"),
    (t.IncompatibleTargetPlatform = "IncompatibleTargetPlatform"),
    (t.ReleaseVersionNotFound = "ReleaseVersionNotFound"),
    (t.Invalid = "Invalid"),
    (t.Download = "Download"),
    (t.DownloadSignature = "DownloadSignature"),
    (t.DownloadFailedWriting = "DownloadFailedWriting"),
    (t.UpdateMetadata = "UpdateMetadata"),
    (t.Extract = "Extract"),
    (t.Scanning = "Scanning"),
    (t.ScanningExtension = "ScanningExtension"),
    (t.ReadUninstalled = "ReadUninstalled"),
    (t.UnsetUninstalled = "UnsetUninstalled"),
    (t.Delete = "Delete"),
    (t.Rename = "Rename"),
    (t.IntializeDefaultProfile = "IntializeDefaultProfile"),
    (t.AddToProfile = "AddToProfile"),
    (t.InstalledExtensionNotFound = "InstalledExtensionNotFound"),
    (t.PostInstall = "PostInstall"),
    (t.CorruptZip = "CorruptZip"),
    (t.IncompleteZip = "IncompleteZip"),
    (t.PackageNotSigned = "PackageNotSigned"),
    (t.SignatureVerificationInternal = "SignatureVerificationInternal"),
    (t.SignatureVerificationFailed = "SignatureVerificationFailed"),
    (t.NotAllowed = "NotAllowed"),
    (t.Gallery = "Gallery"),
    (t.Cancelled = "Cancelled"),
    (t.Unknown = "Unknown"),
    (t.Internal = "Internal");
})(T1 || (T1 = {}));
var vt;
(function (t) {
  (t.Success = "Success"),
    (t.RequiredArgumentMissing = "RequiredArgumentMissing"),
    (t.InvalidArgument = "InvalidArgument"),
    (t.PackageIsUnreadable = "PackageIsUnreadable"),
    (t.UnhandledException = "UnhandledException"),
    (t.SignatureManifestIsMissing = "SignatureManifestIsMissing"),
    (t.SignatureManifestIsUnreadable = "SignatureManifestIsUnreadable"),
    (t.SignatureIsMissing = "SignatureIsMissing"),
    (t.SignatureIsUnreadable = "SignatureIsUnreadable"),
    (t.CertificateIsUnreadable = "CertificateIsUnreadable"),
    (t.SignatureArchiveIsUnreadable = "SignatureArchiveIsUnreadable"),
    (t.FileAlreadyExists = "FileAlreadyExists"),
    (t.SignatureArchiveIsInvalidZip = "SignatureArchiveIsInvalidZip"),
    (t.SignatureArchiveHasSameSignatureFile = "SignatureArchiveHasSameSignatureFile"),
    (t.PackageIntegrityCheckFailed = "PackageIntegrityCheckFailed"),
    (t.SignatureIsInvalid = "SignatureIsInvalid"),
    (t.SignatureManifestIsInvalid = "SignatureManifestIsInvalid"),
    (t.SignatureIntegrityCheckFailed = "SignatureIntegrityCheckFailed"),
    (t.EntryIsMissing = "EntryIsMissing"),
    (t.EntryIsTampered = "EntryIsTampered"),
    (t.Untrusted = "Untrusted"),
    (t.CertificateRevoked = "CertificateRevoked"),
    (t.SignatureIsNotValid = "SignatureIsNotValid"),
    (t.UnknownError = "UnknownError"),
    (t.PackageIsInvalidZip = "PackageIsInvalidZip"),
    (t.SignatureArchiveHasTooManyEntries = "SignatureArchiveHasTooManyEntries");
})(vt || (vt = {}));
var Ne = class extends Error {
    constructor(t, e) {
      super(t), (this.code = e), (this.name = e);
    }
  },
  Vs = z("extensionManagementService"),
  vl = "extensionsIdentifiers/disabled",
  j1 = z("IGlobalExtensionEnablementService"),
  F1 = z("IExtensionTipsService"),
  p3 = Gf(1816, "Extensions"),
  g3 = Gf(1817, "Preferences");
function Q4(t) {
  return t.tags.find((e) => e.startsWith("lp-"))?.split("lp-")[1];
}
var yl = z("languagePackService"),
  bl = class extends O {
    constructor(e) {
      super(), (this.c = e);
    }
    async getAvailableLanguages() {
      const e = new xs();
      setTimeout(() => e.cancel(), 1e3);
      let s;
      try {
        s = await this.c.query({ text: 'category:"language packs"', pageSize: 20 }, e.token);
      } catch {
        return [];
      }
      const n = s.firstPage
        .filter((r) => r.properties.localizedLanguages?.length && r.tags.some((o) => o.startsWith("lp-")))
        .map((r) => {
          const o = r.properties.localizedLanguages?.[0],
            a = Q4(r);
          return { ...this.f(a, o, r), extensionId: r.identifier.id, galleryExtension: r };
        });
      return n.push(this.f("en", "English")), n;
    }
    f(e, s, i) {
      const n = s ?? e;
      let r;
      if ((n !== e && (r = `(${e})`), e.toLowerCase() === hs.toLowerCase() && ((r ??= ""), (r += w(1993, null))), i?.installCount)) {
        r ??= "";
        const o = i.installCount;
        let a;
        o > 1e6 ? (a = `${Math.floor(o / 1e5) / 10}M`) : o > 1e3 ? (a = `${Math.floor(o / 1e3)}K`) : (a = String(o)), (r += ` $(cloud-download) ${a}`);
      }
      return { id: e, label: n, description: r };
    }
  };
bl = __decorate([__param(0, ps)], bl);
var El = class extends O {
  constructor(e) {
    super(), (this.a = e), this.b();
  }
  b() {
    this.a.update();
  }
};
El = __decorate([__param(0, yl)], El);
var Sl = class extends O {
  constructor(e, s) {
    super(),
      (this.a = e),
      (this.b = s),
      this.B(
        new ks(() => {
          this.c();
        }, 10 * 1e3),
      ).schedule();
  }
  async c() {
    this.b.trace("[logs cleanup]: Starting to clean up old logs.");
    try {
      const e = nr(this.a.logsHome),
        s = Wd(this.a.logsHome.with({ scheme: oe.file })).fsPath,
        r = (await he.readdir(s))
          .filter((a) => /^\d{8}T\d{6}$/.test(a))
          .sort()
          .filter((a) => a !== e),
        o = r.slice(0, Math.max(0, r.length - 9));
      o.length > 0 && (this.b.trace(`[logs cleanup]: Removing log folders '${o.join(", ")}'`), await Promise.all(o.map((a) => he.rm(V(s, a)))));
    } catch (e) {
      rt(e);
    }
  }
};
Sl = __decorate([__param(0, fe), __param(1, ne)], Sl);
var M1 = class extends O {
    constructor(t, e, s) {
      super(), (this.a = t), (this.b = e), (this.c = s);
    }
    async getItems() {
      const t = { profile: this.b, workspace: this.c },
        e = await this.a.call("getItems", t);
      return new Map(e);
    }
    updateItems(t) {
      const e = { profile: this.b, workspace: this.c };
      return t.insert && (e.insert = Array.from(t.insert.entries())), t.delete && (e.delete = Array.from(t.delete.values())), this.a.call("updateItems", e);
    }
    optimize() {
      const t = { profile: this.b, workspace: this.c };
      return this.a.call("optimize", t);
    }
  },
  U1 = class extends M1 {
    constructor(t, e) {
      super(t, e, void 0), (this.f = this.B(new D())), (this.onDidChangeItemsExternal = this.f.event), this.g();
    }
    g() {
      this.B(this.a.listen("onDidChangeStorage", { profile: this.b })((t) => this.h(t)));
    }
    h(t) {
      (Array.isArray(t.changed) || Array.isArray(t.deleted)) && this.f.fire({ changed: t.changed ? new Map(t.changed) : void 0, deleted: t.deleted ? new Set(t.deleted) : void 0 });
    }
  },
  _1 = class extends U1 {
    constructor(t) {
      super(t, void 0);
    }
    async close() {
      this.dispose();
    }
  },
  B1 = class extends U1 {
    constructor(t, e) {
      super(t, e);
    }
    async close() {
      this.dispose();
    }
  },
  Y4 = class extends M1 {
    constructor(t, e) {
      super(t, void 0, e), (this.onDidChangeItemsExternal = T.None);
    }
    async close() {
      this.dispose();
    }
  },
  Z4 = class {
    constructor(t) {
      this.a = t;
    }
    isUsed(t) {
      const e = { payload: t, profile: void 0, workspace: void 0 };
      return this.a.call("isUsed", e);
    }
  },
  eb = class {
    constructor() {
      (this.b = ""), (this.c = 0);
    }
    reset(t) {
      return (this.b = t), (this.c = 0), this;
    }
    next() {
      return (this.c += 1), this;
    }
    hasNext() {
      return this.c < this.b.length - 1;
    }
    cmp(t) {
      const e = t.charCodeAt(0),
        s = this.b.charCodeAt(this.c);
      return e - s;
    }
    value() {
      return this.b[this.c];
    }
  },
  tb = class {
    constructor(t = !0) {
      this.e = t;
    }
    reset(t) {
      return (this.b = t), (this.c = 0), (this.d = 0), this.next();
    }
    hasNext() {
      return this.d < this.b.length;
    }
    next() {
      this.c = this.d;
      let t = !0;
      for (; this.d < this.b.length; this.d++)
        if (this.b.charCodeAt(this.d) === 46)
          if (t) this.c++;
          else break;
        else t = !1;
      return this;
    }
    cmp(t) {
      return this.e ? Mc(t, this.b, 0, t.length, this.c, this.d) : tr(t, this.b, 0, t.length, this.c, this.d);
    }
    value() {
      return this.b.substring(this.c, this.d);
    }
  },
  z1 = class {
    constructor(t = !0, e = !0) {
      (this.f = t), (this.g = e);
    }
    reset(t) {
      (this.d = 0), (this.e = 0), (this.b = t), (this.c = t.length);
      for (let e = t.length - 1; e >= 0; e--, this.c--) {
        const s = this.b.charCodeAt(e);
        if (!(s === 47 || (this.f && s === 92))) break;
      }
      return this.next();
    }
    hasNext() {
      return this.e < this.c;
    }
    next() {
      this.d = this.e;
      let t = !0;
      for (; this.e < this.c; this.e++) {
        const e = this.b.charCodeAt(this.e);
        if (e === 47 || (this.f && e === 92))
          if (t) this.d++;
          else break;
        else t = !1;
      }
      return this;
    }
    cmp(t) {
      return this.g ? Mc(t, this.b, 0, t.length, this.d, this.e) : tr(t, this.b, 0, t.length, this.d, this.e);
    }
    value() {
      return this.b.substring(this.d, this.e);
    }
  },
  q1;
(function (t) {
  (t[(t.Scheme = 1)] = "Scheme"), (t[(t.Authority = 2)] = "Authority"), (t[(t.Path = 3)] = "Path"), (t[(t.Query = 4)] = "Query"), (t[(t.Fragment = 5)] = "Fragment");
})(q1 || (q1 = {}));
var sb = class {
    constructor(t, e) {
      (this.f = t), (this.g = e), (this.d = []), (this.e = 0);
    }
    reset(t) {
      return (
        (this.c = t),
        (this.d = []),
        this.c.scheme && this.d.push(1),
        this.c.authority && this.d.push(2),
        this.c.path && ((this.b = new z1(!1, !this.f(t))), this.b.reset(t.path), this.b.value() && this.d.push(3)),
        this.g(t) || (this.c.query && this.d.push(4), this.c.fragment && this.d.push(5)),
        (this.e = 0),
        this
      );
    }
    next() {
      return this.d[this.e] === 3 && this.b.hasNext() ? this.b.next() : (this.e += 1), this;
    }
    hasNext() {
      return (this.d[this.e] === 3 && this.b.hasNext()) || this.e < this.d.length - 1;
    }
    cmp(t) {
      if (this.d[this.e] === 1) return Uc(t, this.c.scheme);
      if (this.d[this.e] === 2) return Uc(t, this.c.authority);
      if (this.d[this.e] === 3) return this.b.cmp(t);
      if (this.d[this.e] === 4) return Eo(t, this.c.query);
      if (this.d[this.e] === 5) return Eo(t, this.c.fragment);
      throw new Error();
    }
    value() {
      if (this.d[this.e] === 1) return this.c.scheme;
      if (this.d[this.e] === 2) return this.c.authority;
      if (this.d[this.e] === 3) return this.b.value();
      if (this.d[this.e] === 4) return this.c.query;
      if (this.d[this.e] === 5) return this.c.fragment;
      throw new Error();
    }
  },
  Uo = class {
    constructor() {
      this.height = 1;
    }
    isEmpty() {
      return !this.left && !this.mid && !this.right && !this.value;
    }
    rotateLeft() {
      const t = this.right;
      return (this.right = t.left), (t.left = this), this.updateHeight(), t.updateHeight(), t;
    }
    rotateRight() {
      const t = this.left;
      return (this.left = t.right), (t.right = this), this.updateHeight(), t.updateHeight(), t;
    }
    updateHeight() {
      this.height = 1 + Math.max(this.heightLeft, this.heightRight);
    }
    balanceFactor() {
      return this.heightRight - this.heightLeft;
    }
    get heightLeft() {
      return this.left?.height ?? 0;
    }
    get heightRight() {
      return this.right?.height ?? 0;
    }
  },
  V1;
(function (t) {
  (t[(t.Left = -1)] = "Left"), (t[(t.Mid = 0)] = "Mid"), (t[(t.Right = 1)] = "Right");
})(V1 || (V1 = {}));
var Cn = class to {
    static forUris(e = () => !1, s = () => !1) {
      return new to(new sb(e, s));
    }
    static forPaths(e = !1) {
      return new to(new z1(void 0, !e));
    }
    static forStrings() {
      return new to(new eb());
    }
    static forConfigKeys() {
      return new to(new tb());
    }
    constructor(e) {
      this.b = e;
    }
    clear() {
      this.c = void 0;
    }
    fill(e, s) {
      if (s) {
        const i = s.slice(0);
        Vf(i);
        for (const n of i) this.set(n, e);
      } else {
        const i = e.slice(0);
        Vf(i);
        for (const n of i) this.set(n[0], n[1]);
      }
    }
    set(e, s) {
      const i = this.b.reset(e);
      let n;
      this.c || ((this.c = new Uo()), (this.c.segment = i.value()));
      const r = [];
      for (n = this.c; ; ) {
        const a = i.cmp(n.segment);
        if (a > 0) n.left || ((n.left = new Uo()), (n.left.segment = i.value())), r.push([-1, n]), (n = n.left);
        else if (a < 0) n.right || ((n.right = new Uo()), (n.right.segment = i.value())), r.push([1, n]), (n = n.right);
        else if (i.hasNext()) i.next(), n.mid || ((n.mid = new Uo()), (n.mid.segment = i.value())), r.push([0, n]), (n = n.mid);
        else break;
      }
      const o = n.value;
      (n.value = s), (n.key = e);
      for (let a = r.length - 1; a >= 0; a--) {
        const c = r[a][1];
        c.updateHeight();
        const l = c.balanceFactor();
        if (l < -1 || l > 1) {
          const h = r[a][0],
            u = r[a + 1][0];
          if (h === 1 && u === 1) r[a][1] = c.rotateLeft();
          else if (h === -1 && u === -1) r[a][1] = c.rotateRight();
          else if (h === 1 && u === -1) (c.right = r[a + 1][1] = r[a + 1][1].rotateRight()), (r[a][1] = c.rotateLeft());
          else if (h === -1 && u === 1) (c.left = r[a + 1][1] = r[a + 1][1].rotateLeft()), (r[a][1] = c.rotateRight());
          else throw new Error();
          if (a > 0)
            switch (r[a - 1][0]) {
              case -1:
                r[a - 1][1].left = r[a][1];
                break;
              case 1:
                r[a - 1][1].right = r[a][1];
                break;
              case 0:
                r[a - 1][1].mid = r[a][1];
                break;
            }
          else this.c = r[0][1];
        }
      }
      return o;
    }
    get(e) {
      return this.d(e)?.value;
    }
    d(e) {
      const s = this.b.reset(e);
      let i = this.c;
      for (; i; ) {
        const n = s.cmp(i.segment);
        if (n > 0) i = i.left;
        else if (n < 0) i = i.right;
        else if (s.hasNext()) s.next(), (i = i.mid);
        else break;
      }
      return i;
    }
    has(e) {
      const s = this.d(e);
      return !(s?.value === void 0 && s?.mid === void 0);
    }
    delete(e) {
      return this.e(e, !1);
    }
    deleteSuperstr(e) {
      return this.e(e, !0);
    }
    e(e, s) {
      const i = this.b.reset(e),
        n = [];
      let r = this.c;
      for (; r; ) {
        const o = i.cmp(r.segment);
        if (o > 0) n.push([-1, r]), (r = r.left);
        else if (o < 0) n.push([1, r]), (r = r.right);
        else if (i.hasNext()) i.next(), n.push([0, r]), (r = r.mid);
        else break;
      }
      if (r) {
        if ((s ? ((r.left = void 0), (r.mid = void 0), (r.right = void 0), (r.height = 1)) : ((r.key = void 0), (r.value = void 0)), !r.mid && !r.value))
          if (r.left && r.right) {
            const o = this.f(r.right);
            if (o.key) {
              const { key: a, value: c, segment: l } = o;
              this.e(o.key, !1), (r.key = a), (r.value = c), (r.segment = l);
            }
          } else {
            const o = r.left ?? r.right;
            if (n.length > 0) {
              const [a, c] = n[n.length - 1];
              switch (a) {
                case -1:
                  c.left = o;
                  break;
                case 0:
                  c.mid = o;
                  break;
                case 1:
                  c.right = o;
                  break;
              }
            } else this.c = o;
          }
        for (let o = n.length - 1; o >= 0; o--) {
          const a = n[o][1];
          a.updateHeight();
          const c = a.balanceFactor();
          if ((c > 1 ? (a.right.balanceFactor() >= 0 || (a.right = a.right.rotateRight()), (n[o][1] = a.rotateLeft())) : c < -1 && (a.left.balanceFactor() <= 0 || (a.left = a.left.rotateLeft()), (n[o][1] = a.rotateRight())), o > 0))
            switch (n[o - 1][0]) {
              case -1:
                n[o - 1][1].left = n[o][1];
                break;
              case 1:
                n[o - 1][1].right = n[o][1];
                break;
              case 0:
                n[o - 1][1].mid = n[o][1];
                break;
            }
          else this.c = n[0][1];
        }
      }
    }
    f(e) {
      for (; e.left; ) e = e.left;
      return e;
    }
    findSubstr(e) {
      const s = this.b.reset(e);
      let i = this.c,
        n;
      for (; i; ) {
        const r = s.cmp(i.segment);
        if (r > 0) i = i.left;
        else if (r < 0) i = i.right;
        else if (s.hasNext()) s.next(), (n = i.value || n), (i = i.mid);
        else break;
      }
      return (i && i.value) || n;
    }
    findSuperstr(e) {
      return this.g(e, !1);
    }
    g(e, s) {
      const i = this.b.reset(e);
      let n = this.c;
      for (; n; ) {
        const r = i.cmp(n.segment);
        if (r > 0) n = n.left;
        else if (r < 0) n = n.right;
        else if (i.hasNext()) i.next(), (n = n.mid);
        else return n.mid ? this.h(n.mid) : s ? n.value : void 0;
      }
    }
    hasElementOrSubtree(e) {
      return this.g(e, !0) !== void 0;
    }
    forEach(e) {
      for (const [s, i] of this) e(i, s);
    }
    *[Symbol.iterator]() {
      yield* this.h(this.c);
    }
    h(e) {
      const s = [];
      return this.j(e, s), s[Symbol.iterator]();
    }
    j(e, s) {
      e && (e.left && this.j(e.left, s), e.value && s.push([e.key, e.value]), e.mid && this.j(e.mid, s), e.right && this.j(e.right, s));
    }
    _isBalanced() {
      const e = (s) => {
        if (!s) return !0;
        const i = s.balanceFactor();
        return i < -1 || i > 1 ? !1 : e(s.left) && e(s.right);
      };
      return e(this.c);
    }
  },
  y3 = z("contextService");
function ib(t) {
  const e = t;
  return typeof e?.id == "string" && C.isUri(e.uri);
}
var nb = { id: "ext-dev" };
function rb(t) {
  const e = t;
  return typeof e?.id == "string" && C.isUri(e.configPath);
}
var W1;
(function (t) {
  (t[(t.EMPTY = 1)] = "EMPTY"), (t[(t.FOLDER = 2)] = "FOLDER"), (t[(t.WORKSPACE = 3)] = "WORKSPACE");
})(W1 || (W1 = {}));
var H1 = "code-workspace",
  b3 = `.${H1}`,
  E3 = [{ name: w(2793, null), extensions: [H1] }];
import "crypto";
var ob = 128 / 4,
  _o = z("nativeHostService"),
  gr = z("mainProcessService"),
  ab = class {
    constructor(t, e) {
      (this.a = t), (this.b = e);
    }
    getChannel(t) {
      return this.a.getChannel(t, this.b);
    }
    registerChannel(t, e) {
      this.a.registerChannel(t, e);
    }
  },
  $l = class extends O {
    constructor(e, s, i, n) {
      super(),
        (this.a = e),
        (this.b = s),
        (this.c = i),
        (this.f = n),
        this.B(
          new ks(() => {
            this.g();
          }, 30 * 1e3),
        ).schedule();
    }
    async g() {
      this.b.trace("[storage cleanup]: Starting to clean up workspace storage folders for unused empty workspaces.");
      try {
        const e = this.a.workspaceStorageHome.with({ scheme: oe.file }).fsPath,
          s = await he.readdir(e),
          i = new Z4(this.f.getChannel("storage"));
        await Promise.all(
          s.map(async (n) => {
            const r = V(e, n);
            n.length === ob ||
              n === nb.id ||
              (await this.c.getWindows({ includeAuxiliaryWindows: !1 })).some((c) => c.workspace?.id === n) ||
              (await i.isUsed(r)) ||
              (this.b.trace(`[storage cleanup]: Deleting workspace storage folder ${n} as it seems to be an unused empty workspace.`), await he.rm(r));
          }),
        );
      } catch (e) {
        rt(e);
      }
    }
  };
$l = __decorate([__param(0, Zt), __param(1, ne), __param(2, _o), __param(3, gr)], $l);
var G1 = z("checksumService");
import { createHash as cb } from "crypto";
var ie = z("fileService"),
  k3 = z("remoteFileService");
function mr(t) {
  return t.create === !0;
}
var Gt;
(function (t) {
  (t[(t.Unknown = 0)] = "Unknown"), (t[(t.File = 1)] = "File"), (t[(t.Directory = 2)] = "Directory"), (t[(t.SymbolicLink = 64)] = "SymbolicLink");
})(Gt || (Gt = {}));
var kn;
(function (t) {
  (t[(t.Readonly = 1)] = "Readonly"), (t[(t.Locked = 2)] = "Locked");
})(kn || (kn = {}));
var J1;
(function (t) {
  (t[(t.UPDATED = 2)] = "UPDATED"), (t[(t.ADDED = 4)] = "ADDED"), (t[(t.DELETED = 8)] = "DELETED");
})(J1 || (J1 = {}));
var K1;
(function (t) {
  (t[(t.None = 0)] = "None"),
    (t[(t.FileReadWrite = 2)] = "FileReadWrite"),
    (t[(t.FileOpenReadWriteClose = 4)] = "FileOpenReadWriteClose"),
    (t[(t.FileReadStream = 16)] = "FileReadStream"),
    (t[(t.FileFolderCopy = 8)] = "FileFolderCopy"),
    (t[(t.PathCaseSensitive = 1024)] = "PathCaseSensitive"),
    (t[(t.Readonly = 2048)] = "Readonly"),
    (t[(t.Trash = 4096)] = "Trash"),
    (t[(t.FileWriteUnlock = 8192)] = "FileWriteUnlock"),
    (t[(t.FileAtomicRead = 16384)] = "FileAtomicRead"),
    (t[(t.FileAtomicWrite = 32768)] = "FileAtomicWrite"),
    (t[(t.FileAtomicDelete = 65536)] = "FileAtomicDelete"),
    (t[(t.FileClone = 131072)] = "FileClone");
})(K1 || (K1 = {}));
function ns(t) {
  return !!(t.capabilities & 2);
}
function xl(t) {
  return !!(t.capabilities & 8);
}
function X1(t) {
  return !!(t.capabilities & 131072);
}
function ni(t) {
  return !!(t.capabilities & 4);
}
function Cl(t) {
  return !!(t.capabilities & 16);
}
function kl(t) {
  return ns(t) ? !!(t.capabilities & 16384) : !1;
}
function Q1(t) {
  return ns(t) ? !!(t.capabilities & 32768) : !1;
}
function lb(t) {
  return !!(t.capabilities & 65536);
}
var X;
(function (t) {
  (t.FileExists = "EntryExists"),
    (t.FileNotFound = "EntryNotFound"),
    (t.FileNotADirectory = "EntryNotADirectory"),
    (t.FileIsADirectory = "EntryIsADirectory"),
    (t.FileExceedsStorageQuota = "EntryExceedsStorageQuota"),
    (t.FileTooLarge = "EntryTooLarge"),
    (t.FileWriteLocked = "EntryWriteLocked"),
    (t.NoPermissions = "NoPermissions"),
    (t.Unavailable = "Unavailable"),
    (t.Unknown = "Unknown");
})(X || (X = {}));
var Dl = class aw extends Error {
  static create(e, s) {
    const i = new aw(e.toString(), s);
    return hb(i, s), i;
  }
  constructor(e, s) {
    super(e), (this.code = s);
  }
};
function Ds(t, e) {
  return Dl.create(t, e);
}
function Ti(t) {
  return t || Ds(w(1907, null), X.Unknown);
}
function hb(t, e) {
  return (t.name = e ? `${e} (FileSystemError)` : "FileSystemError"), t;
}
function Bo(t) {
  if (!t) return X.Unknown;
  if (t instanceof Dl) return t.code;
  const e = /^(.+) \(FileSystemError\)$/.exec(t.name);
  if (!e) return X.Unknown;
  switch (e[1]) {
    case X.FileExists:
      return X.FileExists;
    case X.FileIsADirectory:
      return X.FileIsADirectory;
    case X.FileNotADirectory:
      return X.FileNotADirectory;
    case X.FileNotFound:
      return X.FileNotFound;
    case X.FileTooLarge:
      return X.FileTooLarge;
    case X.FileWriteLocked:
      return X.FileWriteLocked;
    case X.NoPermissions:
      return X.NoPermissions;
    case X.Unavailable:
      return X.Unavailable;
  }
  return X.Unknown;
}
function ct(t) {
  if (t instanceof et) return t.fileOperationResult;
  switch (Bo(t)) {
    case X.FileNotFound:
      return 1;
    case X.FileIsADirectory:
      return 0;
    case X.FileNotADirectory:
      return 9;
    case X.FileWriteLocked:
      return 5;
    case X.NoPermissions:
      return 6;
    case X.FileExists:
      return 4;
    case X.FileTooLarge:
      return 7;
    default:
      return 10;
  }
}
var Y1;
(function (t) {
  (t[(t.CREATE = 0)] = "CREATE"), (t[(t.DELETE = 1)] = "DELETE"), (t[(t.MOVE = 2)] = "MOVE"), (t[(t.COPY = 3)] = "COPY"), (t[(t.WRITE = 4)] = "WRITE");
})(Y1 || (Y1 = {}));
var Dn = class {
    constructor(t, e, s) {
      (this.resource = t), (this.operation = e), (this.target = s);
    }
    isOperation(t) {
      return this.operation === t;
    }
  },
  Z1;
(function (t) {
  (t[(t.UPDATED = 0)] = "UPDATED"), (t[(t.ADDED = 1)] = "ADDED"), (t[(t.DELETED = 2)] = "DELETED");
})(Z1 || (Z1 = {}));
var ub = class fc {
  static {
    this.a = null;
  }
  constructor(e, s) {
    (this.c = s),
      (this.b = void 0),
      (this.d = new fn(() => {
        const i = Cn.forUris(() => this.c);
        return i.fill(this.rawAdded.map((n) => [n, !0])), i;
      })),
      (this.f = new fn(() => {
        const i = Cn.forUris(() => this.c);
        return i.fill(this.rawUpdated.map((n) => [n, !0])), i;
      })),
      (this.g = new fn(() => {
        const i = Cn.forUris(() => this.c);
        return i.fill(this.rawDeleted.map((n) => [n, !0])), i;
      })),
      (this.rawAdded = []),
      (this.rawUpdated = []),
      (this.rawDeleted = []);
    for (const i of e) {
      switch (i.type) {
        case 1:
          this.rawAdded.push(i.resource);
          break;
        case 0:
          this.rawUpdated.push(i.resource);
          break;
        case 2:
          this.rawDeleted.push(i.resource);
          break;
      }
      this.b !== fc.a && (typeof i.cId == "number" ? (this.b === void 0 ? (this.b = i.cId) : this.b !== i.cId && (this.b = fc.a)) : this.b !== void 0 && (this.b = fc.a));
    }
  }
  contains(e, ...s) {
    return this.h(e, { includeChildren: !1 }, ...s);
  }
  affects(e, ...s) {
    return this.h(e, { includeChildren: !0 }, ...s);
  }
  h(e, s, ...i) {
    if (!e) return !1;
    const n = i.length > 0;
    return !!(
      ((!n || i.includes(1)) && (this.d.value.get(e) || (s.includeChildren && this.d.value.findSuperstr(e)))) ||
      ((!n || i.includes(0)) && (this.f.value.get(e) || (s.includeChildren && this.f.value.findSuperstr(e)))) ||
      ((!n || i.includes(2)) && (this.g.value.findSubstr(e) || (s.includeChildren && this.g.value.findSuperstr(e))))
    );
  }
  gotAdded() {
    return this.rawAdded.length > 0;
  }
  gotDeleted() {
    return this.rawDeleted.length > 0;
  }
  gotUpdated() {
    return this.rawUpdated.length > 0;
  }
  correlates(e) {
    return this.b === e;
  }
  hasCorrelation() {
    return typeof this.b == "number";
  }
};
function fb(t, e, s) {
  return !t || !e || t === e || e.length > t.length ? !1 : (e.charAt(e.length - 1) !== Vt && (e += Vt), s ? kd(t, e) : t.indexOf(e) === 0);
}
var et = class extends Error {
    constructor(t, e, s) {
      super(t), (this.fileOperationResult = e), (this.options = s);
    }
  },
  Il = class extends et {
    constructor(t, e, s, i) {
      super(t, e, i), (this.fileOperationResult = e), (this.size = s);
    }
  },
  Rl = class extends et {
    constructor(t, e, s) {
      super(t, 2, s), (this.stat = e);
    }
  },
  ep;
(function (t) {
  (t[(t.FILE_IS_DIRECTORY = 0)] = "FILE_IS_DIRECTORY"),
    (t[(t.FILE_NOT_FOUND = 1)] = "FILE_NOT_FOUND"),
    (t[(t.FILE_NOT_MODIFIED_SINCE = 2)] = "FILE_NOT_MODIFIED_SINCE"),
    (t[(t.FILE_MODIFIED_SINCE = 3)] = "FILE_MODIFIED_SINCE"),
    (t[(t.FILE_MOVE_CONFLICT = 4)] = "FILE_MOVE_CONFLICT"),
    (t[(t.FILE_WRITE_LOCKED = 5)] = "FILE_WRITE_LOCKED"),
    (t[(t.FILE_PERMISSION_DENIED = 6)] = "FILE_PERMISSION_DENIED"),
    (t[(t.FILE_TOO_LARGE = 7)] = "FILE_TOO_LARGE"),
    (t[(t.FILE_INVALID_PATH = 8)] = "FILE_INVALID_PATH"),
    (t[(t.FILE_NOT_DIRECTORY = 9)] = "FILE_NOT_DIRECTORY"),
    (t[(t.FILE_OTHER_ERROR = 10)] = "FILE_OTHER_ERROR");
})(ep || (ep = {}));
var tp;
(function (t) {
  (t[(t.FILE = 0)] = "FILE"), (t[(t.FOLDER = 1)] = "FOLDER"), (t[(t.ROOT_FOLDER = 2)] = "ROOT_FOLDER");
})(tp || (tp = {}));
var Pl = "";
function sp(t) {
  if (!(typeof t.size != "number" || typeof t.mtime != "number")) return t.mtime.toString(29) + t.size.toString(31);
}
var wr = class Ft {
    static {
      this.KB = 1024;
    }
    static {
      this.MB = Ft.KB * Ft.KB;
    }
    static {
      this.GB = Ft.MB * Ft.KB;
    }
    static {
      this.TB = Ft.GB * Ft.KB;
    }
    static formatSize(e) {
      return (
        Sc(e) || (e = 0),
        e < Ft.KB
          ? w(1908, null, e.toFixed(0))
          : e < Ft.MB
            ? w(1909, null, (e / Ft.KB).toFixed(2))
            : e < Ft.GB
              ? w(1910, null, (e / Ft.MB).toFixed(2))
              : e < Ft.TB
                ? w(1911, null, (e / Ft.GB).toFixed(2))
                : w(1912, null, (e / Ft.TB).toFixed(2))
      );
    }
  },
  Al = class {
    constructor(e) {
      this.a = e;
    }
    async checksum(e) {
      const s = (await this.a.readFileStream(e)).value;
      return new Promise((i, n) => {
        const r = cb("sha256");
        Ao(s, { onData: (o) => r.update(o.buffer), onError: (o) => n(o), onEnd: () => i(r.digest("base64").replace(/=+$/, "")) });
      });
    }
  };
Al = __decorate([__param(0, ie)], Al);
var Ce = z("configurationService");
function Ol(t) {
  return t && typeof t == "object" && (!t.overrideIdentifier || typeof t.overrideIdentifier == "string") && (!t.resource || t.resource instanceof C);
}
function db(t) {
  return t && typeof t == "object" && (!t.overrideIdentifiers || Array.isArray(t.overrideIdentifiers)) && !t.overrideIdentifier && (!t.resource || t.resource instanceof C);
}
var ip;
(function (t) {
  (t[(t.APPLICATION = 1)] = "APPLICATION"),
    (t[(t.USER = 2)] = "USER"),
    (t[(t.USER_LOCAL = 3)] = "USER_LOCAL"),
    (t[(t.USER_REMOTE = 4)] = "USER_REMOTE"),
    (t[(t.WORKSPACE = 5)] = "WORKSPACE"),
    (t[(t.WORKSPACE_FOLDER = 6)] = "WORKSPACE_FOLDER"),
    (t[(t.DEFAULT = 7)] = "DEFAULT"),
    (t[(t.MEMORY = 8)] = "MEMORY");
})(ip || (ip = {}));
function Ll(t, e) {
  const s = Object.create(null);
  for (const i in t) np(s, i, t[i], e);
  return s;
}
function np(t, e, s, i) {
  const n = e.split("."),
    r = n.pop();
  let o = t;
  for (let a = 0; a < n.length; a++) {
    const c = n[a];
    let l = o[c];
    switch (typeof l) {
      case "undefined":
        l = o[c] = Object.create(null);
        break;
      case "object":
        if (l === null) {
          i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(l)}`);
        return;
    }
    o = l;
  }
  if (typeof o == "object" && o !== null)
    try {
      o[r] = s;
    } catch {
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(o)}`);
    }
  else i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(o)}`);
}
function pb(t, e) {
  const s = e.split(".");
  rp(t, s);
}
function rp(t, e) {
  const s = e.shift();
  if (e.length === 0) {
    delete t[s];
    return;
  }
  if (Object.keys(t).indexOf(s) !== -1) {
    const i = t[s];
    typeof i == "object" && !Array.isArray(i) && (rp(i, e), Object.keys(i).length === 0 && delete t[s]);
  }
}
function zo(t, e, s) {
  function i(o, a) {
    let c = o;
    for (const l of a) {
      if (typeof c != "object" || c === null) return;
      c = c[l];
    }
    return c;
  }
  const n = e.split("."),
    r = i(t, n);
  return typeof r > "u" ? s : r;
}
function gb(t) {
  return t.replace(/[\[\]]/g, "");
}
var op;
(function (t) {
  (t[(t.None = 0)] = "None"),
    (t[(t.UnexpectedEndOfComment = 1)] = "UnexpectedEndOfComment"),
    (t[(t.UnexpectedEndOfString = 2)] = "UnexpectedEndOfString"),
    (t[(t.UnexpectedEndOfNumber = 3)] = "UnexpectedEndOfNumber"),
    (t[(t.InvalidUnicode = 4)] = "InvalidUnicode"),
    (t[(t.InvalidEscapeCharacter = 5)] = "InvalidEscapeCharacter"),
    (t[(t.InvalidCharacter = 6)] = "InvalidCharacter");
})(op || (op = {}));
var ap;
(function (t) {
  (t[(t.OpenBraceToken = 1)] = "OpenBraceToken"),
    (t[(t.CloseBraceToken = 2)] = "CloseBraceToken"),
    (t[(t.OpenBracketToken = 3)] = "OpenBracketToken"),
    (t[(t.CloseBracketToken = 4)] = "CloseBracketToken"),
    (t[(t.CommaToken = 5)] = "CommaToken"),
    (t[(t.ColonToken = 6)] = "ColonToken"),
    (t[(t.NullKeyword = 7)] = "NullKeyword"),
    (t[(t.TrueKeyword = 8)] = "TrueKeyword"),
    (t[(t.FalseKeyword = 9)] = "FalseKeyword"),
    (t[(t.StringLiteral = 10)] = "StringLiteral"),
    (t[(t.NumericLiteral = 11)] = "NumericLiteral"),
    (t[(t.LineCommentTrivia = 12)] = "LineCommentTrivia"),
    (t[(t.BlockCommentTrivia = 13)] = "BlockCommentTrivia"),
    (t[(t.LineBreakTrivia = 14)] = "LineBreakTrivia"),
    (t[(t.Trivia = 15)] = "Trivia"),
    (t[(t.Unknown = 16)] = "Unknown"),
    (t[(t.EOF = 17)] = "EOF");
})(ap || (ap = {}));
var cp;
(function (t) {
  (t[(t.InvalidSymbol = 1)] = "InvalidSymbol"),
    (t[(t.InvalidNumberFormat = 2)] = "InvalidNumberFormat"),
    (t[(t.PropertyNameExpected = 3)] = "PropertyNameExpected"),
    (t[(t.ValueExpected = 4)] = "ValueExpected"),
    (t[(t.ColonExpected = 5)] = "ColonExpected"),
    (t[(t.CommaExpected = 6)] = "CommaExpected"),
    (t[(t.CloseBraceExpected = 7)] = "CloseBraceExpected"),
    (t[(t.CloseBracketExpected = 8)] = "CloseBracketExpected"),
    (t[(t.EndOfFileExpected = 9)] = "EndOfFileExpected"),
    (t[(t.InvalidCommentToken = 10)] = "InvalidCommentToken"),
    (t[(t.UnexpectedEndOfComment = 11)] = "UnexpectedEndOfComment"),
    (t[(t.UnexpectedEndOfString = 12)] = "UnexpectedEndOfString"),
    (t[(t.UnexpectedEndOfNumber = 13)] = "UnexpectedEndOfNumber"),
    (t[(t.InvalidUnicode = 14)] = "InvalidUnicode"),
    (t[(t.InvalidEscapeCharacter = 15)] = "InvalidEscapeCharacter"),
    (t[(t.InvalidCharacter = 16)] = "InvalidCharacter");
})(cp || (cp = {}));
var vr;
(function (t) {
  t.DEFAULT = { allowTrailingComma: !0 };
})(vr || (vr = {}));
function lp(t, e = !1) {
  let s = 0;
  const i = t.length;
  let n = "",
    r = 0,
    o = 16,
    a = 0;
  function c(g) {
    let m = 0,
      v = 0;
    for (; m < g; ) {
      const b = t.charCodeAt(s);
      if (b >= 48 && b <= 57) v = v * 16 + b - 48;
      else if (b >= 65 && b <= 70) v = v * 16 + b - 65 + 10;
      else if (b >= 97 && b <= 102) v = v * 16 + b - 97 + 10;
      else break;
      s++, m++;
    }
    return m < g && (v = -1), v;
  }
  function l(g) {
    (s = g), (n = ""), (r = 0), (o = 16), (a = 0);
  }
  function h() {
    const g = s;
    if (t.charCodeAt(s) === 48) s++;
    else for (s++; s < t.length && In(t.charCodeAt(s)); ) s++;
    if (s < t.length && t.charCodeAt(s) === 46)
      if ((s++, s < t.length && In(t.charCodeAt(s)))) for (s++; s < t.length && In(t.charCodeAt(s)); ) s++;
      else return (a = 3), t.substring(g, s);
    let m = s;
    if (s < t.length && (t.charCodeAt(s) === 69 || t.charCodeAt(s) === 101))
      if ((s++, ((s < t.length && t.charCodeAt(s) === 43) || t.charCodeAt(s) === 45) && s++, s < t.length && In(t.charCodeAt(s)))) {
        for (s++; s < t.length && In(t.charCodeAt(s)); ) s++;
        m = s;
      } else a = 3;
    return t.substring(g, m);
  }
  function u() {
    let g = "",
      m = s;
    for (;;) {
      if (s >= i) {
        (g += t.substring(m, s)), (a = 2);
        break;
      }
      const v = t.charCodeAt(s);
      if (v === 34) {
        (g += t.substring(m, s)), s++;
        break;
      }
      if (v === 92) {
        if (((g += t.substring(m, s)), s++, s >= i)) {
          a = 2;
          break;
        }
        switch (t.charCodeAt(s++)) {
          case 34:
            g += '"';
            break;
          case 92:
            g += "\\";
            break;
          case 47:
            g += "/";
            break;
          case 98:
            g += "\b";
            break;
          case 102:
            g += "\f";
            break;
          case 110:
            g += `
`;
            break;
          case 114:
            g += "\r";
            break;
          case 116:
            g += "	";
            break;
          case 117: {
            const E = c(4);
            E >= 0 ? (g += String.fromCharCode(E)) : (a = 4);
            break;
          }
          default:
            a = 5;
        }
        m = s;
        continue;
      }
      if (v >= 0 && v <= 31)
        if (qo(v)) {
          (g += t.substring(m, s)), (a = 2);
          break;
        } else a = 6;
      s++;
    }
    return g;
  }
  function f() {
    if (((n = ""), (a = 0), (r = s), s >= i)) return (r = i), (o = 17);
    let g = t.charCodeAt(s);
    if (Nl(g)) {
      do s++, (n += String.fromCharCode(g)), (g = t.charCodeAt(s));
      while (Nl(g));
      return (o = 15);
    }
    if (qo(g))
      return (
        s++,
        (n += String.fromCharCode(g)),
        g === 13 &&
          t.charCodeAt(s) === 10 &&
          (s++,
          (n += `
`)),
        (o = 14)
      );
    switch (g) {
      case 123:
        return s++, (o = 1);
      case 125:
        return s++, (o = 2);
      case 91:
        return s++, (o = 3);
      case 93:
        return s++, (o = 4);
      case 58:
        return s++, (o = 6);
      case 44:
        return s++, (o = 5);
      case 34:
        return s++, (n = u()), (o = 10);
      case 47: {
        const m = s - 1;
        if (t.charCodeAt(s + 1) === 47) {
          for (s += 2; s < i && !qo(t.charCodeAt(s)); ) s++;
          return (n = t.substring(m, s)), (o = 12);
        }
        if (t.charCodeAt(s + 1) === 42) {
          s += 2;
          const v = i - 1;
          let b = !1;
          for (; s < v; ) {
            if (t.charCodeAt(s) === 42 && t.charCodeAt(s + 1) === 47) {
              (s += 2), (b = !0);
              break;
            }
            s++;
          }
          return b || (s++, (a = 1)), (n = t.substring(m, s)), (o = 13);
        }
        return (n += String.fromCharCode(g)), s++, (o = 16);
      }
      case 45:
        if (((n += String.fromCharCode(g)), s++, s === i || !In(t.charCodeAt(s)))) return (o = 16);
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return (n += h()), (o = 11);
      default:
        for (; s < i && d(g); ) s++, (g = t.charCodeAt(s));
        if (r !== s) {
          switch (((n = t.substring(r, s)), n)) {
            case "true":
              return (o = 8);
            case "false":
              return (o = 9);
            case "null":
              return (o = 7);
          }
          return (o = 16);
        }
        return (n += String.fromCharCode(g)), s++, (o = 16);
    }
  }
  function d(g) {
    if (Nl(g) || qo(g)) return !1;
    switch (g) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return !1;
    }
    return !0;
  }
  function p() {
    let g;
    do g = f();
    while (g >= 12 && g <= 15);
    return g;
  }
  return { setPosition: l, getPosition: () => s, scan: e ? p : f, getToken: () => o, getTokenValue: () => n, getTokenOffset: () => r, getTokenLength: () => s - r, getTokenError: () => a };
}
function Nl(t) {
  return t === 32 || t === 9 || t === 11 || t === 12 || t === 160 || t === 5760 || (t >= 8192 && t <= 8203) || t === 8239 || t === 8287 || t === 12288 || t === 65279;
}
function qo(t) {
  return t === 10 || t === 13 || t === 8232 || t === 8233;
}
function In(t) {
  return t >= 48 && t <= 57;
}
var hp;
(function (t) {
  (t[(t.nullCharacter = 0)] = "nullCharacter"),
    (t[(t.maxAsciiCharacter = 127)] = "maxAsciiCharacter"),
    (t[(t.lineFeed = 10)] = "lineFeed"),
    (t[(t.carriageReturn = 13)] = "carriageReturn"),
    (t[(t.lineSeparator = 8232)] = "lineSeparator"),
    (t[(t.paragraphSeparator = 8233)] = "paragraphSeparator"),
    (t[(t.nextLine = 133)] = "nextLine"),
    (t[(t.space = 32)] = "space"),
    (t[(t.nonBreakingSpace = 160)] = "nonBreakingSpace"),
    (t[(t.enQuad = 8192)] = "enQuad"),
    (t[(t.emQuad = 8193)] = "emQuad"),
    (t[(t.enSpace = 8194)] = "enSpace"),
    (t[(t.emSpace = 8195)] = "emSpace"),
    (t[(t.threePerEmSpace = 8196)] = "threePerEmSpace"),
    (t[(t.fourPerEmSpace = 8197)] = "fourPerEmSpace"),
    (t[(t.sixPerEmSpace = 8198)] = "sixPerEmSpace"),
    (t[(t.figureSpace = 8199)] = "figureSpace"),
    (t[(t.punctuationSpace = 8200)] = "punctuationSpace"),
    (t[(t.thinSpace = 8201)] = "thinSpace"),
    (t[(t.hairSpace = 8202)] = "hairSpace"),
    (t[(t.zeroWidthSpace = 8203)] = "zeroWidthSpace"),
    (t[(t.narrowNoBreakSpace = 8239)] = "narrowNoBreakSpace"),
    (t[(t.ideographicSpace = 12288)] = "ideographicSpace"),
    (t[(t.mathematicalSpace = 8287)] = "mathematicalSpace"),
    (t[(t.ogham = 5760)] = "ogham"),
    (t[(t._ = 95)] = "_"),
    (t[(t.$ = 36)] = "$"),
    (t[(t._0 = 48)] = "_0"),
    (t[(t._1 = 49)] = "_1"),
    (t[(t._2 = 50)] = "_2"),
    (t[(t._3 = 51)] = "_3"),
    (t[(t._4 = 52)] = "_4"),
    (t[(t._5 = 53)] = "_5"),
    (t[(t._6 = 54)] = "_6"),
    (t[(t._7 = 55)] = "_7"),
    (t[(t._8 = 56)] = "_8"),
    (t[(t._9 = 57)] = "_9"),
    (t[(t.a = 97)] = "a"),
    (t[(t.b = 98)] = "b"),
    (t[(t.c = 99)] = "c"),
    (t[(t.d = 100)] = "d"),
    (t[(t.e = 101)] = "e"),
    (t[(t.f = 102)] = "f"),
    (t[(t.g = 103)] = "g"),
    (t[(t.h = 104)] = "h"),
    (t[(t.i = 105)] = "i"),
    (t[(t.j = 106)] = "j"),
    (t[(t.k = 107)] = "k"),
    (t[(t.l = 108)] = "l"),
    (t[(t.m = 109)] = "m"),
    (t[(t.n = 110)] = "n"),
    (t[(t.o = 111)] = "o"),
    (t[(t.p = 112)] = "p"),
    (t[(t.q = 113)] = "q"),
    (t[(t.r = 114)] = "r"),
    (t[(t.s = 115)] = "s"),
    (t[(t.t = 116)] = "t"),
    (t[(t.u = 117)] = "u"),
    (t[(t.v = 118)] = "v"),
    (t[(t.w = 119)] = "w"),
    (t[(t.x = 120)] = "x"),
    (t[(t.y = 121)] = "y"),
    (t[(t.z = 122)] = "z"),
    (t[(t.A = 65)] = "A"),
    (t[(t.B = 66)] = "B"),
    (t[(t.C = 67)] = "C"),
    (t[(t.D = 68)] = "D"),
    (t[(t.E = 69)] = "E"),
    (t[(t.F = 70)] = "F"),
    (t[(t.G = 71)] = "G"),
    (t[(t.H = 72)] = "H"),
    (t[(t.I = 73)] = "I"),
    (t[(t.J = 74)] = "J"),
    (t[(t.K = 75)] = "K"),
    (t[(t.L = 76)] = "L"),
    (t[(t.M = 77)] = "M"),
    (t[(t.N = 78)] = "N"),
    (t[(t.O = 79)] = "O"),
    (t[(t.P = 80)] = "P"),
    (t[(t.Q = 81)] = "Q"),
    (t[(t.R = 82)] = "R"),
    (t[(t.S = 83)] = "S"),
    (t[(t.T = 84)] = "T"),
    (t[(t.U = 85)] = "U"),
    (t[(t.V = 86)] = "V"),
    (t[(t.W = 87)] = "W"),
    (t[(t.X = 88)] = "X"),
    (t[(t.Y = 89)] = "Y"),
    (t[(t.Z = 90)] = "Z"),
    (t[(t.ampersand = 38)] = "ampersand"),
    (t[(t.asterisk = 42)] = "asterisk"),
    (t[(t.at = 64)] = "at"),
    (t[(t.backslash = 92)] = "backslash"),
    (t[(t.bar = 124)] = "bar"),
    (t[(t.caret = 94)] = "caret"),
    (t[(t.closeBrace = 125)] = "closeBrace"),
    (t[(t.closeBracket = 93)] = "closeBracket"),
    (t[(t.closeParen = 41)] = "closeParen"),
    (t[(t.colon = 58)] = "colon"),
    (t[(t.comma = 44)] = "comma"),
    (t[(t.dot = 46)] = "dot"),
    (t[(t.doubleQuote = 34)] = "doubleQuote"),
    (t[(t.equals = 61)] = "equals"),
    (t[(t.exclamation = 33)] = "exclamation"),
    (t[(t.greaterThan = 62)] = "greaterThan"),
    (t[(t.lessThan = 60)] = "lessThan"),
    (t[(t.minus = 45)] = "minus"),
    (t[(t.openBrace = 123)] = "openBrace"),
    (t[(t.openBracket = 91)] = "openBracket"),
    (t[(t.openParen = 40)] = "openParen"),
    (t[(t.percent = 37)] = "percent"),
    (t[(t.plus = 43)] = "plus"),
    (t[(t.question = 63)] = "question"),
    (t[(t.semicolon = 59)] = "semicolon"),
    (t[(t.singleQuote = 39)] = "singleQuote"),
    (t[(t.slash = 47)] = "slash"),
    (t[(t.tilde = 126)] = "tilde"),
    (t[(t.backspace = 8)] = "backspace"),
    (t[(t.formFeed = 12)] = "formFeed"),
    (t[(t.byteOrderMark = 65279)] = "byteOrderMark"),
    (t[(t.tab = 9)] = "tab"),
    (t[(t.verticalTab = 11)] = "verticalTab");
})(hp || (hp = {}));
function it(t, e = [], s = vr.DEFAULT) {
  let i = null,
    n = [];
  const r = [];
  function o(c) {
    Array.isArray(n) ? n.push(c) : i !== null && (n[i] = c);
  }
  return (
    Vo(
      t,
      {
        onObjectBegin: () => {
          const c = {};
          o(c), r.push(n), (n = c), (i = null);
        },
        onObjectProperty: (c) => {
          i = c;
        },
        onObjectEnd: () => {
          n = r.pop();
        },
        onArrayBegin: () => {
          const c = [];
          o(c), r.push(n), (n = c), (i = null);
        },
        onArrayEnd: () => {
          n = r.pop();
        },
        onLiteralValue: o,
        onError: (c, l, h) => {
          e.push({ error: c, offset: l, length: h });
        },
      },
      s,
    ),
    n[0]
  );
}
function mb(t, e = [], s = vr.DEFAULT) {
  let i = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function n(c) {
    i.type === "property" && ((i.length = c - i.offset), (i = i.parent));
  }
  function r(c) {
    return i.children.push(c), c;
  }
  Vo(
    t,
    {
      onObjectBegin: (c) => {
        i = r({ type: "object", offset: c, length: -1, parent: i, children: [] });
      },
      onObjectProperty: (c, l, h) => {
        (i = r({ type: "property", offset: l, length: -1, parent: i, children: [] })), i.children.push({ type: "string", value: c, offset: l, length: h, parent: i });
      },
      onObjectEnd: (c, l) => {
        (i.length = c + l - i.offset), (i = i.parent), n(c + l);
      },
      onArrayBegin: (c, l) => {
        i = r({ type: "array", offset: c, length: -1, parent: i, children: [] });
      },
      onArrayEnd: (c, l) => {
        (i.length = c + l - i.offset), (i = i.parent), n(c + l);
      },
      onLiteralValue: (c, l, h) => {
        r({ type: Rn(c), offset: l, length: h, parent: i, value: c }), n(l + h);
      },
      onSeparator: (c, l, h) => {
        i.type === "property" && (c === ":" ? (i.colonOffset = l) : c === "," && n(l));
      },
      onError: (c, l, h) => {
        e.push({ error: c, offset: l, length: h });
      },
    },
    s,
  );
  const a = i.children[0];
  return a && delete a.parent, a;
}
function up(t, e) {
  if (!t) return;
  let s = t;
  for (const i of e)
    if (typeof i == "string") {
      if (s.type !== "object" || !Array.isArray(s.children)) return;
      let n = !1;
      for (const r of s.children)
        if (Array.isArray(r.children) && r.children[0].value === i) {
          (s = r.children[1]), (n = !0);
          break;
        }
      if (!n) return;
    } else {
      const n = i;
      if (s.type !== "array" || n < 0 || !Array.isArray(s.children) || n >= s.children.length) return;
      s = s.children[n];
    }
  return s;
}
function Vo(t, e, s = vr.DEFAULT) {
  const i = lp(t, !1);
  function n(I) {
    return I ? () => I(i.getTokenOffset(), i.getTokenLength()) : () => !0;
  }
  function r(I) {
    return I ? (H) => I(H, i.getTokenOffset(), i.getTokenLength()) : () => !0;
  }
  const o = n(e.onObjectBegin),
    a = r(e.onObjectProperty),
    c = n(e.onObjectEnd),
    l = n(e.onArrayBegin),
    h = n(e.onArrayEnd),
    u = r(e.onLiteralValue),
    f = r(e.onSeparator),
    d = n(e.onComment),
    p = r(e.onError),
    g = s && s.disallowComments,
    m = s && s.allowTrailingComma;
  function v() {
    for (;;) {
      const I = i.scan();
      switch (i.getTokenError()) {
        case 4:
          b(14);
          break;
        case 5:
          b(15);
          break;
        case 3:
          b(13);
          break;
        case 1:
          g || b(11);
          break;
        case 2:
          b(12);
          break;
        case 6:
          b(16);
          break;
      }
      switch (I) {
        case 12:
        case 13:
          g ? b(10) : d();
          break;
        case 16:
          b(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return I;
      }
    }
  }
  function b(I, H = [], B = []) {
    if ((p(I), H.length + B.length > 0)) {
      let j = i.getToken();
      for (; j !== 17; ) {
        if (H.indexOf(j) !== -1) {
          v();
          break;
        } else if (B.indexOf(j) !== -1) break;
        j = v();
      }
    }
  }
  function E(I) {
    const H = i.getTokenValue();
    return I ? u(H) : a(H), v(), !0;
  }
  function $() {
    switch (i.getToken()) {
      case 11: {
        let I = 0;
        try {
          (I = JSON.parse(i.getTokenValue())), typeof I != "number" && (b(2), (I = 0));
        } catch {
          b(2);
        }
        u(I);
        break;
      }
      case 7:
        u(null);
        break;
      case 8:
        u(!0);
        break;
      case 9:
        u(!1);
        break;
      default:
        return !1;
    }
    return v(), !0;
  }
  function P() {
    return i.getToken() !== 10 ? (b(3, [], [2, 5]), !1) : (E(!1), i.getToken() === 6 ? (f(":"), v(), k() || b(4, [], [2, 5])) : b(5, [], [2, 5]), !0);
  }
  function U() {
    o(), v();
    let I = !1;
    for (; i.getToken() !== 2 && i.getToken() !== 17; ) {
      if (i.getToken() === 5) {
        if ((I || b(4, [], []), f(","), v(), i.getToken() === 2 && m)) break;
      } else I && b(6, [], []);
      P() || b(4, [], [2, 5]), (I = !0);
    }
    return c(), i.getToken() !== 2 ? b(7, [2], []) : v(), !0;
  }
  function Q() {
    l(), v();
    let I = !1;
    for (; i.getToken() !== 4 && i.getToken() !== 17; ) {
      if (i.getToken() === 5) {
        if ((I || b(4, [], []), f(","), v(), i.getToken() === 4 && m)) break;
      } else I && b(6, [], []);
      k() || b(4, [], [4, 5]), (I = !0);
    }
    return h(), i.getToken() !== 4 ? b(8, [4], []) : v(), !0;
  }
  function k() {
    switch (i.getToken()) {
      case 3:
        return Q();
      case 1:
        return U();
      case 10:
        return E(!0);
      default:
        return $();
    }
  }
  return v(), i.getToken() === 17 ? (s.allowEmptyContent ? !0 : (b(4, [], []), !1)) : k() ? (i.getToken() !== 17 && b(9, [], []), !0) : (b(4, [], []), !1);
}
function Rn(t) {
  switch (typeof t) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (t) {
        if (Array.isArray(t)) return "array";
      } else return "null";
      return "object";
    }
    default:
      return "null";
  }
}
function wb(t, e, s) {
  let i, n, r, o, a;
  if (e) {
    for (o = e.offset, a = o + e.length, r = o; r > 0 && !Wo(t, r - 1); ) r--;
    let E = a;
    for (; E < t.length && !Wo(t, E); ) E++;
    (n = t.substring(r, E)), (i = vb(n, s));
  } else (n = t), (i = 0), (r = 0), (o = 0), (a = t.length);
  const c = fp(s, t);
  let l = !1,
    h = 0,
    u;
  s.insertSpaces ? (u = Tl(" ", s.tabSize || 4)) : (u = "	");
  const f = lp(n, !1);
  let d = !1;
  function p() {
    return c + Tl(u, i + h);
  }
  function g() {
    let E = f.scan();
    for (l = !1; E === 15 || E === 14; ) (l = l || E === 14), (E = f.scan());
    return (d = E === 16 || f.getTokenError() !== 0), E;
  }
  const m = [];
  function v(E, $, P) {
    !d && $ < a && P > o && t.substring($, P) !== E && m.push({ offset: $, length: P - $, content: E });
  }
  let b = g();
  if (b !== 17) {
    const E = f.getTokenOffset() + r,
      $ = Tl(u, i);
    v($, r, E);
  }
  for (; b !== 17; ) {
    let E = f.getTokenOffset() + f.getTokenLength() + r,
      $ = g(),
      P = "";
    for (; !l && ($ === 12 || $ === 13); ) {
      const Q = f.getTokenOffset() + r;
      v(" ", E, Q), (E = f.getTokenOffset() + f.getTokenLength() + r), (P = $ === 12 ? p() : ""), ($ = g());
    }
    if ($ === 2) b !== 1 && (h--, (P = p()));
    else if ($ === 4) b !== 3 && (h--, (P = p()));
    else {
      switch (b) {
        case 3:
        case 1:
          h++, (P = p());
          break;
        case 5:
        case 12:
          P = p();
          break;
        case 13:
          l ? (P = p()) : (P = " ");
          break;
        case 6:
          P = " ";
          break;
        case 10:
          if ($ === 6) {
            P = "";
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          $ === 12 || $ === 13 ? (P = " ") : $ !== 5 && $ !== 17 && (d = !0);
          break;
        case 16:
          d = !0;
          break;
      }
      l && ($ === 12 || $ === 13) && (P = p());
    }
    const U = f.getTokenOffset() + r;
    v(P, E, U), (b = $);
  }
  return m;
}
function yr(t, e) {
  const s = JSON.stringify(t, void 0, e.insertSpaces ? e.tabSize || 4 : "	");
  return e.eol !== void 0 ? s.replace(/\r\n|\r|\n/g, e.eol) : s;
}
function Tl(t, e) {
  let s = "";
  for (let i = 0; i < e; i++) s += t;
  return s;
}
function vb(t, e) {
  let s = 0,
    i = 0;
  const n = e.tabSize || 4;
  for (; s < t.length; ) {
    const r = t.charAt(s);
    if (r === " ") i++;
    else if (r === "	") i += n;
    else break;
    s++;
  }
  return Math.floor(i / n);
}
function fp(t, e) {
  for (let s = 0; s < e.length; s++) {
    const i = e.charAt(s);
    if (i === "\r")
      return s + 1 < e.length &&
        e.charAt(s + 1) ===
          `
`
        ? `\r
`
        : "\r";
    if (
      i ===
      `
`
    )
      return `
`;
  }
  return (
    (t && t.eol) ||
    `
`
  );
}
function Wo(t, e) {
  return (
    `\r
`.indexOf(t.charAt(e)) !== -1
  );
}
function jl(t, e, s, i, n) {
  const r = e.slice(),
    a = mb(t, []);
  let c, l;
  for (; r.length > 0 && ((l = r.pop()), (c = up(a, r)), c === void 0 && s !== void 0); ) typeof l == "string" ? (s = { [l]: s }) : (s = [s]);
  if (c)
    if (c.type === "object" && typeof l == "string" && Array.isArray(c.children)) {
      const h = up(c, [l]);
      if (h !== void 0)
        if (s === void 0) {
          if (!h.parent) throw new Error("Malformed AST");
          const u = c.children.indexOf(h.parent);
          let f,
            d = h.parent.offset + h.parent.length;
          if (u > 0) {
            const p = c.children[u - 1];
            f = p.offset + p.length;
          } else (f = c.offset + 1), c.children.length > 1 && (d = c.children[1].offset);
          return ji(t, { offset: f, length: d - f, content: "" }, i);
        } else return ji(t, { offset: h.offset, length: h.length, content: JSON.stringify(s) }, i);
      else {
        if (s === void 0) return [];
        const u = `${JSON.stringify(l)}: ${JSON.stringify(s)}`,
          f = n ? n(c.children.map((p) => p.children[0].value)) : c.children.length;
        let d;
        if (f > 0) {
          const p = c.children[f - 1];
          d = { offset: p.offset + p.length, length: 0, content: "," + u };
        } else c.children.length === 0 ? (d = { offset: c.offset + 1, length: 0, content: u }) : (d = { offset: c.offset + 1, length: 0, content: u + "," });
        return ji(t, d, i);
      }
    } else if (c.type === "array" && typeof l == "number" && Array.isArray(c.children))
      if (s !== void 0) {
        const h = `${JSON.stringify(s)}`;
        let u;
        if (c.children.length === 0 || l === 0) u = { offset: c.offset + 1, length: 0, content: c.children.length === 0 ? h : h + "," };
        else {
          const f = l === -1 || l > c.children.length ? c.children.length : l,
            d = c.children[f - 1];
          u = { offset: d.offset + d.length, length: 0, content: "," + h };
        }
        return ji(t, u, i);
      } else {
        const h = l,
          u = c.children[h];
        let f;
        if (c.children.length === 1) f = { offset: c.offset + 1, length: c.length - 2, content: "" };
        else if (c.children.length - 1 === h) {
          const d = c.children[h - 1],
            p = d.offset + d.length,
            g = c.offset + c.length;
          f = { offset: p, length: g - 2 - p, content: "" };
        } else f = { offset: u.offset, length: c.children[h + 1].offset - u.offset, content: "" };
        return ji(t, f, i);
      }
    else throw new Error(`Can not add ${typeof l != "number" ? "index" : "property"} to parent of type ${c.type}`);
  else return s === void 0 ? [] : ji(t, { offset: a ? a.offset : 0, length: a ? a.length : 0, content: JSON.stringify(s) }, i);
}
function ji(t, e, s) {
  let i = Fl(t, e),
    n = e.offset,
    r = e.offset + e.content.length;
  if (e.length === 0 || e.content.length === 0) {
    for (; n > 0 && !Wo(i, n - 1); ) n--;
    for (; r < i.length && !Wo(i, r); ) r++;
  }
  const o = wb(i, { offset: n, length: r - n }, s);
  for (let c = o.length - 1; c >= 0; c--) {
    const l = o[c];
    (i = Fl(i, l)), (n = Math.min(n, l.offset)), (r = Math.max(r, l.offset + l.length)), (r += l.content.length - l.length);
  }
  const a = t.length - (i.length - r) - n;
  return [{ offset: n, length: a, content: i.substring(n, r) }];
}
function Fl(t, e) {
  return t.substring(0, e.offset) + e.content + t.substring(e.offset + e.length);
}
function dp(t, e) {
  const s = e.slice(0).sort((n, r) => {
    const o = n.offset - r.offset;
    return o === 0 ? n.length - r.length : o;
  });
  let i = t.length;
  for (let n = s.length - 1; n >= 0; n--) {
    const r = s[n];
    if (r.offset + r.length <= i) t = Fl(t, r);
    else throw new Error("Overlapping edit");
    i = r.offset;
  }
  return t;
}
function rs(t) {
  if (!t || typeof t != "object" || t instanceof RegExp) return t;
  const e = Array.isArray(t) ? [] : {};
  return (
    Object.entries(t).forEach(([s, i]) => {
      e[s] = i && typeof i == "object" ? rs(i) : i;
    }),
    e
  );
}
function yb(t) {
  if (!t || typeof t != "object") return t;
  const e = [t];
  for (; e.length > 0; ) {
    const s = e.shift();
    Object.freeze(s);
    for (const i in s)
      if (pp.call(s, i)) {
        const n = s[i];
        typeof n == "object" && !Object.isFrozen(n) && !Tw(n) && e.push(n);
      }
  }
  return t;
}
var pp = Object.prototype.hasOwnProperty;
function gp(t, e) {
  return Ml(t, e, new Set());
}
function Ml(t, e, s) {
  if (mt(t)) return t;
  const i = e(t);
  if (typeof i < "u") return i;
  if (Array.isArray(t)) {
    const n = [];
    for (const r of t) n.push(Ml(r, e, s));
    return n;
  }
  if (Ke(t)) {
    if (s.has(t)) throw new Error("Cannot clone recursive data-structure");
    s.add(t);
    const n = {};
    for (const r in t) pp.call(t, r) && (n[r] = Ml(t[r], e, s));
    return s.delete(t), n;
  }
  return t;
}
function br(t, e, s = !0) {
  return Ke(t)
    ? (Ke(e) &&
        Object.keys(e).forEach((i) => {
          i in t ? s && (Ke(t[i]) && Ke(e[i]) ? br(t[i], e[i], s) : (t[i] = e[i])) : (t[i] = e[i]);
        }),
      t)
    : e;
}
function Rt(t, e) {
  if (t === e) return !0;
  if (t == null || e === null || e === void 0 || typeof t != typeof e || typeof t != "object" || Array.isArray(t) !== Array.isArray(e)) return !1;
  let s, i;
  if (Array.isArray(t)) {
    if (t.length !== e.length) return !1;
    for (s = 0; s < t.length; s++) if (!Rt(t[s], e[s])) return !1;
  } else {
    const n = [];
    for (i in t) n.push(i);
    n.sort();
    const r = [];
    for (i in e) r.push(i);
    if ((r.sort(), !Rt(n, r))) return !1;
    for (s = 0; s < n.length; s++) if (!Rt(t[n[s]], e[n[s]])) return !1;
  }
  return !0;
}
function mp(t) {
  const e = new Set();
  return JSON.stringify(t, (s, i) => {
    if (Ke(i) || Array.isArray(i)) {
      if (e.has(i)) return "[Circular]";
      e.add(i);
    }
    return typeof i == "bigint" ? `[BigInt ${i.toString()}]` : i;
  });
}
function bb(t) {
  let e = !1;
  const s = new Map(),
    i = new Map();
  if (
    (Eb(t, (h) => {
      if (t === h) return !0;
      const u = JSON.stringify(h);
      if (u.length < 30) return !0;
      const f = s.get(u);
      if (!f) {
        const d = { schemas: [h] };
        return s.set(u, d), i.set(h, d), !0;
      }
      return f.schemas.push(h), i.set(h, f), (e = !0), !1;
    }),
    s.clear(),
    !e)
  )
    return JSON.stringify(t);
  let r = "$defs";
  for (; t.hasOwnProperty(r); ) r += "_";
  const o = [];
  function a(h) {
    return JSON.stringify(h, (u, f) => {
      if (f !== h) {
        const d = i.get(f);
        if (d && d.schemas.length > 1) return d.id || ((d.id = `_${o.length}`), o.push(d.schemas[0])), { $ref: `#/${r}/${d.id}` };
      }
      return f;
    });
  }
  const c = a(t),
    l = [];
  for (let h = 0; h < o.length; h++) l.push(`"_${h}":${a(o[h])}`);
  return l.length ? `${c.substring(0, c.length - 1)},"${r}":{${l.join(",")}}}` : c;
}
function Pn(t) {
  return typeof t == "object" && t !== null;
}
function Eb(t, e) {
  if (!t || typeof t != "object") return;
  const s = (...c) => {
      for (const l of c) Pn(l) && o.push(l);
    },
    i = (...c) => {
      for (const l of c)
        if (Pn(l))
          for (const h in l) {
            const u = l[h];
            Pn(u) && o.push(u);
          }
    },
    n = (...c) => {
      for (const l of c) if (Array.isArray(l)) for (const h of l) Pn(h) && o.push(h);
    },
    r = (c) => {
      if (Array.isArray(c)) for (const l of c) Pn(l) && o.push(l);
      else Pn(c) && o.push(c);
    },
    o = [t];
  let a = o.pop();
  for (; a; )
    e(a) &&
      (s(a.additionalItems, a.additionalProperties, a.not, a.contains, a.propertyNames, a.if, a.then, a.else, a.unevaluatedItems, a.unevaluatedProperties),
      i(a.definitions, a.$defs, a.properties, a.patternProperties, a.dependencies, a.dependentSchemas),
      n(a.anyOf, a.allOf, a.oneOf, a.prefixItems),
      r(a.items)),
      (a = o.pop());
}
function Ul(t, e) {
  if (!t) throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
var Sb = class {
    constructor() {
      this.a = new Map();
    }
    add(t, e) {
      Ul(_e(t)), Ul(Ke(e)), Ul(!this.a.has(t), "There is already an extension with this id"), this.a.set(t, e);
    }
    knows(t) {
      return this.a.has(t);
    }
    as(t) {
      return this.a.get(t) || null;
    }
  },
  yt = new Sb(),
  _l = { JSONContribution: "base.contributions.json" };
function $b(t) {
  return t.length > 0 && t.charAt(t.length - 1) === "#" ? t.substring(0, t.length - 1) : t;
}
var xb = class {
    constructor() {
      (this.b = new D()), (this.onDidChangeSchema = this.b.event), (this.a = {});
    }
    registerSchema(t, e) {
      (this.a[$b(t)] = e), this.b.fire(t);
    }
    notifySchemaChanged(t) {
      this.b.fire(t);
    }
    getSchemaContributions() {
      return { schemas: this.a };
    }
    getSchemaContent(t) {
      const e = this.a[t];
      return e ? bb(e) : void 0;
    }
    hasSchemaContent(t) {
      return !!this.a[t];
    }
  },
  Cb = new xb();
yt.add(_l.JSONContribution, Cb);
var wp;
(function (t) {
  (t.Multiline = "multilineText"), (t.Singleline = "singlelineText");
})(wp || (wp = {}));
var Jt = { Configuration: "base.contributions.configuration" },
  vp;
(function (t) {
  (t[(t.APPLICATION = 1)] = "APPLICATION"),
    (t[(t.MACHINE = 2)] = "MACHINE"),
    (t[(t.WINDOW = 3)] = "WINDOW"),
    (t[(t.RESOURCE = 4)] = "RESOURCE"),
    (t[(t.LANGUAGE_OVERRIDABLE = 5)] = "LANGUAGE_OVERRIDABLE"),
    (t[(t.MACHINE_OVERRIDABLE = 6)] = "MACHINE_OVERRIDABLE");
})(vp || (vp = {}));
var Er = { properties: {}, patternProperties: {} },
  Ho = { properties: {}, patternProperties: {} },
  Go = { properties: {}, patternProperties: {} },
  Jo = { properties: {}, patternProperties: {} },
  Ko = { properties: {}, patternProperties: {} },
  Sr = { properties: {}, patternProperties: {} },
  Fi = "vscode://schemas/settings/resourceLanguage",
  Xo = yt.as(_l.JSONContribution),
  kb = class {
    constructor() {
      (this.a = []),
        (this.i = new Set()),
        (this.j = new D()),
        (this.onDidSchemaChange = this.j.event),
        (this.k = new D()),
        (this.onDidUpdateConfiguration = this.k.event),
        (this.b = new Map()),
        (this.c = { id: "defaultOverrides", title: w(1696, null), properties: {} }),
        (this.d = [this.c]),
        (this.h = { properties: {}, patternProperties: {}, additionalProperties: !0, allowTrailingCommas: !0, allowComments: !0 }),
        (this.e = {}),
        (this.f = new Map()),
        (this.g = {}),
        Xo.registerSchema(Fi, this.h),
        this.z();
    }
    registerConfiguration(t, e = !0) {
      this.registerConfigurations([t], e);
    }
    registerConfigurations(t, e = !0) {
      const s = new Set();
      this.r(t, e, s), Xo.registerSchema(Fi, this.h), this.j.fire(), this.k.fire({ properties: s });
    }
    deregisterConfigurations(t) {
      const e = new Set();
      this.s(t, e), Xo.registerSchema(Fi, this.h), this.j.fire(), this.k.fire({ properties: e });
    }
    updateConfigurations({ add: t, remove: e }) {
      const s = new Set();
      this.s(e, s), this.r(t, !1, s), Xo.registerSchema(Fi, this.h), this.j.fire(), this.k.fire({ properties: s });
    }
    registerDefaultConfigurations(t) {
      const e = new Set();
      this.l(t, e), this.j.fire(), this.k.fire({ properties: e, defaultsOverrides: !0 });
    }
    l(t, e) {
      this.a.push(...t);
      const s = [];
      for (const { overrides: i, source: n } of t)
        for (const r in i) {
          e.add(r);
          const o = this.b.get(r) ?? this.b.set(r, { configurationDefaultOverrides: [] }).get(r),
            a = i[r];
          if ((o.configurationDefaultOverrides.push({ value: a, source: n }), Ws.test(r))) {
            const c = this.o(r, a, n, o.configurationDefaultOverrideValue);
            if (!c) continue;
            (o.configurationDefaultOverrideValue = c), this.n(r, c, n), s.push(...$r(r));
          } else {
            const c = this.p(r, a, n, o.configurationDefaultOverrideValue);
            if (!c) continue;
            o.configurationDefaultOverrideValue = c;
            const l = this.e[r];
            l && (this.A(r, l), this.w(r, l));
          }
        }
      this.q(s);
    }
    deregisterDefaultConfigurations(t) {
      const e = new Set();
      this.m(t, e), this.j.fire(), this.k.fire({ properties: e, defaultsOverrides: !0 });
    }
    m(t, e) {
      for (const s of t) {
        const i = this.a.indexOf(s);
        i !== -1 && this.a.splice(i, 1);
      }
      for (const { overrides: s, source: i } of t)
        for (const n in s) {
          const r = this.b.get(n);
          if (!r) continue;
          const o = r.configurationDefaultOverrides.findIndex((a) => (i ? a.source?.id === i.id : a.value === s[n]));
          if (o !== -1) {
            if ((r.configurationDefaultOverrides.splice(o, 1), r.configurationDefaultOverrides.length === 0 && this.b.delete(n), Ws.test(n))) {
              let a;
              for (const c of r.configurationDefaultOverrides) a = this.o(n, c.value, c.source, a);
              a && !$c(a.value) ? ((r.configurationDefaultOverrideValue = a), this.n(n, a, i)) : (this.b.delete(n), delete this.e[n], delete this.c.properties[n]);
            } else {
              let a;
              for (const l of r.configurationDefaultOverrides) a = this.p(n, l.value, l.source, a);
              r.configurationDefaultOverrideValue = a;
              const c = this.e[n];
              c && (this.A(n, c), this.w(n, c));
            }
            e.add(n);
          }
        }
      this.y();
    }
    n(t, e, s) {
      const i = { type: "object", default: e.value, description: w(1697, null, gb(t)), $ref: Fi, defaultDefaultValue: e.value, source: s, defaultValueSource: s };
      (this.e[t] = i), (this.c.properties[t] = i);
    }
    o(t, e, s, i) {
      const n = i?.value || {},
        r = i?.source ?? new Map();
      if (!(r instanceof Map)) {
        console.error("objectConfigurationSources is not a Map");
        return;
      }
      for (const o of Object.keys(e)) {
        const a = e[o];
        if (Ke(a) && (Ct(n[o]) || Ke(n[o]))) {
          if (((n[o] = { ...(n[o] ?? {}), ...a }), s)) for (const l in a) r.set(`${o}.${l}`, s);
        } else (n[o] = a), s ? r.set(o, s) : r.delete(o);
      }
      return { value: n, source: r };
    }
    p(t, e, s, i) {
      const n = this.e[t],
        r = i?.value ?? n?.defaultDefaultValue;
      let o = s;
      if (Ke(e) && ((n !== void 0 && n.type === "object") || (n === void 0 && (Ct(r) || Ke(r))))) {
        if (((o = i?.source ?? new Map()), !(o instanceof Map))) {
          console.error("defaultValueSource is not a Map");
          return;
        }
        for (const c in e) s && o.set(`${t}.${c}`, s);
        e = { ...(Ke(r) ? r : {}), ...e };
      }
      return { value: e, source: o };
    }
    deltaConfiguration(t) {
      let e = !1;
      const s = new Set();
      t.removedDefaults && (this.m(t.removedDefaults, s), (e = !0)),
        t.addedDefaults && (this.l(t.addedDefaults, s), (e = !0)),
        t.removedConfigurations && this.s(t.removedConfigurations, s),
        t.addedConfigurations && this.r(t.addedConfigurations, !1, s),
        this.j.fire(),
        this.k.fire({ properties: s, defaultsOverrides: e });
    }
    notifyConfigurationSchemaUpdated(...t) {
      this.j.fire();
    }
    registerOverrideIdentifiers(t) {
      this.q(t), this.j.fire();
    }
    q(t) {
      for (const e of t) this.i.add(e);
      this.y();
    }
    r(t, e, s) {
      t.forEach((i) => {
        this.u(i, e, i.extensionInfo, i.restrictedProperties, void 0, s), this.d.push(i), this.v(i);
      });
    }
    s(t, e) {
      const s = (i) => {
        if (i.properties)
          for (const n in i.properties) {
            e.add(n);
            const r = this.e[n];
            r?.policy?.name && this.f.delete(r.policy.name), delete this.e[n], this.x(n, i.properties[n]);
          }
        i.allOf?.forEach((n) => s(n));
      };
      for (const i of t) {
        s(i);
        const n = this.d.indexOf(i);
        n !== -1 && this.d.splice(n, 1);
      }
    }
    u(t, e = !0, s, i, n = 3, r) {
      n = mt(t.scope) ? n : t.scope;
      const o = t.properties;
      if (o)
        for (const c in o) {
          const l = o[c];
          if (e && Rb(c, l)) {
            delete o[c];
            continue;
          }
          if (
            ((l.source = s),
            (l.defaultDefaultValue = o[c].default),
            this.A(c, l),
            Ws.test(c) ? (l.scope = void 0) : ((l.scope = mt(l.scope) ? n : l.scope), (l.restricted = mt(l.restricted) ? !!i?.includes(c) : l.restricted)),
            o[c].hasOwnProperty("included") && !o[c].included)
          ) {
            (this.g[c] = o[c]), delete o[c];
            continue;
          } else (this.e[c] = o[c]), o[c].policy?.name && this.f.set(o[c].policy.name, c);
          !o[c].deprecationMessage && o[c].markdownDeprecationMessage && (o[c].deprecationMessage = o[c].markdownDeprecationMessage), r.add(c);
        }
      const a = t.allOf;
      if (a) for (const c of a) this.u(c, e, s, i, n, r);
    }
    getConfigurations() {
      return this.d;
    }
    getConfigurationProperties() {
      return this.e;
    }
    getPolicyConfigurations() {
      return this.f;
    }
    getExcludedConfigurationProperties() {
      return this.g;
    }
    getRegisteredDefaultConfigurations() {
      return [...this.a];
    }
    getConfigurationDefaultsOverrides() {
      const t = new Map();
      for (const [e, s] of this.b) s.configurationDefaultOverrideValue && t.set(e, s.configurationDefaultOverrideValue);
      return t;
    }
    v(t) {
      const e = (s) => {
        const i = s.properties;
        if (i) for (const r in i) this.w(r, i[r]);
        s.allOf?.forEach(e);
      };
      e(t);
    }
    w(t, e) {
      switch (((Er.properties[t] = e), e.scope)) {
        case 1:
          Ho.properties[t] = e;
          break;
        case 2:
          Go.properties[t] = e;
          break;
        case 6:
          Jo.properties[t] = e;
          break;
        case 3:
          Ko.properties[t] = e;
          break;
        case 4:
          Sr.properties[t] = e;
          break;
        case 5:
          (Sr.properties[t] = e), (this.h.properties[t] = e);
          break;
      }
    }
    x(t, e) {
      switch ((delete Er.properties[t], e.scope)) {
        case 1:
          delete Ho.properties[t];
          break;
        case 2:
          delete Go.properties[t];
          break;
        case 6:
          delete Jo.properties[t];
          break;
        case 3:
          delete Ko.properties[t];
          break;
        case 4:
        case 5:
          delete Sr.properties[t], delete this.h.properties[t];
          break;
      }
    }
    y() {
      for (const t of this.i.values()) {
        const e = `[${t}]`,
          s = { type: "object", description: w(1698, null), errorMessage: w(1699, null), $ref: Fi };
        this.A(e, s), (Er.properties[e] = s), (Ho.properties[e] = s), (Go.properties[e] = s), (Jo.properties[e] = s), (Ko.properties[e] = s), (Sr.properties[e] = s);
      }
    }
    z() {
      const t = { type: "object", description: w(1700, null), errorMessage: w(1701, null), $ref: Fi };
      (Er.patternProperties[Mi] = t), (Ho.patternProperties[Mi] = t), (Go.patternProperties[Mi] = t), (Jo.patternProperties[Mi] = t), (Ko.patternProperties[Mi] = t), (Sr.patternProperties[Mi] = t), this.j.fire();
    }
    A(t, e) {
      const s = this.b.get(t)?.configurationDefaultOverrideValue;
      let i, n;
      s && (!e.disallowConfigurationDefault || !s.source) && ((i = s.value), (n = s.source)), Ct(i) && ((i = e.defaultDefaultValue), (n = void 0)), Ct(i) && (i = Ib(e.type)), (e.default = i), (e.defaultValueSource = n);
    }
  },
  yp = "\\[([^\\]]+)\\]",
  bp = new RegExp(yp, "g"),
  Mi = `^(${yp})+$`,
  Ws = new RegExp(Mi);
function $r(t) {
  const e = [];
  if (Ws.test(t)) {
    let s = bp.exec(t);
    for (; s?.length; ) {
      const i = s[1].trim();
      i && e.push(i), (s = bp.exec(t));
    }
  }
  return Bt(e);
}
function Db(t) {
  return t.reduce((e, s) => `${e}[${s}]`, "");
}
function Ib(t) {
  switch (Array.isArray(t) ? t[0] : t) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
var Qo = new kb();
yt.add(Jt.Configuration, Qo);
function Rb(t, e) {
  return t.trim()
    ? Ws.test(t)
      ? w(1703, null, t)
      : Qo.getConfigurationProperties()[t] !== void 0
        ? w(1704, null, t)
        : e.policy?.name && Qo.getPolicyConfigurations().get(e.policy?.name) !== void 0
          ? w(1705, null, t, e.policy?.name, Qo.getPolicyConfigurations().get(e.policy?.name))
          : null
    : w(1702, null);
}
function Ep(t) {
  const e = {};
  for (const s of t) {
    const i = s.properties;
    if (Ke(i)) for (const n in i) e[n] = i[n];
    s.allOf && Object.assign(e, Ep(s.allOf));
  }
  return e;
}
function Pb(t) {
  switch (t) {
    case "application":
      return 1;
    case "machine":
      return 2;
    case "resource":
      return 4;
    case "machine-overridable":
      return 6;
    case "language-overridable":
      return 5;
    default:
      return 3;
  }
}
function xr(t) {
  return Object.isFrozen(t) ? t : yb(t);
}
var tt = class Zi {
    static createEmptyModel(e) {
      return new Zi({}, [], [], void 0, e);
    }
    constructor(e, s, i, n, r) {
      (this.b = e), (this.c = s), (this.d = i), (this.raw = n), (this.f = r), (this.a = new Map());
    }
    get rawConfiguration() {
      if (!this.g)
        if (this.raw?.length) {
          const e = this.raw.map((s) => {
            if (s instanceof Zi) return s;
            const i = new Bl("", this.f);
            return i.parseRaw(s), i.configurationModel;
          });
          this.g = e.reduce((s, i) => (i === s ? i : s.merge(i)), e[0]);
        } else this.g = this;
      return this.g;
    }
    get contents() {
      return this.b;
    }
    get overrides() {
      return this.d;
    }
    get keys() {
      return this.c;
    }
    isEmpty() {
      return this.c.length === 0 && Object.keys(this.b).length === 0 && this.d.length === 0;
    }
    getValue(e) {
      return e ? zo(this.contents, e) : this.contents;
    }
    inspect(e, s) {
      const i = this;
      return {
        get value() {
          return xr(i.rawConfiguration.getValue(e));
        },
        get override() {
          return s ? xr(i.rawConfiguration.getOverrideValue(e, s)) : void 0;
        },
        get merged() {
          return xr(s ? i.rawConfiguration.override(s).getValue(e) : i.rawConfiguration.getValue(e));
        },
        get overrides() {
          const n = [];
          for (const { contents: r, identifiers: o, keys: a } of i.rawConfiguration.overrides) {
            const c = new Zi(r, a, [], void 0, i.f).getValue(e);
            c !== void 0 && n.push({ identifiers: o, value: c });
          }
          return n.length ? xr(n) : void 0;
        },
      };
    }
    getOverrideValue(e, s) {
      const i = this.j(s);
      return i ? (e ? zo(i, e) : i) : void 0;
    }
    getKeysForOverrideIdentifier(e) {
      const s = [];
      for (const i of this.overrides) i.identifiers.includes(e) && s.push(...i.keys);
      return Bt(s);
    }
    getAllOverrideIdentifiers() {
      const e = [];
      for (const s of this.overrides) e.push(...s.identifiers);
      return Bt(e);
    }
    override(e) {
      let s = this.a.get(e);
      return s || ((s = this.h(e)), this.a.set(e, s)), s;
    }
    merge(...e) {
      const s = rs(this.contents),
        i = rs(this.overrides),
        n = [...this.keys],
        r = this.raw?.length ? [...this.raw] : [this];
      for (const o of e)
        if ((r.push(...(o.raw?.length ? o.raw : [o])), !o.isEmpty())) {
          this.i(s, o.contents);
          for (const a of o.overrides) {
            const [c] = i.filter((l) => _t(l.identifiers, a.identifiers));
            c ? (this.i(c.contents, a.contents), c.keys.push(...a.keys), (c.keys = Bt(c.keys))) : i.push(rs(a));
          }
          for (const a of o.keys) n.indexOf(a) === -1 && n.push(a);
        }
      return new Zi(s, n, i, r.every((o) => o instanceof Zi) ? void 0 : r, this.f);
    }
    h(e) {
      const s = this.j(e);
      if (!s || typeof s != "object" || !Object.keys(s).length) return this;
      const i = {};
      for (const n of Bt([...Object.keys(this.contents), ...Object.keys(s)])) {
        let r = this.contents[n];
        const o = s[n];
        o && (typeof r == "object" && typeof o == "object" ? ((r = rs(r)), this.i(r, o)) : (r = o)), (i[n] = r);
      }
      return new Zi(i, this.keys, this.overrides, void 0, this.f);
    }
    i(e, s) {
      for (const i of Object.keys(s)) {
        if (i in e && Ke(e[i]) && Ke(s[i])) {
          this.i(e[i], s[i]);
          continue;
        }
        e[i] = rs(s[i]);
      }
    }
    j(e) {
      let s = null,
        i = null;
      const n = (r) => {
        r && (i ? this.i(i, r) : (i = rs(r)));
      };
      for (const r of this.overrides) r.identifiers.length === 1 && r.identifiers[0] === e ? (s = r.contents) : r.identifiers.includes(e) && n(r.contents);
      return n(s), i;
    }
    toJSON() {
      return { contents: this.contents, overrides: this.overrides, keys: this.keys };
    }
    addValue(e, s) {
      this.k(e, s, !0);
    }
    setValue(e, s) {
      this.k(e, s, !1);
    }
    removeValue(e) {
      const s = this.keys.indexOf(e);
      s !== -1 &&
        (this.keys.splice(s, 1),
        pb(this.contents, e),
        Ws.test(e) &&
          this.overrides.splice(
            this.overrides.findIndex((i) => _t(i.identifiers, $r(e))),
            1,
          ));
    }
    k(e, s, i) {
      if ((np(this.contents, e, s, (n) => this.f.error(n)), (i = i || this.keys.indexOf(e) === -1), i && this.keys.push(e), Ws.test(e))) {
        const n = $r(e),
          r = { identifiers: n, keys: Object.keys(this.contents[e]), contents: Ll(this.contents[e], (a) => this.f.error(a)) },
          o = this.overrides.findIndex((a) => _t(a.identifiers, n));
        o !== -1 ? (this.overrides[o] = r) : this.overrides.push(r);
      }
    }
  },
  Bl = class {
    constructor(t, e) {
      (this.f = t), (this.g = e), (this.a = null), (this.b = null), (this.c = []), (this.d = []);
    }
    get configurationModel() {
      return this.b || tt.createEmptyModel(this.g);
    }
    get restrictedConfigurations() {
      return this.c;
    }
    get errors() {
      return this.d;
    }
    parse(t, e) {
      if (!mt(t)) {
        const s = this.h(t);
        this.parseRaw(s, e);
      }
    }
    reparse(t) {
      this.a && this.parseRaw(this.a, t);
    }
    parseRaw(t, e) {
      this.a = t;
      const { contents: s, keys: i, overrides: n, restricted: r, hasExcludedProperties: o } = this.i(t, e);
      (this.b = new tt(s, i, n, o ? [t] : void 0, this.g)), (this.c = r || []);
    }
    h(t) {
      let e = {},
        s = null,
        i = [];
      const n = [],
        r = [];
      function o(c) {
        Array.isArray(i) ? i.push(c) : s !== null && (i[s] = c);
      }
      const a = {
        onObjectBegin: () => {
          const c = {};
          o(c), n.push(i), (i = c), (s = null);
        },
        onObjectProperty: (c) => {
          s = c;
        },
        onObjectEnd: () => {
          i = n.pop();
        },
        onArrayBegin: () => {
          const c = [];
          o(c), n.push(i), (i = c), (s = null);
        },
        onArrayEnd: () => {
          i = n.pop();
        },
        onLiteralValue: o,
        onError: (c, l, h) => {
          r.push({ error: c, offset: l, length: h });
        },
      };
      if (t)
        try {
          Vo(t, a), (e = i[0] || {});
        } catch (c) {
          this.g.error(`Error while parsing settings file ${this.f}: ${c}`), (this.d = [c]);
        }
      return e;
    }
    i(t, e) {
      const s = yt.as(Jt.Configuration).getConfigurationProperties(),
        i = this.j(t, s, !0, e);
      t = i.raw;
      const n = Ll(t, (a) => this.g.error(`Conflict in settings file ${this.f}: ${a}`)),
        r = Object.keys(t),
        o = this.l(t, (a) => this.g.error(`Conflict in settings file ${this.f}: ${a}`));
      return { contents: n, keys: r, overrides: o, restricted: i.restricted, hasExcludedProperties: i.hasExcludedProperties };
    }
    j(t, e, s, i) {
      let n = !1;
      if (!i?.scopes && !i?.skipRestricted && !i?.exclude?.length) return { raw: t, restricted: [], hasExcludedProperties: n };
      const r = {},
        o = [];
      for (const a in t)
        if (Ws.test(a) && s) {
          const c = this.j(t[a], e, !1, i);
          (r[a] = c.raw), (n = n || c.hasExcludedProperties), o.push(...c.restricted);
        } else {
          const c = e[a],
            l = c ? (typeof c.scope < "u" ? c.scope : 3) : void 0;
          c?.restricted && o.push(a), !i.exclude?.includes(a) && (i.include?.includes(a) || ((l === void 0 || i.scopes === void 0 || i.scopes.includes(l)) && !(i.skipRestricted && c?.restricted))) ? (r[a] = t[a]) : (n = !0);
        }
      return { raw: r, restricted: o, hasExcludedProperties: n };
    }
    l(t, e) {
      const s = [];
      for (const i of Object.keys(t))
        if (Ws.test(i)) {
          const n = {};
          for (const r in t[i]) n[r] = t[i][r];
          s.push({ identifiers: $r(i), keys: Object.keys(n), contents: Ll(n, e) });
        }
      return s;
    }
  },
  Ab = class extends O {
    constructor(t, e, s, i, n) {
      super(),
        (this.c = t),
        (this.f = e),
        (this.g = i),
        (this.h = n),
        (this.b = this.B(new D())),
        (this.onDidChange = this.b.event),
        (this.a = new Bl(this.c.toString(), n)),
        this.B(this.g.watch(s.dirname(this.c))),
        this.B(this.g.watch(this.c)),
        this.B(
          T.any(
            T.filter(this.g.onDidFilesChange, (r) => r.contains(this.c)),
            T.filter(this.g.onDidRunOperation, (r) => (r.isOperation(0) || r.isOperation(3) || r.isOperation(1) || r.isOperation(4)) && s.isEqual(r.resource, t)),
          )(() => this.b.fire()),
        );
    }
    async loadConfiguration() {
      try {
        const t = await this.g.readFile(this.c);
        return this.a.parse(t.value.toString() || "{}", this.f), this.a.configurationModel;
      } catch {
        return tt.createEmptyModel(this.h);
      }
    }
    reparse(t) {
      return t && (this.f = t), this.a.reparse(this.f), this.a.configurationModel;
    }
    getRestrictedSettings() {
      return this.a.restrictedConfigurations;
    }
  },
  Ob = class {
    constructor(t, e, s, i, n, r, o, a, c, l, h, u, f) {
      (this.a = t), (this.b = e), (this.c = s), (this.overrideIdentifiers = i), (this.d = n), (this.f = r), (this.g = o), (this.h = a), (this.i = c), (this.j = l), (this.k = h), (this.l = u), (this.m = f);
    }
    get value() {
      return xr(this.c);
    }
    n(t) {
      return t?.value !== void 0 || t?.override !== void 0 || t?.overrides !== void 0 ? t : void 0;
    }
    get q() {
      return this.p || (this.p = this.d.inspect(this.a, this.b.overrideIdentifier)), this.p;
    }
    get defaultValue() {
      return this.q.merged;
    }
    get default() {
      return this.n(this.q);
    }
    get s() {
      return this.r === void 0 && (this.r = this.f ? this.f.inspect(this.a) : null), this.r;
    }
    get policyValue() {
      return this.s?.merged;
    }
    get policy() {
      return this.s?.value !== void 0 ? { value: this.s.value } : void 0;
    }
    get u() {
      return this.t === void 0 && (this.t = this.g ? this.g.inspect(this.a) : null), this.t;
    }
    get applicationValue() {
      return this.u?.merged;
    }
    get application() {
      return this.n(this.u);
    }
    get w() {
      return this.v || (this.v = this.h.inspect(this.a, this.b.overrideIdentifier)), this.v;
    }
    get userValue() {
      return this.w.merged;
    }
    get user() {
      return this.n(this.w);
    }
    get y() {
      return this.x || (this.x = this.i.inspect(this.a, this.b.overrideIdentifier)), this.x;
    }
    get userLocalValue() {
      return this.y.merged;
    }
    get userLocal() {
      return this.n(this.y);
    }
    get A() {
      return this.z || (this.z = this.j.inspect(this.a, this.b.overrideIdentifier)), this.z;
    }
    get userRemoteValue() {
      return this.A.merged;
    }
    get userRemote() {
      return this.n(this.A);
    }
    get D() {
      return this.B === void 0 && (this.B = this.k ? this.k.inspect(this.a, this.b.overrideIdentifier) : null), this.B;
    }
    get workspaceValue() {
      return this.D?.merged;
    }
    get workspace() {
      return this.n(this.D);
    }
    get F() {
      return this.E === void 0 && (this.E = this.l ? this.l.inspect(this.a, this.b.overrideIdentifier) : null), this.E;
    }
    get workspaceFolderValue() {
      return this.F?.merged;
    }
    get workspaceFolder() {
      return this.n(this.F);
    }
    get H() {
      return this.G === void 0 && (this.G = this.m.inspect(this.a, this.b.overrideIdentifier)), this.G;
    }
    get memoryValue() {
      return this.H.merged;
    }
    get memory() {
      return this.n(this.H);
    }
  },
  zl = class cw {
    constructor(e, s, i, n, r, o, a, c, l, h) {
      (this.j = e), (this.l = s), (this.m = i), (this.n = n), (this.p = r), (this.q = o), (this.r = a), (this.s = c), (this.t = l), (this.u = h), (this.h = null), (this.i = new kt()), (this.v = null);
    }
    getValue(e, s, i) {
      return this.w(e, s, i).getValue(e);
    }
    updateValue(e, s, i = {}) {
      let n;
      i.resource ? ((n = this.t.get(i.resource)), n || ((n = tt.createEmptyModel(this.u)), this.t.set(i.resource, n))) : (n = this.s), s === void 0 ? n.removeValue(e) : n.setValue(e, s), i.resource || (this.h = null);
    }
    inspect(e, s, i) {
      const n = this.w(e, s, i),
        r = this.A(s.resource, i),
        o = s.resource ? this.t.get(s.resource) || this.s : this.s,
        a = new Set();
      for (const c of n.overrides) for (const l of c.identifiers) n.getOverrideValue(e, l) !== void 0 && a.add(l);
      return new Ob(
        e,
        s,
        n.getValue(e),
        a.size ? [...a] : void 0,
        this.j,
        this.l.isEmpty() ? void 0 : this.l,
        this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration,
        this.userConfiguration,
        this.localUserConfiguration,
        this.remoteUserConfiguration,
        i ? this.q : void 0,
        r || void 0,
        o,
      );
    }
    keys(e) {
      const s = this.A(void 0, e);
      return { default: this.j.keys.slice(0), user: this.userConfiguration.keys.slice(0), workspace: this.q.keys.slice(0), workspaceFolder: s ? s.keys.slice(0) : [] };
    }
    updateDefaultConfiguration(e) {
      (this.j = e), (this.h = null), this.i.clear();
    }
    updatePolicyConfiguration(e) {
      this.l = e;
    }
    updateApplicationConfiguration(e) {
      (this.m = e), (this.h = null), this.i.clear();
    }
    updateLocalUserConfiguration(e) {
      (this.n = e), (this.v = null), (this.h = null), this.i.clear();
    }
    updateRemoteUserConfiguration(e) {
      (this.p = e), (this.v = null), (this.h = null), this.i.clear();
    }
    updateWorkspaceConfiguration(e) {
      (this.q = e), (this.h = null), this.i.clear();
    }
    updateFolderConfiguration(e, s) {
      this.r.set(e, s), this.i.delete(e);
    }
    deleteFolderConfiguration(e) {
      this.folderConfigurations.delete(e), this.i.delete(e);
    }
    compareAndUpdateDefaultConfiguration(e, s) {
      const i = [];
      if (!s) {
        const { added: n, updated: r, removed: o } = ri(this.j, e);
        s = [...n, ...r, ...o];
      }
      for (const n of s)
        for (const r of $r(n)) {
          const o = this.j.getKeysForOverrideIdentifier(r),
            a = e.getKeysForOverrideIdentifier(r),
            c = [...a.filter((l) => o.indexOf(l) === -1), ...o.filter((l) => a.indexOf(l) === -1), ...o.filter((l) => !Rt(this.j.override(r).getValue(l), e.override(r).getValue(l)))];
          i.push([r, c]);
        }
      return this.updateDefaultConfiguration(e), { keys: s, overrides: i };
    }
    compareAndUpdatePolicyConfiguration(e) {
      const { added: s, updated: i, removed: n } = ri(this.l, e),
        r = [...s, ...i, ...n];
      return r.length && this.updatePolicyConfiguration(e), { keys: r, overrides: [] };
    }
    compareAndUpdateApplicationConfiguration(e) {
      const { added: s, updated: i, removed: n, overrides: r } = ri(this.applicationConfiguration, e),
        o = [...s, ...i, ...n];
      return o.length && this.updateApplicationConfiguration(e), { keys: o, overrides: r };
    }
    compareAndUpdateLocalUserConfiguration(e) {
      const { added: s, updated: i, removed: n, overrides: r } = ri(this.localUserConfiguration, e),
        o = [...s, ...i, ...n];
      return o.length && this.updateLocalUserConfiguration(e), { keys: o, overrides: r };
    }
    compareAndUpdateRemoteUserConfiguration(e) {
      const { added: s, updated: i, removed: n, overrides: r } = ri(this.remoteUserConfiguration, e),
        o = [...s, ...i, ...n];
      return o.length && this.updateRemoteUserConfiguration(e), { keys: o, overrides: r };
    }
    compareAndUpdateWorkspaceConfiguration(e) {
      const { added: s, updated: i, removed: n, overrides: r } = ri(this.workspaceConfiguration, e),
        o = [...s, ...i, ...n];
      return o.length && this.updateWorkspaceConfiguration(e), { keys: o, overrides: r };
    }
    compareAndUpdateFolderConfiguration(e, s) {
      const i = this.folderConfigurations.get(e),
        { added: n, updated: r, removed: o, overrides: a } = ri(i, s),
        c = [...n, ...r, ...o];
      return (c.length || !i) && this.updateFolderConfiguration(e, s), { keys: c, overrides: a };
    }
    compareAndDeleteFolderConfiguration(e) {
      const s = this.folderConfigurations.get(e);
      if (!s) throw new Error("Unknown folder");
      this.deleteFolderConfiguration(e);
      const { added: i, updated: n, removed: r, overrides: o } = ri(s, void 0);
      return { keys: [...i, ...n, ...r], overrides: o };
    }
    get defaults() {
      return this.j;
    }
    get applicationConfiguration() {
      return this.m;
    }
    get userConfiguration() {
      return this.v || (this.v = this.p.isEmpty() ? this.n : this.n.merge(this.p)), this.v;
    }
    get localUserConfiguration() {
      return this.n;
    }
    get remoteUserConfiguration() {
      return this.p;
    }
    get workspaceConfiguration() {
      return this.q;
    }
    get folderConfigurations() {
      return this.r;
    }
    w(e, s, i) {
      let n = this.x(s, i);
      return s.overrideIdentifier && (n = n.override(s.overrideIdentifier)), !this.l.isEmpty() && this.l.getValue(e) !== void 0 && (n = n.merge(this.l)), n;
    }
    x({ resource: e }, s) {
      let i = this.y();
      if (s && e) {
        const n = s.getFolder(e);
        n && (i = this.z(n.uri) || i);
        const r = this.t.get(e);
        r && (i = i.merge(r));
      }
      return i;
    }
    y() {
      return this.h || (this.h = this.j.merge(this.applicationConfiguration, this.userConfiguration, this.q, this.s)), this.h;
    }
    z(e) {
      let s = this.i.get(e);
      if (!s) {
        const i = this.y(),
          n = this.r.get(e);
        n ? ((s = i.merge(n)), this.i.set(e, s)) : (s = i);
      }
      return s;
    }
    A(e, s) {
      if (s && e) {
        const i = s.getFolder(e);
        if (i) return this.r.get(i.uri);
      }
    }
    toData() {
      return {
        defaults: { contents: this.j.contents, overrides: this.j.overrides, keys: this.j.keys },
        policy: { contents: this.l.contents, overrides: this.l.overrides, keys: this.l.keys },
        application: { contents: this.applicationConfiguration.contents, overrides: this.applicationConfiguration.overrides, keys: this.applicationConfiguration.keys },
        user: { contents: this.userConfiguration.contents, overrides: this.userConfiguration.overrides, keys: this.userConfiguration.keys },
        workspace: { contents: this.q.contents, overrides: this.q.overrides, keys: this.q.keys },
        folders: [...this.r.keys()].reduce((e, s) => {
          const { contents: i, overrides: n, keys: r } = this.r.get(s);
          return e.push([s, { contents: i, overrides: n, keys: r }]), e;
        }, []),
      };
    }
    allKeys() {
      const e = new Set();
      return this.j.keys.forEach((s) => e.add(s)), this.userConfiguration.keys.forEach((s) => e.add(s)), this.q.keys.forEach((s) => e.add(s)), this.r.forEach((s) => s.keys.forEach((i) => e.add(i))), [...e.values()];
    }
    B() {
      const e = new Set();
      return (
        this.j.getAllOverrideIdentifiers().forEach((s) => e.add(s)),
        this.userConfiguration.getAllOverrideIdentifiers().forEach((s) => e.add(s)),
        this.q.getAllOverrideIdentifiers().forEach((s) => e.add(s)),
        this.r.forEach((s) => s.getAllOverrideIdentifiers().forEach((i) => e.add(i))),
        [...e.values()]
      );
    }
    D(e) {
      const s = new Set();
      return (
        this.j.getKeysForOverrideIdentifier(e).forEach((i) => s.add(i)),
        this.userConfiguration.getKeysForOverrideIdentifier(e).forEach((i) => s.add(i)),
        this.q.getKeysForOverrideIdentifier(e).forEach((i) => s.add(i)),
        this.r.forEach((i) => i.getKeysForOverrideIdentifier(e).forEach((n) => s.add(n))),
        [...s.values()]
      );
    }
    static parse(e, s) {
      const i = this.E(e.defaults, s),
        n = this.E(e.policy, s),
        r = this.E(e.application, s),
        o = this.E(e.user, s),
        a = this.E(e.workspace, s),
        c = e.folders.reduce((l, h) => (l.set(C.revive(h[0]), this.E(h[1], s)), l), new kt());
      return new cw(i, n, r, o, tt.createEmptyModel(s), a, c, tt.createEmptyModel(s), new kt(), s);
    }
    static E(e, s) {
      return new tt(e.contents, e.keys, e.overrides, void 0, s);
    }
  },
  Lb = class {
    constructor(t, e, s, i, n) {
      (this.change = t),
        (this.f = e),
        (this.g = s),
        (this.h = i),
        (this.i = n),
        (this.a = `
`),
        (this.b = this.a.charCodeAt(0)),
        (this.c = 46),
        (this.affectedKeys = new Set()),
        (this.j = void 0);
      for (const r of t.keys) this.affectedKeys.add(r);
      for (const [, r] of t.overrides) for (const o of r) this.affectedKeys.add(o);
      this.d = this.a;
      for (const r of this.affectedKeys) this.d += r + this.a;
    }
    get previousConfiguration() {
      return !this.j && this.f && (this.j = zl.parse(this.f.data, this.i)), this.j;
    }
    affectsConfiguration(t, e) {
      const s = this.a + t,
        i = this.d.indexOf(s);
      if (i < 0) return !1;
      const n = i + s.length;
      if (n >= this.d.length) return !1;
      const r = this.d.charCodeAt(n);
      if (r !== this.b && r !== this.c) return !1;
      if (e) {
        const o = this.previousConfiguration ? this.previousConfiguration.getValue(t, e, this.f?.workspace) : void 0,
          a = this.g.getValue(t, e, this.h);
        return !Rt(o, a);
      }
      return !0;
    }
  };
function ri(t, e) {
  const { added: s, removed: i, updated: n } = Sp(e?.rawConfiguration, t?.rawConfiguration),
    r = [],
    o = t?.getAllOverrideIdentifiers() || [],
    a = e?.getAllOverrideIdentifiers() || [];
  if (e) {
    const c = a.filter((l) => !o.includes(l));
    for (const l of c) r.push([l, e.getKeysForOverrideIdentifier(l)]);
  }
  if (t) {
    const c = o.filter((l) => !a.includes(l));
    for (const l of c) r.push([l, t.getKeysForOverrideIdentifier(l)]);
  }
  if (e && t) {
    for (const c of o)
      if (a.includes(c)) {
        const l = Sp({ contents: t.getOverrideValue(void 0, c) || {}, keys: t.getKeysForOverrideIdentifier(c) }, { contents: e.getOverrideValue(void 0, c) || {}, keys: e.getKeysForOverrideIdentifier(c) });
        r.push([c, [...l.added, ...l.removed, ...l.updated]]);
      }
  }
  return { added: s, removed: i, updated: n, overrides: r };
}
function Sp(t, e) {
  const s = t ? (e ? t.keys.filter((r) => e.keys.indexOf(r) === -1) : [...t.keys]) : [],
    i = e ? (t ? e.keys.filter((r) => t.keys.indexOf(r) === -1) : [...e.keys]) : [],
    n = [];
  if (t && e) {
    for (const r of e.keys)
      if (t.keys.indexOf(r) !== -1) {
        const o = zo(e.contents, r),
          a = zo(t.contents, r);
        Rt(o, a) || n.push(r);
      }
  }
  return { added: s, removed: i, updated: n };
}
var $p = z("policy"),
  Nb = class extends O {
    constructor() {
      super(...arguments), (this.f = {}), (this.g = new Map()), (this.h = this.B(new D())), (this.onDidChange = this.h.event);
    }
    async updatePolicyDefinitions(t) {
      const e = Object.keys(this.f).length;
      return (this.f = { ...t, ...this.f }), e !== Object.keys(this.f).length && (await this.j(t)), $i.reduce(this.g.entries(), (s, [i, n]) => ({ ...s, [i]: n }), {});
    }
    getPolicyValue(t) {
      return this.g.get(t);
    }
    serialize() {
      return $i.reduce(Object.entries(this.f), (t, [e, s]) => ({ ...t, [e]: { definition: s, value: this.g.get(e) } }), {});
    }
  },
  xp = class {
    constructor() {
      this.onDidChange = T.None;
    }
    async updatePolicyDefinitions() {
      return {};
    }
    getPolicyValue() {}
    serialize() {}
  },
  Tb = class extends O {
    get configurationModel() {
      return this.b;
    }
    constructor(t) {
      super(), (this.c = t), (this.a = this.B(new D())), (this.onDidChangeConfiguration = this.a.event), (this.b = tt.createEmptyModel(this.c));
    }
    async initialize() {
      return this.h(), this.B(yt.as(Jt.Configuration).onDidUpdateConfiguration(({ properties: t, defaultsOverrides: e }) => this.f(Array.from(t), e))), this.configurationModel;
    }
    reload() {
      return this.h(), this.configurationModel;
    }
    f(t, e) {
      this.j(t, yt.as(Jt.Configuration).getConfigurationProperties()), this.a.fire({ defaults: this.configurationModel, properties: t });
    }
    g() {
      return {};
    }
    h() {
      this.b = tt.createEmptyModel(this.c);
      const t = yt.as(Jt.Configuration).getConfigurationProperties();
      this.j(Object.keys(t), t);
    }
    j(t, e) {
      const s = this.g();
      for (const i of t) {
        const n = s[i],
          r = e[i];
        n !== void 0 ? this.b.setValue(i, n) : r ? this.b.setValue(i, r.default) : this.b.removeValue(i);
      }
    }
  },
  jb = class {
    constructor() {
      (this.onDidChangeConfiguration = T.None), (this.configurationModel = tt.createEmptyModel(new q4()));
    }
    async initialize() {
      return this.configurationModel;
    }
  },
  ql = class extends O {
    get configurationModel() {
      return this.b;
    }
    constructor(e, s, i) {
      super(), (this.c = e), (this.f = s), (this.g = i), (this.a = this.B(new D())), (this.onDidChangeConfiguration = this.a.event), (this.b = tt.createEmptyModel(this.g));
    }
    async initialize() {
      return (
        this.g.trace("PolicyConfiguration#initialize"),
        this.m(await this.h(this.c.configurationModel.keys), !1),
        this.B(this.f.onDidChange((e) => this.j(e))),
        this.B(this.c.onDidChangeConfiguration(async ({ properties: e }) => this.m(await this.h(e), !0))),
        this.b
      );
    }
    async h(e) {
      this.g.trace("PolicyConfiguration#updatePolicyDefinitions", e);
      const s = {},
        i = [],
        n = yt.as(Jt.Configuration).getConfigurationProperties();
      for (const r of e) {
        const o = n[r];
        if (!o) {
          i.push(r);
          continue;
        }
        if (o.policy) {
          if (o.type !== "string" && o.type !== "number") {
            this.g.warn(`Policy ${o.policy.name} has unsupported type ${o.type}`);
            continue;
          }
          i.push(r), (s[o.policy.name] = { type: o.type });
        }
      }
      return $c(s) || (await this.f.updatePolicyDefinitions(s)), i;
    }
    j(e) {
      this.g.trace("PolicyConfiguration#onDidChangePolicies", e);
      const s = yt.as(Jt.Configuration).getPolicyConfigurations(),
        i = nn(e.map((n) => s.get(n)));
      this.m(i, !0);
    }
    m(e, s) {
      this.g.trace("PolicyConfiguration#update", e);
      const i = yt.as(Jt.Configuration).getConfigurationProperties(),
        n = [],
        r = this.b.isEmpty();
      for (const o of e) {
        const a = i[o]?.policy?.name;
        if (a) {
          const c = this.f.getPolicyValue(a);
          (r ? c !== void 0 : !Rt(this.b.getValue(o), c)) && n.push([o, c]);
        } else this.b.getValue(o) !== void 0 && n.push([o, void 0]);
      }
      if (n.length) {
        this.g.trace("PolicyConfiguration#changed", n);
        const o = this.b;
        this.b = tt.createEmptyModel(this.g);
        for (const a of o.keys) this.b.setValue(a, o.getValue(a));
        for (const [a, c] of n) c === void 0 ? this.b.removeValue(a) : this.b.setValue(a, c);
        s && this.a.fire(this.b);
      }
    }
  };
ql = __decorate([__param(1, $p), __param(2, ne)], ql);
var Fb = class extends O {
    constructor(t, e, s, i) {
      super(),
        (this.m = t),
        (this.n = i),
        (this.h = this.B(new D())),
        (this.onDidChangeConfiguration = this.h.event),
        (this.b = this.B(new Tb(i))),
        (this.c = s instanceof xp ? new jb() : this.B(new ql(this.b, s, i))),
        (this.f = this.B(new Ab(this.m, {}, Wc, e, i))),
        (this.a = new zl(this.b.configurationModel, this.c.configurationModel, tt.createEmptyModel(i), tt.createEmptyModel(i), tt.createEmptyModel(i), tt.createEmptyModel(i), new kt(), tt.createEmptyModel(i), new kt(), i)),
        (this.j = new Mb(t, e, this)),
        (this.g = this.B(new ks(() => this.reloadConfiguration(), 50))),
        this.B(this.b.onDidChangeConfiguration(({ defaults: n, properties: r }) => this.s(n, r))),
        this.B(this.c.onDidChangeConfiguration((n) => this.t(n))),
        this.B(this.f.onDidChange(() => this.g.schedule()));
    }
    async initialize() {
      const [t, e, s] = await Promise.all([this.b.initialize(), this.c.initialize(), this.f.loadConfiguration()]);
      this.a = new zl(t, e, tt.createEmptyModel(this.n), s, tt.createEmptyModel(this.n), tt.createEmptyModel(this.n), new kt(), tt.createEmptyModel(this.n), new kt(), this.n);
    }
    getConfigurationData() {
      return this.a.toData();
    }
    getValue(t, e) {
      const s = typeof t == "string" ? t : void 0;
      switch (s) {
        case "window.titleBarStyle":
          return "custom";
      }
      const i = Ol(t) ? t : Ol(e) ? e : {};
      return this.a.getValue(s, i, void 0);
    }
    async updateValue(t, e, s, i, n) {
      const r = db(s) ? s : Ol(s) ? { resource: s.resource, overrideIdentifiers: s.overrideIdentifier ? [s.overrideIdentifier] : void 0 } : void 0,
        o = r ? i : s;
      if (o !== void 0 && o !== 3 && o !== 2) throw new Error(`Unable to write ${t} to target ${o}.`);
      r?.overrideIdentifiers && ((r.overrideIdentifiers = Bt(r.overrideIdentifiers)), (r.overrideIdentifiers = r.overrideIdentifiers.length ? r.overrideIdentifiers : void 0));
      const a = this.inspect(t, { resource: r?.resource, overrideIdentifier: r?.overrideIdentifiers ? r.overrideIdentifiers[0] : void 0 });
      if (a.policyValue !== void 0) throw new Error(`Unable to write ${t} because it is configured in system policy.`);
      if ((Rt(e, a.defaultValue) && (e = void 0), r?.overrideIdentifiers?.length && r.overrideIdentifiers.length > 1)) {
        const l = r.overrideIdentifiers.sort(),
          h = this.a.localUserConfiguration.overrides.find((u) => _t([...u.identifiers].sort(), l));
        h && (r.overrideIdentifiers = h.identifiers);
      }
      const c = r?.overrideIdentifiers?.length ? [Db(r.overrideIdentifiers), t] : [t];
      await this.j.write(c, e), await this.reloadConfiguration();
    }
    inspect(t, e = {}) {
      return this.a.inspect(t, e, void 0);
    }
    keys() {
      return this.a.keys(void 0);
    }
    async reloadConfiguration() {
      const t = await this.f.loadConfiguration();
      this.r(t);
    }
    r(t) {
      const e = this.a.toData(),
        s = this.a.compareAndUpdateLocalUserConfiguration(t);
      this.u(s, e, 2);
    }
    s(t, e) {
      const s = this.a.toData(),
        i = this.a.compareAndUpdateDefaultConfiguration(t, e);
      this.u(i, s, 7);
    }
    t(t) {
      const e = this.a.toData(),
        s = this.a.compareAndUpdatePolicyConfiguration(t);
      this.u(s, e, 7);
    }
    u(t, e, s) {
      const i = new Lb(t, { data: e }, this.a, void 0, this.n);
      (i.source = s), this.h.fire(i);
    }
  },
  Mb = class {
    constructor(t, e, s) {
      (this.b = t), (this.c = e), (this.d = s), (this.a = new rr());
    }
    write(t, e) {
      return this.a.queue(() => this.e(t, e));
    }
    async e(t, e) {
      let s;
      try {
        s = (await this.c.readFile(this.b)).value.toString();
      } catch (r) {
        if (r.fileOperationResult === 1) s = "{}";
        else throw r;
      }
      const i = [];
      if ((it(s, i, { allowTrailingComma: !0, allowEmptyContent: !0 }), i.length > 0)) throw new Error("Unable to write into the settings file. Please open the file to correct errors/warnings in the file and try again.");
      const n = this.f(s, t, e);
      (s = dp(s, n)), await this.c.writeFile(this.b, L.fromString(s));
    }
    f(t, e, s) {
      const { tabSize: i, insertSpaces: n, eol: r } = this.h;
      if (!e.length) {
        const o = JSON.stringify(s, null, n ? " ".repeat(i) : "	");
        return [{ content: o, length: o.length, offset: 0 }];
      }
      return jl(t, e, s, { tabSize: i, insertSpaces: n, eol: r });
    }
    get h() {
      if (!this.g) {
        let t =
          hn === 3 || hn === 2
            ? `
`
            : `\r
`;
        const e = this.d.getValue("files.eol", { overrideIdentifier: "jsonc" });
        e && typeof e == "string" && e !== "auto" && (t = e),
          (this.g = { eol: t, insertSpaces: !!this.d.getValue("editor.insertSpaces", { overrideIdentifier: "jsonc" }), tabSize: this.d.getValue("editor.tabSize", { overrideIdentifier: "jsonc" }) });
      }
      return this.g;
    }
  },
  Ub = "diagnosticsService",
  Cp = z(Ub);
function kp(t) {
  return !!t.hostName && !!t.errorMessage;
}
import * as _b from "fs";
import * as Nt from "os";
import { networkInterfaces as Bb } from "os";
var zb = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function qb(t) {
  return zb.test(t);
}
var Me = (function () {
  if (typeof crypto == "object" && typeof crypto.randomUUID == "function") return crypto.randomUUID.bind(crypto);
  let t;
  typeof crypto == "object" && typeof crypto.getRandomValues == "function"
    ? (t = crypto.getRandomValues.bind(crypto))
    : (t = function (i) {
        for (let n = 0; n < i.length; n++) i[n] = Math.floor(Math.random() * 256);
        return i;
      });
  const e = new Uint8Array(16),
    s = [];
  for (let i = 0; i < 256; i++) s.push(i.toString(16).padStart(2, "0"));
  return function () {
    t(e), (e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128);
    let n = 0,
      r = "";
    return (
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += "-"),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += "-"),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += "-"),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += "-"),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      (r += s[e[n++]]),
      r
    );
  };
})();
import "os";
var Dp = new (class {
  c(t) {
    return (
      this.a ||
        ((this.a = Cn.forStrings()),
        this.a.set("00-50-56", !0),
        this.a.set("00-0C-29", !0),
        this.a.set("00-05-69", !0),
        this.a.set("00-03-FF", !0),
        this.a.set("00-1C-42", !0),
        this.a.set("00-16-3E", !0),
        this.a.set("08-00-27", !0),
        this.a.set("00:50:56", !0),
        this.a.set("00:0C:29", !0),
        this.a.set("00:05:69", !0),
        this.a.set("00:03:FF", !0),
        this.a.set("00:1C:42", !0),
        this.a.set("00:16:3E", !0),
        this.a.set("08:00:27", !0)),
      !!this.a.findSubstr(t)
    );
  }
  value() {
    if (this.b === void 0) {
      let t = 0,
        e = 0;
      const s = Bb();
      for (const i in s) {
        const n = s[i];
        if (n) for (const { mac: r, internal: o } of n) o || ((e += 1), this.c(r.toUpperCase()) && (t += 1));
      }
      this.b = e > 0 ? t / e : 0;
    }
    return this.b;
  }
})();
import { exec as Yo } from "child_process";
function Ip(t) {
  return new Promise((e, s) => {
    let i;
    const n = new Map();
    function r(l, h, u, f, d) {
      const p = n.get(h);
      if (l === t || p) {
        const g = { name: a(u), cmd: u, pid: l, ppid: h, load: f, mem: d };
        n.set(l, g), l === t && (i = g), p && (p.children || (p.children = []), p.children.push(g), p.children.length > 1 && (p.children = p.children.sort((m, v) => m.pid - v.pid)));
      }
    }
    function o(l) {
      const h = /bin\/manager/i,
        u = /ckg_server/i,
        f = /aiserver/i,
        d = /ai-completion/i;
      return h.test(l) ? "rust-manager" : u.test(l) ? "ckg-server" : f.test(l) ? "ai-server" : d.test(l) ? "ai-completion" : l;
    }
    function a(l) {
      const h = /--utility-sub-type=network/i,
        u = /--crashes-directory/i,
        f = /\\pipe\\winpty-control/i,
        d = /conhost\.exe.+--headless/i,
        p = /--type=([a-zA-Z-]+)/;
      if (u.exec(l)) return "electron-crash-reporter";
      if (f.exec(l)) return "winpty-agent";
      if (d.exec(l)) return "conpty-agent";
      let g = p.exec(l);
      if (g && g.length === 2) return g[1] === "renderer" ? "window" : g[1] === "utility" ? (h.exec(l) ? "utility-network-service" : "utility-process") : g[1] === "extensionHost" ? "extension-host" : g[1];
      const m = /[a-zA-Z-]+\.js/g;
      let v = "";
      do (g = m.exec(l)), g && (v += g + " ");
      while (g);
      return v && l.indexOf("node ") < 0 && l.indexOf("node.exe") < 0 ? `electron-nodejs (${v})` : /--ms-enable-electron-run-as-node/i.exec(l) ? `electron-nodejs (${l})` : o(l);
    }
    if (process.platform === "win32") {
      const l = (h) => (h.indexOf("\\\\?\\") === 0 || h.indexOf("\\??\\") === 0 ? h.substring(4) : h.indexOf('"\\\\?\\') === 0 || h.indexOf('"\\??\\') === 0 ? '"' + h.substring(5) : h);
      import("@vscode/windows-process-tree").then((h) => {
        h.getProcessList(
          t,
          (u) => {
            if (!u) {
              s(new Error(`Root process ${t} not found`));
              return;
            }
            h.getProcessCpuUsage(u, (f) => {
              const d = new Map();
              f.forEach((p) => {
                const g = l(p.commandLine || "");
                d.set(p.pid, { name: a(g), cmd: g, pid: p.pid, ppid: p.ppid, load: p.cpu || 0, mem: p.memory || 0 });
              }),
                (i = d.get(t)),
                i
                  ? (d.forEach((p) => {
                      const g = d.get(p.ppid);
                      g && (g.children || (g.children = []), g.children.push(p));
                    }),
                    d.forEach((p) => {
                      p.children && (p.children = p.children.sort((g, m) => g.pid - m.pid));
                    }),
                    e(i))
                  : s(new Error(`Root process ${t} not found`));
            });
          },
          h.ProcessDataFlag.CommandLine | h.ProcessDataFlag.Memory,
        );
      });
    } else {
      let l = function () {
        let h = [i];
        const u = [];
        for (; h.length; ) {
          const d = h.shift();
          d && (u.push(d.pid), d.children && (h = h.concat(d.children)));
        }
        let f = JSON.stringify(Cs.asFileUri("vs/base/node/cpuUsage.sh").fsPath);
        (f += " " + u.join(" ")),
          Yo(f, {}, (d, p, g) => {
            if (d || g) s(d || new Error(g.toString()));
            else {
              const m = p.toString().split(`
`);
              for (let v = 0; v < u.length; v++) {
                const b = n.get(u[v]);
                b.load = parseFloat(m[v]);
              }
              if (!i) {
                s(new Error(`Root process ${t} not found`));
                return;
              }
              e(i);
            }
          });
      };
      var c = l;
      Yo("which ps", {}, (h, u, f) => {
        if (h || f)
          if (process.platform !== "linux") s(h || new Error(f.toString()));
          else {
            const d = JSON.stringify(Cs.asFileUri("vs/base/node/ps.sh").fsPath);
            Yo(d, {}, (p, g, m) => {
              p || m ? s(p || new Error(m.toString())) : (Rp(g, r), l());
            });
          }
        else {
          const d = u.toString().trim();
          Yo(`${d} -ax -o pid=,ppid=,pcpu=,pmem=,command=`, { maxBuffer: 1e3 * 1024, env: { LC_NUMERIC: "en_US.UTF-8" } }, (g, m, v) => {
            g || (v && !v.includes("screen size is bogus")) ? s(g || new Error(v.toString())) : (Rp(m, r), process.platform === "linux" ? l() : i ? e(i) : s(new Error(`Root process ${t} not found`)));
          });
        }
      });
    }
  });
}
function Rp(t, e) {
  const s = /^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+\.[0-9]+)\s+([0-9]+\.[0-9]+)\s+(.+)$/,
    i = t.toString().split(`
`);
  for (const n of i) {
    const r = s.exec(n.trim());
    r && r.length === 6 && e(parseInt(r[1]), parseInt(r[2]), r[5], parseFloat(r[3]), parseFloat(r[4]));
  }
}
var Se = z("telemetryService"),
  Pp = z("customEndpointTelemetryService"),
  Ap = "telemetry",
  Zo = "telemetry.telemetryLevel",
  Op = "telemetry.enableCrashReporter",
  Vl = "telemetry.enableTelemetry",
  Lp;
(function (t) {
  (t[(t.NONE = 0)] = "NONE"), (t[(t.CRASH = 1)] = "CRASH"), (t[(t.ERROR = 2)] = "ERROR"), (t[(t.USAGE = 3)] = "USAGE");
})(Lp || (Lp = {}));
var Np;
(function (t) {
  (t.OFF = "off"), (t.CRASH = "crash"), (t.ERROR = "error"), (t.ON = "all");
})(Np || (Np = {}));
var Tp = new Map();
async function Wl(t, e) {
  const s = `${t}::${e.join(":")}`,
    i = Tp.get(s);
  if (i) return i;
  const n = [
      { tag: "grunt.js", filePattern: /^gruntfile\.js$/i },
      { tag: "gulp.js", filePattern: /^gulpfile\.js$/i },
      { tag: "tsconfig.json", filePattern: /^tsconfig\.json$/i },
      { tag: "package.json", filePattern: /^package\.json$/i },
      { tag: "jsconfig.json", filePattern: /^jsconfig\.json$/i },
      { tag: "tslint.json", filePattern: /^tslint\.json$/i },
      { tag: "eslint.json", filePattern: /^eslint\.json$/i },
      { tag: "tasks.json", filePattern: /^tasks\.json$/i },
      { tag: "launch.json", filePattern: /^launch\.json$/i },
      { tag: "settings.json", filePattern: /^settings\.json$/i },
      { tag: "webpack.config.js", filePattern: /^webpack\.config\.js$/i },
      { tag: "project.json", filePattern: /^project\.json$/i },
      { tag: "makefile", filePattern: /^makefile$/i },
      { tag: "sln", filePattern: /^.+\.sln$/i },
      { tag: "csproj", filePattern: /^.+\.csproj$/i },
      { tag: "cmake", filePattern: /^.+\.cmake$/i },
      { tag: "github-actions", filePattern: /^.+\.ya?ml$/i, relativePathPattern: /^\.github(?:\/|\\)workflows$/i },
      { tag: "devcontainer.json", filePattern: /^devcontainer\.json$/i },
      { tag: "dockerfile", filePattern: /^(dockerfile|docker\-compose\.ya?ml)$/i },
      { tag: "cursorrules", filePattern: /^\.cursorrules$/i },
    ],
    r = new Map(),
    o = new Map(),
    a = 2e4;
  function c(h, u, f, d) {
    const p = u.substring(h.length + 1);
    return Ze.withAsyncBody(async (g) => {
      let m;
      d.readdirCount++;
      try {
        m = await he.readdir(u, { withFileTypes: !0 });
      } catch {
        g();
        return;
      }
      if (d.count >= a) {
        (d.count += m.length), (d.maxReached = !0), g();
        return;
      }
      let v = m.length;
      if (v === 0) {
        g();
        return;
      }
      let b = m;
      d.count + m.length > a && ((d.maxReached = !0), (v = a - d.count), (b = m.slice(0, v))), (d.count += m.length);
      for (const E of b)
        if (E.isDirectory()) {
          if ((f.includes(E.name) || (await c(h, V(u, E.name), f, d)), --v === 0)) {
            g();
            return;
          }
        } else {
          const $ = E.name.lastIndexOf(".");
          if ($ >= 0) {
            const P = E.name.substring($ + 1);
            P && r.set(P, (r.get(P) ?? 0) + 1);
          }
          for (const P of n) P.relativePathPattern?.test(p) !== !1 && P.filePattern.test(E.name) && o.set(P.tag, (o.get(P.tag) ?? 0) + 1);
          if (--v === 0) {
            g();
            return;
          }
        }
    });
  }
  const l = Ze.withAsyncBody(async (h) => {
    const u = { count: 0, maxReached: !1, readdirCount: 0 },
      f = new un(!0);
    await c(t, t, e, u);
    const d = await Wb(t);
    h({ configFiles: Hl(o), fileTypes: Hl(r), fileCount: u.count, maxFilesReached: u.maxReached, launchConfigFiles: d, totalScanTime: f.elapsed(), totalReaddirCount: u.readdirCount });
  });
  return Tp.set(s, l), l;
}
function Hl(t) {
  return Array.from(t.entries(), ([e, s]) => ({ name: e, count: s })).sort((e, s) => s.count - e.count);
}
function Vb() {
  const t = { os: `${Nt.type()} ${Nt.arch()} ${Nt.release()}`, memory: `${(Nt.totalmem() / wr.GB).toFixed(2)}GB (${(Nt.freemem() / wr.GB).toFixed(2)}GB free)`, vmHint: `${Math.round(Dp.value() * 100)}%` },
    e = Nt.cpus();
  return e && e.length > 0 && (t.cpus = `${e[0].model} (${e.length} x ${e[0].speed})`), t;
}
async function Wb(t) {
  try {
    const e = new Map(),
      s = V(t, ".vscode", "launch.json"),
      i = await _b.promises.readFile(s),
      n = [],
      r = it(i.toString(), n);
    if (n.length) return console.log(`Unable to parse ${s}`), [];
    if (Rn(r) === "object" && r.configurations)
      for (const o of r.configurations) {
        const a = o.type;
        a && (e.has(a) ? e.set(a, e.get(a) + 1) : e.set(a, 1));
      }
    return Hl(e);
  } catch {
    return [];
  }
}
var Gl = class {
  constructor(e, s) {
    (this.c = e), (this.d = s);
  }
  f(e) {
    const s = [];
    return (
      s.push(`OS Version:       ${e.os}`),
      s.push(`CPUs:             ${e.cpus}`),
      s.push(`Memory (System):  ${e.memory}`),
      s.push(`VM:               ${e.vmHint}`),
      s.join(`
`)
    );
  }
  g(e) {
    const s = [];
    s.push(`Version:          ${this.d.nameShort} ${this.d.version} (${this.d.commit || "Commit unknown"}, ${this.d.date || "Date unknown"})`), s.push(`OS Version:       ${Nt.type()} ${Nt.arch()} ${Nt.release()}`);
    const i = Nt.cpus();
    return (
      i && i.length > 0 && s.push(`CPUs:             ${i[0].model} (${i.length} x ${i[0].speed})`),
      s.push(`Memory (System):  ${(Nt.totalmem() / wr.GB).toFixed(2)}GB (${(Nt.freemem() / wr.GB).toFixed(2)}GB free)`),
      Be ||
        s.push(
          `Load (avg):       ${Nt.loadavg()
            .map((n) => Math.round(n))
            .join(", ")}`,
        ),
      s.push(`VM:               ${Math.round(Dp.value() * 100)}%`),
      s.push(`Screen Reader:    ${e.screenReader ? "yes" : "no"}`),
      s.push(`Process Argv:     ${e.mainArguments.join(" ")}`),
      s.push(`GPU Status:       ${this.j(e.gpuFeatureStatus)}`),
      s.join(`
`)
    );
  }
  async getPerformanceInfo(e, s) {
    return Promise.all([Ip(e.mainPID), this.k(e)]).then(async (i) => {
      let [n, r] = i,
        o = this.m(e, n);
      return (
        s.forEach((a) => {
          if (kp(a))
            (o += `
${a.errorMessage}`),
              (r += `
${a.errorMessage}`);
          else if (
            ((o += `

Remote: ${a.hostName}`),
            a.processes &&
              (o += `
${this.m(e, a.processes)}`),
            a.workspaceMetadata)
          ) {
            r += `
|  Remote: ${a.hostName}`;
            for (const c of Object.keys(a.workspaceMetadata)) {
              const l = a.workspaceMetadata[c];
              let h = `${l.fileCount} files`;
              l.maxFilesReached && (h = `more than ${h}`), (r += `|    Folder (${c}): ${h}`), (r += this.h(l));
            }
          }
        }),
        { processInfo: o, workspaceInfo: r }
      );
    });
  }
  async getSystemInfo(e, s) {
    const { memory: i, vmHint: n, os: r, cpus: o } = Vb(),
      a = { os: r, memory: i, cpus: o, vmHint: n, processArgs: `${e.mainArguments.join(" ")}`, gpuStatus: e.gpuFeatureStatus, screenReader: `${e.screenReader ? "yes" : "no"}`, remoteData: s };
    return (
      Be ||
        (a.load = `${Nt.loadavg()
          .map((c) => Math.round(c))
          .join(", ")}`),
      ht && (a.linuxEnv = { desktopSession: process.env.DESKTOP_SESSION, xdgSessionDesktop: process.env.XDG_SESSION_DESKTOP, xdgCurrentDesktop: process.env.XDG_CURRENT_DESKTOP, xdgSessionType: process.env.XDG_SESSION_TYPE }),
      Promise.resolve(a)
    );
  }
  async getDiagnostics(e, s) {
    const i = [];
    return Ip(e.mainPID).then(
      async (n) => (
        i.push(""),
        i.push(this.g(e)),
        i.push(""),
        i.push(this.m(e, n)),
        e.windows.some((r) => r.folderURIs && r.folderURIs.length > 0 && !r.remoteAuthority) && (i.push(""), i.push("Workspace Stats: "), i.push(await this.k(e))),
        s.forEach((r) => {
          if (kp(r))
            i.push(`
${r.errorMessage}`);
          else if (
            (i.push(`

`),
            i.push(`Remote:           ${r.hostName}`),
            i.push(this.f(r.machineInfo)),
            r.processes && i.push(this.m(e, r.processes)),
            r.workspaceMetadata)
          )
            for (const o of Object.keys(r.workspaceMetadata)) {
              const a = r.workspaceMetadata[o];
              let c = `${a.fileCount} files`;
              a.maxFilesReached && (c = `more than ${c}`), i.push(`Folder (${o}): ${c}`), i.push(this.h(a));
            }
        }),
        i.push(""),
        i.push(""),
        i.join(`
`)
      ),
    );
  }
  h(e) {
    const s = [];
    let n = 0;
    const r = (l, h) => {
      const u = ` ${l}(${h})`;
      n + u.length > 60 ? (s.push(o), (o = "|                 "), (n = o.length)) : (n += u.length), (o += u);
    };
    let o = "|      File types:";
    const a = 10,
      c = e.fileTypes.length > a ? a : e.fileTypes.length;
    for (let l = 0; l < c; l++) {
      const h = e.fileTypes[l];
      r(h.name, h.count);
    }
    if (
      (s.push(o),
      e.configFiles.length >= 0 &&
        ((o = "|      Conf files:"),
        (n = 0),
        e.configFiles.forEach((l) => {
          r(l.name, l.count);
        }),
        s.push(o)),
      e.launchConfigFiles.length > 0)
    ) {
      let l = "|      Launch Configs:";
      e.launchConfigFiles.forEach((h) => {
        const u = h.count > 1 ? ` ${h.name}(${h.count})` : ` ${h.name}`;
        l += u;
      }),
        s.push(l);
    }
    return s.join(`
`);
  }
  j(e) {
    const s = Math.max(...Object.keys(e).map((i) => i.length));
    return Object.keys(e).map((i) => `${i}:  ${" ".repeat(s - i.length)}  ${e[i]}`).join(`
                  `);
  }
  k(e) {
    const s = [],
      i = [];
    return (
      e.windows.forEach((n) => {
        n.folderURIs.length === 0 ||
          n.remoteAuthority ||
          (s.push(`|  Window (${n.title})`),
          n.folderURIs.forEach((r) => {
            const o = C.revive(r);
            if (o.scheme === oe.file) {
              const a = o.fsPath;
              i.push(
                Wl(a, ["node_modules", ".git"])
                  .then((c) => {
                    let l = `${c.fileCount} files`;
                    c.maxFilesReached && (l = `more than ${l}`), s.push(`|    Folder (${Ot(a)}): ${l}`), s.push(this.h(c));
                  })
                  .catch((c) => {
                    s.push(`|      Error: Unable to collect workspace stats for folder ${a} (${c.toString()})`);
                  }),
              );
            } else s.push(`|    Folder (${o.toString()}): Workspace stats not available.`);
          }));
      }),
      Promise.all(i)
        .then((n) =>
          s.join(`
`),
        )
        .catch((n) => `Unable to collect workspace stats: ${n}`)
    );
  }
  m(e, s) {
    const i = new Map();
    e.windows.forEach((r) => i.set(r.pid, `window [${r.id}] (${r.title})`)), e.pidToNames.forEach(({ pid: r, name: o }) => i.set(r, o));
    const n = [];
    return (
      n.push("CPU %	Mem MB	   PID	Process"),
      s && this.n(e.mainPID, i, n, s, 0),
      n.join(`
`)
    );
  }
  n(e, s, i, n, r) {
    const o = r === 0;
    let a;
    o ? (a = n.pid === e ? `${this.d.applicationName} main` : "remote agent") : s.has(n.pid) ? (a = s.get(n.pid)) : (a = `${"  ".repeat(r)} ${n.name}`);
    const c = process.platform === "win32" ? n.mem : Nt.totalmem() * (n.mem / 100);
    i.push(`${n.load.toFixed(0).padStart(5, " ")}	${(c / wr.MB).toFixed(0).padStart(6, " ")}	${n.pid.toFixed(0).padStart(6, " ")}	${a}`), Array.isArray(n.children) && n.children.forEach((l) => this.n(e, s, i, l, r + 1));
  }
  async getWorkspaceFileExtensions(e) {
    const s = new Set();
    for (const { uri: i } of e.folders) {
      const n = C.revive(i);
      if (n.scheme !== oe.file) continue;
      const r = n.fsPath;
      try {
        (await Wl(r, ["node_modules", ".git"])).fileTypes.forEach((a) => s.add(a.name));
      } catch {}
    }
    return { extensions: [...s] };
  }
  async reportWorkspaceStats(e) {
    for (const { uri: s } of e.folders) {
      const i = C.revive(s);
      if (i.scheme !== oe.file) continue;
      const n = i.fsPath;
      try {
        const r = await Wl(n, ["node_modules", ".git"]);
        this.c.publicLog2("workspace.stats", { "workspace.id": e.telemetryId, rendererSessionId: e.rendererSessionId }),
          r.fileTypes.forEach((o) => {
            this.c.publicLog2("workspace.stats.file", { rendererSessionId: e.rendererSessionId, type: o.name, count: o.count });
          }),
          r.launchConfigFiles.forEach((o) => {
            this.c.publicLog2("workspace.stats.launchConfigFile", { rendererSessionId: e.rendererSessionId, type: o.name, count: o.count });
          }),
          r.configFiles.forEach((o) => {
            this.c.publicLog2("workspace.stats.configFiles", { rendererSessionId: e.rendererSessionId, type: o.name, count: o.count });
          }),
          this.c.publicLog2("workspace.stats.metadata", { duration: r.totalScanTime, reachedLimit: r.maxFilesReached, fileCount: r.fileCount, readdirCount: r.totalReaddirCount });
      } catch {}
    }
  }
};
Gl = __decorate([__param(0, Se), __param(1, Ee)], Gl);
var jp = z("downloadService"),
  oi = z("requestService"),
  Hb = class {
    constructor(t) {
      this.b = t;
    }
    toJSON() {
      if (!this.a) {
        const t = Object.create(null);
        for (const e in this.b) e.toLowerCase() === "authorization" || e.toLowerCase() === "proxy-authorization" ? (t[e] = "*****") : (t[e] = this.b[e]);
        this.a = t;
      }
      return this.a;
    }
  },
  Gb = class extends O {
    constructor(t) {
      super(), (this.b = t), (this.a = 0);
    }
    async c(t, e) {
      const s = `[network] #${++this.a}: ${t.url}`;
      this.b.trace(`${s} - begin`, t.type, new Hb(t.headers ?? {}));
      try {
        const i = await e();
        return this.b.trace(`${s} - end`, t.type, i.res.statusCode, i.res.headers), i;
      } catch (i) {
        throw (this.b.error(`${s} - error`, t.type, ve(i)), i);
      }
    }
  };
function Cr(t) {
  return (t.res.statusCode && t.res.statusCode >= 200 && t.res.statusCode < 300) || t.res.statusCode === 1223;
}
function Jl(t) {
  return t.res.statusCode === 204;
}
async function Fp(t) {
  return Jl(t) ? null : (await Ai(t.stream)).toString();
}
async function Is(t) {
  if (!Cr(t)) throw new Error("Server returned " + t.res.statusCode);
  return Fp(t);
}
async function Ui(t) {
  if (!Cr(t)) throw new Error("Server returned " + t.res.statusCode);
  if (Jl(t)) return null;
  const s = (await Ai(t.stream)).toString();
  try {
    return JSON.parse(s);
  } catch (i) {
    throw (
      ((i.message +=
        `:
` + s),
      i)
    );
  }
}
var Kl;
function Jb(t) {
  const e = yt.as(Jt.Configuration),
    s = Kl;
  (Kl = {
    id: "http",
    order: 15,
    title: w(2118, null),
    type: "object",
    scope: t,
    properties: {
      "http.proxy": { type: "string", pattern: "^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$", markdownDescription: w(2119, null), restricted: !0 },
      "http.proxyStrictSSL": { type: "boolean", default: !0, description: w(2120, null), restricted: !0 },
      "http.proxyKerberosServicePrincipal": { type: "string", markdownDescription: w(2121, null), restricted: !0 },
      "http.noProxy": { type: "array", items: { type: "string" }, markdownDescription: w(2122, null), restricted: !0 },
      "http.proxyAuthorization": { type: ["null", "string"], default: null, markdownDescription: w(2123, null), restricted: !0 },
      "http.proxySupport": { type: "string", enum: ["off", "on", "fallback", "override"], enumDescriptions: [w(2124, null), w(2125, null), w(2126, null), w(2127, null)], default: "override", description: w(2128, null), restricted: !0 },
      "http.systemCertificates": { type: "boolean", default: !0, description: w(2129, null), restricted: !0 },
      "http.experimental.systemCertificatesV2": { type: "boolean", tags: ["experimental"], default: !1, description: w(2130, null), restricted: !0 },
      "http.electronFetch": { type: "boolean", default: !1, description: w(2131, null), restricted: !0 },
    },
  }),
    e.updateConfigurations({ add: [Kl], remove: s ? [s] : [] });
}
Jb(1);
var Xl = class {
  constructor(e, s) {
    (this.a = e), (this.b = s);
  }
  async download(e, s, i = J.None) {
    if (e.scheme === oe.file || e.scheme === oe.vscodeRemote) {
      await this.b.copy(e, s);
      return;
    }
    const n = { type: "GET", url: e.toString(!0) },
      r = await this.a.request(n, i);
    if (r.res.statusCode === 200) await this.b.writeFile(s, r.stream);
    else {
      const o = await Is(r);
      throw new Error(`Expected 200, got back ${r.res.statusCode} instead.

${o}`);
    }
  }
};
Xl = __decorate([__param(0, oi), __param(1, ie)], Xl);
var Mp = "extensions.user.cache",
  Kb = "extensions.builtin.cache",
  Up = "undefined_publisher",
  _p;
(function (t) {
  (t[(t.System = 0)] = "System"), (t[(t.User = 1)] = "User");
})(_p || (_p = {}));
var Bp;
(function (t) {
  (t.WIN32_X64 = "win32-x64"),
    (t.WIN32_ARM64 = "win32-arm64"),
    (t.LINUX_X64 = "linux-x64"),
    (t.LINUX_ARM64 = "linux-arm64"),
    (t.LINUX_ARMHF = "linux-armhf"),
    (t.ALPINE_X64 = "alpine-x64"),
    (t.ALPINE_ARM64 = "alpine-arm64"),
    (t.DARWIN_X64 = "darwin-x64"),
    (t.DARWIN_ARM64 = "darwin-arm64"),
    (t.WEB = "web"),
    (t.UNIVERSAL = "universal"),
    (t.UNKNOWN = "unknown"),
    (t.UNDEFINED = "undefined");
})(Bp || (Bp = {}));
var An = class {
    constructor(t) {
      (this.value = t), (this._lower = t.toLowerCase());
    }
    static equals(t, e) {
      if (typeof t > "u" || t === null) return typeof e > "u" || e === null;
      if (typeof e > "u" || e === null) return !1;
      if (typeof t == "string" || typeof e == "string") {
        const s = typeof t == "string" ? t : t.value,
          i = typeof e == "string" ? e : e.value;
        return Ci(s, i);
      }
      return t._lower === e._lower;
    }
    static toKey(t) {
      return typeof t == "string" ? t.toLowerCase() : t._lower;
    }
  },
  Xb = class {
    constructor() {
      this.c = new Map();
    }
    clear() {
      this.c.clear();
    }
    delete(t) {
      this.c.delete(An.toKey(t));
    }
    get(t) {
      return this.c.get(An.toKey(t));
    }
    has(t) {
      return this.c.has(An.toKey(t));
    }
    set(t, e) {
      this.c.set(An.toKey(t), e);
    }
    values() {
      return this.c.values();
    }
    forEach(t) {
      this.c.forEach(t);
    }
    [Symbol.iterator]() {
      return this.c[Symbol.iterator]();
    }
  };
function Ql(t) {
  return Qb(t);
}
function Qb(t) {
  return t.contributes && t.contributes.localizations ? t.contributes.localizations.length > 0 : !1;
}
function Yb(t) {
  return t.map((e) => {
    const [s, i] = e.split("@");
    return { proposalName: s, version: i ? parseInt(i) : void 0 };
  });
}
function Zb(t) {
  return t.map((e) => e.split("@")[0]);
}
var N3 = z("IBuiltinExtensionsScannerService");
function e5(t) {
  if (ln === 2 && /^penguin(\.|$)/i.test(t)) return "chromebook";
}
function t5(t, e, s, i, n, r, o, a, c, l, h, u, f, d, p, g, m) {
  const v = Object.create(null);
  (v["common.machineId"] = r),
    (v["common.sqmId"] = o),
    (v["common.devDeviceId"] = a),
    (v["common.deviceId"] = m || "0"),
    (v.sessionID = Me() + Date.now()),
    (v.commitHash = i),
    (v.version = n),
    (v["common.platformVersion"] = (t || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3")),
    (v["common.platform"] = Oc(ln)),
    (v["common.nodePlatform"] = So),
    (v["common.nodeArch"] = s),
    (v["common.product"] = l || "desktop"),
    (v.memory = u),
    (v.cpu = f),
    (v.memoryUsagePercentage = d),
    (v.cpuPercentage = p),
    (v["native.buildVersion"] = h),
    (v.buildVersion = h),
    (v.quality = g),
    (v.platform = Oc(ln)),
    (v.nodePlatform = So),
    c && (v["common.msftInternal"] = c);
  let b = 0;
  const E = Date.now();
  Object.defineProperties(v, { timestamp: { get: () => new Date(), enumerable: !0 }, "common.timesincesessionstart": { get: () => Date.now() - E, enumerable: !0 }, "common.sequence": { get: () => b++, enumerable: !0 } }),
    iv && (v["common.snap"] = "true");
  const $ = e5(e);
  return $ && (v["common.platformDetail"] = $), v;
}
function s5(t) {
  const e = Y.USERDNSDOMAIN;
  if (!e) return !1;
  const s = e.toLowerCase();
  return t.some((i) => s === i);
}
var Yl = class {
    constructor(t) {
      (this.value = t), (this.isTrustedTelemetryValue = !0);
    }
  },
  i5 = class {
    constructor() {
      (this.telemetryLevel = 0),
        (this.sessionId = "someValue.sessionId"),
        (this.machineId = "someValue.machineId"),
        (this.sqmId = "someValue.sqmId"),
        (this.devDeviceId = "someValue.devDeviceId"),
        (this.firstSessionDate = "someValue.firstSessionDate"),
        (this.sendErrorTelemetry = !1);
    }
    publicLog() {}
    publicLog2() {}
    publicLogError() {}
    publicLogError2() {}
    setExperimentProperty() {}
  },
  n5 = new i5(),
  Zl = "telemetry",
  r5 = { log: () => null, flush: () => Promise.resolve(void 0) };
function eh(t, e) {
  return !e.isBuilt && !e.disableTelemetry ? !0 : !(e.disableTelemetry || !t.enableTelemetry);
}
function zp(t, e) {
  return e.extensionTestsLocationURI ? !0 : !(e.isBuilt || e.disableTelemetry || t.enableTelemetry);
}
function qp(t) {
  const e = t.getValue(Zo),
    s = t.getValue(Op);
  if (t.getValue(Vl) === !1 || s === !1) return 0;
  switch (e ?? "all") {
    case "all":
      return 3;
    case "error":
      return 2;
    case "crash":
      return 1;
    case "off":
      return 0;
  }
}
function Vp(t) {
  const e = {},
    s = {},
    i = {};
  Wp(t, i);
  for (let n in i) {
    n = n.length > 150 ? n.substr(n.length - 149) : n;
    const r = i[n];
    typeof r == "number"
      ? (s[n] = r)
      : typeof r == "boolean"
        ? (s[n] = r ? 1 : 0)
        : typeof r == "string"
          ? (r.length > 8192 && console.warn(`Telemetry property: ${n} has been trimmed to 8192, the original length is ${r.length}`), (e[n] = r.substring(0, 8191)))
          : typeof r < "u" && r !== null && (e[n] = r);
  }
  return { properties: e, measurements: s };
}
function Wp(t, e, s = 0, i) {
  if (t)
    for (const n of Object.getOwnPropertyNames(t)) {
      const r = t[n],
        o = i ? i + n : n;
      Array.isArray(r) ? (e[o] = mp(r)) : r instanceof Date ? (e[o] = r.toISOString()) : Ke(r) ? (s < 2 ? Wp(r, e, s + 1, o + ".") : (e[o] = mp(r))) : (e[o] = r);
    }
}
function o5(t, e) {
  const s = t.msftInternalDomains || [],
    i = e.getValue("telemetry.internalTesting");
  return s5(s) || i;
}
function a5(t) {
  return [t.appRoot, t.extensionsPath, t.userHome.fsPath, t.tmpDir.fsPath, t.userDataPath];
}
function c5(t, e) {
  if (!t || (!t.includes("/") && !t.includes("\\"))) return t;
  let s = t;
  const i = [];
  for (const a of e)
    for (;;) {
      const c = a.exec(t);
      if (!c) break;
      i.push([c.index, a.lastIndex]);
    }
  const n = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/,
    r = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
  let o = 0;
  for (s = ""; ; ) {
    const a = r.exec(t);
    if (!a) break;
    const c = i.some(([l, h]) => a.index < h && l < r.lastIndex);
    !n.test(a[0]) && !c && ((s += t.substring(o, a.index) + "<REDACTED: user-file-path>"), (o = r.lastIndex));
  }
  return o < t.length && (s += t.substr(o)), s;
}
function l5(t) {
  if (!t) return t;
  const e = [
    { label: "Google API Key", regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
    { label: "Slack Token", regex: /xox[pbar]\-[A-Za-z0-9]/ },
    { label: "GitHub Token", regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },
    { label: "Generic Secret", regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i },
    {
      label: "CLI Credentials",
      regex:
        /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/,
    },
    { label: "Microsoft Entra ID", regex: /eyJ(?:0eXAiOiJKV1Qi|hbGci|[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+\.)/ },
    { label: "Email", regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/ },
  ];
  for (const s of e) if (s.regex.test(t)) return `<REDACTED: ${s.label}>`;
  return t;
}
function h5(t, e) {
  return gp(t, (s) => {
    if (s instanceof Yl || Object.hasOwnProperty.call(s, "isTrustedTelemetryValue")) return s.value;
    if (typeof s == "string") {
      let i = s.replaceAll("%20", " ");
      i = c5(i, e);
      for (const n of e) i = i.replace(n, "");
      return (i = l5(i)), i;
    }
  });
}
function G(t, e) {
  return t.uuid && e.uuid ? (t.uuid === e.uuid ? !0 : t.id === e.id) : t.id === e.id ? !0 : Uc(t.id, e.id) === 0;
}
var u5 = /^([^.]+\..+)-(\d+\.\d+\.\d+)(-(.+))?$/,
  Tt = class dc {
    static create(e) {
      const s = e.manifest ? e.manifest.version : e.version,
        i = e.manifest ? e.targetPlatform : e.properties.targetPlatform;
      return new dc(e.identifier, s, i);
    }
    static parse(e) {
      const s = u5.exec(e);
      return s && s[1] && s[2] ? new dc({ id: s[1] }, s[2], s[4] || void 0) : null;
    }
    constructor(e, s, i = "undefined") {
      (this.identifier = e), (this.version = s), (this.targetPlatform = i), (this.id = e.id);
    }
    toString() {
      return `${this.id}-${this.version}${this.targetPlatform !== "undefined" ? `-${this.targetPlatform}` : ""}`;
    }
    equals(e) {
      return e instanceof dc ? G(this, e) && this.version === e.version && this.targetPlatform === e.targetPlatform : !1;
    }
  },
  f5 = /^([^.]+\..+)@((prerelease)|(\d+\.\d+\.\d+(-.*)?))$/;
function d5(t) {
  const e = f5.exec(t);
  return e && e[1] ? [kr(e[1]), e[2]] : [kr(t), void 0];
}
function ea(t, e) {
  return `${t}.${e}`;
}
function kr(t) {
  return t.toLowerCase();
}
function ai(t, e) {
  return kr(ea(t ?? Up, e));
}
function Hp(t, e) {
  const s = [],
    i = (n) => {
      for (const r of s) if (r.some((o) => G(e(o), e(n)))) return r;
      return null;
    };
  for (const n of t) {
    const r = i(n);
    r ? r.push(n) : s.push([n]);
  }
  return s;
}
function p5(t) {
  return {
    id: t.identifier.id,
    name: t.manifest.name,
    galleryId: null,
    publisherId: t.publisherId,
    publisherName: t.manifest.publisher,
    publisherDisplayName: t.publisherDisplayName,
    dependencies: t.manifest.extensionDependencies && t.manifest.extensionDependencies.length > 0,
  };
}
function th(t) {
  return {
    id: new Yl(t.identifier.id),
    name: new Yl(t.name),
    version: t.version,
    galleryId: t.identifier.uuid,
    publisherId: t.publisherId,
    publisherName: t.publisher,
    publisherDisplayName: t.publisherDisplayName,
    isPreReleaseVersion: t.properties.isPreReleaseVersion,
    dependencies: !!(t.properties.dependencies && t.properties.dependencies.length > 0),
    isSigned: t.isSigned,
    ...t.telemetryData,
  };
}
var T3 = new An("pprice.better-merge");
async function g5(t, e) {
  if (!ht) return !1;
  let s;
  try {
    s = (await t.readFile(C.file("/etc/os-release"))).value.toString();
  } catch {
    try {
      s = (await t.readFile(C.file("/usr/lib/os-release"))).value.toString();
    } catch (n) {
      e.debug("Error while getting the os-release file.", ve(n));
    }
  }
  return !!s && (s.match(/^ID=([^\u001b\r\n]*)/m) || [])[1] === "alpine";
}
async function Gp(t, e) {
  const s = await g5(t, e),
    i = R1(s ? "alpine" : ln, Bc);
  return e.debug("ComputeTargetPlatform:", i), i;
}
function sh(t) {
  const e = [];
  typeof t == "number" && e.push("code/timeOrigin", t);
  function s(n, r) {
    e.push(n, r?.startTime ?? Date.now());
  }
  function i() {
    const n = [];
    for (let r = 0; r < e.length; r += 2) n.push({ name: e[r], startTime: e[r + 1] });
    return n;
  }
  return { mark: s, getMarks: i };
}
function m5() {
  if (typeof performance == "object" && typeof performance.mark == "function" && !performance.nodeTiming)
    return typeof performance.timeOrigin != "number" && !performance.timing
      ? sh()
      : {
          mark(t, e) {
            performance.mark(t, e);
          },
          getMarks() {
            let t = performance.timeOrigin;
            typeof t != "number" && (t = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart);
            const e = [{ name: "code/timeOrigin", startTime: Math.round(t) }];
            for (const s of performance.getEntriesByType("mark")) e.push({ name: s.name, startTime: Math.round(t + s.startTime) });
            return e;
          },
        };
  if (typeof process == "object") {
    const t = performance?.timeOrigin;
    return sh(t);
  } else return console.trace("perf-util loaded in UNKNOWN environment"), sh();
}
function w5(t) {
  return t.MonacoPerformanceMarks || (t.MonacoPerformanceMarks = m5()), t.MonacoPerformanceMarks;
}
var Jp = w5(globalThis),
  _i = Jp.mark,
  j3 = Jp.getMarks,
  Dr;
(function (t) {
  (t[(t.STORAGE_DOES_NOT_EXIST = 0)] = "STORAGE_DOES_NOT_EXIST"), (t[(t.STORAGE_IN_MEMORY = 1)] = "STORAGE_IN_MEMORY");
})(Dr || (Dr = {}));
var gs;
(function (t) {
  (t[(t.None = 0)] = "None"), (t[(t.Initialized = 1)] = "Initialized"), (t[(t.Closed = 2)] = "Closed");
})(gs || (gs = {}));
var v5 = ["workbench.auxiliaryBar.size", "workbench.sideBar.size", "workbench.panel.size"],
  ta = class lw extends O {
    static {
      this.a = 100;
    }
    constructor(e, s = Object.create(null)) {
      super(),
        (this.r = e),
        (this.s = s),
        (this.b = this.B(new jc())),
        (this.onDidChangeStorage = this.b.event),
        (this.c = gs.None),
        (this.f = new Map()),
        (this.g = this.B(new Ri(lw.a))),
        (this.h = new Set()),
        (this.j = new Map()),
        (this.m = void 0),
        (this.n = []),
        this.t();
    }
    t() {
      this.B(this.r.onDidChangeItemsExternal((e) => this.u(e)));
    }
    u(e) {
      this.b.pause();
      try {
        e.changed?.forEach((s, i) => this.w(i, s)), e.deleted?.forEach((s) => this.w(s, void 0));
      } finally {
        this.b.resume();
      }
    }
    w(e, s) {
      if (this.c === gs.Closed) return;
      let i = !1;
      mt(s) ? (i = this.f.delete(e)) : this.f.get(e) !== s && (this.f.set(e, s), (i = !0)), i && this.b.fire({ key: e, external: !0 });
    }
    get items() {
      return this.f;
    }
    get size() {
      return this.f.size;
    }
    async init() {
      this.c === gs.None && ((this.c = gs.Initialized), this.s.hint !== Dr.STORAGE_DOES_NOT_EXIST && (this.f = await this.r.getItems()));
    }
    get(e, s) {
      const i = this.f.get(e);
      return mt(i) ? s : i;
    }
    getBoolean(e, s) {
      const i = this.get(e);
      return mt(i) ? s : i === "true";
    }
    getNumber(e, s) {
      const i = this.get(e);
      return mt(i) ? s : parseInt(i, 10);
    }
    getObject(e, s) {
      const i = this.get(e);
      return mt(i) ? s : qy(i);
    }
    async set(e, s, i = !1) {
      if (this.c === gs.Closed) return;
      if (mt(s)) return this.delete(e, i);
      const n = Ke(s) || Array.isArray(s) ? zy(s) : String(s);
      if (this.f.get(e) !== n) return this.f.set(e, n), this.j.set(e, n), this.h.delete(e), this.b.fire({ key: e, external: i }), v5.includes(e) ? this.C() : this.D();
    }
    async delete(e, s = !1) {
      if (!(this.c === gs.Closed || !this.f.delete(e))) return this.h.has(e) || this.h.add(e), this.j.delete(e), this.b.fire({ key: e, external: s }), this.D();
    }
    async optimize() {
      if (this.c !== gs.Closed) return await this.flush(0), this.r.optimize();
    }
    async close() {
      return this.m || (this.m = this.y()), this.m;
    }
    async y() {
      this.c = gs.Closed;
      try {
        await this.D(0);
      } catch {}
      await this.r.close(() => this.f);
    }
    get z() {
      return this.j.size > 0 || this.h.size > 0;
    }
    async C() {
      if (!this.z) return;
      const e = { insert: this.j, delete: this.h };
      return (
        (this.h = new Set()),
        (this.j = new Map()),
        this.r.updateItems(e).finally(() => {
          if (!this.z) for (; this.n.length; ) this.n.pop()?.();
        })
      );
    }
    async flush(e) {
      if (!(this.c === gs.Closed || this.m)) return this.D(e);
    }
    async D(e) {
      return this.s.hint === Dr.STORAGE_IN_MEMORY ? this.C() : this.g.trigger(() => this.C(), e);
    }
    async whenFlushed() {
      if (this.z) return new Promise((e) => this.n.push(e));
    }
    isInMemory() {
      return this.s.hint === Dr.STORAGE_IN_MEMORY;
    }
  },
  ke = z("IUriIdentityService"),
  Kp;
(function (t) {
  (t.Settings = "settings"), (t.Keybindings = "keybindings"), (t.Snippets = "snippets"), (t.Tasks = "tasks"), (t.Extensions = "extensions"), (t.GlobalState = "globalState");
})(Kp || (Kp = {}));
function Xp(t) {
  const e = t;
  return !!(
    e &&
    typeof e == "object" &&
    typeof e.id == "string" &&
    typeof e.isDefault == "boolean" &&
    typeof e.name == "string" &&
    C.isUri(e.location) &&
    C.isUri(e.globalStorageHome) &&
    C.isUri(e.settingsResource) &&
    C.isUri(e.keybindingsResource) &&
    C.isUri(e.tasksResource) &&
    C.isUri(e.snippetsHome) &&
    C.isUri(e.extensionsResource)
  );
}
var Te = z("IUserDataProfilesService");
function es(t, e) {
  return {
    id: t.id,
    isDefault: t.isDefault,
    name: t.name,
    icon: t.icon,
    location: C.revive(t.location).with({ scheme: e }),
    globalStorageHome: C.revive(t.globalStorageHome).with({ scheme: e }),
    settingsResource: C.revive(t.settingsResource).with({ scheme: e }),
    keybindingsResource: C.revive(t.keybindingsResource).with({ scheme: e }),
    tasksResource: C.revive(t.tasksResource).with({ scheme: e }),
    snippetsHome: C.revive(t.snippetsHome).with({ scheme: e }),
    extensionsResource: C.revive(t.extensionsResource).with({ scheme: e }),
    cacheHome: C.revive(t.cacheHome).with({ scheme: e }),
    useDefaultFlags: t.useDefaultFlags,
    isTransient: t.isTransient,
    workspaces: t.workspaces?.map((s) => C.revive(s)),
  };
}
function sa(t, e, s, i, n, r) {
  return {
    id: t,
    name: e,
    location: s,
    isDefault: !1,
    icon: n?.icon,
    globalStorageHome: r && n?.useDefaultFlags?.globalState ? r.globalStorageHome : M(s, "globalStorage"),
    settingsResource: r && n?.useDefaultFlags?.settings ? r.settingsResource : M(s, "settings.json"),
    keybindingsResource: r && n?.useDefaultFlags?.keybindings ? r.keybindingsResource : M(s, "keybindings.json"),
    tasksResource: r && n?.useDefaultFlags?.tasks ? r.tasksResource : M(s, "tasks.json"),
    snippetsHome: r && n?.useDefaultFlags?.snippets ? r.snippetsHome : M(s, "snippets"),
    extensionsResource: r && n?.useDefaultFlags?.extensions ? r.extensionsResource : M(s, "extensions.json"),
    cacheHome: M(i, t),
    useDefaultFlags: n?.useDefaultFlags,
    isTransient: n?.transient,
    workspaces: n?.workspaces,
  };
}
var Qp = class extends O {
  static {
    this.b = "userDataProfiles";
  }
  static {
    this.c = "profileAssociations";
  }
  get defaultProfile() {
    return this.profiles[0];
  }
  get profiles() {
    return [...this.C.profiles, ...this.r.profiles];
  }
  constructor(e, s, i, n) {
    super(),
      (this.s = e),
      (this.t = s),
      (this.u = i),
      (this.y = n),
      (this.g = this.B(new D())),
      (this.onDidChangeProfiles = this.g.event),
      (this.h = this.B(new D())),
      (this.onWillCreateProfile = this.h.event),
      (this.j = this.B(new D())),
      (this.onWillRemoveProfile = this.j.event),
      (this.m = this.B(new D())),
      (this.onDidResetWorkspaces = this.m.event),
      (this.n = new Map()),
      (this.r = { profiles: [], emptyWindows: new Map() }),
      (this.profilesHome = M(this.s.userRoamingDataHome, "profiles")),
      (this.f = M(this.s.cacheHome, "CachedProfilesData"));
  }
  init() {
    this.z = void 0;
  }
  get C() {
    if (!this.z) {
      const e = this.D(),
        s = [e];
      try {
        for (const n of this.N()) {
          if (!n.name || !_e(n.name) || !n.location) {
            this.y.warn("Skipping the invalid stored profile", n.location || n.name);
            continue;
          }
          s.push(sa(nr(n.location), n.name, n.location, this.f, { icon: n.icon, useDefaultFlags: n.useDefaultFlags }, e));
        }
      } catch (n) {
        this.y.error(n);
      }
      const i = new Map();
      if (s.length)
        try {
          const n = this.P();
          if (n.workspaces)
            for (const [r, o] of Object.entries(n.workspaces)) {
              const a = C.parse(r),
                c = s.find((l) => l.id === o);
              if (c) {
                const l = c.workspaces ? c.workspaces.slice(0) : [];
                l.push(a), (c.workspaces = l);
              }
            }
          if (n.emptyWindows)
            for (const [r, o] of Object.entries(n.emptyWindows)) {
              const a = s.find((c) => c.id === o);
              a && i.set(r, a);
            }
        } catch (n) {
          this.y.error(n);
        }
      this.z = { profiles: s, emptyWindows: i };
    }
    return this.z;
  }
  D() {
    const e = sa("__default__profile__", w(2746, null), this.s.userRoamingDataHome, this.f);
    return { ...e, extensionsResource: this.R() ?? e.extensionsResource, isDefault: !0 };
  }
  async createTransientProfile(e) {
    const s = "Temp",
      i = new RegExp(`${dn(s)}\\s(\\d+)`);
    let n = 0;
    for (const o of this.profiles) {
      const a = i.exec(o.name),
        c = a ? parseInt(a[1]) : 0;
      n = c > n ? c : n;
    }
    const r = `${s} ${n + 1}`;
    return this.createProfile(Sn(Me()).toString(16), r, { transient: !0 }, e);
  }
  async createNamedProfile(e, s, i) {
    return this.createProfile(Sn(Me()).toString(16), e, s, i);
  }
  async createProfile(e, s, i, n) {
    return await this.F(e, s, i, n);
  }
  async F(e, s, i, n) {
    if (!_e(s) || !s) throw new Error("Name of the profile is mandatory and must be of type `string`");
    let r = this.n.get(s);
    return (
      r ||
        ((r = (async () => {
          try {
            if (this.profiles.find((h) => h.id === e || (!h.isTransient && !i?.transient && h.name === s))) throw new Error(`Profile with ${s} name already exists`);
            const a = n ? this.G(n) : void 0;
            C.isUri(a) && (i = { ...i, workspaces: [a] });
            const c = sa(e, s, M(this.profilesHome, e), this.f, i, this.defaultProfile);
            await this.t.createFolder(c.location);
            const l = [];
            return (
              this.h.fire({
                profile: c,
                join(h) {
                  l.push(h);
                },
              }),
              await Ze.settled(l),
              a && !C.isUri(a) && this.L(a, c, !!c.isTransient),
              this.I([c], [], []),
              c
            );
          } finally {
            this.n.delete(s);
          }
        })()),
        this.n.set(s, r)),
      r
    );
  }
  async updateProfile(e, s) {
    const i = [];
    for (const r of this.profiles) {
      let o;
      if (e.id === r.id)
        r.isDefault
          ? s.workspaces && ((o = r), (o.workspaces = s.workspaces))
          : (o = sa(
              r.id,
              s.name ?? r.name,
              r.location,
              this.f,
              { icon: s.icon === null ? void 0 : (s.icon ?? r.icon), transient: s.transient ?? r.isTransient, useDefaultFlags: s.useDefaultFlags ?? r.useDefaultFlags, workspaces: s.workspaces ?? r.workspaces },
              this.defaultProfile,
            ));
      else if (s.workspaces) {
        const a = r.workspaces?.filter((c) => !s.workspaces?.some((l) => this.u.extUri.isEqual(c, l)));
        r.workspaces?.length !== a?.length && ((o = r), (o.workspaces = a));
      }
      o && i.push(o);
    }
    if (!i.length) throw e.isDefault ? new Error("Cannot update default profile") : new Error(`Profile '${e.name}' does not exist`);
    this.I([], [], i);
    const n = this.profiles.find((r) => r.id === e.id);
    if (!n) throw new Error(`Profile '${e.name}' was not updated`);
    return n;
  }
  async removeProfile(e) {
    if (e.isDefault) throw new Error("Cannot remove default profile");
    const s = this.profiles.find((n) => n.id === e.id);
    if (!s) throw new Error(`Profile '${e.name}' does not exist`);
    const i = [];
    this.j.fire({
      profile: s,
      join(n) {
        i.push(n);
      },
    });
    try {
      await Promise.allSettled(i);
    } catch (n) {
      this.y.error(n);
    }
    this.I([], [s], []);
    try {
      await this.t.del(s.cacheHome, { recursive: !0 });
    } catch (n) {
      ct(n) !== 1 && this.y.error(n);
    }
  }
  async setProfileForWorkspace(e, s) {
    const i = this.profiles.find((r) => r.id === s.id);
    if (!i) throw new Error(`Profile '${s.name}' does not exist`);
    const n = this.G(e);
    if (C.isUri(n)) {
      const r = i.workspaces ? [...i.workspaces] : [];
      r.some((o) => this.u.extUri.isEqual(o, n)) || (r.push(n), await this.updateProfile(i, { workspaces: r }));
    } else this.L(n, i, !1), this.M(this.profiles);
  }
  unsetWorkspace(e, s = !1) {
    const i = this.G(e);
    if (C.isUri(i)) {
      const n = this.getProfileForWorkspace(e);
      n && this.updateProfile(n, { workspaces: n.workspaces?.filter((r) => !this.u.extUri.isEqual(r, i)) });
    } else this.L(i, void 0, s), this.M(this.profiles);
  }
  async resetWorkspaces() {
    this.r.emptyWindows.clear(), this.C.emptyWindows.clear();
    for (const e of this.profiles) e.workspaces = void 0;
    this.I([], [], this.profiles), this.m.fire();
  }
  async cleanUp() {
    if (await this.t.exists(this.profilesHome)) {
      const e = await this.t.resolve(this.profilesHome);
      await Promise.all((e.children || []).filter((s) => s.isDirectory && this.profiles.every((i) => !this.u.extUri.isEqual(i.location, s.resource))).map((s) => this.t.del(s.resource, { recursive: !0 })));
    }
  }
  async cleanUpTransientProfiles() {
    const e = this.r.profiles.filter((s) => !this.H(s));
    await Promise.allSettled(e.map((s) => this.removeProfile(s)));
  }
  getProfileForWorkspace(e) {
    const s = this.G(e);
    return C.isUri(s) ? this.profiles.find((i) => i.workspaces?.some((n) => this.u.extUri.isEqual(n, s))) : (this.C.emptyWindows.get(s) ?? this.r.emptyWindows.get(s));
  }
  G(e) {
    return ib(e) ? e.uri : rb(e) ? e.configPath : e.id;
  }
  H(e) {
    return !!(e.workspaces?.length || [...this.C.emptyWindows.values()].some((s) => this.u.extUri.isEqual(s.location, e.location)) || [...this.r.emptyWindows.values()].some((s) => this.u.extUri.isEqual(s.location, e.location)));
  }
  I(e, s, i) {
    const n = [...this.profiles, ...e],
      r = this.r.profiles;
    this.r.profiles = [];
    const o = [];
    for (let a of n) {
      if (s.some((c) => a.id === c.id)) {
        for (const c of [...this.C.emptyWindows.keys()]) a.id === this.C.emptyWindows.get(c)?.id && this.C.emptyWindows.delete(c);
        continue;
      }
      if (!a.isDefault) {
        a = i.find((l) => a.id === l.id) ?? a;
        const c = r.find((l) => a.id === l.id);
        if (a.isTransient) this.r.profiles.push(a);
        else if (c) {
          for (const [l, h] of this.r.emptyWindows.entries())
            if (a.id === h.id) {
              this.r.emptyWindows.delete(l), this.C.emptyWindows.set(l, a);
              break;
            }
        }
      }
      a.workspaces?.length === 0 && (a.workspaces = void 0), o.push(a);
    }
    this.M(o), this.J(e, s, i);
  }
  J(e, s, i) {
    this.g.fire({ added: e, removed: s, updated: i, all: this.profiles });
  }
  L(e, s, i) {
    (i = s?.isTransient ? !0 : i), i ? (s ? this.r.emptyWindows.set(e, s) : this.r.emptyWindows.delete(e)) : (this.r.emptyWindows.delete(e), s ? this.C.emptyWindows.set(e, s) : this.C.emptyWindows.delete(e));
  }
  M(e) {
    const s = [],
      i = {},
      n = {};
    for (const r of e) if (!r.isTransient && (r.isDefault || s.push({ location: r.location, name: r.name, icon: r.icon, useDefaultFlags: r.useDefaultFlags }), r.workspaces)) for (const o of r.workspaces) i[o.toString()] = r.id;
    for (const [r, o] of this.C.emptyWindows.entries()) n[r.toString()] = o.id;
    this.Q({ workspaces: i, emptyWindows: n }), this.O(s), (this.z = void 0);
  }
  N() {
    return [];
  }
  O(e) {
    throw new Error("not implemented");
  }
  P() {
    return {};
  }
  Q(e) {
    throw new Error("not implemented");
  }
  R() {}
};
Qp = __decorate([__param(0, fe), __param(1, ie), __param(2, ke), __param(3, ne)], Qp);
var y5 = "__$__isNewStorageMarker",
  ia = "__$__targetStorageMarker",
  ae = z("storageService"),
  Bi;
(function (t) {
  (t[(t.NONE = 0)] = "NONE"), (t[(t.SHUTDOWN = 1)] = "SHUTDOWN");
})(Bi || (Bi = {}));
var Yp;
(function (t) {
  (t[(t.APPLICATION = -1)] = "APPLICATION"), (t[(t.PROFILE = 0)] = "PROFILE"), (t[(t.WORKSPACE = 1)] = "WORKSPACE"), (t[(t.ICUBE_PROFILE = 2)] = "ICUBE_PROFILE");
})(Yp || (Yp = {}));
var Zp;
(function (t) {
  (t[(t.USER = 0)] = "USER"), (t[(t.MACHINE = 1)] = "MACHINE");
})(Zp || (Zp = {}));
function b5(t) {
  const e = t.get(ia);
  if (e)
    try {
      return JSON.parse(e);
    } catch {}
  return Object.create(null);
}
var eg = class hw extends O {
  static {
    this.a = 60 * 1e3;
  }
  constructor(e = { flushInterval: hw.a }) {
    super(),
      (this.m = e),
      (this.b = this.B(new jc())),
      (this.c = this.B(new jc())),
      (this.onDidChangeTarget = this.c.event),
      (this.f = this.B(new D())),
      (this.onWillSaveState = this.f.event),
      (this.h = this.B(new ks(() => this.n(), this.m.flushInterval))),
      (this.j = this.B(new Es())),
      (this.C = void 0),
      (this.F = void 0),
      (this.H = void 0),
      (this.J = void 0);
  }
  onDidChangeValue(e, s, i) {
    return T.filter(this.b.event, (n) => n.scope === e && (s === void 0 || n.key === s), i);
  }
  n() {
    this.j.value = Qd(() => {
      this.r() && this.flush(), this.h.schedule();
    });
  }
  r() {
    return !0;
  }
  t() {
    Xt([this.j, this.h]);
  }
  initialize() {
    return (
      this.g ||
        (this.g = (async () => {
          _i("code/willInitStorage");
          try {
            await this.Q();
          } finally {
            _i("code/didInitStorage");
          }
          this.h.schedule();
        })()),
      this.g
    );
  }
  u(e, s) {
    const { key: i, external: n } = s;
    if (i === ia) {
      switch (e) {
        case -1:
          this.H = void 0;
          break;
        case 0:
          this.F = void 0;
          break;
        case 1:
          this.C = void 0;
          break;
        case 2:
          this.J = void 0;
          break;
      }
      this.c.fire({ scope: e });
    } else this.b.fire({ scope: e, key: i, target: this.M(e)[i], external: n });
  }
  w(e) {
    this.f.fire({ reason: e });
  }
  get(e, s, i) {
    return this.R(s)?.get(e, i);
  }
  getBoolean(e, s, i) {
    return this.R(s)?.getBoolean(e, i);
  }
  getNumber(e, s, i) {
    return this.R(s)?.getNumber(e, i);
  }
  getObject(e, s, i) {
    return this.R(s)?.getObject(e, i);
  }
  storeAll(e, s) {
    this.y(() => {
      for (const i of e) this.store(i.key, i.value, i.scope, i.target, s);
    });
  }
  store(e, s, i, n, r = !1) {
    if (mt(s)) {
      this.remove(e, i, r);
      return;
    }
    this.y(() => {
      this.z(e, i, n), this.R(i)?.set(e, s, r);
    });
  }
  remove(e, s, i = !1) {
    this.y(() => {
      this.z(e, s, void 0), this.R(s)?.delete(e, i);
    });
  }
  y(e) {
    this.b.pause(), this.c.pause();
    try {
      e();
    } finally {
      this.b.resume(), this.c.resume();
    }
  }
  keys(e, s) {
    const i = [],
      n = this.M(e);
    for (const r of Object.keys(n)) n[r] === s && i.push(r);
    return i;
  }
  z(e, s, i, n = !1) {
    const r = this.M(s);
    typeof i == "number" ? r[e] !== i && ((r[e] = i), this.R(s)?.set(ia, JSON.stringify(r), n)) : typeof r[e] == "number" && (delete r[e], this.R(s)?.set(ia, JSON.stringify(r), n));
  }
  get D() {
    return this.C || (this.C = this.N(1)), this.C;
  }
  get G() {
    return this.F || (this.F = this.N(0)), this.F;
  }
  get I() {
    return this.H || (this.H = this.N(-1)), this.H;
  }
  get L() {
    return this.J || (this.J = this.N(2)), this.J;
  }
  M(e) {
    switch (e) {
      case -1:
        return this.I;
      case 0:
        return this.G;
      case 2:
        return this.L;
      default:
        return this.D;
    }
  }
  N(e) {
    const s = this.R(e);
    return s ? b5(s) : Object.create(null);
  }
  isNew(e) {
    return this.getBoolean(y5, e) === !0;
  }
  async flush(e = Bi.NONE) {
    this.f.fire({ reason: e });
    const s = this.R(-1),
      i = this.R(0),
      n = this.R(1);
    switch (e) {
      case Bi.NONE:
        await Ze.settled([s?.whenFlushed() ?? Promise.resolve(), i?.whenFlushed() ?? Promise.resolve(), n?.whenFlushed() ?? Promise.resolve()]);
        break;
      case Bi.SHUTDOWN:
        await Ze.settled([s?.flush(0) ?? Promise.resolve(), i?.flush(0) ?? Promise.resolve(), n?.flush(0) ?? Promise.resolve()]);
        break;
    }
  }
  async log() {
    const e = this.R(-1)?.items ?? new Map(),
      s = this.R(0)?.items ?? new Map(),
      i = this.R(1)?.items ?? new Map();
    return E5(e, s, i, this.S(-1) ?? "", this.S(0) ?? "", this.S(1) ?? "");
  }
  async optimize(e) {
    return await this.flush(), this.R(e)?.optimize();
  }
  async switch(e, s) {
    return this.w(Bi.NONE), Xp(e) ? this.U(e, s) : this.W(e, s);
  }
  O(e, s) {
    return !(e.id === s.id || (na(s) && na(e)));
  }
  P(e, s, i) {
    this.y(() => {
      const n = new Set();
      for (const [r, o] of e) n.add(r), s.get(r) !== o && this.u(i, { key: r, external: !0 });
      for (const [r] of s.items) n.has(r) || this.u(i, { key: r, external: !0 });
    });
  }
};
function na(t) {
  return t.isDefault || !!t.useDefaultFlags?.globalState;
}
async function E5(t, e, s, i, n, r) {
  const o = (g) => {
      try {
        return JSON.parse(g);
      } catch {
        return g;
      }
    },
    a = new Map(),
    c = new Map();
  t.forEach((g, m) => {
    a.set(m, g), c.set(m, o(g));
  });
  const l = new Map(),
    h = new Map();
  e.forEach((g, m) => {
    l.set(m, g), h.set(m, o(g));
  });
  const u = new Map(),
    f = new Map();
  s.forEach((g, m) => {
    u.set(m, g), f.set(m, o(g));
  }),
    console.group(i !== n ? `Storage: Application (path: ${i})` : `Storage: Application & Profile (path: ${i}, default profile)`);
  const d = [];
  if (
    (a.forEach((g, m) => {
      d.push({ key: m, value: g });
    }),
    console.table(d),
    console.groupEnd(),
    console.log(c),
    i !== n)
  ) {
    console.group(`Storage: Profile (path: ${n}, profile specific)`);
    const g = [];
    l.forEach((m, v) => {
      g.push({ key: v, value: m });
    }),
      console.table(g),
      console.groupEnd(),
      console.log(h);
  }
  console.group(`Storage: Workspace (path: ${r})`);
  const p = [];
  u.forEach((g, m) => {
    p.push({ key: m, value: g });
  }),
    console.table(p),
    console.groupEnd(),
    console.log(f);
}
var M3 = z("remoteStorageService"),
  ra = class extends O {
    constructor(e, s) {
      super(),
        (this.a = new D()),
        (this.onDidChangeEnablement = this.a.event),
        (this.b = this.B(new S5(e))),
        this.B(this.b.onDidChange((i) => this.a.fire({ extensions: i, source: "storage" }))),
        this.B(
          s.onDidInstallExtensions((i) =>
            i.forEach(({ local: n, operation: r }) => {
              n && r === 4 && this.f(n.identifier);
            }),
          ),
        );
    }
    async enableExtension(e, s) {
      return this.f(e) ? (this.a.fire({ extensions: [e], source: s }), !0) : !1;
    }
    async disableExtension(e, s) {
      return this.c(e) ? (this.a.fire({ extensions: [e], source: s }), !0) : !1;
    }
    getDisabledExtensions() {
      return this.h(vl);
    }
    async getDisabledExtensionsAsync() {
      return this.getDisabledExtensions();
    }
    c(e) {
      const s = this.getDisabledExtensions();
      return s.every((i) => !G(i, e)) ? (s.push(e), this.g(s), !0) : !1;
    }
    f(e) {
      const s = this.getDisabledExtensions();
      for (let i = 0; i < s.length; i++) {
        const n = s[i];
        if (G(n, e)) return s.splice(i, 1), this.g(s), !0;
      }
      return !1;
    }
    g(e) {
      this.j(vl, e);
    }
    h(e) {
      return this.b.get(e, 0);
    }
    j(e, s) {
      this.b.set(e, s, 0);
    }
  };
ra = __decorate([__param(0, ae), __param(1, Vs)], ra);
var S5 = class extends O {
    constructor(t) {
      super(), (this.c = t), (this.a = Object.create(null)), (this.b = this.B(new D())), (this.onDidChange = this.b.event), this.B(t.onDidChangeValue(0, void 0, this.B(new ye()))((e) => this.f(e)));
    }
    get(t, e) {
      let s;
      return e === 0 ? (mt(this.a[t]) && (this.a[t] = this.g(t, e)), (s = this.a[t])) : (s = this.g(t, e)), JSON.parse(s);
    }
    set(t, e, s) {
      const i = JSON.stringify(e.map(({ id: r, uuid: o }) => ({ id: r, uuid: o })));
      this.g(t, s) !== i && (s === 0 && (e.length ? (this.a[t] = i) : delete this.a[t]), this.h(t, e.length ? i : void 0, s));
    }
    f(t) {
      if (!mt(this.a[t.key]) && this.g(t.key, t.scope) !== this.a[t.key]) {
        const s = this.get(t.key, t.scope);
        delete this.a[t.key];
        const i = this.get(t.key, t.scope),
          n = s.filter((o) => !i.some((a) => G(o, a))),
          r = i.filter((o) => !s.some((a) => G(a, o)));
        (n.length || r.length) && this.b.fire([...n, ...r]);
      }
    }
    g(t, e) {
      return this.c.get(t, e, "[]");
    }
    h(t, e, s) {
      e ? this.c.store(t, e, s, 1) : this.c.remove(t, s);
    }
  },
  ih = "Offline";
function $5(t) {
  return t instanceof x5 ? !0 : t instanceof Error && t.name === ih && t.message === ih;
}
var x5 = class extends Error {
    constructor() {
      super(ih), (this.name = this.message);
    }
  },
  Ir;
(function (t) {
  (t[(t.Ignore = 0)] = "Ignore"), (t[(t.Info = 1)] = "Info"), (t[(t.Warning = 2)] = "Warning"), (t[(t.Error = 3)] = "Error");
})(Ir || (Ir = {})),
  (function (t) {
    const e = "error",
      s = "warning",
      i = "warn",
      n = "info",
      r = "ignore";
    function o(c) {
      return c ? (Ci(e, c) ? t.Error : Ci(s, c) || Ci(i, c) ? t.Warning : Ci(n, c) ? t.Info : t.Ignore) : t.Ignore;
    }
    t.fromValue = o;
    function a(c) {
      switch (c) {
        case t.Error:
          return e;
        case t.Warning:
          return s;
        case t.Info:
          return n;
        default:
          return r;
      }
    }
    t.toString = a;
  })(Ir || (Ir = {}));
var bt = Ir,
  oa = {},
  ce = { exports: oa };
(function (t, e) {
  if (typeof oa == "object" && typeof ce == "object") ce.exports = e();
  else if (typeof define == "function" && define.amd) define([], e);
  else {
    var s = e();
    for (var i in s) (typeof oa == "object" ? oa : t)[i] = s[i];
  }
})(typeof self < "u" ? self : void 0, function () {
  return (function (t) {
    var e = {};
    function s(i) {
      if (e[i]) return e[i].exports;
      var n = (e[i] = { i, l: !1, exports: {} });
      return t[i].call(n.exports, n, n.exports, s), (n.l = !0), n.exports;
    }
    return (
      (s.m = t),
      (s.c = e),
      (s.d = function (i, n, r) {
        s.o(i, n) || Object.defineProperty(i, n, { enumerable: !0, get: r });
      }),
      (s.r = function (i) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: !0 });
      }),
      (s.t = function (i, n) {
        if ((1 & n && (i = s(i)), 8 & n || (4 & n && typeof i == "object" && i && i.__esModule))) return i;
        var r = Object.create(null);
        if ((s.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: i }), 2 & n && typeof i != "string"))
          for (var o in i)
            s.d(
              r,
              o,
              function (a) {
                return i[a];
              }.bind(null, o),
            );
        return r;
      }),
      (s.n = function (i) {
        var n =
          i && i.__esModule
            ? function () {
                return i.default;
              }
            : function () {
                return i;
              };
        return s.d(n, "a", n), n;
      }),
      (s.o = function (i, n) {
        return Object.prototype.hasOwnProperty.call(i, n);
      }),
      (s.p = ""),
      s((s.s = 0))
    );
  })([
    function (t, e, s) {
      (function (i) {
        var n;
        (e = t.exports = $e),
          (n =
            typeof i == "object" && i.env && i.env.NODE_DEBUG && /\bsemver\b/i.test(i.env.NODE_DEBUG)
              ? function () {
                  var y = Array.prototype.slice.call(arguments, 0);
                  y.unshift("SEMVER"), console.log.apply(console, y);
                }
              : function () {}),
          (e.SEMVER_SPEC_VERSION = "2.0.0");
        var r = 256,
          o = Number.MAX_SAFE_INTEGER || 9007199254740991,
          a = (e.re = []),
          c = (e.src = []),
          l = 0,
          h = l++;
        c[h] = "0|[1-9]\\d*";
        var u = l++;
        c[u] = "[0-9]+";
        var f = l++;
        c[f] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
        var d = l++;
        c[d] = "(" + c[h] + ")\\.(" + c[h] + ")\\.(" + c[h] + ")";
        var p = l++;
        c[p] = "(" + c[u] + ")\\.(" + c[u] + ")\\.(" + c[u] + ")";
        var g = l++;
        c[g] = "(?:" + c[h] + "|" + c[f] + ")";
        var m = l++;
        c[m] = "(?:" + c[u] + "|" + c[f] + ")";
        var v = l++;
        c[v] = "(?:-(" + c[g] + "(?:\\." + c[g] + ")*))";
        var b = l++;
        c[b] = "(?:-?(" + c[m] + "(?:\\." + c[m] + ")*))";
        var E = l++;
        c[E] = "[0-9A-Za-z-]+";
        var $ = l++;
        c[$] = "(?:\\+(" + c[E] + "(?:\\." + c[E] + ")*))";
        var P = l++,
          U = "v?" + c[d] + c[v] + "?" + c[$] + "?";
        c[P] = "^" + U + "$";
        var Q = "[v=\\s]*" + c[p] + c[b] + "?" + c[$] + "?",
          k = l++;
        c[k] = "^" + Q + "$";
        var I = l++;
        c[I] = "((?:<|>)?=?)";
        var H = l++;
        c[H] = c[u] + "|x|X|\\*";
        var B = l++;
        c[B] = c[h] + "|x|X|\\*";
        var j = l++;
        c[j] = "[v=\\s]*(" + c[B] + ")(?:\\.(" + c[B] + ")(?:\\.(" + c[B] + ")(?:" + c[v] + ")?" + c[$] + "?)?)?";
        var Z = l++;
        c[Z] = "[v=\\s]*(" + c[H] + ")(?:\\.(" + c[H] + ")(?:\\.(" + c[H] + ")(?:" + c[b] + ")?" + c[$] + "?)?)?";
        var A = l++;
        c[A] = "^" + c[I] + "\\s*" + c[j] + "$";
        var R = l++;
        c[R] = "^" + c[I] + "\\s*" + c[Z] + "$";
        var F = l++;
        c[F] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
        var N = l++;
        c[N] = "(?:~>?)";
        var W = l++;
        (c[W] = "(\\s*)" + c[N] + "\\s+"), (a[W] = new RegExp(c[W], "g"));
        var se = l++;
        c[se] = "^" + c[N] + c[j] + "$";
        var pe = l++;
        c[pe] = "^" + c[N] + c[Z] + "$";
        var Ue = l++;
        c[Ue] = "(?:\\^)";
        var He = l++;
        (c[He] = "(\\s*)" + c[Ue] + "\\s+"), (a[He] = new RegExp(c[He], "g"));
        var Ns = l++;
        c[Ns] = "^" + c[Ue] + c[j] + "$";
        var yi = l++;
        c[yi] = "^" + c[Ue] + c[Z] + "$";
        var Ts = l++;
        c[Ts] = "^" + c[I] + "\\s*(" + Q + ")$|^$";
        var tn = l++;
        c[tn] = "^" + c[I] + "\\s*(" + U + ")$|^$";
        var ys = l++;
        (c[ys] = "(\\s*)" + c[I] + "\\s*(" + Q + "|" + c[j] + ")"), (a[ys] = new RegExp(c[ys], "g"));
        var no = l++;
        c[no] = "^\\s*(" + c[j] + ")\\s+-\\s+(" + c[j] + ")\\s*$";
        var ro = l++;
        c[ro] = "^\\s*(" + c[Z] + ")\\s+-\\s+(" + c[Z] + ")\\s*$";
        var Tf = l++;
        c[Tf] = "(<|>)?=?\\s*\\*";
        for (var bi = 0; bi < 35; bi++) n(bi, c[bi]), a[bi] || (a[bi] = new RegExp(c[bi]));
        function Ei(y, S) {
          if (y instanceof $e) return y;
          if (typeof y != "string" || y.length > r || !(S ? a[k] : a[P]).test(y)) return null;
          try {
            return new $e(y, S);
          } catch {
            return null;
          }
        }
        function $e(y, S) {
          if (y instanceof $e) {
            if (y.loose === S) return y;
            y = y.version;
          } else if (typeof y != "string") throw new TypeError("Invalid Version: " + y);
          if (y.length > r) throw new TypeError("version is longer than " + r + " characters");
          if (!(this instanceof $e)) return new $e(y, S);
          n("SemVer", y, S), (this.loose = S);
          var x = y.trim().match(S ? a[k] : a[P]);
          if (!x) throw new TypeError("Invalid Version: " + y);
          if (((this.raw = y), (this.major = +x[1]), (this.minor = +x[2]), (this.patch = +x[3]), this.major > o || this.major < 0)) throw new TypeError("Invalid major version");
          if (this.minor > o || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > o || this.patch < 0) throw new TypeError("Invalid patch version");
          x[4]
            ? (this.prerelease = x[4].split(".").map(function (q) {
                if (/^[0-9]+$/.test(q)) {
                  var K = +q;
                  if (K >= 0 && K < o) return K;
                }
                return q;
              }))
            : (this.prerelease = []),
            (this.build = x[5] ? x[5].split(".") : []),
            this.format();
        }
        (e.parse = Ei),
          (e.valid = function (y, S) {
            var x = Ei(y, S);
            return x ? x.version : null;
          }),
          (e.clean = function (y, S) {
            var x = Ei(y.trim().replace(/^[=v]+/, ""), S);
            return x ? x.version : null;
          }),
          (e.SemVer = $e),
          ($e.prototype.format = function () {
            return (this.version = this.major + "." + this.minor + "." + this.patch), this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
          }),
          ($e.prototype.toString = function () {
            return this.version;
          }),
          ($e.prototype.compare = function (y) {
            return n("SemVer.compare", this.version, this.loose, y), y instanceof $e || (y = new $e(y, this.loose)), this.compareMain(y) || this.comparePre(y);
          }),
          ($e.prototype.compareMain = function (y) {
            return y instanceof $e || (y = new $e(y, this.loose)), sn(this.major, y.major) || sn(this.minor, y.minor) || sn(this.patch, y.patch);
          }),
          ($e.prototype.comparePre = function (y) {
            if ((y instanceof $e || (y = new $e(y, this.loose)), this.prerelease.length && !y.prerelease.length)) return -1;
            if (!this.prerelease.length && y.prerelease.length) return 1;
            if (!this.prerelease.length && !y.prerelease.length) return 0;
            var S = 0;
            do {
              var x = this.prerelease[S],
                q = y.prerelease[S];
              if ((n("prerelease compare", S, x, q), x === void 0 && q === void 0)) return 0;
              if (q === void 0) return 1;
              if (x === void 0) return -1;
              if (x !== q) return sn(x, q);
            } while (++S);
          }),
          ($e.prototype.inc = function (y, S) {
            switch (y) {
              case "premajor":
                (this.prerelease.length = 0), (this.patch = 0), (this.minor = 0), this.major++, this.inc("pre", S);
                break;
              case "preminor":
                (this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc("pre", S);
                break;
              case "prepatch":
                (this.prerelease.length = 0), this.inc("patch", S), this.inc("pre", S);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", S), this.inc("pre", S);
                break;
              case "major":
                (this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0) || this.major++, (this.minor = 0), (this.patch = 0), (this.prerelease = []);
                break;
              case "minor":
                (this.patch === 0 && this.prerelease.length !== 0) || this.minor++, (this.patch = 0), (this.prerelease = []);
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
                break;
              case "pre":
                if (this.prerelease.length === 0) this.prerelease = [0];
                else {
                  for (var x = this.prerelease.length; --x >= 0; ) typeof this.prerelease[x] == "number" && (this.prerelease[x]++, (x = -2));
                  x === -1 && this.prerelease.push(0);
                }
                S && (this.prerelease[0] === S ? isNaN(this.prerelease[1]) && (this.prerelease = [S, 0]) : (this.prerelease = [S, 0]));
                break;
              default:
                throw new Error("invalid increment argument: " + y);
            }
            return this.format(), (this.raw = this.version), this;
          }),
          (e.inc = function (y, S, x, q) {
            typeof x == "string" && ((q = x), (x = void 0));
            try {
              return new $e(y, x).inc(S, q).version;
            } catch {
              return null;
            }
          }),
          (e.diff = function (y, S) {
            if (gc(y, S)) return null;
            var x = Ei(y),
              q = Ei(S);
            if (x.prerelease.length || q.prerelease.length) {
              for (var K in x) if ((K === "major" || K === "minor" || K === "patch") && x[K] !== q[K]) return "pre" + K;
              return "prerelease";
            }
            for (var K in x) if ((K === "major" || K === "minor" || K === "patch") && x[K] !== q[K]) return K;
          }),
          (e.compareIdentifiers = sn);
        var jf = /^[0-9]+$/;
        function sn(y, S) {
          var x = jf.test(y),
            q = jf.test(S);
          return x && q && ((y = +y), (S = +S)), x && !q ? -1 : q && !x ? 1 : y < S ? -1 : y > S ? 1 : 0;
        }
        function js(y, S, x) {
          return new $e(y, x).compare(new $e(S, x));
        }
        function oo(y, S, x) {
          return js(y, S, x) > 0;
        }
        function ao(y, S, x) {
          return js(y, S, x) < 0;
        }
        function gc(y, S, x) {
          return js(y, S, x) === 0;
        }
        function Ff(y, S, x) {
          return js(y, S, x) !== 0;
        }
        function mc(y, S, x) {
          return js(y, S, x) >= 0;
        }
        function wc(y, S, x) {
          return js(y, S, x) <= 0;
        }
        function co(y, S, x, q) {
          var K;
          switch (S) {
            case "===":
              typeof y == "object" && (y = y.version), typeof x == "object" && (x = x.version), (K = y === x);
              break;
            case "!==":
              typeof y == "object" && (y = y.version), typeof x == "object" && (x = x.version), (K = y !== x);
              break;
            case "":
            case "=":
            case "==":
              K = gc(y, x, q);
              break;
            case "!=":
              K = Ff(y, x, q);
              break;
            case ">":
              K = oo(y, x, q);
              break;
            case ">=":
              K = mc(y, x, q);
              break;
            case "<":
              K = ao(y, x, q);
              break;
            case "<=":
              K = wc(y, x, q);
              break;
            default:
              throw new TypeError("Invalid operator: " + S);
          }
          return K;
        }
        function is(y, S) {
          if (y instanceof is) {
            if (y.loose === S) return y;
            y = y.value;
          }
          if (!(this instanceof is)) return new is(y, S);
          n("comparator", y, S), (this.loose = S), this.parse(y), this.semver === Gn ? (this.value = "") : (this.value = this.operator + this.semver.version), n("comp", this);
        }
        (e.rcompareIdentifiers = function (y, S) {
          return sn(S, y);
        }),
          (e.major = function (y, S) {
            return new $e(y, S).major;
          }),
          (e.minor = function (y, S) {
            return new $e(y, S).minor;
          }),
          (e.patch = function (y, S) {
            return new $e(y, S).patch;
          }),
          (e.compare = js),
          (e.compareLoose = function (y, S) {
            return js(y, S, !0);
          }),
          (e.rcompare = function (y, S, x) {
            return js(S, y, x);
          }),
          (e.sort = function (y, S) {
            return y.sort(function (x, q) {
              return e.compare(x, q, S);
            });
          }),
          (e.rsort = function (y, S) {
            return y.sort(function (x, q) {
              return e.rcompare(x, q, S);
            });
          }),
          (e.gt = oo),
          (e.lt = ao),
          (e.eq = gc),
          (e.neq = Ff),
          (e.gte = mc),
          (e.lte = wc),
          (e.cmp = co),
          (e.Comparator = is);
        var Gn = {};
        function qe(y, S) {
          if (y instanceof qe) return y.loose === S ? y : new qe(y.raw, S);
          if (y instanceof is) return new qe(y.value, S);
          if (!(this instanceof qe)) return new qe(y, S);
          if (
            ((this.loose = S),
            (this.raw = y),
            (this.set = y
              .split(/\s*\|\|\s*/)
              .map(function (x) {
                return this.parseRange(x.trim());
              }, this)
              .filter(function (x) {
                return x.length;
              })),
            !this.set.length)
          )
            throw new TypeError("Invalid SemVer Range: " + y);
          this.format();
        }
        function At(y) {
          return !y || y.toLowerCase() === "x" || y === "*";
        }
        function pw(y, S, x, q, K, lt, xe, Mt, Ge, xt, bs, Je, pt) {
          return (
            (S = At(x) ? "" : At(q) ? ">=" + x + ".0.0" : At(K) ? ">=" + x + "." + q + ".0" : ">=" + S) +
            " " +
            (Mt = At(Ge) ? "" : At(xt) ? "<" + (+Ge + 1) + ".0.0" : At(bs) ? "<" + Ge + "." + (+xt + 1) + ".0" : Je ? "<=" + Ge + "." + xt + "." + bs + "-" + Je : "<=" + Mt)
          ).trim();
        }
        function gw(y, S) {
          for (var x = 0; x < y.length; x++) if (!y[x].test(S)) return !1;
          if (S.prerelease.length) {
            for (x = 0; x < y.length; x++)
              if ((n(y[x].semver), y[x].semver !== Gn && y[x].semver.prerelease.length > 0)) {
                var q = y[x].semver;
                if (q.major === S.major && q.minor === S.minor && q.patch === S.patch) return !0;
              }
            return !1;
          }
          return !0;
        }
        function lo(y, S, x) {
          try {
            S = new qe(S, x);
          } catch {
            return !1;
          }
          return S.test(y);
        }
        function vc(y, S, x, q) {
          var K, lt, xe, Mt, Ge;
          switch (((y = new $e(y, q)), (S = new qe(S, q)), x)) {
            case ">":
              (K = oo), (lt = wc), (xe = ao), (Mt = ">"), (Ge = ">=");
              break;
            case "<":
              (K = ao), (lt = mc), (xe = oo), (Mt = "<"), (Ge = "<=");
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (lo(y, S, q)) return !1;
          for (var xt = 0; xt < S.set.length; ++xt) {
            var bs = S.set[xt],
              Je = null,
              pt = null;
            if (
              (bs.forEach(function (Ut) {
                Ut.semver === Gn && (Ut = new is(">=0.0.0")), (Je = Je || Ut), (pt = pt || Ut), K(Ut.semver, Je.semver, q) ? (Je = Ut) : xe(Ut.semver, pt.semver, q) && (pt = Ut);
              }),
              Je.operator === Mt || Je.operator === Ge || ((!pt.operator || pt.operator === Mt) && lt(y, pt.semver)) || (pt.operator === Ge && xe(y, pt.semver)))
            )
              return !1;
          }
          return !0;
        }
        (is.prototype.parse = function (y) {
          var S = this.loose ? a[Ts] : a[tn],
            x = y.match(S);
          if (!x) throw new TypeError("Invalid comparator: " + y);
          (this.operator = x[1]), this.operator === "=" && (this.operator = ""), x[2] ? (this.semver = new $e(x[2], this.loose)) : (this.semver = Gn);
        }),
          (is.prototype.toString = function () {
            return this.value;
          }),
          (is.prototype.test = function (y) {
            return n("Comparator.test", y, this.loose), this.semver === Gn || (typeof y == "string" && (y = new $e(y, this.loose)), co(y, this.operator, this.semver, this.loose));
          }),
          (is.prototype.intersects = function (y, S) {
            if (!(y instanceof is)) throw new TypeError("a Comparator is required");
            var x;
            if (this.operator === "") return (x = new qe(y.value, S)), lo(this.value, x, S);
            if (y.operator === "") return (x = new qe(this.value, S)), lo(y.semver, x, S);
            var q = !((this.operator !== ">=" && this.operator !== ">") || (y.operator !== ">=" && y.operator !== ">")),
              K = !((this.operator !== "<=" && this.operator !== "<") || (y.operator !== "<=" && y.operator !== "<")),
              lt = this.semver.version === y.semver.version,
              xe = !((this.operator !== ">=" && this.operator !== "<=") || (y.operator !== ">=" && y.operator !== "<=")),
              Mt = co(this.semver, "<", y.semver, S) && (this.operator === ">=" || this.operator === ">") && (y.operator === "<=" || y.operator === "<"),
              Ge = co(this.semver, ">", y.semver, S) && (this.operator === "<=" || this.operator === "<") && (y.operator === ">=" || y.operator === ">");
            return q || K || (lt && xe) || Mt || Ge;
          }),
          (e.Range = qe),
          (qe.prototype.format = function () {
            return (
              (this.range = this.set
                .map(function (y) {
                  return y.join(" ").trim();
                })
                .join("||")
                .trim()),
              this.range
            );
          }),
          (qe.prototype.toString = function () {
            return this.range;
          }),
          (qe.prototype.parseRange = function (y) {
            var S = this.loose;
            (y = y.trim()), n("range", y, S);
            var x = S ? a[ro] : a[no];
            (y = y.replace(x, pw)), n("hyphen replace", y), (y = y.replace(a[ys], "$1$2$3")), n("comparator trim", y, a[ys]), (y = (y = (y = y.replace(a[W], "$1~")).replace(a[He], "$1^")).split(/\s+/).join(" "));
            var q = S ? a[Ts] : a[tn],
              K = y
                .split(" ")
                .map(function (lt) {
                  return (function (xe, Mt) {
                    return (
                      n("comp", xe),
                      (xe = (function (Ge, xt) {
                        return Ge.trim()
                          .split(/\s+/)
                          .map(function (bs) {
                            return (function (Je, pt) {
                              n("caret", Je, pt);
                              var Ut = pt ? a[yi] : a[Ns];
                              return Je.replace(Ut, function (cs, ee, le, Ae, Fe) {
                                var gt;
                                return (
                                  n("caret", Je, cs, ee, le, Ae, Fe),
                                  At(ee)
                                    ? (gt = "")
                                    : At(le)
                                      ? (gt = ">=" + ee + ".0.0 <" + (+ee + 1) + ".0.0")
                                      : At(Ae)
                                        ? (gt = ee === "0" ? ">=" + ee + "." + le + ".0 <" + ee + "." + (+le + 1) + ".0" : ">=" + ee + "." + le + ".0 <" + (+ee + 1) + ".0.0")
                                        : Fe
                                          ? (n("replaceCaret pr", Fe),
                                            Fe.charAt(0) !== "-" && (Fe = "-" + Fe),
                                            (gt =
                                              ee === "0"
                                                ? le === "0"
                                                  ? ">=" + ee + "." + le + "." + Ae + Fe + " <" + ee + "." + le + "." + (+Ae + 1)
                                                  : ">=" + ee + "." + le + "." + Ae + Fe + " <" + ee + "." + (+le + 1) + ".0"
                                                : ">=" + ee + "." + le + "." + Ae + Fe + " <" + (+ee + 1) + ".0.0"))
                                          : (n("no pr"),
                                            (gt =
                                              ee === "0"
                                                ? le === "0"
                                                  ? ">=" + ee + "." + le + "." + Ae + " <" + ee + "." + le + "." + (+Ae + 1)
                                                  : ">=" + ee + "." + le + "." + Ae + " <" + ee + "." + (+le + 1) + ".0"
                                                : ">=" + ee + "." + le + "." + Ae + " <" + (+ee + 1) + ".0.0")),
                                  n("caret return", gt),
                                  gt
                                );
                              });
                            })(bs, xt);
                          })
                          .join(" ");
                      })(xe, Mt)),
                      n("caret", xe),
                      (xe = (function (Ge, xt) {
                        return Ge.trim()
                          .split(/\s+/)
                          .map(function (bs) {
                            return (function (Je, pt) {
                              var Ut = pt ? a[pe] : a[se];
                              return Je.replace(Ut, function (cs, ee, le, Ae, Fe) {
                                var gt;
                                return (
                                  n("tilde", Je, cs, ee, le, Ae, Fe),
                                  At(ee)
                                    ? (gt = "")
                                    : At(le)
                                      ? (gt = ">=" + ee + ".0.0 <" + (+ee + 1) + ".0.0")
                                      : At(Ae)
                                        ? (gt = ">=" + ee + "." + le + ".0 <" + ee + "." + (+le + 1) + ".0")
                                        : Fe
                                          ? (n("replaceTilde pr", Fe), Fe.charAt(0) !== "-" && (Fe = "-" + Fe), (gt = ">=" + ee + "." + le + "." + Ae + Fe + " <" + ee + "." + (+le + 1) + ".0"))
                                          : (gt = ">=" + ee + "." + le + "." + Ae + " <" + ee + "." + (+le + 1) + ".0"),
                                  n("tilde return", gt),
                                  gt
                                );
                              });
                            })(bs, xt);
                          })
                          .join(" ");
                      })(xe, Mt)),
                      n("tildes", xe),
                      (xe = (function (Ge, xt) {
                        return (
                          n("replaceXRanges", Ge, xt),
                          Ge.split(/\s+/)
                            .map(function (bs) {
                              return (function (Je, pt) {
                                Je = Je.trim();
                                var Ut = pt ? a[R] : a[A];
                                return Je.replace(Ut, function (cs, ee, le, Ae, Fe, gt) {
                                  n("xRange", Je, cs, ee, le, Ae, Fe, gt);
                                  var Mf = At(le),
                                    Jn = Mf || At(Ae),
                                    Kn = Jn || At(Fe);
                                  return (
                                    ee === "=" && Kn && (ee = ""),
                                    Mf
                                      ? (cs = ee === ">" || ee === "<" ? "<0.0.0" : "*")
                                      : ee && Kn
                                        ? (Jn && (Ae = 0),
                                          Kn && (Fe = 0),
                                          ee === ">" ? ((ee = ">="), Jn ? ((le = +le + 1), (Ae = 0), (Fe = 0)) : Kn && ((Ae = +Ae + 1), (Fe = 0))) : ee === "<=" && ((ee = "<"), Jn ? (le = +le + 1) : (Ae = +Ae + 1)),
                                          (cs = ee + le + "." + Ae + "." + Fe))
                                        : Jn
                                          ? (cs = ">=" + le + ".0.0 <" + (+le + 1) + ".0.0")
                                          : Kn && (cs = ">=" + le + "." + Ae + ".0 <" + le + "." + (+Ae + 1) + ".0"),
                                    n("xRange return", cs),
                                    cs
                                  );
                                });
                              })(bs, xt);
                            })
                            .join(" ")
                        );
                      })(xe, Mt)),
                      n("xrange", xe),
                      (xe = (function (Ge, xt) {
                        return n("replaceStars", Ge, xt), Ge.trim().replace(a[Tf], "");
                      })(xe, Mt)),
                      n("stars", xe),
                      xe
                    );
                  })(lt, S);
                })
                .join(" ")
                .split(/\s+/);
            return (
              this.loose &&
                (K = K.filter(function (lt) {
                  return !!lt.match(q);
                })),
              (K = K.map(function (lt) {
                return new is(lt, S);
              }))
            );
          }),
          (qe.prototype.intersects = function (y, S) {
            if (!(y instanceof qe)) throw new TypeError("a Range is required");
            return this.set.some(function (x) {
              return x.every(function (q) {
                return y.set.some(function (K) {
                  return K.every(function (lt) {
                    return q.intersects(lt, S);
                  });
                });
              });
            });
          }),
          (e.toComparators = function (y, S) {
            return new qe(y, S).set.map(function (x) {
              return x
                .map(function (q) {
                  return q.value;
                })
                .join(" ")
                .trim()
                .split(" ");
            });
          }),
          (qe.prototype.test = function (y) {
            if (!y) return !1;
            typeof y == "string" && (y = new $e(y, this.loose));
            for (var S = 0; S < this.set.length; S++) if (gw(this.set[S], y)) return !0;
            return !1;
          }),
          (e.satisfies = lo),
          (e.maxSatisfying = function (y, S, x) {
            var q = null,
              K = null;
            try {
              var lt = new qe(S, x);
            } catch {
              return null;
            }
            return (
              y.forEach(function (xe) {
                lt.test(xe) && ((q && K.compare(xe) !== -1) || (K = new $e((q = xe), x)));
              }),
              q
            );
          }),
          (e.minSatisfying = function (y, S, x) {
            var q = null,
              K = null;
            try {
              var lt = new qe(S, x);
            } catch {
              return null;
            }
            return (
              y.forEach(function (xe) {
                lt.test(xe) && ((q && K.compare(xe) !== 1) || (K = new $e((q = xe), x)));
              }),
              q
            );
          }),
          (e.validRange = function (y, S) {
            try {
              return new qe(y, S).range || "*";
            } catch {
              return null;
            }
          }),
          (e.ltr = function (y, S, x) {
            return vc(y, S, "<", x);
          }),
          (e.gtr = function (y, S, x) {
            return vc(y, S, ">", x);
          }),
          (e.outside = vc),
          (e.prerelease = function (y, S) {
            var x = Ei(y, S);
            return x && x.prerelease.length ? x.prerelease : null;
          }),
          (e.intersects = function (y, S, x) {
            return (y = new qe(y, x)), (S = new qe(S, x)), y.intersects(S);
          }),
          (e.coerce = function (y) {
            if (y instanceof $e) return y;
            if (typeof y != "string") return null;
            var S = y.match(a[F]);
            return S == null ? null : Ei((S[1] || "0") + "." + (S[2] || "0") + "." + (S[3] || "0"));
          });
      }).call(this, s(1));
    },
    function (t, e) {
      var s,
        i,
        n = (t.exports = {});
      function r() {
        throw new Error("setTimeout has not been defined");
      }
      function o() {
        throw new Error("clearTimeout has not been defined");
      }
      function a(m) {
        if (s === setTimeout) return setTimeout(m, 0);
        if ((s === r || !s) && setTimeout) return (s = setTimeout), setTimeout(m, 0);
        try {
          return s(m, 0);
        } catch {
          try {
            return s.call(null, m, 0);
          } catch {
            return s.call(this, m, 0);
          }
        }
      }
      (function () {
        try {
          s = typeof setTimeout == "function" ? setTimeout : r;
        } catch {
          s = r;
        }
        try {
          i = typeof clearTimeout == "function" ? clearTimeout : o;
        } catch {
          i = o;
        }
      })();
      var c,
        l = [],
        h = !1,
        u = -1;
      function f() {
        h && c && ((h = !1), c.length ? (l = c.concat(l)) : (u = -1), l.length && d());
      }
      function d() {
        if (!h) {
          var m = a(f);
          h = !0;
          for (var v = l.length; v; ) {
            for (c = l, l = []; ++u < v; ) c && c[u].run();
            (u = -1), (v = l.length);
          }
          (c = null),
            (h = !1),
            (function (b) {
              if (i === clearTimeout) return clearTimeout(b);
              if ((i === o || !i) && clearTimeout) return (i = clearTimeout), clearTimeout(b);
              try {
                i(b);
              } catch {
                try {
                  return i.call(null, b);
                } catch {
                  return i.call(this, b);
                }
              }
            })(m);
        }
      }
      function p(m, v) {
        (this.fun = m), (this.array = v);
      }
      function g() {}
      (n.nextTick = function (m) {
        var v = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var b = 1; b < arguments.length; b++) v[b - 1] = arguments[b];
        l.push(new p(m, v)), l.length !== 1 || h || a(d);
      }),
        (p.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (n.title = "browser"),
        (n.browser = !0),
        (n.env = {}),
        (n.argv = []),
        (n.version = ""),
        (n.versions = {}),
        (n.on = g),
        (n.addListener = g),
        (n.once = g),
        (n.off = g),
        (n.removeListener = g),
        (n.removeAllListeners = g),
        (n.emit = g),
        (n.prependListener = g),
        (n.prependOnceListener = g),
        (n.listeners = function (m) {
          return [];
        }),
        (n.binding = function (m) {
          throw new Error("process.binding is not supported");
        }),
        (n.cwd = function () {
          return "/";
        }),
        (n.chdir = function (m) {
          throw new Error("process.chdir is not supported");
        }),
        (n.umask = function () {
          return 0;
        });
    },
  ]);
});
var _3 = ce.exports.SEMVER_SPEC_VERSION,
  B3 = ce.exports.parse,
  C5 = ce.exports.valid,
  z3 = ce.exports.coerce,
  q3 = ce.exports.clean,
  V3 = ce.exports.inc,
  W3 = ce.exports.major,
  H3 = ce.exports.minor,
  G3 = ce.exports.patch,
  J3 = ce.exports.prerelease,
  aa = ce.exports.gt,
  K3 = ce.exports.gte,
  X3 = ce.exports.lt,
  Q3 = ce.exports.lte,
  k5 = ce.exports.eq,
  Y3 = ce.exports.neq,
  Z3 = ce.exports.cmp,
  eE = ce.exports.compare,
  tg = ce.exports.rcompare,
  tE = ce.exports.compareIdentifiers,
  sE = ce.exports.rcompareIdentifiers,
  iE = ce.exports.compareBuild,
  nE = ce.exports.sort,
  rE = ce.exports.rsort,
  oE = ce.exports.diff,
  aE = ce.exports.validRange,
  cE = ce.exports.satisfies,
  lE = ce.exports.maxSatisfying,
  hE = ce.exports.minSatisfying,
  uE = ce.exports.minVersion,
  fE = ce.exports.gtr,
  dE = ce.exports.ltr,
  pE = ce.exports.outside,
  gE = ce.exports.intersects,
  mE = ce.exports.SemVer,
  wE = ce.exports.Comparator,
  vE = ce.exports.Range,
  D5 = {
    activeComment: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts" },
    aiRelatedInformation: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts" },
    aiTextSearchProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts" },
    aiTextSearchProviderNew: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProviderNew.d.ts" },
    attributableCoverage: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.attributableCoverage.d.ts" },
    authLearnMore: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts" },
    authSession: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts" },
    canonicalUriProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts" },
    chatParticipantAdditions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts" },
    chatParticipantPrivate: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts", version: 2 },
    chatProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts" },
    chatReferenceBinaryData: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatReferenceBinaryData.d.ts" },
    chatTab: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts" },
    chatVariableResolver: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariableResolver.d.ts" },
    codeActionAI: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts" },
    codeActionRanges: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts" },
    codiconDecoration: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts" },
    commentReactor: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts" },
    commentReveal: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts" },
    commentThreadApplicability: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts" },
    commentingRangeHint: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts" },
    commentsDraftState: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts" },
    contribAccessibilityHelpContent: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts" },
    contribCommentEditorActionsMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts" },
    contribCommentPeekContext: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts" },
    contribCommentThreadAdditionalMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts" },
    contribCommentsViewThreadMenus: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts" },
    contribDebugCreateConfiguration: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDebugCreateConfiguration.d.ts" },
    contribDiffEditorGutterToolBarMenus: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts" },
    contribEditSessions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts" },
    contribEditorContentMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts" },
    contribIssueReporter: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribIssueReporter.d.ts" },
    contribLabelFormatterWorkspaceTooltip: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts" },
    contribMenuBarHome: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts" },
    contribMergeEditorMenus: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts" },
    contribMultiDiffEditorMenus: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts" },
    contribNotebookStaticPreloads: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts" },
    contribRemoteHelp: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts" },
    contribShareMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts" },
    contribSourceControlHistoryItemMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts" },
    contribSourceControlHistoryTitleMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryTitleMenu.d.ts" },
    contribSourceControlInputBoxMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts" },
    contribSourceControlTitleMenu: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts" },
    contribStatusBarItems: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts" },
    contribViewContainerTitle: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewContainerTitle.d.ts" },
    contribViewsRemote: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts" },
    contribViewsWelcome: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts" },
    createFileSystemWatcher: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.createFileSystemWatcher.d.ts" },
    customEditorMove: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts" },
    debugVisualization: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts" },
    defaultChatParticipant: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts", version: 2 },
    diffCommand: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts" },
    diffContentOptions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts" },
    documentFiltersExclusive: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts" },
    documentPaste: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts" },
    editSessionIdentityProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts" },
    editorHoverVerbosityLevel: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts" },
    editorInsets: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts" },
    embeddings: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts" },
    extensionRuntime: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts" },
    extensionsAny: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts" },
    externalUriOpener: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts" },
    fileComments: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts" },
    fileSearchProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts" },
    fileSearchProviderNew: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProviderNew.d.ts" },
    findFiles2: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts" },
    findFiles2New: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2New.d.ts" },
    findTextInFiles: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts" },
    findTextInFilesNew: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFilesNew.d.ts" },
    fsChunks: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts" },
    icube: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icube.d.ts" },
    icubeAuthenticationProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeAuthenticationProvider.d.ts" },
    icubeChat: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeChat.d.ts" },
    icubeChatAgents2: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeChatAgents2.d.ts" },
    icubeChatAgents2Additions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeChatAgents2Additions.d.ts" },
    icubeFolderSearchProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeFolderSearchProvider.d.ts" },
    icubeInteractive: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeInteractive.d.ts" },
    icubeInteractive2: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeInteractive2.d.ts" },
    icubeUser: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.icubeUser.d.ts" },
    idToken: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts" },
    inlineCompletionsAdditions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts" },
    inlineEdit: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts" },
    interactive: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts" },
    interactiveUserActions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveUserActions.d.ts" },
    interactiveWindow: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts" },
    ipc: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts" },
    languageModelSystem: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts" },
    languageStatusText: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts" },
    lmTools: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.lmTools.d.ts", version: 15 },
    mappedEditsProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts" },
    multiDocumentHighlightProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts" },
    newSymbolNamesProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts" },
    notebookCellExecution: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts" },
    notebookCellExecutionState: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts" },
    notebookControllerAffinityHidden: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts" },
    notebookDeprecated: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts" },
    notebookExecution: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts" },
    notebookKernelSource: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts" },
    notebookLiveShare: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts" },
    notebookMessaging: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts" },
    notebookMime: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts" },
    notebookReplDocument: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookReplDocument.d.ts" },
    notebookVariableProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts" },
    portsAttributes: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts" },
    profileContentHandlers: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts" },
    quickDiffProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts" },
    quickInputButtonLocation: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts" },
    quickPickItemTooltip: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts" },
    quickPickSortByLabel: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts" },
    resolvers: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts" },
    scmActionButton: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts" },
    scmHistoryProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts" },
    scmMultiDiffEditor: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts" },
    scmSelectedProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts" },
    scmTextDocument: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts" },
    scmValidation: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts" },
    shareProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts" },
    showLocal: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts" },
    speech: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts" },
    tabInputMultiDiff: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts" },
    tabInputTextMerge: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts" },
    taskPresentationGroup: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts" },
    telemetry: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts" },
    terminalDataWriteEvent: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts" },
    terminalDimensions: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts" },
    terminalExecuteCommandEvent: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts" },
    terminalQuickFixProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts" },
    terminalSelection: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts" },
    testObserver: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts" },
    testRelatedCode: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts" },
    textSearchCompleteNew: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchCompleteNew.d.ts" },
    textSearchProvider: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts" },
    textSearchProviderNew: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProviderNew.d.ts" },
    timeline: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts" },
    tokenInformation: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts" },
    treeViewActiveItem: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts" },
    treeViewMarkdownMessage: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts" },
    treeViewReveal: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts" },
    tunnelFactory: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts" },
    tunnels: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts" },
    webviewInitialState: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.webviewInitialState.d.ts" },
    workspaceTrust: { proposal: "https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts" },
  },
  I5 = Object.freeze(D5),
  sg = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/,
  R5 = /^-(\d{4})(\d{2})(\d{2})$/;
function P5(t) {
  return (t = t.trim()), t === "*" || sg.test(t);
}
function nh(t) {
  if (!P5(t)) return null;
  if (((t = t.trim()), t === "*")) return { hasCaret: !1, hasGreaterEquals: !1, majorBase: 0, majorMustEqual: !1, minorBase: 0, minorMustEqual: !1, patchBase: 0, patchMustEqual: !1, preRelease: null };
  const e = t.match(sg);
  return e
    ? {
        hasCaret: e[1] === "^",
        hasGreaterEquals: e[1] === ">=",
        majorBase: e[2] === "x" ? 0 : parseInt(e[2], 10),
        majorMustEqual: e[2] !== "x",
        minorBase: e[4] === "x" ? 0 : parseInt(e[4], 10),
        minorMustEqual: e[4] !== "x",
        patchBase: e[6] === "x" ? 0 : parseInt(e[6], 10),
        patchMustEqual: e[6] !== "x",
        preRelease: e[8] || null,
      }
    : null;
}
function rh(t) {
  if (!t) return null;
  const e = t.majorBase,
    s = t.majorMustEqual,
    i = t.minorBase;
  let n = t.minorMustEqual;
  const r = t.patchBase;
  let o = t.patchMustEqual;
  t.hasCaret && (e === 0 || (n = !1), (o = !1));
  let a = 0;
  if (t.preRelease) {
    const c = R5.exec(t.preRelease);
    if (c) {
      const [, l, h, u] = c;
      a = Date.UTC(Number(l), Number(h) - 1, Number(u));
    }
  }
  return { majorBase: e, majorMustEqual: s, minorBase: i, minorMustEqual: n, patchBase: r, patchMustEqual: o, isMinimum: t.hasGreaterEquals, notBefore: a };
}
function A5(t, e, s) {
  let i;
  typeof t == "string" ? (i = rh(nh(t))) : (i = t);
  let n;
  e instanceof Date ? (n = e.getTime()) : typeof e == "string" && (n = new Date(e).getTime());
  let r;
  if ((typeof s == "string" ? (r = rh(nh(s))) : (r = s), !i || !r)) return !1;
  const o = i.majorBase,
    a = i.minorBase,
    c = i.patchBase;
  let l = r.majorBase,
    h = r.minorBase,
    u = r.patchBase;
  const f = r.notBefore;
  let d = r.majorMustEqual,
    p = r.minorMustEqual,
    g = r.patchMustEqual;
  return r.isMinimum
    ? o > l
      ? !0
      : o < l
        ? !1
        : a > h
          ? !0
          : a < h || (n && n < f)
            ? !1
            : c >= u
    : (o === 1 && l === 0 && (!d || !p || !g) && ((l = 1), (h = 0), (u = 0), (d = !0), (p = !1), (g = !1)), o < l ? !1 : o > l ? !d : a < h ? !1 : a > h ? !p : c < u ? !1 : c > u ? !g : !(n && n < f));
}
function O5(t, e, s, i, n, r) {
  const o = [];
  if (typeof i.publisher < "u" && typeof i.publisher != "string") return o.push([bt.Error, w(1873, null)]), o;
  if (typeof i.name != "string") return o.push([bt.Error, w(1874, null, "name")]), o;
  if (typeof i.version != "string") return o.push([bt.Error, w(1875, null, "version")]), o;
  if (!i.engines) return o.push([bt.Error, w(1876, null, "engines")]), o;
  if (typeof i.engines.vscode != "string") return o.push([bt.Error, w(1877, null, "engines.vscode")]), o;
  if (typeof i.extensionDependencies < "u" && !ng(i.extensionDependencies)) return o.push([bt.Error, w(1878, null, "extensionDependencies")]), o;
  if (typeof i.activationEvents < "u") {
    if (!ng(i.activationEvents)) return o.push([bt.Error, w(1879, null, "activationEvents")]), o;
    if (typeof i.main > "u" && typeof i.browser > "u") return o.push([bt.Error, w(1880, null, "activationEvents", "main", "browser")]), o;
  }
  if ((typeof i.extensionKind < "u" && typeof i.main > "u" && o.push([bt.Warning, w(1881, null, "extensionKind")]), typeof i.main < "u")) {
    if (typeof i.main != "string") return o.push([bt.Error, w(1882, null, "main")]), o;
    {
      const l = M(s, i.main);
      Vd(l, s) || o.push([bt.Warning, w(1883, null, l.path, s.path)]);
    }
  }
  if (typeof i.browser < "u") {
    if (typeof i.browser != "string") return o.push([bt.Error, w(1884, null, "browser")]), o;
    {
      const l = M(s, i.browser);
      Vd(l, s) || o.push([bt.Warning, w(1885, null, l.path, s.path)]);
    }
  }
  if (!C5(i.version)) return o.push([bt.Error, w(1886, null)]), o;
  const a = [];
  if (!L5(t, e, i, n, a)) for (const l of a) o.push([bt.Error, l]);
  if (r && i.enabledApiProposals?.length) {
    const l = [];
    if (!oh([...i.enabledApiProposals], l)) for (const h of l) o.push([bt.Error, h]);
  }
  return o;
}
function L5(t, e, s, i, n) {
  return i || (typeof s.main > "u" && typeof s.browser > "u") ? !0 : ig(t, e, s.engines.vscode, n);
}
function ca(t, e, s) {
  return t === "*" || ig(e, s, t);
}
function oh(t, e) {
  if (t.length === 0) return !0;
  const s = Array.isArray(e) ? e : void 0,
    i = (s ? void 0 : e) ?? I5,
    n = [],
    r = Yb(t);
  for (const { proposalName: o, version: a } of r) {
    const c = i[o];
    c && a && c.version !== a && n.push(o);
  }
  return n.length
    ? (s &&
        (n.length === 1
          ? s.push(w(1887, null, n[0]))
          : s.push(
              w(
                1888,
                null,
                n
                  .slice(0, n.length - 1)
                  .map((o) => `'${o}'`)
                  .join(", "),
                n[n.length - 1],
              ),
            )),
      !1)
    : !0;
}
function ig(t, e, s, i = []) {
  const n = rh(nh(s));
  if (!n) return i.push(w(1889, null, s)), !1;
  if (n.majorBase === 0) {
    if (!n.majorMustEqual || !n.minorMustEqual) return i.push(w(1890, null, s)), !1;
  } else if (!n.majorMustEqual) return i.push(w(1891, null, s)), !1;
  return A5(t, e, n) ? !0 : (i.push(w(1892, null, t, s)), !1);
}
function ng(t) {
  if (!Array.isArray(t)) return !1;
  for (let e = 0, s = t.length; e < s; e++) if (typeof t[e] != "string") return !1;
  return !0;
}
async function On(t, e, s) {
  let i = (s && s.get("storage.serviceMachineId", -1)) || null;
  if (i) return i;
  try {
    const r = (await e.readFile(t.serviceMachineIdResource)).value.toString();
    i = qb(r) ? r : null;
  } catch {
    i = null;
  }
  if (!i) {
    i = Me();
    try {
      await e.writeFile(t.serviceMachineIdResource, L.fromString(i));
    } catch {}
  }
  return s?.store("storage.serviceMachineId", i, -1, 1), i;
}
async function N5(t, e, s, i, n, r, o) {
  const a = { "X-Market-Client-Id": `VSCode ${t}`, "User-Agent": `VSCode ${t} (${e.nameShort})` };
  if (eh(e, s) && qp(i) === 3) {
    const c = await On(s, n, r);
    (a["X-Market-User-Id"] = c), (a["VSCode-SessionId"] = o.machineId || c);
  }
  return a;
}
var rg = Qe ? "web" : R1(ln, Bc),
  Rr = "X-Market-Search-Activity-Id",
  Re;
(function (t) {
  (t[(t.None = 0)] = "None"),
    (t[(t.IncludeVersions = 1)] = "IncludeVersions"),
    (t[(t.IncludeFiles = 2)] = "IncludeFiles"),
    (t[(t.IncludeCategoryAndTags = 4)] = "IncludeCategoryAndTags"),
    (t[(t.IncludeSharedAccounts = 8)] = "IncludeSharedAccounts"),
    (t[(t.IncludeVersionProperties = 16)] = "IncludeVersionProperties"),
    (t[(t.ExcludeNonValidated = 32)] = "ExcludeNonValidated"),
    (t[(t.IncludeInstallationTargets = 64)] = "IncludeInstallationTargets"),
    (t[(t.IncludeAssetUri = 128)] = "IncludeAssetUri"),
    (t[(t.IncludeStatistics = 256)] = "IncludeStatistics"),
    (t[(t.IncludeLatestVersionOnly = 512)] = "IncludeLatestVersionOnly"),
    (t[(t.Unpublished = 4096)] = "Unpublished"),
    (t[(t.IncludeNameConflictInfo = 32768)] = "IncludeNameConflictInfo");
})(Re || (Re = {}));
function T5(...t) {
  return String(t.reduce((e, s) => e | s, 0));
}
var dt;
(function (t) {
  (t[(t.Tag = 1)] = "Tag"),
    (t[(t.ExtensionId = 4)] = "ExtensionId"),
    (t[(t.Category = 5)] = "Category"),
    (t[(t.ExtensionName = 7)] = "ExtensionName"),
    (t[(t.Target = 8)] = "Target"),
    (t[(t.Featured = 9)] = "Featured"),
    (t[(t.SearchText = 10)] = "SearchText"),
    (t[(t.ExcludeWithFlags = 12)] = "ExcludeWithFlags");
})(dt || (dt = {}));
var Et = {
    Icon: "Microsoft.VisualStudio.Services.Icons.Default",
    Details: "Microsoft.VisualStudio.Services.Content.Details",
    Changelog: "Microsoft.VisualStudio.Services.Content.Changelog",
    Manifest: "Microsoft.VisualStudio.Code.Manifest",
    VSIX: "Microsoft.VisualStudio.Services.VSIXPackage",
    License: "Microsoft.VisualStudio.Services.Content.License",
    Repository: "Microsoft.VisualStudio.Services.Links.Source",
    Signature: "Microsoft.VisualStudio.Services.VsixSignature",
  },
  Hs = {
    Dependency: "Microsoft.VisualStudio.Code.ExtensionDependencies",
    ExtensionPack: "Microsoft.VisualStudio.Code.ExtensionPack",
    Engine: "Microsoft.VisualStudio.Code.Engine",
    PreRelease: "Microsoft.VisualStudio.Code.PreRelease",
    EnabledApiProposals: "Microsoft.VisualStudio.Code.EnabledApiProposals",
    LocalizedLanguages: "Microsoft.VisualStudio.Code.LocalizedLanguages",
    WebExtension: "Microsoft.VisualStudio.Code.WebExtension",
    SponsorLink: "Microsoft.VisualStudio.Code.SponsorLink",
    SupportLink: "Microsoft.VisualStudio.Services.Links.Support",
    ExecutesCode: "Microsoft.VisualStudio.Code.ExecutesCode",
  },
  j5 = 10,
  F5 = { pageNumber: 1, pageSize: j5, sortBy: 0, sortOrder: 0, flags: Re.None, criteria: [], assetTypes: [] },
  Pr = class wi {
    constructor(e = F5) {
      this.d = e;
    }
    get pageNumber() {
      return this.d.pageNumber;
    }
    get pageSize() {
      return this.d.pageSize;
    }
    get sortBy() {
      return this.d.sortBy;
    }
    get sortOrder() {
      return this.d.sortOrder;
    }
    get flags() {
      return this.d.flags;
    }
    get criteria() {
      return this.d.criteria;
    }
    withPage(e, s = this.d.pageSize) {
      return new wi({ ...this.d, pageNumber: e, pageSize: s });
    }
    withFilter(e, ...s) {
      const i = [...this.d.criteria, ...(s.length ? s.map((n) => ({ filterType: e, value: n })) : [{ filterType: e }])];
      return new wi({ ...this.d, criteria: i });
    }
    withSortBy(e) {
      return new wi({ ...this.d, sortBy: e });
    }
    withSortOrder(e) {
      return new wi({ ...this.d, sortOrder: e });
    }
    withFlags(...e) {
      return new wi({ ...this.d, flags: e.reduce((s, i) => s | i, 0) });
    }
    withAssetTypes(...e) {
      return new wi({ ...this.d, assetTypes: e });
    }
    withSource(e) {
      return new wi({ ...this.d, source: e });
    }
    get raw() {
      const { criteria: e, pageNumber: s, pageSize: i, sortBy: n, sortOrder: r, flags: o, assetTypes: a } = this.d;
      return { filters: [{ criteria: e, pageNumber: s, pageSize: i, sortBy: n, sortOrder: r }], assetTypes: a, flags: o };
    }
    get searchText() {
      const e = this.d.criteria.filter((s) => s.filterType === dt.SearchText)[0];
      return e && e.value ? e.value : "";
    }
    get telemetryData() {
      return {
        filterTypes: this.d.criteria.map((e) => String(e.filterType)),
        flags: this.d.flags,
        sortBy: String(this.sortBy),
        sortOrder: String(this.sortOrder),
        pageNumber: String(this.pageNumber),
        source: this.d.source,
        searchTextLength: this.searchText.length,
      };
    }
  };
function ah(t, e) {
  const s = (t || []).filter((i) => i.statisticName === e)[0];
  return s ? s.value : 0;
}
function M5(t) {
  const e = "Microsoft.VisualStudio.Code.Translation.";
  return t.files
    .filter((i) => i.assetType.indexOf(e) === 0)
    .reduce((i, n) => {
      const r = Gs(t, n.assetType);
      return r && i.push([n.assetType.substring(e.length), r]), i;
    }, []);
}
function U5(t) {
  if (t.properties) {
    const e = t.properties.filter((n) => n.key === Et.Repository),
      s = new RegExp("((git|ssh|http(s)?)|(git@[\\w.]+))(:(//)?)([\\w.@:/\\-~]+)(.git)(/)?"),
      i = e.filter((n) => s.test(n.value))[0];
    return i ? { uri: i.value, fallbackUri: i.value } : null;
  }
  return Gs(t, Et.Repository);
}
function _5(t) {
  return {
    uri: `${t.fallbackAssetUri}/${Et.VSIX}?redirect=true${t.targetPlatform ? `&targetPlatform=${t.targetPlatform}` : ""}`,
    fallbackUri: `${t.fallbackAssetUri}/${Et.VSIX}${t.targetPlatform ? `?targetPlatform=${t.targetPlatform}` : ""}`,
  };
}
function Gs(t, e) {
  return t.files.filter((i) => i.assetType === e)[0]
    ? { uri: `${t.assetUri}/${e}${t.targetPlatform ? `?targetPlatform=${t.targetPlatform}` : ""}`, fallbackUri: `${t.fallbackAssetUri}/${e}${t.targetPlatform ? `?targetPlatform=${t.targetPlatform}` : ""}` }
    : null;
}
function og(t, e) {
  const s = t.properties ? t.properties.filter((n) => n.key === e) : [],
    i = s.length > 0 && s[0].value;
  return i ? i.split(",").map((n) => kr(n)) : [];
}
function ag(t) {
  const e = t.properties ? t.properties.filter((s) => s.key === Hs.Engine) : [];
  return (e.length > 0 && e[0].value) || "";
}
function la(t) {
  const e = t.properties ? t.properties.filter((s) => s.key === Hs.PreRelease) : [];
  return e.length > 0 && e[0].value === "true";
}
function B5(t) {
  const e = t.properties ? t.properties.filter((s) => s.key === Hs.ExecutesCode) : [];
  return e.length > 0 ? e[0].value === "true" : void 0;
}
function ch(t) {
  const e = t.properties ? t.properties.filter((i) => i.key === Hs.EnabledApiProposals) : [],
    s = (e.length > 0 && e[0].value) || "";
  return s ? s.split(",") : [];
}
function z5(t) {
  const e = t.properties ? t.properties.filter((i) => i.key === Hs.LocalizedLanguages) : [],
    s = (e.length > 0 && e[0].value) || "";
  return s ? s.split(",") : [];
}
function q5(t) {
  return t.properties?.find((e) => e.key === Hs.SponsorLink)?.value;
}
function V5(t) {
  return t.properties?.find((e) => e.key === Hs.SupportLink)?.value;
}
function W5(t) {
  return t.indexOf("preview") !== -1;
}
function ha(t) {
  return t.targetPlatform ? K4(t.targetPlatform) : "undefined";
}
function lh(t) {
  const e = Bt(t.versions.map(ha)),
    s = !!t.tags?.includes(V4),
    i = e.indexOf("web");
  return s ? i === -1 && e.push("web") : i !== -1 && e.splice(i, 1), e;
}
function cg(t, e) {
  for (let s = 0; s < t.length; s++) {
    const i = t[s];
    if (i.version === t[s - 1]?.version) {
      let n = s;
      if (ha(i) === e) for (; n > 0 && t[n - 1].version === i.version; ) n--;
      n !== s && (t.splice(s, 1), t.splice(n, 0, i));
    }
  }
  return t;
}
function lg(t, e, s) {
  t.telemetryData = { index: e, querySource: s, queryActivityId: t.queryContext?.[Rr] };
}
function hg(t, e, s, i) {
  const n = t.versions[0],
    r = {
      manifest: Gs(e, Et.Manifest),
      readme: Gs(e, Et.Details),
      changelog: Gs(e, Et.Changelog),
      license: Gs(e, Et.License),
      repository: U5(e),
      download: _5(e),
      icon: Gs(e, Et.Icon),
      signature: Gs(e, Et.Signature),
      coreTranslations: M5(e),
    };
  return {
    type: "gallery",
    identifier: { id: ai(t.publisher.publisherName, t.extensionName), uuid: t.extensionId },
    name: t.extensionName,
    version: e.version,
    displayName: t.displayName,
    publisherId: t.publisher.publisherId,
    publisher: t.publisher.publisherName,
    publisherDisplayName: t.publisher.displayName,
    publisherDomain: t.publisher.domain ? { link: t.publisher.domain, verified: !!t.publisher.isDomainVerified } : void 0,
    publisherSponsorLink: q5(n),
    description: t.shortDescription ?? "",
    installCount: ah(t.statistics, "install"),
    rating: ah(t.statistics, "averagerating"),
    ratingCount: ah(t.statistics, "ratingcount"),
    categories: t.categories || [],
    tags: t.tags || [],
    releaseDate: Date.parse(t.releaseDate),
    lastUpdated: Date.parse(t.lastUpdated),
    allTargetPlatforms: s,
    assets: r,
    properties: { dependencies: og(e, Hs.Dependency), extensionPack: og(e, Hs.ExtensionPack), engine: ag(e), enabledApiProposals: ch(e), localizedLanguages: z5(e), targetPlatform: ha(e), isPreReleaseVersion: la(e), executesCode: B5(e) },
    hasPreReleaseVersion: la(n),
    hasReleaseVersion: !0,
    preview: W5(t.flags),
    isSigned: !!r.signature,
    queryContext: i,
    supportLink: V5(n),
  };
}
var ua = class {
  get g() {
    if (Qe) {
      const s = this.x.extensionsGallery;
      return s?.servicePPEUrl && this.y.getValue("_extensionsGallery.enablePPE") ? s.servicePPEUrl : s?.serviceUrl;
    }
    return !this.d || this.d.account.scope !== "bytedance" ? this.x.iCubeApp?.desktopOuterExtensionGallery?.serviceUrl : this.x.iCubeApp?.desktopInnerExtensionsGallery?.serviceUrl;
  }
  get h() {
    if (Qe) {
      const s = this.x.extensionsGallery;
      return s?.servicePPEUrl && this.y.getValue("_extensionsGallery.enablePPE") ? void 0 : s?.searchUrl;
    }
    return !this.d || this.d.account.scope !== "bytedance" ? this.x.iCubeApp?.desktopOuterExtensionGallery?.searchUrl : this.x.iCubeApp?.desktopInnerExtensionsGallery?.searchUrl;
  }
  get j() {
    return Qe ? this.x.extensionsGallery?.controlUrl : !this.d || this.d.account.scope !== "bytedance" ? this.x.iCubeApp?.desktopOuterExtensionGallery?.controlUrl : this.x.iCubeApp?.desktopInnerExtensionsGallery?.controlUrl;
  }
  constructor(e, s, i, n, r, o, a, c) {
    (this.n = s),
      (this.o = i),
      (this.q = n),
      (this.u = r),
      (this.w = o),
      (this.x = a),
      (this.y = c),
      (this.d = null),
      (this.l = a.extensionsEnabledWithApiProposalVersion?.map((l) => l.toLowerCase()) ?? []),
      (this.k = N5(a.version, a, this.q, this.y, this.w, e, this.u));
  }
  z(e = "") {
    return `${this.g}${e}`;
  }
  updateUserInfo(e = null) {
    this.d = e;
  }
  isEnabled() {
    return !!this.g;
  }
  async getExtensions(e, s, i) {
    const n = J.isCancellationToken(s) ? {} : s,
      r = J.isCancellationToken(s) ? s : i,
      o = await this.A(e, n, r),
      a = o.map((l) => l.identifier.uuid),
      c = [];
    for (const l of e) l.uuid && !a.includes(l.uuid) && c.push({ ...l, uuid: void 0 });
    if (c.length) {
      this.u.publicLog2("galleryService:additionalQueryByName", { count: c.length });
      const l = await this.A(c, n, r);
      o.push(...l);
    }
    return o;
  }
  async A(e, s, i) {
    const n = [],
      r = [],
      o = [],
      a = [];
    let c = !0;
    for (const u of e) {
      u.uuid ? r.push(u.uuid) : n.push(u.id);
      const f = !!(u.version || u.preRelease);
      o.push({ id: u.id, uuid: u.uuid, includePreRelease: f }), u.version && a.push({ id: u.id, uuid: u.uuid, version: u.version }), (c = c && !!u.hasPreRelease && !f);
    }
    if (!r.length && !n.length) return [];
    let l = new Pr().withPage(1, e.length);
    r.length && (l = l.withFilter(dt.ExtensionId, ...r)), n.length && (l = l.withFilter(dt.ExtensionName, ...n)), (s.queryAllVersions || c) && (l = l.withFlags(l.flags, Re.IncludeVersions)), s.source && (l = l.withSource(s.source));
    const { extensions: h } = await this.D(l, { targetPlatform: s.targetPlatform ?? rg, includePreRelease: o, versions: a, compatible: !!s.compatible, productVersion: s.productVersion ?? { version: this.x.version, date: this.x.date } }, i);
    return s.source && h.forEach((u, f) => lg(u, f, s.source)), h;
  }
  async getCompatibleExtension(e, s, i, n = { version: this.x.version, date: this.x.date }) {
    if (pr(e.allTargetPlatforms, i)) return null;
    if (await this.isExtensionCompatible(e, s, i)) return e;
    const r = new Pr().withFlags(Re.IncludeVersions).withPage(1, 1).withFilter(dt.ExtensionId, e.identifier.uuid),
      { extensions: o } = await this.D(r, { targetPlatform: i, compatible: !0, includePreRelease: s, productVersion: n }, J.None);
    return o[0] || null;
  }
  async isExtensionCompatible(e, s, i, n = { version: this.x.version, date: this.x.date }) {
    if (!wl(e.properties.targetPlatform, e.allTargetPlatforms, i) || (!s && e.properties.isPreReleaseVersion)) return !1;
    let r = e.properties.engine;
    if (!r) {
      const o = await this.getManifest(e, J.None);
      if (!o) throw new Error("Manifest was not found");
      r = o.engines.vscode;
    }
    return !(!ca(r, n.version, n.date) || !this.B(e.identifier, e.properties.enabledApiProposals));
  }
  B(e, s) {
    return !s || !this.l.includes(e.id.toLowerCase()) ? !0 : oh(s);
  }
  async C(e, s, i, n, r, o, a = { version: this.x.version, date: this.x.date }) {
    if (!wl(ha(s), r, o) || (i !== "any" && la(s) !== (i === "prerelease"))) return !1;
    if (n)
      try {
        const c = await this.I(e, s);
        if (!ca(c, a.version, a.date)) return !1;
      } catch (c) {
        return this.o.error(`Error while getting the engine for the version ${s.version}.`, ve(c)), !1;
      }
    return !0;
  }
  async query(e, s) {
    let i = e.text || "";
    const n = e.pageSize ?? 50;
    let r = new Pr().withPage(1, n);
    i
      ? ((i = i.replace(/\bcategory:("([^"]*)"|([^"]\S*))(\s+|\b|$)/g, (h, u, f) => ((r = r.withFilter(dt.Category, f || u)), ""))),
        (i = i.replace(/\btag:("([^"]*)"|([^"]\S*))(\s+|\b|$)/g, (h, u, f) => ((r = r.withFilter(dt.Tag, f || u)), ""))),
        (i = i.replace(/\bfeatured(\s+|\b|$)/g, () => ((r = r.withFilter(dt.Featured)), ""))),
        (i = i.trim()),
        i && ((i = i.length < 200 ? i : i.substring(0, 200)), (r = r.withFilter(dt.SearchText, i))),
        (r = r.withSortBy(0)))
      : e.ids
        ? (r = r.withFilter(dt.ExtensionId, ...e.ids))
        : e.names
          ? (r = r.withFilter(dt.ExtensionName, ...e.names))
          : (r = r.withSortBy(4)),
      typeof e.sortBy == "number" && (r = r.withSortBy(e.sortBy)),
      typeof e.sortOrder == "number" && (r = r.withSortOrder(e.sortOrder)),
      e.source && (r = r.withSource(e.source));
    const o = async (h, u) => {
        const { extensions: f, total: d } = await this.D(h, { targetPlatform: rg, compatible: !1, includePreRelease: !!e.includePreRelease, productVersion: e.productVersion ?? { version: this.x.version, date: this.x.date } }, u);
        return f.forEach((p, g) => lg(p, (h.pageNumber - 1) * h.pageSize + g, e.source)), { extensions: f, total: d };
      },
      { extensions: a, total: c } = await o(r, s),
      l = async (h, u) => {
        if (u.isCancellationRequested) throw new ot();
        const { extensions: f } = await o(r.withPage(h + 1), u);
        return f;
      };
    return { firstPage: a, total: c, pageSize: r.pageSize, getPage: l };
  }
  async D(e, s, i) {
    const n = e.flags;
    e.flags & Re.IncludeLatestVersionOnly && e.flags & Re.IncludeVersions && (e = e.withFlags(e.flags & ~Re.IncludeVersions, Re.IncludeLatestVersionOnly)),
      !(e.flags & Re.IncludeLatestVersionOnly) && !(e.flags & Re.IncludeVersions) && (e = e.withFlags(e.flags, Re.IncludeLatestVersionOnly)),
      s.versions?.length && (e = e.withFlags(e.flags & ~Re.IncludeLatestVersionOnly, Re.IncludeVersions)),
      (e = e.withFlags(e.flags, Re.IncludeAssetUri, Re.IncludeCategoryAndTags, Re.IncludeFiles, Re.IncludeStatistics, Re.IncludeVersionProperties));
    const { galleryExtensions: r, total: o, context: a } = await this.F(e, i);
    if (!(e.flags & Re.IncludeLatestVersionOnly)) {
      const u = [];
      for (const f of r) {
        const d = await this.E(f, s, a);
        d && u.push(d);
      }
      return { extensions: u, total: o };
    }
    const l = [],
      h = new Map();
    for (let u = 0; u < r.length; u++) {
      const f = r[u],
        d = { id: ai(f.publisher.publisherName, f.extensionName), uuid: f.extensionId },
        p = Ms(s.includePreRelease) ? s.includePreRelease : !!s.includePreRelease.find((m) => G(m, d))?.includePreRelease;
      if (s.compatible && pr(lh(f), s.targetPlatform)) continue;
      const g = await this.E(f, s, a);
      !g || (g.properties.isPreReleaseVersion && (!p || !g.hasReleaseVersion)) || (!g.properties.isPreReleaseVersion && g.properties.targetPlatform !== s.targetPlatform && g.hasPreReleaseVersion) ? h.set(f.extensionId, u) : l.push([u, g]);
    }
    if (h.size) {
      const u = new un(),
        f = new Pr()
          .withFlags(n & ~Re.IncludeLatestVersionOnly, Re.IncludeVersions)
          .withPage(1, h.size)
          .withFilter(dt.ExtensionId, ...h.keys()),
        { extensions: d } = await this.D(f, s, i);
      this.u.publicLog2("galleryService:additionalQuery", { duration: u.elapsed(), count: h.size });
      for (const p of d) {
        const g = h.get(p.identifier.uuid);
        l.push([g, p]);
      }
    }
    return { extensions: l.sort((u, f) => u[0] - f[0]).map(([, u]) => u), total: o };
  }
  async E(e, s, i) {
    const n = { id: ai(e.publisher.publisherName, e.extensionName), uuid: e.extensionId },
      r = s.versions?.find((l) => G(l, n))?.version,
      o = Ms(s.includePreRelease) ? s.includePreRelease : !!s.includePreRelease.find((l) => G(l, n))?.includePreRelease,
      a = lh(e),
      c = cg(e.versions, s.targetPlatform);
    if (s.compatible && pr(a, s.targetPlatform)) return null;
    for (let l = 0; l < c.length; l++) {
      const h = c[l];
      if (!(r && h.version !== r)) {
        if (await this.C(n.id, h, o ? "any" : "release", s.compatible, a, s.targetPlatform, s.productVersion)) {
          if (s.compatible && !this.B(n, ch(h))) continue;
          return hg(e, h, a, i);
        }
        if (r && h.version === r) return null;
      }
    }
    return r || s.compatible ? null : hg(e, e.versions[0], a);
  }
  async F(e, s) {
    if (!this.isEnabled()) throw new Error("No extension gallery service configured.");
    e = e.withFlags(e.flags, Re.ExcludeNonValidated).withFilter(dt.Target, "Microsoft.VisualStudio.Code").withFilter(dt.ExcludeWithFlags, T5(Re.Unpublished));
    const i = await this.k,
      n = JSON.stringify(e.raw),
      r = { ...i, "Content-Type": "application/json", Accept: "application/json;api-version=3.0-preview.1", "Accept-Encoding": "gzip", "Content-Length": String(n.length) },
      o = new un();
    let a,
      c,
      l = 0;
    try {
      if (
        ((a = await this.n.request({ type: "POST", url: this.h && e.criteria.some((u) => u.filterType === dt.SearchText) ? this.h : this.z("/extensionquery"), data: n, headers: r }, s)),
        a.res.statusCode && a.res.statusCode >= 400 && a.res.statusCode < 500)
      )
        return { galleryExtensions: [], total: l };
      const h = await Ui(a);
      if (h) {
        const u = h.results[0],
          f = u.extensions,
          d = u.resultMetadata && u.resultMetadata.filter((p) => p.metadataType === "ResultCount")[0];
        return (l = (d && d.metadataItems.filter((p) => p.name === "TotalCount")[0].count) || 0), { galleryExtensions: f, total: l, context: a.res.headers.activityid ? { [Rr]: a.res.headers.activityid } : {} };
      }
      return { galleryExtensions: [], total: l };
    } catch (h) {
      if (Fs(h)) throw ((c = "Cancelled"), h);
      {
        const u = ve(h);
        throw ((c = $5(h) ? "Offline" : u.startsWith("XHR timeout") ? "Timeout" : "Failed"), new Mo(u, c));
      }
    } finally {
      this.u.publicLog2("galleryService:query", {
        ...e.telemetryData,
        requestBodySize: String(n.length),
        duration: o.elapsed(),
        success: !!a && Cr(a),
        responseBodySize: a?.res.headers["Content-Length"],
        statusCode: a ? String(a.res.statusCode) : void 0,
        errorCode: c,
        count: String(l),
      });
    }
  }
  async reportStatistic(e, s, i, n) {
    if (!this.isEnabled()) return;
    const r = Qe ? this.z(`/itemName/${e}.${s}/version/${i}/statType/${n === "install" ? "1" : "3"}/vscodewebextension`) : this.z(`/publishers/${e}/extensions/${s}/${i}/stats?statType=${n}`),
      o = Qe ? "api-version=6.1-preview.1" : "*/*;api-version=4.0-preview.1",
      c = { ...(await this.k), Accept: o };
    try {
      await this.n.request({ type: "POST", url: r, headers: c }, J.None);
    } catch {}
  }
  async download(e, s, i) {
    this.o.trace("ExtensionGalleryService#download", e.identifier.id);
    const n = th(e),
      r = new Date().getTime(),
      o = i === 2 ? "install" : i === 3 ? "update" : "",
      a = o
        ? { uri: `${e.assets.download.uri}${C.parse(e.assets.download.uri).query ? "&" : "?"}${o}=true`, fallbackUri: `${e.assets.download.fallbackUri}${C.parse(e.assets.download.fallbackUri).query ? "&" : "?"}${o}=true` }
        : e.assets.download,
      c = e.queryContext?.[Rr] ? { [Rr]: e.queryContext[Rr] } : void 0,
      l = await this.H(e.identifier.id, a, Et.VSIX, c ? { headers: c } : void 0);
    try {
      await this.w.writeFile(s, l.stream);
    } catch (h) {
      try {
        await this.w.del(s);
      } catch (u) {
        this.o.warn(`Error while deleting the file ${s.toString()}`, ve(u));
      }
      throw new Mo(ve(h), "DownloadFailedWriting");
    }
    this.u.publicLog("galleryService:downloadVSIX", { ...n, duration: new Date().getTime() - r });
  }
  async downloadSignatureArchive(e, s) {
    if (!e.assets.signature) throw new Error("No signature asset found");
    this.o.trace("ExtensionGalleryService#downloadSignatureArchive", e.identifier.id);
    const i = await this.H(e.identifier.id, e.assets.signature, Et.Signature);
    try {
      await this.w.writeFile(s, i.stream);
    } catch (n) {
      try {
        await this.w.del(s);
      } catch (r) {
        this.o.warn(`Error while deleting the file ${s.toString()}`, ve(r));
      }
      throw new Mo(ve(n), "DownloadFailedWriting");
    }
  }
  async getReadme(e, s) {
    if (e.assets.readme) {
      const i = await this.H(e.identifier.id, e.assets.readme, Et.Details, {}, s);
      return (await Is(i)) || "";
    }
    return "";
  }
  async getManifest(e, s) {
    if (e.assets.manifest) {
      const i = await this.H(e.identifier.id, e.assets.manifest, Et.Manifest, {}, s),
        n = await Is(i);
      return n ? JSON.parse(n) : null;
    }
    return null;
  }
  async G(e, s, i) {
    const n = Gs(s, Et.Manifest);
    if (!n) throw new Error("Manifest was not found");
    const r = { "Accept-Encoding": "gzip" },
      o = await this.H(e, n, Et.Manifest, { headers: r });
    return await Ui(o);
  }
  async getCoreTranslation(e, s) {
    const i = e.assets.coreTranslations.filter((n) => n[0] === s.toUpperCase())[0];
    if (i) {
      const n = await this.H(e.identifier.id, i[1], i[0]),
        r = await Is(n);
      return r ? JSON.parse(r) : null;
    }
    return null;
  }
  async getChangelog(e, s) {
    if (e.assets.changelog) {
      const i = await this.H(e.identifier.id, e.assets.changelog, Et.Changelog, {}, s);
      return (await Is(i)) || "";
    }
    return "";
  }
  async getAllCompatibleVersions(e, s, i) {
    let n = new Pr().withFlags(Re.IncludeVersions, Re.IncludeCategoryAndTags, Re.IncludeFiles, Re.IncludeVersionProperties).withPage(1, 1);
    e.uuid ? (n = n.withFilter(dt.ExtensionId, e.uuid)) : (n = n.withFilter(dt.ExtensionName, e.id));
    const { galleryExtensions: r } = await this.F(n, J.None);
    if (!r.length) return [];
    const o = lh(r[0]);
    if (pr(o, i)) return [];
    const a = [];
    await Promise.all(
      r[0].versions.map(async (h) => {
        try {
          (await this.C(e.id, h, s ? "any" : "release", !0, o, i)) && this.B(e, ch(h)) && a.push(h);
        } catch {}
      }),
    );
    const c = [],
      l = new Set();
    for (const h of cg(a, i)) l.has(h.version) || (l.add(h.version), c.push({ version: h.version, date: h.lastUpdated, isPreReleaseVersion: la(h) }));
    return c;
  }
  async H(e, s, i, n = {}, r = J.None) {
    const o = await this.k,
      a = { type: "GET" },
      c = { ...o, ...(n.headers || {}) };
    n = { ...n, ...a, headers: c };
    const l = s.uri,
      h = s.fallbackUri,
      u = { ...n, url: l };
    try {
      const f = await this.n.request(u, r);
      if (f.res.statusCode === 200) return f;
      const d = await Is(f);
      throw new Error(`Expected 200, got back ${f.res.statusCode} instead.

${d}`);
    } catch (f) {
      if (Fs(f)) throw f;
      const d = ve(f);
      this.u.publicLog2("galleryService:cdnFallback", { extension: e, assetType: i, message: d });
      const p = { ...n, url: h };
      return this.n.request(p, r);
    }
  }
  async I(e, s) {
    let i = ag(s);
    if (!i) {
      this.u.publicLog2("galleryService:engineFallback", { extension: e, version: s.version });
      const n = await this.G(e, s, J.None);
      if (!n) throw new Error("Manifest was not found");
      i = n.engines.vscode;
    }
    return i;
  }
  async getExtensionsControlManifest() {
    if (!this.isEnabled()) throw new Error("No extension gallery service configured.");
    if (!this.j) return { malicious: [], deprecated: {}, search: [] };
    const e = await this.n.request({ type: "GET", url: this.j }, J.None);
    if (e.res.statusCode !== 200) throw new Error("Could not get extensions report.");
    const s = await Ui(e),
      i = [],
      n = {},
      r = [],
      o = [];
    if (s) {
      for (const a of s.malicious) i.push({ id: a });
      if (s.migrateToPreRelease)
        for (const [a, c] of Object.entries(s.migrateToPreRelease))
          (!c.engine || ca(c.engine, this.x.version, this.x.date)) && (n[a.toLowerCase()] = { disallowInstall: !0, extension: { id: c.id, displayName: c.displayName, autoMigrate: { storage: !!c.migrateStorage }, preRelease: !0 } });
      if (s.deprecated) for (const [a, c] of Object.entries(s.deprecated)) c && (n[a.toLowerCase()] = Ms(c) ? {} : c);
      if (s.search) for (const a of s.search) r.push(a);
      if (Array.isArray(s.extensionsEnabledWithPreRelease)) for (const a of s.extensionsEnabledWithPreRelease) o.push(a.toLowerCase());
    }
    return { malicious: i, deprecated: n, search: r, extensionsEnabledWithPreRelease: o };
  }
};
ua = __decorate([__param(1, oi), __param(2, ne), __param(3, fe), __param(4, Se), __param(5, ie), __param(6, Ee), __param(7, Ce)], ua);
var hh = class extends ua {
  constructor(e, s, i, n, r, o, a, c) {
    super(e, s, i, n, r, o, a, c);
  }
};
hh = __decorate([__param(0, ae), __param(1, oi), __param(2, ne), __param(3, fe), __param(4, Se), __param(5, ie), __param(6, Ee), __param(7, Ce)], hh);
var ug = class extends ua {
  constructor(e, s, i, n, r, o, a) {
    super(void 0, e, s, i, n, r, o, a);
  }
};
ug = __decorate([__param(0, oi), __param(1, ne), __param(2, fe), __param(3, Se), __param(4, ie), __param(5, Ee), __param(6, Ce)], ug);
var uh = z("IExtensionSignatureVerificationService"),
  fh = class {
    constructor(e, s) {
      (this.b = e), (this.c = s);
    }
    d() {
      return this.a || (this.a = this.f()), this.a;
    }
    async f() {
      return import("@vscode/vsce-sign");
    }
    async verify(e, s, i, n, r) {
      let o;
      try {
        o = await this.d();
      } catch (h) {
        this.b.error("Could not load vsce-sign module", ve(h)), this.b.info(`Extension signature verification is not done: ${e}`);
        return;
      }
      const a = new Date().getTime();
      let c;
      try {
        this.b.trace(`Verifying extension signature for ${e}...`), (c = await o.verify(i, n, this.b.getLevel() === te.Trace));
      } catch (h) {
        c = { code: vt.UnknownError, didExecute: !1, output: ve(h) };
      }
      const l = new Date().getTime() - a;
      return (
        this.b.info(`Extension signature verification result for ${e}: ${c.code}. Executed: ${c.didExecute}. Duration: ${l}ms.`),
        this.b.trace(`Extension signature verification output for ${e}:
${c.output}`),
        this.c.publicLog2("extensionsignature:verification", { extensionId: e, extensionVersion: s, code: c.code, internalCode: c.internalCode, duration: l, didExecute: c.didExecute, clientTargetPlatform: r }),
        { code: c.code }
      );
    }
  };
fh = __decorate([__param(0, ne), __param(1, Se)], fh);
var fg = new (class {
  transformIncoming(t) {
    return t;
  }
  transformOutgoing(t) {
    return t;
  }
  transformOutgoingURI(t) {
    return t;
  }
  transformOutgoingScheme(t) {
    return t;
  }
})();
function dg(t, e, s, i) {
  if (!t || i > 200) return null;
  if (typeof t == "object") {
    if (t.$mid === 1) return s ? C.revive(e.transformIncoming(t)) : e.transformIncoming(t);
    if (t instanceof L) return null;
    for (const n in t)
      if (Object.hasOwnProperty.call(t, n)) {
        const r = dg(t[n], e, s, i + 1);
        r !== null && (t[n] = r);
      }
  }
  return null;
}
function pg(t, e) {
  const s = dg(t, e, !0, 0);
  return s === null ? t : s;
}
function ms(t, e) {
  return t ? C.revive(e ? e.transformIncoming(t) : t) : void 0;
}
function Ln(t, e) {
  return e ? e.transformOutgoingURI(t) : t;
}
function Nn(t, e) {
  e = e || fg;
  const s = t.manifest;
  return { ...pg({ ...t, manifest: void 0 }, e), manifest: s };
}
function Ar(t, e) {
  return t?.profileLocation ? pg(t, e ?? fg) : t;
}
function Or(t, e) {
  return e ? gp(t, (s) => (s instanceof C ? e.transformOutgoingURI(s) : void 0)) : t;
}
var H5 = class {
    constructor(t, e) {
      (this.a = t),
        (this.b = e),
        (this.onInstallExtension = T.buffer(t.onInstallExtension, !0)),
        (this.onDidInstallExtensions = T.buffer(t.onDidInstallExtensions, !0)),
        (this.onUninstallExtension = T.buffer(t.onUninstallExtension, !0)),
        (this.onDidUninstallExtension = T.buffer(t.onDidUninstallExtension, !0)),
        (this.onDidUpdateExtensionMetadata = T.buffer(t.onDidUpdateExtensionMetadata, !0));
    }
    listen(t, e) {
      const s = this.b(t);
      switch (e) {
        case "onInstallExtension":
          return T.map(this.onInstallExtension, (i) => ({ ...i, profileLocation: i.profileLocation ? Ln(i.profileLocation, s) : i.profileLocation }));
        case "onDidInstallExtensions":
          return T.map(this.onDidInstallExtensions, (i) => i.map((n) => ({ ...n, local: n.local ? Or(n.local, s) : n.local, profileLocation: n.profileLocation ? Ln(n.profileLocation, s) : n.profileLocation })));
        case "onUninstallExtension":
          return T.map(this.onUninstallExtension, (i) => ({ ...i, profileLocation: i.profileLocation ? Ln(i.profileLocation, s) : i.profileLocation }));
        case "onDidUninstallExtension":
          return T.map(this.onDidUninstallExtension, (i) => ({ ...i, profileLocation: i.profileLocation ? Ln(i.profileLocation, s) : i.profileLocation }));
        case "onDidUpdateExtensionMetadata":
          return T.map(this.onDidUpdateExtensionMetadata, (i) => ({ local: Or(i.local, s), profileLocation: Ln(i.profileLocation, s) }));
      }
      throw new Error("Invalid listen");
    }
    async call(t, e, s) {
      const i = this.b(t);
      switch (e) {
        case "zip": {
          const n = Nn(s[0], i),
            r = await this.a.zip(n);
          return Ln(r, i);
        }
        case "install":
          return this.a.install(ms(s[0], i), Ar(s[1], i));
        case "installFromLocation":
          return this.a.installFromLocation(ms(s[0], i), ms(s[1], i));
        case "installExtensionsFromProfile":
          return this.a.installExtensionsFromProfile(s[0], ms(s[1], i), ms(s[2], i));
        case "getManifest":
          return this.a.getManifest(ms(s[0], i));
        case "getTargetPlatform":
          return this.a.getTargetPlatform();
        case "canInstall":
          return this.a.canInstall(s[0]);
        case "installFromGallery":
          return this.a.installFromGallery(s[0], Ar(s[1], i));
        case "installGalleryExtensions": {
          const n = s[0];
          return this.a.installGalleryExtensions(n.map(({ extension: r, options: o }) => ({ extension: r, options: Ar(o, i) ?? {} })));
        }
        case "uninstall":
          return this.a.uninstall(Nn(s[0], i), Ar(s[1], i));
        case "uninstallExtensions": {
          const n = s[0];
          return this.a.uninstallExtensions(n.map(({ extension: r, options: o }) => ({ extension: Nn(r, i), options: Ar(o, i) })));
        }
        case "reinstallFromGallery":
          return this.a.reinstallFromGallery(Nn(s[0], i));
        case "getInstalled":
          return (await this.a.getInstalled(s[0], ms(s[1], i), s[2])).map((r) => Or(r, i));
        case "toggleAppliationScope": {
          const n = await this.a.toggleAppliationScope(Nn(s[0], i), ms(s[1], i));
          return Or(n, i);
        }
        case "copyExtensions":
          return this.a.copyExtensions(ms(s[0], i), ms(s[1], i));
        case "updateMetadata": {
          const n = await this.a.updateMetadata(Nn(s[0], i), s[1], ms(s[2], i));
          return Or(n, i);
        }
        case "resetPinnedStateForAllUserExtensions":
          return this.a.resetPinnedStateForAllUserExtensions(s[0]);
        case "getExtensionsControlManifest":
          return this.a.getExtensionsControlManifest();
        case "download":
          return this.a.download(s[0], s[1], s[2]);
        case "cleanUp":
          return this.a.cleanUp();
      }
      throw new Error("Invalid call");
    }
  },
  G5 = class {
    constructor(t) {
      this.a = t;
    }
    listen(t, e) {
      throw new Error("Invalid listen");
    }
    call(t, e, s) {
      switch (e) {
        case "getConfigBasedTips":
          return this.a.getConfigBasedTips(C.revive(s[0]));
        case "getImportantExecutableBasedTips":
          return this.a.getImportantExecutableBasedTips();
        case "getOtherExecutableBasedTips":
          return this.a.getOtherExecutableBasedTips();
      }
      throw new Error("Invalid call");
    }
  };
import * as J5 from "fs";
import { createWriteStream as gg, promises as mg } from "fs";
var wg = "end of central directory record signature not found",
  K5 = new RegExp(wg),
  fa = class extends Error {
    constructor(t, e) {
      let s = e.message;
      switch (t) {
        case "CorruptZip":
          s = `Corrupt ZIP: ${s}`;
          break;
      }
      super(s), (this.type = t), (this.cause = e);
    }
  };
function X5(t) {
  const e = t.externalFileAttributes >> 16 || 33188;
  return [448, 56, 7].map((s) => e & s).reduce((s, i) => s + i, e & 61440);
}
function vg(t) {
  if (t instanceof fa) return t;
  let e;
  return K5.test(t.message) && (e = "CorruptZip"), new fa(e, t);
}
function Q5(t, e, s, i, n, r) {
  const o = Yt(e),
    a = V(i, o);
  if (!a.startsWith(i)) return Promise.reject(new Error(w(147, null, e)));
  const c = V(i, e);
  let l;
  return (
    r.onCancellationRequested(() => {
      l?.destroy();
    }),
    Promise.resolve(mg.mkdir(a, { recursive: !0 })).then(
      () =>
        new Promise((h, u) => {
          if (!r.isCancellationRequested)
            try {
              (l = gg(c, { mode: s })), l.once("close", () => h()), l.once("error", u), t.once("error", u), t.pipe(l);
            } catch (f) {
              u(f);
            }
        }),
    )
  );
}
function Y5(t, e, s, i) {
  let n = wt(() => Promise.resolve()),
    r = 0;
  const o = i.onCancellationRequested(() => {
    n.cancel(), t.close();
  });
  return new Promise((a, c) => {
    const l = new py(),
      h = (u) => {
        u.isCancellationRequested || (r++, t.readEntry());
      };
    t.once("error", c),
      t.once("close", () =>
        n.then(() => {
          i.isCancellationRequested || t.entryCount === r ? a() : c(new fa("Incomplete", new Error(w(148, null, r, t.entryCount))));
        }, c),
      ),
      t.readEntry(),
      t.on("entry", (u) => {
        if (i.isCancellationRequested) return;
        if (!s.sourcePathRegex.test(u.fileName)) {
          h(i);
          return;
        }
        const f = u.fileName.replace(s.sourcePathRegex, "");
        if (/\/$/.test(f)) {
          const g = V(e, f);
          n = wt((m) =>
            mg
              .mkdir(g, { recursive: !0 })
              .then(() => h(m))
              .then(void 0, c),
          );
          return;
        }
        const d = bg(t, u),
          p = X5(u);
        n = wt((g) => l.queue(() => d.then((m) => Q5(m, f, p, e, s, g).then(() => h(g)))).then(null, c));
      });
  }).finally(() => o.dispose());
}
async function yg(t, e = !1) {
  const { open: s } = await import("yauzl");
  return new Promise((i, n) => {
    s(t, e ? { lazyEntries: !0 } : void 0, (r, o) => {
      r ? n(vg(r)) : i(ls(o));
    });
  });
}
function bg(t, e) {
  return new Promise((s, i) => {
    t.openReadStream(e, (n, r) => {
      n ? i(vg(n)) : s(ls(r));
    });
  });
}
async function Z5(t, e) {
  const { ZipFile: s } = await import("yazl");
  return new Promise((i, n) => {
    const r = new s();
    e.forEach((a) => {
      a.contents ? r.addBuffer(typeof a.contents == "string" ? Buffer.from(a.contents, "utf8") : a.contents, a.path) : a.localPath && r.addFile(a.localPath, a.path);
    }),
      r.end();
    const o = gg(t);
    r.outputStream.pipe(o), r.outputStream.once("error", n), o.once("error", n), o.once("finish", () => i(t));
  });
}
function e2(t, e, s = {}, i) {
  const n = new RegExp(s.sourcePath ? `^${s.sourcePath}` : "");
  let r = yg(t, !0);
  return s.overwrite && (r = r.then((o) => he.rm(e).then(() => o))), r.then((o) => Y5(o, e, { sourcePathRegex: n }, i));
}
function t2(t, e) {
  return yg(t).then(
    (s) =>
      new Promise((i, n) => {
        s.on("entry", (r) => {
          r.fileName === e &&
            bg(s, r).then(
              (o) => i(o),
              (o) => n(o),
            );
        }),
          s.once("close", () => n(new Error(w(149, null, e))));
      }),
  );
}
function Eg(t, e) {
  return t2(t, e).then(
    (s) =>
      new Promise((i, n) => {
        const r = [];
        s.once("error", n), s.on("data", (o) => r.push(o)), s.on("end", () => i(Buffer.concat(r)));
      }),
  );
}
var dh = class extends O {
  get onInstallExtension() {
    return this.n.event;
  }
  get onDidInstallExtensions() {
    return this.s.event;
  }
  get onUninstallExtension() {
    return this.t.event;
  }
  get onDidUninstallExtension() {
    return this.u.event;
  }
  get onDidUpdateExtensionMetadata() {
    return this.w.event;
  }
  constructor(e, s, i, n, r, o) {
    super(),
      (this.z = e),
      (this.C = s),
      (this.D = i),
      (this.F = n),
      (this.G = r),
      (this.H = o),
      (this.h = 0),
      (this.j = new Map()),
      (this.m = new Map()),
      (this.n = this.B(new D())),
      (this.s = this.B(new D())),
      (this.t = this.B(new D())),
      (this.u = this.B(new D())),
      (this.w = this.B(new D())),
      (this.y = []),
      this.B(
        ue(() => {
          this.j.forEach(({ task: a }) => a.cancel()), this.m.forEach((a) => a.cancel()), this.j.clear(), this.m.clear();
        }),
      );
  }
  async canInstall(e) {
    const s = await this.getTargetPlatform();
    return e.allTargetPlatforms.some((i) => wl(i, e.allTargetPlatforms, s));
  }
  async installFromGallery(e, s = {}) {
    try {
      const n = (await this.installGalleryExtensions([{ extension: e, options: s }])).find(({ identifier: r }) => G(r, e.identifier));
      if (n?.local) return n?.local;
      throw n?.error ? n.error : new Ne(`Unknown error while installing extension ${e.identifier.id}`, "Unknown");
    } catch (i) {
      throw We(i);
    }
  }
  async installGalleryExtensions(e) {
    if (!this.z.isEnabled()) throw new Ne(w(1803, null), "NotAllowed");
    const s = [],
      i = [];
    return (
      await Promise.allSettled(
        e.map(async ({ extension: n, options: r }) => {
          try {
            const o = await this.O(n, !!r?.installGivenVersion, !!r?.installPreReleaseVersion, r.productVersion ?? { version: this.G.version, date: this.G.date });
            i.push({ ...o, options: r });
          } catch (o) {
            s.push({ identifier: n.identifier, operation: 2, source: n, error: o, profileLocation: r.profileLocation ?? this.X() });
          }
        }),
      ),
      i.length && s.push(...(await this.I(i))),
      s
    );
  }
  async uninstall(e, s) {
    return this.F.trace("ExtensionManagementService#uninstall", e.identifier.id), this.uninstallExtensions([{ extension: e, options: s }]);
  }
  async toggleAppliationScope(e, s) {
    if (Ql(e.manifest) || e.isBuiltin) return e;
    if (e.isApplicationScoped) {
      let i = await this.updateMetadata(e, { isApplicationScoped: !1 }, this.H.defaultProfile.extensionsResource);
      this.D.extUri.isEqual(s, this.H.defaultProfile.extensionsResource) || (i = await this.$(e, this.H.defaultProfile.extensionsResource, s));
      for (const n of this.H.profiles) {
        const r = (await this.getInstalled(1, n.extensionsResource)).find((o) => G(o.identifier, e.identifier));
        r ? this.w.fire({ local: r, profileLocation: n.extensionsResource }) : this.u.fire({ identifier: e.identifier, profileLocation: n.extensionsResource });
      }
      return i;
    } else {
      const i = this.D.extUri.isEqual(s, this.H.defaultProfile.extensionsResource)
        ? await this.updateMetadata(e, { isApplicationScoped: !0 }, this.H.defaultProfile.extensionsResource)
        : await this.$(e, s, this.H.defaultProfile.extensionsResource, { isApplicationScoped: !0 });
      return this.s.fire([{ identifier: i.identifier, operation: 2, local: i, profileLocation: this.H.defaultProfile.extensionsResource, applicationScoped: !0 }]), i;
    }
  }
  getExtensionsControlManifest() {
    const e = new Date().getTime();
    return (!this.g || e - this.h > 1e3 * 60 * 5) && ((this.g = this.W()), (this.h = e)), this.g;
  }
  registerParticipant(e) {
    this.y.push(e);
  }
  async resetPinnedStateForAllUserExtensions(e) {
    try {
      await this.M(
        this.H.profiles.map(async (s) => {
          const i = await this.getInstalled(1, s.extensionsResource);
          await this.M(
            i.map(async (n) => {
              n.pinned !== e && (await this.updateMetadata(n, { pinned: e }, s.extensionsResource));
            }),
          );
        }),
      );
    } catch (s) {
      throw (this.F.error("Error while resetting pinned state for all user extensions", ve(s)), s);
    }
  }
  async I(e) {
    const s = new Map(),
      i = new Map(),
      n = [],
      r = (a, c) => `${Tt.create(a).toString()}-${c.toString()}`,
      o = (a, c, l, h) => {
        if (!C.isUri(c)) {
          if (i.has(`${c.identifier.id.toLowerCase()}-${l.profileLocation.toString()}`)) return;
          const d = this.j.get(r(c, l.profileLocation));
          if (d) {
            if (h && this.L(h, d.task)) {
              const p = d.task.identifier;
              this.F.info("Waiting for already requested installing extension", p.id, h.identifier.id, l.profileLocation.toString()),
                d.waitingTasks.push(h),
                n.push(
                  T.toPromise(T.filter(this.onDidInstallExtensions, (g) => g.some((m) => G(m.identifier, p)))).then((g) => {
                    if ((this.F.info("Finished waiting for already requested installing extension", p.id, h.identifier.id, l.profileLocation.toString()), !g.find((v) => G(v.identifier, p))?.local))
                      throw new Error(`Extension ${p.id} is not installed`);
                  }),
                );
            }
            return;
          }
        }
        const u = this.Y(a, c, l),
          f = `${ai(a.publisher, a.name)}-${l.profileLocation.toString()}`;
        i.set(f, { task: u, root: h }),
          this.n.fire({ identifier: u.identifier, source: c, profileLocation: l.profileLocation }),
          this.F.info("Installing extension:", u.identifier.id, l),
          C.isUri(c) || this.j.set(r(c, l.profileLocation), { task: u, waitingTasks: [] });
      };
    try {
      for (const { manifest: c, extension: l, options: h } of e) {
        const u = h.isApplicationScoped || h.isBuiltin || Ql(c),
          f = {
            ...h,
            installOnlyNewlyAddedFromExtensionPack: h.installOnlyNewlyAddedFromExtensionPack ?? !C.isUri(l),
            isApplicationScoped: u,
            profileLocation: u ? this.H.defaultProfile.extensionsResource : (h.profileLocation ?? this.X()),
            productVersion: h.productVersion ?? { version: this.G.version, date: this.G.date },
          },
          d = C.isUri(l) ? void 0 : this.j.get(r(l, f.profileLocation));
        d ? (this.F.info("Extension is already requested to install", d.task.identifier.id, f.profileLocation.toString()), n.push(d.task.waitUntilTaskIsFinished())) : o(c, l, f, void 0);
      }
      await Promise.all(
        [...i.values()].map(async ({ task: c }) => {
          if (c.options.donotIncludePackAndDependencies) this.F.info("Installing the extension without checking dependencies and pack", c.identifier.id);
          else
            try {
              const l = await this.N(c.identifier, c.manifest, !!c.options.installOnlyNewlyAddedFromExtensionPack, !!c.options.installPreReleaseVersion, c.options.profileLocation, c.options.productVersion),
                h = await this.getInstalled(void 0, c.options.profileLocation, c.options.productVersion),
                u = { ...c.options, context: { ...c.options.context, [H4]: !0 } };
              for (const { gallery: f, manifest: d } of Bt(l, ({ gallery: p }) => p.identifier.id)) h.some(({ identifier: p }) => G(p, f.identifier)) || o(d, f, u, c);
            } catch (l) {
              if (C.isUri(c.source))
                Xn(c.manifest.extensionDependencies) && this.F.warn("Cannot install dependencies of extension:", c.identifier.id, l.message),
                  Xn(c.manifest.extensionPack) && this.F.warn("Cannot install packed extensions of extension:", c.identifier.id, l.message);
              else throw (this.F.error("Error while preparing to install dependencies and extension packs of the extension:", c.identifier.id), l);
            }
        }),
      );
      const a = await this.J([...i.values()].map(({ task: c }) => c));
      for (const [c, l] of a) o(l.manifest, l.source, { ...l.options, profileLocation: c }, void 0);
      return (
        await this.M(
          [...i.entries()].map(async ([c, { task: l }]) => {
            const h = new Date().getTime();
            let u;
            try {
              (u = await l.run()),
                await this.M(
                  this.y.map((f) => f.postInstall(u, l.source, l.options, J.None)),
                  "PostInstall",
                );
            } catch (f) {
              const d = We(f);
              throw (
                (C.isUri(l.source) || ph(this.C, l.operation === 3 ? "extensionGallery:update" : "extensionGallery:install", { extensionData: th(l.source), error: d, source: l.options.context?.[ml] }),
                s.set(c, { error: d, identifier: l.identifier, operation: l.operation, source: l.source, context: l.options.context, profileLocation: l.options.profileLocation, applicationScoped: l.options.isApplicationScoped }),
                this.F.error("Error while installing the extension", l.identifier.id, ve(d), l.options.profileLocation.toString()),
                d)
              );
            }
            if (!C.isUri(l.source)) {
              const f = l.operation === 3,
                d = f ? void 0 : (new Date().getTime() - l.source.lastUpdated) / 1e3;
              if (
                (ph(this.C, f ? "extensionGallery:update" : "extensionGallery:install", {
                  extensionData: th(l.source),
                  verificationStatus: l.verificationStatus,
                  duration: new Date().getTime() - h,
                  durationSinceUpdate: d,
                  source: l.options.context?.[ml],
                }),
                Qe && l.operation !== 3)
              )
                try {
                  await this.z.reportStatistic(u.manifest.publisher, u.manifest.name, u.manifest.version, "install");
                } catch {}
            }
            s.set(c, { local: u, identifier: l.identifier, operation: l.operation, source: l.source, context: l.options.context, profileLocation: l.options.profileLocation, applicationScoped: u.isApplicationScoped });
          }),
        ),
        n.length && (await this.M(n)),
        [...s.values()]
      );
    } catch (a) {
      const c = (u, f, d) => {
          const p = [];
          u.manifest.extensionDependencies?.length && p.push(...u.manifest.extensionDependencies), u.manifest.extensionPack?.length && p.push(...u.manifest.extensionPack);
          for (const g of p) {
            if (d.includes(g.toLowerCase())) continue;
            d.push(g.toLowerCase());
            const m = s.get(`${g.toLowerCase()}-${f.toString()}`);
            m?.local && (d = c(m.local, f, d));
          }
          return d;
        },
        l = (u) => ({ identifier: u.identifier, operation: 2, source: u.source, context: u.options.context, profileLocation: u.options.profileLocation, error: a }),
        h = [];
      for (const [u, { task: f, root: d }] of i) {
        const p = s.get(u);
        p
          ? p.local && d && !s.get(`${d.identifier.id.toLowerCase()}-${f.options.profileLocation.toString()}`)?.local && (h.push(this.Z(p.local, { versionOnly: !0, profileLocation: f.options.profileLocation })), s.set(u, l(f)))
          : (f.cancel(), s.set(u, l(f)));
      }
      for (const [u, { task: f }] of i) {
        const d = s.get(u);
        if (!d?.local || f.options.donotIncludePackAndDependencies) continue;
        c(d.local, f.options.profileLocation, [d.local.identifier.id.toLowerCase()])
          .slice(1)
          .some((g) => i.has(`${g.toLowerCase()}-${f.options.profileLocation.toString()}`) && !s.get(`${g.toLowerCase()}-${f.options.profileLocation.toString()}`)?.local) &&
          (h.push(this.Z(d.local, { versionOnly: !0, profileLocation: f.options.profileLocation })), s.set(u, l(f)));
      }
      throw (
        (h.length &&
          (await Promise.allSettled(
            h.map(async (u) => {
              try {
                await u.run(), this.F.info("Rollback: Uninstalled extension", u.extension.identifier.id);
              } catch (f) {
                this.F.warn("Rollback: Error while uninstalling extension", u.extension.identifier.id, ve(f));
              }
            }),
          )),
        a)
      );
    } finally {
      for (const { task: a } of i.values()) a.source && !C.isUri(a.source) && this.j.delete(r(a.source, a.options.profileLocation));
      if (s.size) {
        const a = [...s.values()];
        for (const c of a) c.local && this.F.info("Extension installed successfully:", c.identifier.id, c.profileLocation.toString());
        this.s.fire(a);
      }
    }
  }
  async J(e) {
    const s = [],
      i = new kt();
    for (const n of e)
      if (!(n.operation !== 3 || n.options.isApplicationScoped || n.options.pinned || n.options.installGivenVersion || C.isUri(n.source)))
        for (const r of this.H.profiles) {
          if (this.D.extUri.isEqual(r.extensionsResource, n.options.profileLocation)) continue;
          let o = i.get(r.extensionsResource);
          o || ((o = await this.getInstalled(1, r.extensionsResource)), i.set(r.extensionsResource, o));
          const a = o.find((c) => G(c.identifier, n.identifier));
          a && !a.pinned && s.push([r.extensionsResource, n]);
        }
    return s;
  }
  L(e, s) {
    for (const [, { task: i, waitingTasks: n }] of this.j.entries()) if ((i === e && (n.includes(s) || n.some((r) => this.L(r, s)))) || (i === s && n[0] && !this.L(e, n[0]))) return !1;
    return !0;
  }
  async M(e, s) {
    const i = [],
      n = [],
      r = await Promise.allSettled(e);
    for (const a of r) a.status === "fulfilled" ? i.push(a.value) : n.push(We(a.reason, s));
    if (!n.length) return i;
    if (n.length === 1) throw n[0];
    let o = new Ne("", "Unknown");
    for (const a of n) o = new Ne(o.message ? `${o.message}, ${a.message}` : a.message, a.code !== "Unknown" && a.code !== "Internal" ? a.code : o.code);
    throw o;
  }
  async N(e, s, i, n, r, o) {
    if (!this.z.isEnabled()) return [];
    const a = await this.getInstalled(void 0, r, o),
      c = [],
      l = [],
      h = async (u, f) => {
        c.push(u);
        const d = f.extensionDependencies || [],
          p = [...d];
        if (f.extensionPack) {
          const g = i ? a.find((m) => G(m.identifier, u)) : void 0;
          for (const m of f.extensionPack) (g && g.manifest.extensionPack && g.manifest.extensionPack.some((v) => G({ id: v }, { id: m }))) || (p.every((v) => !G({ id: v }, { id: m })) && p.push(m));
        }
        if (p.length) {
          const g = p.filter((m) => c.every((v) => !G(v, { id: m })));
          if (g.length) {
            const m = await this.z.getExtensions(
              g.map((v) => ({ id: v, preRelease: n })),
              J.None,
            );
            for (const v of m) {
              if (c.find(($) => G($, v.identifier))) continue;
              const b = d.some(($) => G({ id: $ }, v.identifier));
              let E;
              try {
                E = await this.O(v, !1, n, o);
              } catch ($) {
                if (b) throw $;
                this.F.info("Skipping the packed extension as it cannot be installed", v.identifier.id, ve($));
                continue;
              }
              l.push({ gallery: E.extension, manifest: E.manifest }), await h(E.extension.identifier, E.manifest);
            }
          }
        }
      };
    return await h(e, s), l;
  }
  async O(e, s, i, n) {
    let r;
    const o = await this.getExtensionsControlManifest();
    if (o.malicious.some((l) => G(e.identifier, l))) throw new Ne(w(1804, null, e.identifier.id), "Malicious");
    const a = o.deprecated[e.identifier.id.toLowerCase()];
    if (a?.extension?.autoMigrate) {
      if (
        (this.F.info(`The '${e.identifier.id}' extension is deprecated, fetching the compatible '${a.extension.id}' extension instead.`),
        (r = (await this.z.getExtensions([{ id: a.extension.id, preRelease: a.extension.preRelease }], { targetPlatform: await this.getTargetPlatform(), compatible: !0, productVersion: n }, J.None))[0]),
        !r)
      )
        throw new Ne(w(1805, null, e.identifier.id, a.extension.id), "Deprecated");
    } else {
      if (!(await this.canInstall(e))) {
        const l = await this.getTargetPlatform();
        throw new Ne(w(1806, null, e.identifier.id, this.G.nameLong, J4(l)), "IncompatibleTargetPlatform");
      }
      if (((r = await this.P(e, s, i, n)), !r)) {
        const l = [];
        throw oh(e.properties.enabledApiProposals ?? [], l)
          ? !i && e.properties.isPreReleaseVersion && (await this.z.getExtensions([e.identifier], J.None))[0]
            ? new Ne(w(1808, null, e.displayName ?? e.identifier.id), "ReleaseVersionNotFound")
            : new Ne(w(1809, null, e.identifier.id, this.G.nameLong, this.G.version), "Incompatible")
          : new Ne(w(1807, null, e.displayName ?? e.identifier.id, l[0]), "IncompatibleApi");
      }
    }
    this.F.info("Getting Manifest...", r.identifier.id);
    const c = await this.z.getManifest(r, J.None);
    if (c === null) throw new Ne(`Missing manifest for extension ${r.identifier.id}`, "Invalid");
    if (c.version !== r.version) throw new Ne(`Cannot install '${r.identifier.id}' extension because of version mismatch in Marketplace`, "Invalid");
    return { extension: r, manifest: c };
  }
  async P(e, s, i, n) {
    const r = await this.getTargetPlatform();
    let o = null;
    return (
      !s && e.hasPreReleaseVersion && e.properties.isPreReleaseVersion !== i && (o = (await this.z.getExtensions([{ ...e.identifier, preRelease: i }], { targetPlatform: r, compatible: !0, productVersion: n }, J.None))[0] || null),
      !o && (await this.z.isExtensionCompatible(e, i, r, n)) && (o = e),
      o || (s ? (o = (await this.z.getExtensions([{ ...e.identifier, version: e.version }], { targetPlatform: r, compatible: !0, productVersion: n }, J.None))[0] || null) : (o = await this.z.getCompatibleExtension(e, i, r, n))),
      o
    );
  }
  async uninstallExtensions(e) {
    const s = (l, h) => `${l.identifier.id.toLowerCase()}${h.versionOnly ? `-${l.manifest.version}` : ""}@${h.profileLocation.toString()}`,
      i = (l, h) => {
        const u = this.Z(l, h);
        return (
          this.m.set(s(u.extension, h), u),
          this.F.info("Uninstalling extension from the profile:", `${l.identifier.id}@${l.manifest.version}`, h.profileLocation.toString()),
          this.t.fire({ identifier: l.identifier, profileLocation: h.profileLocation, applicationScoped: l.isApplicationScoped }),
          u
        );
      },
      n = (l, h, u) => {
        u
          ? this.F.error("Failed to uninstall extension from the profile:", `${l.identifier.id}@${l.manifest.version}`, h.profileLocation.toString(), u.message)
          : this.F.info("Successfully uninstalled extension from the profile", `${l.identifier.id}@${l.manifest.version}`, h.profileLocation.toString()),
          ph(this.C, "extensionGallery:uninstall", { extensionData: p5(l), error: u }),
          this.u.fire({ identifier: l.identifier, error: u?.code, profileLocation: h.profileLocation, applicationScoped: l.isApplicationScoped });
      },
      r = [],
      o = [],
      a = [],
      c = new kt();
    for (const { extension: l, options: h } of e) {
      const u = { ...h, profileLocation: l.isApplicationScoped ? this.H.defaultProfile.extensionsResource : (h?.profileLocation ?? this.X()) },
        f = this.m.get(s(l, u));
      f ? (this.F.info("Extensions is already requested to uninstall", l.identifier.id), a.push(f.waitUntilTaskIsFinished())) : r.push(i(l, u));
    }
    try {
      for (const l of r.slice(0)) {
        let h = c.get(l.options.profileLocation);
        if ((h || c.set(l.options.profileLocation, (h = await this.getInstalled(1, l.options.profileLocation))), l.options.donotIncludePack))
          this.F.info("Uninstalling the extension without including packed extension", `${l.extension.identifier.id}@${l.extension.manifest.version}`);
        else {
          const u = this.S(l.extension, h);
          for (const f of u) this.m.has(s(f, l.options)) ? this.F.info("Extensions is already requested to uninstall", f.identifier.id) : r.push(i(f, l.options));
        }
        l.options.donotCheckDependents
          ? this.F.info("Uninstalling the extension without checking dependents", `${l.extension.identifier.id}@${l.extension.manifest.version}`)
          : this.Q(
              r.map((u) => u.extension),
              h,
              l.extension,
            );
      }
      await this.M(
        r.map(async (l) => {
          try {
            if ((await l.run(), await this.M(this.y.map((h) => h.postUninstall(l.extension, l.options, J.None))), l.extension.identifier.uuid))
              try {
                await this.z.reportStatistic(l.extension.manifest.publisher, l.extension.manifest.name, l.extension.manifest.version, "uninstall");
              } catch {}
          } catch (h) {
            const u = We(h);
            throw (n(l.extension, l.options, u), u);
          } finally {
            o.push(l);
          }
        }),
      ),
        a.length && (await this.M(a));
      for (const l of r) n(l.extension, l.options);
    } catch (l) {
      const h = We(l);
      for (const u of r) {
        try {
          u.cancel();
        } catch {}
        o.includes(u) || n(u.extension, u.options, h);
      }
      throw h;
    } finally {
      for (const l of r) this.m.delete(s(l.extension, l.options)) || this.F.warn("Uninstallation task is not found in the cache", l.extension.identifier.id);
    }
  }
  Q(e, s, i) {
    for (const n of e) {
      const r = this.U(n, s);
      if (r.length) {
        const o = r.filter((a) => !e.some((c) => G(c.identifier, a.identifier)));
        if (o.length) throw new Error(this.R(n, o, i));
      }
    }
  }
  R(e, s, i) {
    return i === e
      ? s.length === 1
        ? w(1810, null, i.manifest.displayName || i.manifest.name, s[0].manifest.displayName || s[0].manifest.name)
        : s.length === 2
          ? w(1811, null, i.manifest.displayName || i.manifest.name, s[0].manifest.displayName || s[0].manifest.name, s[1].manifest.displayName || s[1].manifest.name)
          : w(1812, null, i.manifest.displayName || i.manifest.name, s[0].manifest.displayName || s[0].manifest.name, s[1].manifest.displayName || s[1].manifest.name)
      : s.length === 1
        ? w(1813, null, i.manifest.displayName || i.manifest.name, e.manifest.displayName || e.manifest.name, s[0].manifest.displayName || s[0].manifest.name)
        : s.length === 2
          ? w(1814, null, i.manifest.displayName || i.manifest.name, e.manifest.displayName || e.manifest.name, s[0].manifest.displayName || s[0].manifest.name, s[1].manifest.displayName || s[1].manifest.name)
          : w(1815, null, i.manifest.displayName || i.manifest.name, e.manifest.displayName || e.manifest.name, s[0].manifest.displayName || s[0].manifest.name, s[1].manifest.displayName || s[1].manifest.name);
  }
  S(e, s, i = []) {
    if (i.indexOf(e) !== -1) return [];
    i.push(e);
    const n = e.manifest.extensionPack ? e.manifest.extensionPack : [];
    if (n.length) {
      const r = s.filter((a) => !a.isBuiltin && n.some((c) => G({ id: c }, a.identifier))),
        o = [];
      for (const a of r) o.push(...this.S(a, s, i));
      return [...r, ...o];
    }
    return [];
  }
  U(e, s) {
    return s.filter((i) => i.manifest.extensionDependencies && i.manifest.extensionDependencies.some((n) => G({ id: n }, e.identifier)));
  }
  async W() {
    try {
      return this.F.trace("ExtensionManagementService.updateControlCache"), await this.z.getExtensionsControlManifest();
    } catch (e) {
      return this.F.trace("ExtensionManagementService.refreshControlCache - failed to get extension control manifest", ve(e)), { malicious: [], deprecated: {}, search: [] };
    }
  }
};
dh = __decorate([__param(0, ps), __param(1, Se), __param(2, ke), __param(3, ne), __param(4, Ee), __param(5, Te)], dh);
function We(t, e) {
  if (t instanceof Ne) return t;
  let s;
  return t instanceof Mo ? (s = new Ne(t.message, t.code === "DownloadFailedWriting" ? "DownloadFailedWriting" : "Gallery")) : (s = new Ne(t.message, Fs(t) ? "Cancelled" : (e ?? "Internal"))), (s.stack = t.stack), s;
}
function ph(t, e, { extensionData: s, verificationStatus: i, duration: n, error: r, source: o, durationSinceUpdate: a }) {
  t.publicLog(e, { ...s, source: o, duration: n, durationSinceUpdate: a, success: !r, errorcode: r?.code, verificationStatus: i === vt.Success ? "Verified" : (i ?? "Unverified") });
}
var Sg = class {
    constructor() {
      this.d = new Jc();
    }
    async waitUntilTaskIsFinished() {
      return await this.d.wait(), this.g;
    }
    run() {
      return this.g || (this.g = wt((t) => this.h(t))), this.d.open(), this.g;
    }
    cancel() {
      this.g ||
        ((this.g = wt(
          (t) =>
            new Promise((e, s) => {
              const i = t.onCancellationRequested(() => {
                i.dispose(), s(new ot());
              });
            }),
        )),
        this.d.open()),
        this.g.cancel();
    }
  },
  $g;
(function (t) {
  (t.ERROR_PROFILE_NOT_FOUND = "ERROR_PROFILE_NOT_FOUND"), (t.ERROR_INVALID_CONTENT = "ERROR_INVALID_CONTENT");
})($g || ($g = {}));
var da = class extends Error {
    constructor(t, e) {
      super(t), (this.code = e);
    }
  },
  ci = z("IExtensionsProfileScannerService"),
  gh = class extends O {
    constructor(e, s, i, n, r, o) {
      super(),
        (this.j = e),
        (this.m = s),
        (this.n = i),
        (this.r = n),
        (this.s = r),
        (this.t = o),
        (this.b = this.B(new D())),
        (this.onAddExtensions = this.b.event),
        (this.c = this.B(new D())),
        (this.onDidAddExtensions = this.c.event),
        (this.f = this.B(new D())),
        (this.onRemoveExtensions = this.f.event),
        (this.g = this.B(new D())),
        (this.onDidRemoveExtensions = this.g.event),
        (this.h = new kt());
    }
    scanProfileExtensions(e, s) {
      return this.u(e, void 0, s);
    }
    async addExtensionsToProfile(e, s, i) {
      const n = [],
        r = [];
      try {
        return (
          await this.u(s, (o) => {
            const a = [];
            if (i) a.push(...o);
            else for (const c of o) e.some(([l]) => G(l.identifier, c.identifier) && l.manifest.version !== c.version) ? n.push(c) : a.push(c);
            for (const [c, l] of e) {
              const h = a.findIndex((f) => G(f.identifier, c.identifier) && f.version === c.manifest.version),
                u = { identifier: c.identifier, version: c.manifest.version, location: c.location, metadata: l };
              h === -1 ? (r.push(u), a.push(u)) : a.splice(h, 1, u);
            }
            return r.length && this.b.fire({ extensions: r, profileLocation: s }), n.length && this.f.fire({ extensions: n, profileLocation: s }), a;
          }),
          r.length && this.c.fire({ extensions: r, profileLocation: s }),
          n.length && this.g.fire({ extensions: n, profileLocation: s }),
          r
        );
      } catch (o) {
        throw (r.length && this.c.fire({ extensions: r, error: o, profileLocation: s }), n.length && this.g.fire({ extensions: n, error: o, profileLocation: s }), o);
      }
    }
    async updateMetadata(e, s) {
      const i = [];
      return (
        await this.u(s, (n) => {
          const r = [];
          for (const o of n) {
            const a = e.find(([c]) => G(c.identifier, o.identifier) && c.manifest.version === o.version);
            a && ((o.metadata = { ...o.metadata, ...a[1] }), i.push(o)), r.push(o);
          }
          return r;
        }),
        i
      );
    }
    async removeExtensionFromProfile(e, s) {
      const i = [];
      try {
        await this.u(s, (n) => {
          const r = [];
          for (const o of n) G(o.identifier, e.identifier) ? i.push(o) : r.push(o);
          return i.length && this.f.fire({ extensions: i, profileLocation: s }), r;
        }),
          i.length && this.g.fire({ extensions: i, profileLocation: s });
      } catch (n) {
        throw (i.length && this.g.fire({ extensions: i, error: n, profileLocation: s }), n);
      }
    }
    async u(e, s, i) {
      return this.F(e).queue(async () => {
        let n = [],
          r;
        try {
          const o = await this.m.readFile(e);
          r = JSON.parse(o.value.toString().trim() || "[]");
        } catch (o) {
          if (ct(o) !== 1) throw o;
          if ((this.r.extUri.isEqual(e, this.n.defaultProfile.extensionsResource) && (r = await this.D()), !r && i?.bailOutWhenFileNotFound)) throw new da(ve(o), "ERROR_PROFILE_NOT_FOUND");
        }
        if (r) {
          Array.isArray(r) || this.w(e);
          let o = !1;
          for (const a of r) {
            xg(a) || this.w(e);
            let c;
            if (_e(a.relativeLocation) && a.relativeLocation) c = this.z(a.relativeLocation);
            else if (_e(a.location)) {
              this.t.warn(`Extensions profile: Ignoring extension with invalid location: ${a.location}`);
              continue;
            } else {
              c = C.revive(a.location);
              const l = this.y(c);
              l && ((o = !0), (a.relativeLocation = l));
            }
            Ct(a.metadata?.hasPreReleaseVersion) && a.metadata?.preRelease && ((o = !0), (a.metadata.hasPreReleaseVersion = !0)), n.push({ identifier: a.identifier, location: c, version: a.version, metadata: a.metadata });
          }
          o && (await this.m.writeFile(e, L.fromString(JSON.stringify(r))));
        }
        if (s) {
          n = s(n);
          const o = n.map((a) => ({ identifier: a.identifier, version: a.version, location: a.location.toJSON(), relativeLocation: this.y(a.location), metadata: a.metadata }));
          await this.m.writeFile(e, L.fromString(JSON.stringify(o)));
        }
        return n;
      });
    }
    w(e) {
      const s = new da(`Invalid extensions content in ${e.toString()}`, "ERROR_INVALID_CONTENT");
      throw (this.s.publicLogError2("extensionsProfileScanningError", { code: s.code }), s);
    }
    y(e) {
      return this.r.extUri.isEqual(this.r.extUri.dirname(e), this.j) ? this.r.extUri.basename(e) : void 0;
    }
    z(e) {
      return this.r.extUri.joinPath(this.j, e);
    }
    async D() {
      return (
        this.C ||
          (this.C = (async () => {
            const e = this.r.extUri.joinPath(this.n.defaultProfile.location, "extensions.json"),
              s = this.r.extUri.joinPath(this.j, ".init-default-profile-extensions");
            let i;
            try {
              i = (await this.m.readFile(e)).value.toString();
            } catch (r) {
              if (ct(r) === 1) return;
              throw r;
            }
            this.t.info("Migrating extensions from old default profile location", e.toString());
            let n;
            try {
              const r = JSON.parse(i);
              Array.isArray(r) && r.every((o) => xg(o)) ? (n = r) : this.t.warn("Skipping migrating from old default profile locaiton: Found invalid data", r);
            } catch (r) {
              this.t.error(r);
            }
            if (n)
              try {
                await this.m.createFile(this.n.defaultProfile.extensionsResource, L.fromString(JSON.stringify(n)), { overwrite: !1 }),
                  this.t.info("Migrated extensions from old default profile location to new location", e.toString(), this.n.defaultProfile.extensionsResource.toString());
              } catch (r) {
                if (ct(r) === 3) this.t.info("Migration from old default profile location to new location is done by another window", e.toString(), this.n.defaultProfile.extensionsResource.toString());
                else throw r;
              }
            try {
              await this.m.del(e);
            } catch (r) {
              ct(r) !== 1 && this.t.error(r);
            }
            try {
              await this.m.del(s);
            } catch (r) {
              ct(r) !== 1 && this.t.error(r);
            }
            return n;
          })()),
        this.C
      );
    }
    F(e) {
      let s = this.h.get(e);
      return s || ((s = new rr()), this.h.set(e, s)), s;
    }
  };
gh = __decorate([__param(1, ie), __param(2, Te), __param(3, ke), __param(4, Se), __param(5, ne)], gh);
function xg(t) {
  return Ke(t) && X4(t.identifier) && (s2(t.location) || (_e(t.location) && t.location)) && (Ct(t.relativeLocation) || _e(t.relativeLocation)) && t.version && _e(t.version);
}
function s2(t) {
  return t ? _e(t.path) && _e(t.scheme) : !1;
}
function mh(t) {
  switch (t) {
    case 1:
      return w(118, null);
    case 2:
      return w(119, null);
    case 3:
      return w(120, null);
    case 4:
      return w(121, null);
    case 5:
      return w(122, null);
    case 6:
      return w(123, null);
    case 7:
      return w(124, null);
    case 8:
      return w(125, null);
    case 9:
      return w(126, null);
    default:
      return "";
  }
}
function i2(t, e, s, i) {
  try {
    n2(t, e, s, i);
  } catch (n) {
    t.error(n?.message ?? n);
  }
  return e;
}
function n2(t, e, s, i) {
  const n = (r, o, a) => {
    const c = r[o];
    if (_e(c)) {
      const l = c,
        h = l.length;
      if (h > 1 && l[0] === "%" && l[h - 1] === "%") {
        const u = l.substr(1, h - 2);
        let f = s[u];
        f === void 0 && i && (f = i[u]);
        const d = typeof f == "string" ? f : f?.message,
          p = i?.[u],
          g = typeof p == "string" ? p : p?.message;
        if (!d) {
          g || t.warn(`[${e.name}]: ${w(1851, null, u)}`);
          return;
        }
        if (a && (o === "title" || o === "category") && g && g !== d) {
          const m = { value: d, original: g };
          r[o] = m;
        } else r[o] = d;
      }
    } else if (Ke(c)) for (const l in c) c.hasOwnProperty(l) && (l === "commands" ? n(c, l, !0) : n(c, l, a));
    else if (Array.isArray(c)) for (let l = 0; l < c.length; l++) n(c, l, a);
  };
  for (const r in e) e.hasOwnProperty(r) && n(e, r);
}
var wh;
(function (t) {
  function e(s, i) {
    if (s === i) return !0;
    const n = Object.keys(s),
      r = new Set();
    for (const o of Object.keys(i)) r.add(o);
    if (n.length !== r.size) return !1;
    for (const o of n) {
      if (s[o] !== i[o]) return !1;
      r.delete(o);
    }
    return r.size === 0;
  }
  t.equals = e;
})(wh || (wh = {}));
var pa = z("IExtensionsScannerService"),
  vh = class extends O {
    constructor(e, s, i, n, r, o, a, c, l, h, u, f) {
      super(),
        (this.systemExtensionsLocation = e),
        (this.userExtensionsLocation = s),
        (this.r = i),
        (this.s = n),
        (this.t = r),
        (this.u = o),
        (this.w = a),
        (this.y = c),
        (this.z = l),
        (this.C = h),
        (this.D = u),
        (this.F = f),
        (this.g = this.B(new D())),
        (this.onDidChangeCache = this.g.event),
        (this.h = M(this.userExtensionsLocation, ".obsolete")),
        (this.j = this.B(this.F.createInstance(ma, this.s, this.h))),
        (this.m = this.B(this.F.createInstance(ma, this.s, this.h))),
        (this.n = this.B(this.F.createInstance(ga, this.h))),
        (this.H = void 0),
        this.B(this.j.onDidChangeCache(() => this.g.fire(0))),
        this.B(this.m.onDidChangeCache(() => this.g.fire(1)));
    }
    getTargetPlatform() {
      return this.G || (this.G = Gp(this.w, this.y)), this.G;
    }
    async scanAllExtensions(e, s, i) {
      const [n, r] = await Promise.all([this.scanSystemExtensions(e), this.scanUserExtensions(s)]),
        o = i ? await this.scanExtensionsUnderDevelopment(e, [...n, ...r]) : [];
      return this.L(n, r, o, await this.getTargetPlatform(), !0);
    }
    async scanSystemExtensions(e) {
      const s = [];
      s.push(this.M(!!e.useCache, e.language, e.filterExtensionIds)), s.push(this.N(e.language, !!e.checkControlFile));
      const [i, n] = await Promise.all(s);
      return this.J([...i, ...n], 0, e, !1);
    }
    async scanUserExtensions(e) {
      const s = e.profileLocation ?? this.userExtensionsLocation;
      this.y.trace("Started scanning user extensions", s);
      const i = this.D.extUri.isEqual(e.profileLocation, this.t.defaultProfile.extensionsResource) ? { bailOutWhenFileNotFound: !0 } : void 0,
        n = await this.P(s, !!e.profileLocation, 1, !e.includeUninstalled, e.language, !0, i, e.productVersion ?? this.R(), e.filterExtensionIds),
        r = e.useCache && !n.devMode && n.excludeObsolete ? this.m : this.n;
      let o;
      try {
        o = await r.scanExtensions(n);
      } catch (a) {
        if (a instanceof da && a.code === "ERROR_PROFILE_NOT_FOUND") await this.I(), (o = await r.scanExtensions(n));
        else throw a;
      }
      return (o = await this.J(o, 1, e, !0)), this.y.trace("Scanned user extensions:", o.length), o;
    }
    async scanExtensionsUnderDevelopment(e, s) {
      if (this.z.isExtensionDevelopment && this.z.extensionDevelopmentLocationURI) {
        const i = (
          await Promise.all(
            this.z.extensionDevelopmentLocationURI
              .filter((n) => n.scheme === oe.file)
              .map(async (n) => {
                const r = await this.P(n, !1, 1, !0, e.language, !1, void 0, e.productVersion ?? this.R(), e.filterExtensionIds);
                return (await this.n.scanOneOrMultipleExtensions(r)).map((a) => ((a.type = s.find((c) => G(c.identifier, a.identifier))?.type ?? a.type), this.n.validate(a, r)));
              }),
          )
        ).flat();
        return this.J(i, "development", e, !0);
      }
      return [];
    }
    async scanExistingExtension(e, s, i) {
      const n = await this.P(e, !1, s, !0, i.language, !0, void 0, i.productVersion ?? this.R(), i.filterExtensionIds),
        r = await this.n.scanExtension(n);
      return !r || (!i.includeInvalid && !r.isValid) ? null : r;
    }
    async scanOneOrMultipleExtensions(e, s, i) {
      const n = await this.P(e, !1, s, !0, i.language, !0, void 0, i.productVersion ?? this.R(), i.filterExtensionIds),
        r = await this.n.scanOneOrMultipleExtensions(n);
      return this.J(r, s, i, !0);
    }
    async scanMultipleExtensions(e, s, i) {
      const n = [];
      return (
        await Promise.all(
          e.map(async (r) => {
            const o = await this.scanOneOrMultipleExtensions(r, s, i);
            n.push(...o);
          }),
        ),
        this.J(n, s, i, !0)
      );
    }
    async scanMetadata(e) {
      const s = M(e, "package.json"),
        i = (await this.w.readFile(s)).value.toString();
      return JSON.parse(i).__metadata;
    }
    async updateMetadata(e, s) {
      const i = M(e, "package.json"),
        n = (await this.w.readFile(i)).value.toString(),
        r = JSON.parse(n);
      s.isMachineScoped === !1 && delete s.isMachineScoped, s.isBuiltin === !1 && delete s.isBuiltin, (r.__metadata = { ...r.__metadata, ...s }), await this.w.writeFile(M(e, "package.json"), L.fromString(JSON.stringify(r, null, "	")));
    }
    async initializeDefaultProfileExtensions() {
      try {
        await this.u.scanProfileExtensions(this.t.defaultProfile.extensionsResource, { bailOutWhenFileNotFound: !0 });
      } catch (e) {
        if (e instanceof da && e.code === "ERROR_PROFILE_NOT_FOUND") await this.I();
        else throw e;
      }
    }
    async I() {
      return (
        this.H ||
          (this.H = (async () => {
            try {
              this.y.info("Started initializing default profile extensions in extensions installation folder.", this.userExtensionsLocation.toString());
              const e = await this.scanUserExtensions({ includeInvalid: !0 });
              if (e.length)
                await this.u.addExtensionsToProfile(
                  e.map((s) => [s, s.metadata]),
                  this.t.defaultProfile.extensionsResource,
                );
              else
                try {
                  await this.w.createFile(this.t.defaultProfile.extensionsResource, L.fromString(JSON.stringify([])));
                } catch (s) {
                  ct(s) !== 1 && this.y.warn("Failed to create default profile extensions manifest in extensions installation folder.", this.userExtensionsLocation.toString(), ve(s));
                }
              this.y.info("Completed initializing default profile extensions in extensions installation folder.", this.userExtensionsLocation.toString());
            } catch (e) {
              this.y.error(e);
            } finally {
              this.H = void 0;
            }
          })()),
        this.H
      );
    }
    async J(e, s, i, n) {
      return (
        i.includeAllVersions || (e = this.L(s === 0 ? e : void 0, s === 1 ? e : void 0, s === "development" ? e : void 0, await this.getTargetPlatform(), n)),
        i.includeInvalid || (e = e.filter((r) => r.isValid)),
        e.sort((r, o) => {
          const a = Ot(r.location.fsPath),
            c = Ot(o.location.fsPath);
          return a < c ? -1 : a > c ? 1 : 0;
        })
      );
    }
    L(e, s, i, n, r) {
      const o = (c, l, h) => {
          if (c.isValid && !l.isValid) return !1;
          if (c.isValid === l.isValid) {
            if (r && aa(c.manifest.version, l.manifest.version)) return this.y.debug(`Skipping extension ${l.location.path} with lower version ${l.manifest.version} in favour of ${c.location.path} with version ${c.manifest.version}`), !1;
            if (k5(c.manifest.version, l.manifest.version)) {
              if (c.type === 0) return this.y.debug(`Skipping extension ${l.location.path} in favour of system extension ${c.location.path} with same version`), !1;
              if (c.targetPlatform === n) return this.y.debug(`Skipping extension ${l.location.path} from different target platform ${l.targetPlatform}`), !1;
            }
          }
          return h ? this.y.warn(`Overwriting user extension ${c.location.path} with ${l.location.path}.`) : this.y.debug(`Overwriting user extension ${c.location.path} with ${l.location.path}.`), !0;
        },
        a = new Xb();
      return (
        e?.forEach((c) => {
          const l = a.get(c.identifier.id);
          (!l || o(l, c, !1)) && a.set(c.identifier.id, c);
        }),
        s?.forEach((c) => {
          const l = a.get(c.identifier.id);
          if (!l && e && c.type === 0) {
            this.y.debug(`Skipping obsolete system extension ${c.location.path}.`);
            return;
          }
          (!l || o(l, c, !1)) && a.set(c.identifier.id, c);
        }),
        i?.forEach((c) => {
          const l = a.get(c.identifier.id);
          (!l || o(l, c, !0)) && a.set(c.identifier.id, c), a.set(c.identifier.id, c);
        }),
        [...a.values()]
      );
    }
    async M(e, s, i) {
      this.y.trace("Started scanning system extensions");
      const n = await this.P(this.systemExtensionsLocation, !1, 0, !0, s, !0, void 0, this.R(), i),
        o = await (e && !n.devMode ? this.j : this.n).scanExtensions(n);
      return this.y.trace("Scanned system extensions:", o.length), o;
    }
    async N(e, s) {
      const i = this.z.isBuilt ? [] : this.C.builtInExtensions;
      if (!i?.length) return [];
      this.y.trace("Started scanning dev system extensions");
      const n = s ? await this.O() : {},
        r = [],
        o = C.file(Di(V(Cs.asFileUri("").fsPath, "..", ".build", "builtInExtensions")));
      for (const c of i) {
        const l = n[c.name] || "marketplace";
        switch (l) {
          case "disabled":
            break;
          case "marketplace":
            r.push(M(o, c.name));
            break;
          default:
            r.push(C.file(l));
            break;
        }
      }
      const a = await Promise.all(r.map(async (c) => this.n.scanExtension(await this.P(c, !1, 0, !0, e, !0, void 0, this.R()))));
      return this.y.trace("Scanned dev system extensions:", a.length), nn(a);
    }
    async O() {
      try {
        const e = await this.w.readFile(this.r);
        return JSON.parse(e.value.toString());
      } catch {
        return {};
      }
    }
    async P(e, s, i, n, r, o, a, c, l) {
      const h = await this.f(r ?? hs),
        u = await this.Q(e),
        f = s && !this.D.extUri.isEqual(e, this.t.defaultProfile.extensionsResource) ? this.t.defaultProfile.extensionsResource : void 0,
        d = f ? await this.Q(f) : void 0;
      return new Lr(e, u, f, d, s, a, i, n, o, c.version, c.date, this.C.commit, !this.z.isBuilt, r, h, l);
    }
    async Q(e) {
      try {
        const s = await this.w.stat(e);
        if (typeof s.mtime == "number") return s.mtime;
      } catch {}
    }
    R() {
      return { version: this.C.version, date: this.C.date };
    }
  };
vh = __decorate([__param(4, Te), __param(5, ci), __param(6, ie), __param(7, ne), __param(8, fe), __param(9, Ee), __param(10, ke), __param(11, ds)], vh);
var Lr = class {
    constructor(t, e, s, i, n, r, o, a, c, l, h, u, f, d, p, g) {
      (this.location = t),
        (this.mtime = e),
        (this.applicationExtensionslocation = s),
        (this.applicationExtensionslocationMtime = i),
        (this.profile = n),
        (this.profileScanOptions = r),
        (this.type = o),
        (this.excludeObsolete = a),
        (this.validate = c),
        (this.productVersion = l),
        (this.productDate = h),
        (this.productCommit = u),
        (this.devMode = f),
        (this.language = d),
        (this.translations = p),
        (this.filterExtensionIds = g);
    }
    static createNlsConfiguration(t) {
      return { language: t.language, pseudo: t.language === "pseudo", devMode: t.devMode, translations: t.translations };
    }
    static equals(t, e) {
      return (
        zs(t.location, e.location) &&
        t.mtime === e.mtime &&
        zs(t.applicationExtensionslocation, e.applicationExtensionslocation) &&
        t.applicationExtensionslocationMtime === e.applicationExtensionslocationMtime &&
        t.profile === e.profile &&
        Rt(t.profileScanOptions, e.profileScanOptions) &&
        t.type === e.type &&
        t.excludeObsolete === e.excludeObsolete &&
        t.validate === e.validate &&
        t.productVersion === e.productVersion &&
        t.productDate === e.productDate &&
        t.productCommit === e.productCommit &&
        t.devMode === e.devMode &&
        t.language === e.language &&
        wh.equals(t.translations, e.translations)
      );
    }
  },
  ga = class extends O {
    constructor(e, s, i, n, r, o, a) {
      super(), (this.g = e), (this.h = s), (this.j = i), (this.m = n), (this.n = o), (this.r = a), (this.f = r.extensionsEnabledWithApiProposalVersion?.map((c) => c.toLowerCase()) ?? []);
    }
    async scanExtensions(e) {
      let s = e.profile ? await this.t(e) : await this.s(e);
      e.filterExtensionIds && e.filterExtensionIds.length > 0 && (s = s.filter((n) => !(e.filterExtensionIds || []).includes(n.identifier.id)));
      let i = {};
      if (e.excludeObsolete && e.type === 1)
        try {
          const n = (await this.m.readFile(this.g)).value.toString();
          i = JSON.parse(n);
        } catch {}
      return $c(i) ? s : s.filter((n) => !i[Tt.create(n).toString()]);
    }
    async s(e) {
      const s = await this.m.resolve(e.location);
      if (!s.children?.length) return [];
      const i = await Promise.all(
        s.children.map(async (n) => {
          if (!n.isDirectory || (e.type === 1 && nr(n.resource).indexOf(".") === 0)) return null;
          const r = new Lr(
            n.resource,
            e.mtime,
            e.applicationExtensionslocation,
            e.applicationExtensionslocationMtime,
            e.profile,
            e.profileScanOptions,
            e.type,
            e.excludeObsolete,
            e.validate,
            e.productVersion,
            e.productDate,
            e.productCommit,
            e.devMode,
            e.language,
            e.translations,
          );
          return this.scanExtension(r);
        }),
      );
      return nn(i).sort((n, r) => (n.location.path < r.location.path ? -1 : 1));
    }
    async t(e) {
      let s = await this.u(e.location, () => !0, e);
      if (e.applicationExtensionslocation && !this.j.extUri.isEqual(e.location, e.applicationExtensionslocation)) {
        s = s.filter((n) => !n.metadata?.isApplicationScoped);
        const i = await this.u(e.applicationExtensionslocation, (n) => !!n.metadata?.isBuiltin || !!n.metadata?.isApplicationScoped, e);
        s.push(...i);
      }
      return s;
    }
    async u(e, s, i) {
      const n = await this.h.scanProfileExtensions(e, i.profileScanOptions);
      if (!n.length) return [];
      const r = await Promise.all(
        n.map(async (o) => {
          if (s(o)) {
            const a = new Lr(
              o.location,
              i.mtime,
              i.applicationExtensionslocation,
              i.applicationExtensionslocationMtime,
              i.profile,
              i.profileScanOptions,
              i.type,
              i.excludeObsolete,
              i.validate,
              i.productVersion,
              i.productDate,
              i.productCommit,
              i.devMode,
              i.language,
              i.translations,
            );
            return this.scanExtension(a, o.metadata);
          }
          return null;
        }),
      );
      return nn(r);
    }
    async scanOneOrMultipleExtensions(e) {
      try {
        if (await this.m.exists(M(e.location, "package.json"))) {
          const s = await this.scanExtension(e);
          return s ? [s] : [];
        } else return await this.scanExtensions(e);
      } catch (s) {
        return this.r.error(`Error scanning extensions at ${e.location.path}:`, ve(s)), [];
      }
    }
    async scanExtension(e, s) {
      try {
        let i = await this.w(e.location);
        if (i) {
          i.publisher || (i.publisher = Up), (s = s ?? i.__metadata), delete i.__metadata;
          const n = ai(i.publisher, i.name),
            r = s?.id ? { id: n, uuid: s.id } : { id: n },
            o = s?.isSystem ? 0 : e.type,
            a = o === 0 || !!s?.isBuiltin;
          i = await this.y(e.location, i, Lr.createNlsConfiguration(e));
          let c = { type: o, identifier: r, manifest: i, location: e.location, isBuiltin: a, targetPlatform: s?.targetPlatform ?? "undefined", publisherDisplayName: s?.publisherDisplayName, metadata: s, isValid: !0, validations: [] };
          return (
            e.validate && (c = this.validate(c, e)),
            i.enabledApiProposals && (!this.n.isBuilt || this.f.includes(n.toLowerCase())) && ((i.originalEnabledApiProposals = i.enabledApiProposals), (i.enabledApiProposals = Zb([...i.enabledApiProposals]))),
            c
          );
        }
      } catch (i) {
        e.type !== 0 && this.r.error(i);
      }
      return null;
    }
    validate(e, s) {
      let i = !0;
      const n = this.n.isBuilt && this.f.includes(e.identifier.id.toLowerCase()),
        r = O5(s.productVersion, s.productDate, s.location, e.manifest, e.isBuiltin, n);
      for (const [o, a] of r) o === bt.Error && ((i = !1), this.r.error(this.F(s.location, a)));
      return (e.isValid = i), (e.validations = r), e;
    }
    async w(e) {
      const s = M(e, "package.json");
      let i;
      try {
        i = (await this.m.readFile(s)).value.toString();
      } catch (r) {
        return ct(r) !== 1 && this.r.error(this.F(e, w(1852, null, s.path, r.message))), null;
      }
      let n;
      try {
        n = JSON.parse(i);
      } catch {
        const o = [];
        it(i, o);
        for (const a of o) this.r.error(this.F(e, w(1853, null, s.path, a.offset, a.length, mh(a.error))));
        return null;
      }
      return Rn(n) !== "object" ? (this.r.error(this.F(e, w(1854, null, s.path))), null) : n;
    }
    async y(e, s, i) {
      const n = await this.z(e, s, i);
      if (n)
        try {
          const r = [],
            o = await this.C(n.default, r);
          if (r.length > 0)
            return (
              r.forEach((c) => {
                this.r.error(this.F(e, w(1855, null, n.default?.path, mh(c.error))));
              }),
              s
            );
          if (Rn(n) !== "object") return this.r.error(this.F(e, w(1856, null, n.default?.path))), s;
          const a = n.values || Object.create(null);
          return i2(this.r, s, a, o);
        } catch {}
      return s;
    }
    async z(e, s, i) {
      const n = M(e, "package.nls.json"),
        r = (l, h) => {
          h.forEach((u) => {
            this.r.error(this.F(e, w(1857, null, l?.path, mh(u.error))));
          });
        },
        o = (l) => {
          this.r.error(this.F(e, w(1858, null, l?.path)));
        },
        a = `${s.publisher}.${s.name}`,
        c = i.translations[a];
      if (c)
        try {
          const l = C.file(c),
            h = (await this.m.readFile(l)).value.toString(),
            u = [],
            f = it(h, u);
          return u.length > 0 ? (r(l, u), { values: void 0, default: n }) : Rn(f) !== "object" ? (o(l), { values: void 0, default: n }) : { values: f.contents ? f.contents.package : void 0, default: n };
        } catch {
          return { values: void 0, default: n };
        }
      else {
        if (!(await this.m.exists(n))) return;
        let h;
        try {
          h = await this.D(e, i);
        } catch {
          return;
        }
        if (!h.localized) return { values: void 0, default: h.original };
        try {
          const u = (await this.m.readFile(h.localized)).value.toString(),
            f = [],
            d = it(u, f);
          return f.length > 0 ? (r(h.localized, f), { values: void 0, default: h.original }) : Rn(d) !== "object" ? (o(h.localized), { values: void 0, default: h.original }) : { values: d, default: h.original };
        } catch {
          return { values: void 0, default: h.original };
        }
      }
    }
    async C(e, s) {
      if (e)
        try {
          const i = (await this.m.readFile(e)).value.toString();
          return it(i, s);
        } catch {}
    }
    D(e, s) {
      return new Promise((i, n) => {
        const r = (o) => {
          const a = M(e, `package.nls.${o}.json`);
          this.m.exists(a).then((c) => {
            c && i({ localized: a, original: M(e, "package.nls.json") });
            const l = o.lastIndexOf("-");
            l === -1 ? i({ localized: M(e, "package.nls.json"), original: null }) : ((o = o.substring(0, l)), r(o));
          });
        };
        if (s.devMode || s.pseudo || !s.language) return i({ localized: M(e, "package.nls.json"), original: null });
        r(s.language);
      });
    }
    F(e, s) {
      return `[${e.path}]: ${s}`;
    }
  };
ga = __decorate([__param(1, ci), __param(2, ke), __param(3, ie), __param(4, Ee), __param(5, fe), __param(6, ne)], ga);
var ma = class extends ga {
  constructor(e, s, i, n, r, o, a, c, l) {
    super(s, n, r, o, a, c, l), (this.J = e), (this.L = i), (this.H = this.B(new Ri(3e3))), (this.I = this.B(new D())), (this.onDidChangeCache = this.I.event);
  }
  async scanExtensions(e) {
    const s = this.P(e),
      i = await this.M(s);
    if (((this.G = e), i && i.input && Lr.equals(i.input, this.G)))
      return this.r.debug("Using cached extensions scan result", e.type === 0 ? "system" : "user", e.location.toString()), this.H.trigger(() => this.O()), i.result.map((r) => ((r.location = C.revive(r.location)), r));
    const n = await super.scanExtensions(e);
    return await this.N(s, { input: e, result: n }), n;
  }
  async M(e) {
    try {
      const s = await this.m.readFile(e),
        i = JSON.parse(s.value.toString());
      return { result: i.result, input: mn(i.input) };
    } catch (s) {
      this.r.debug("Error while reading the extension cache file:", e.path, ve(s));
    }
    return null;
  }
  async N(e, s) {
    try {
      await this.m.writeFile(e, L.fromString(JSON.stringify(s)));
    } catch (i) {
      this.r.debug("Error while writing the extension cache file:", e.path, ve(i));
    }
  }
  async O() {
    if (!this.G) return;
    const e = this.P(this.G),
      s = await this.M(e);
    if (!s) return;
    const i = s.result,
      n = JSON.parse(JSON.stringify(await super.scanExtensions(this.G)));
    if (!Rt(n, i))
      try {
        this.r.info("Invalidating Cache", i, n), await this.m.del(e), this.I.fire();
      } catch (r) {
        this.r.error(r);
      }
  }
  P(e) {
    const s = this.Q(e);
    return this.j.extUri.joinPath(s.cacheHome, e.type === 0 ? Kb : Mp);
  }
  Q(e) {
    return e.type === 0
      ? this.L.defaultProfile
      : e.profile
        ? this.j.extUri.isEqual(e.location, this.J.extensionsResource)
          ? this.J
          : (this.L.profiles.find((s) => this.j.extUri.isEqual(e.location, s.extensionsResource)) ?? this.J)
        : this.L.defaultProfile;
  }
};
ma = __decorate([__param(2, Te), __param(3, ci), __param(4, ke), __param(5, ie), __param(6, Ee), __param(7, fe), __param(8, ne)], ma);
var r2 = class extends vh {
  constructor(t, e, s, i, n, r, o, a, c, l, h, u) {
    super(t, e, M(s, ".vscode-oss-dev", "extensions", "control.json"), i, n, r, o, a, c, l, h, u),
      (this.S = (async () => {
        if (fd)
          try {
            const f = await this.w.readFile(C.file(fd));
            return JSON.parse(f.value.toString());
          } catch {}
        return Object.create(null);
      })());
  }
  f(t) {
    return this.S;
  }
};
function yh(t) {
  let e = "Extract";
  return t instanceof fa && (t.type === "CorruptZip" ? (e = "CorruptZip") : t.type === "Incomplete" && (e = "IncompleteZip")), We(t, e);
}
async function bh(t) {
  let e;
  try {
    e = await Eg(t, "extension/package.json");
  } catch (s) {
    throw yh(s);
  }
  try {
    return JSON.parse(e.toString("utf8"));
  } catch {
    throw new Ne(w(1872, null), "Invalid");
  }
}
var Eh,
  Sh = class extends O {
    static {
      Eh = this;
    }
    static {
      this.c = ".sigzip";
    }
    constructor(e, s, i, n, r, o) {
      super(), (this.h = s), (this.j = i), (this.m = n), (this.n = r), (this.r = o), (this.extensionsDownloadDir = e.extensionsDownloadLocation), (this.f = 20), (this.g = this.C());
    }
    async download(e, s, i, n) {
      await this.g;
      const r = await this.t(e, s);
      if (!i || !e.isSigned) return { location: r, verificationStatus: void 0 };
      let o;
      try {
        o = await this.u(e);
        const a = (await this.m.verify(e.identifier.id, e.version, r.fsPath, o.fsPath, n))?.code;
        if (a === vt.PackageIsInvalidZip || a === vt.SignatureArchiveIsInvalidZip) {
          try {
            await this.delete(r);
          } catch (c) {
            this.r.error(c);
          }
          throw new Ne(wg, "CorruptZip");
        }
        return { location: r, verificationStatus: a };
      } catch (a) {
        try {
          await this.delete(r);
        } catch (c) {
          this.r.error(c);
        }
        throw a;
      } finally {
        if (o)
          try {
            await this.delete(o);
          } catch (a) {
            this.r.error(a);
          }
      }
    }
    async t(e, s) {
      try {
        const i = M(this.extensionsDownloadDir, this.D(e)),
          n = await this.y(
            e,
            "vsix",
            async () => {
              await this.w(e, i, (r) => this.j.download(e, r, s));
              try {
                await this.z(i.fsPath, "extension/package.json");
              } catch (r) {
                try {
                  await this.h.del(i);
                } catch (o) {
                  this.r.warn(`Error while deleting: ${i.path}`, ve(o));
                }
                throw r;
              }
            },
            2,
          );
        return n > 1 && this.n.publicLog2("extensiongallery:downloadvsix:retry", { extensionId: e.identifier.id, attempts: n }), i;
      } catch (i) {
        throw We(i, "Download");
      }
    }
    async u(e) {
      try {
        const s = M(this.extensionsDownloadDir, `.${Me()}`),
          i = await this.y(
            e,
            "sigzip",
            async () => {
              await this.j.downloadSignatureArchive(e, s);
              try {
                await this.z(s.fsPath, ".signature.p7s");
              } catch (n) {
                try {
                  await this.h.del(s);
                } catch (r) {
                  this.r.warn(`Error while deleting: ${s.path}`, ve(r));
                }
                throw n;
              }
            },
            2,
          );
        return i > 1 && this.n.publicLog2("extensiongallery:downloadsigzip:retry", { extensionId: e.identifier.id, attempts: i }), s;
      } catch (s) {
        throw We(s, "DownloadSignature");
      }
    }
    async w(e, s, i) {
      if (await this.h.exists(s)) return;
      if (s.scheme !== oe.file) {
        await i(s);
        return;
      }
      const n = M(this.extensionsDownloadDir, `.${Me()}`);
      try {
        await i(n);
      } catch (r) {
        try {
          await this.h.del(n);
        } catch {}
        throw r;
      }
      try {
        await he.rename(n.fsPath, s.fsPath, 2 * 60 * 1e3);
      } catch (r) {
        try {
          await this.h.del(n);
        } catch {}
        let o = !1;
        try {
          o = await this.h.exists(s);
        } catch {}
        if (o) this.r.info("Rename failed because the file was downloaded by another source. So ignoring renaming.", e.identifier.id, s.path);
        else throw (this.r.info(`Rename failed because of ${ve(r)}. Deleted the file from downloaded location`, n.path), r);
      }
    }
    async y(e, s, i, n) {
      let r = 1;
      for (;;)
        try {
          return await i(), r;
        } catch (o) {
          if (r++ > n) throw o;
          this.r.warn(`Failed downloading ${s}. ${ve(o)}. Retry again...`, e.identifier.id);
        }
    }
    async z(e, s) {
      try {
        await Eg(e, s);
      } catch (i) {
        throw yh(i);
      }
    }
    async delete(e) {
      await this.g, await this.h.del(e);
    }
    async C() {
      try {
        if (!(await this.h.exists(this.extensionsDownloadDir))) {
          this.r.trace("Extension VSIX downloads cache dir does not exist");
          return;
        }
        const e = await this.h.resolve(this.extensionsDownloadDir, { resolveMetadata: !0 });
        if (e.children) {
          const s = [],
            i = [],
            n = [];
          for (const a of e.children)
            if (a.name.endsWith(Eh.c)) n.push(a.resource);
            else {
              const c = Tt.parse(a.name);
              c && i.push([c, a]);
            }
          const r = Hp(i, ([a]) => a),
            o = [];
          for (const a of r) a.sort((c, l) => tg(c[0].version, l[0].version)), s.push(...a.slice(1).map((c) => c[1].resource)), o.push(a[0][1]);
          o.sort((a, c) => a.mtime - c.mtime), s.push(...o.slice(0, Math.max(0, o.length - this.f)).map((a) => a.resource)), s.push(...n), await Ze.settled(s.map((a) => (this.r.trace("Deleting from cache", a.path), this.h.del(a))));
        }
      } catch (e) {
        this.r.error(e);
      }
    }
    D(e) {
      return this.f ? Tt.create(e).toString().toLowerCase() : Me();
    }
  };
Sh = Eh = __decorate([__param(0, Zt), __param(1, ie), __param(2, ps), __param(3, uh), __param(4, Se), __param(5, ne)], Sh);
import { fork as o2 } from "child_process";
var $h = class extends O {
  constructor(e, s) {
    super(), (this.b = e), (this.f = s), (this.a = new Kd(5));
  }
  async postUninstall(e) {
    const s = this.g(e, "uninstall");
    s &&
      (this.f.info(e.identifier.id, e.manifest.version, "Running post uninstall script"),
      await this.a.queue(async () => {
        try {
          await this.h(s.script, "uninstall", s.args, !0, e), this.f.info("Finished running post uninstall script", e.identifier.id, e.manifest.version);
        } catch (i) {
          this.f.error("Failed to run post uninstall script", e.identifier.id, e.manifest.version), this.f.error(i);
        }
      }));
    try {
      await he.rm(this.m(e));
    } catch (i) {
      this.f.error("Error while removing extension storage path", e.identifier.id), this.f.error(i);
    }
  }
  g(e, s) {
    const i = `vscode:${s}`;
    if (e.location.scheme === oe.file && e.manifest && e.manifest.scripts && typeof e.manifest.scripts[i] == "string") {
      const n = e.manifest.scripts[i].split(" ");
      return n.length < 2 || n[0] !== "node" || !n[1] ? (this.f.warn(e.identifier.id, e.manifest.version, `${i} should be a node script`), null) : { script: V(e.location.fsPath, n[1]), args: n.slice(2) || [] };
    }
    return null;
  }
  h(e, s, i, n, r) {
    return new Promise((o, a) => {
      const c = this.j(e, s, i, r);
      let l;
      const h = (u) => {
        l && (clearTimeout(l), (l = null)), u ? a(u) : o(void 0);
      };
      c.on("error", (u) => {
        h(Xe(u) || "Unknown");
      }),
        c.on("exit", (u, f) => {
          h(u ? `post-${s} process exited with code ${u}` : void 0);
        }),
        n &&
          (l = setTimeout(() => {
            (l = null), c.kill(), a("timed out");
          }, 5e3));
    });
  }
  j(e, s, i, n) {
    const r = { silent: !0, execArgv: void 0 },
      o = o2(e, [`--type=extension-post-${s}`, ...i], r);
    o.stdout.setEncoding("utf8"), o.stderr.setEncoding("utf8");
    const a = T.fromNodeEventEmitter(o.stdout, "data"),
      c = T.fromNodeEventEmitter(o.stderr, "data");
    this.B(a((u) => this.f.info(n.identifier.id, n.manifest.version, `post-${s}`, u))), this.B(c((u) => this.f.error(n.identifier.id, n.manifest.version, `post-${s}`, u)));
    const l = T.any(
      T.map(a, (u) => ({ data: `%c${u}`, format: [""] }), this.q),
      T.map(c, (u) => ({ data: `%c${u}`, format: ["color: red"] }), this.q),
    );
    return (
      T.debounce(
        l,
        (u, f) => (u ? { data: u.data + f.data, format: [...u.format, ...f.format] } : { data: f.data, format: f.format }),
        100,
        void 0,
        void 0,
        void 0,
        this.q,
      )((u) => {
        console.group(n.identifier.id), console.log(u.data, ...u.format), console.groupEnd();
      }),
      o
    );
  }
  m(e) {
    return V(this.b.defaultProfile.globalStorageHome.fsPath, e.identifier.id.toLowerCase());
  }
};
$h = __decorate([__param(0, Te), __param(1, ne)], $h);
var a2 = class extends O {
    constructor(t, e, s, i, n) {
      super(), (this.a = t), (this.b = e), (this.c = s), (this.f = n), this.B(i.onDidInstallExtensions((r) => this.g(r))), this.B(i.onDidUninstallExtension((r) => this.h(r)));
    }
    g(t) {
      for (const e of t) e.local && this.invalidate(e.profileLocation);
    }
    h(t) {
      t.error || this.invalidate(t.profileLocation);
    }
    async invalidate(t) {
      if (t) for (const e of this.a.profiles) this.c.extUri.isEqual(e.extensionsResource, t) && (await this.j(e));
      else await this.j(this.a.defaultProfile);
    }
    async j(t) {
      try {
        await this.b.del(this.c.extUri.joinPath(t.cacheHome, Mp));
      } catch (e) {
        ct(e) !== 1 && this.f.error(e);
      }
    }
  },
  c2 = class extends O {
    constructor(t, e, s, i, n, r, o) {
      super(),
        (this.f = t),
        (this.g = e),
        (this.h = s),
        (this.j = i),
        (this.m = n),
        (this.n = r),
        (this.r = o),
        (this.a = this.B(new D())),
        (this.onDidChangeExtensionsByAnotherSource = this.a.event),
        (this.b = new Map()),
        (this.c = this.B(new po())),
        this.s().then(null, (a) => o.error("Error while initializing Extensions Watcher", ve(a)));
    }
    async s() {
      await this.g.initializeDefaultProfileExtensions(), await this.u(this.h.profiles), this.t(), await this.H();
    }
    t() {
      this.B(this.h.onDidChangeProfiles((t) => this.u(t.added))),
        this.B(this.j.onAddExtensions((t) => this.w(t))),
        this.B(this.j.onDidAddExtensions((t) => this.y(t))),
        this.B(this.j.onRemoveExtensions((t) => this.z(t))),
        this.B(this.j.onDidRemoveExtensions((t) => this.C(t))),
        this.B(this.n.onDidFilesChange((t) => this.D(t)));
    }
    async u(t) {
      try {
        t.length && (await Promise.all(t.map((e) => (this.c.set(e.id, Rc(this.n.watch(this.m.extUri.dirname(e.extensionsResource)), this.n.watch(e.extensionsResource))), this.G(e.extensionsResource)))));
      } catch (e) {
        throw (this.r.error(e), e);
      }
    }
    async w(t) {
      for (const e of t.extensions) this.I(this.L(e.identifier, e.version), t.profileLocation);
    }
    async y(t) {
      for (const e of t.extensions) {
        const s = this.L(e.identifier, e.version);
        t.error ? this.J(s, t.profileLocation) : this.I(s, t.profileLocation);
      }
    }
    async z(t) {
      for (const e of t.extensions) this.J(this.L(e.identifier, e.version), t.profileLocation);
    }
    async C(t) {
      const e = [],
        s = [];
      for (const i of t.extensions) {
        const n = this.L(i.identifier, i.version);
        t.error
          ? this.I(n, t.profileLocation)
          : (this.J(n, t.profileLocation),
            this.b.has(n) ||
              (this.r.debug("Extension is removed from all profiles", i.identifier.id, i.version),
              s.push(
                this.f.scanInstalledExtensionAtLocation(i.location).then(
                  (r) => {
                    r ? e.push(r) : this.r.info("Extension not found at the location", i.location.toString());
                  },
                  (r) => this.r.error(r),
                ),
              )));
      }
      try {
        await Promise.all(s), e.length && (await this.H(e));
      } catch (i) {
        this.r.error(i);
      }
    }
    D(t) {
      for (const e of this.h.profiles) t.contains(e.extensionsResource, 0, 1) && this.F(e.extensionsResource);
    }
    async F(t) {
      const e = [],
        s = [],
        i = await this.j.scanProfileExtensions(t),
        n = new Set(),
        r = new Set();
      for (const [o, a] of this.b) a.has(t) && r.add(o);
      for (const o of i) {
        const a = this.L(o.identifier, o.version);
        n.add(a), r.has(a) || (e.push(o.identifier), this.I(a, t));
      }
      for (const o of r)
        if (!n.has(o)) {
          const a = this.M(o);
          a && (s.push(a.identifier), this.J(o, t));
        }
      (e.length || s.length) && this.a.fire({ added: e.length ? { extensions: e, profileLocation: t } : void 0, removed: s.length ? { extensions: s, profileLocation: t } : void 0 });
    }
    async G(t) {
      const e = await this.j.scanProfileExtensions(t);
      for (const s of e) this.I(this.L(s.identifier, s.version), t);
    }
    async H(t) {
      t || (t = (await this.f.scanAllUserInstalledExtensions()).filter((s) => !this.b.has(this.L(s.identifier, s.manifest.version)))), t.length && (await this.f.markAsUninstalled(...t));
    }
    I(t, e) {
      let s = this.b.get(t);
      s || this.b.set(t, (s = new kc((i) => this.m.extUri.getComparisonKey(i)))), s.add(e);
    }
    J(t, e) {
      const s = this.b.get(t);
      s && s.delete(e), s?.size || this.b.delete(t);
    }
    L(t, e) {
      return `${An.toKey(t.id)}@${e}`;
    }
    M(t) {
      const [e, s] = d5(t);
      return s ? { identifier: { id: e }, version: s } : void 0;
    }
  },
  Cg = Vs,
  kg = ".vsctmp",
  xh = class extends dh {
    constructor(e, s, i, n, r, o, a, c, l, h, u, f, d) {
      super(e, s, f, i, u, d), (this.eb = n), (this.fb = r), (this.gb = o), (this.hb = a), (this.ib = c), (this.jb = l), (this.kb = h), (this.db = new Map()), (this.wb = new kc());
      const p = this.B(c.createInstance($h));
      (this.ab = this.B(c.createInstance(Ch, (m) => p.postUninstall(m)))), (this.bb = this.B(new a2(d, l, f, this, this.F))), (this.cb = this.B(c.createInstance(Sh)));
      const g = this.B(new c2(this, this.fb, d, o, f, l, i));
      this.B(g.onDidChangeExtensionsByAnotherSource((m) => this.vb(m))), this.xb();
    }
    getTargetPlatform() {
      return this.lb || (this.lb = Gp(this.jb, this.F)), this.lb;
    }
    async zip(e) {
      this.F.trace("ExtensionManagementService#zip", e.identifier.id);
      const s = await this.ub(e),
        i = await Z5(M(this.cb.extensionsDownloadDir, Me()).fsPath, s);
      return C.file(i);
    }
    async getManifest(e) {
      const { location: s, cleanup: i } = await this.nb(e),
        n = Ii(s.fsPath);
      try {
        return await bh(n);
      } finally {
        await i();
      }
    }
    getInstalled(e, s = this.H.defaultProfile.extensionsResource, i = { version: this.G.version, date: this.G.date }) {
      return this.ab.scanExtensions(e ?? null, s, i);
    }
    scanAllUserInstalledExtensions() {
      return this.ab.scanAllUserExtensions(!1);
    }
    scanInstalledExtensionAtLocation(e) {
      return this.ab.scanUserExtensionAtLocation(e);
    }
    async install(e, s = {}) {
      this.F.trace("ExtensionManagementService#install", e.toString());
      const { location: i, cleanup: n } = await this.nb(e);
      try {
        const r = await bh(Ii(i.fsPath)),
          o = ai(r.publisher, r.name);
        if (r.engines && r.engines.vscode && !ca(r.engines.vscode, this.G.version, this.G.date)) throw new Error(w(1859, null, o, this.G.version));
        const c = (await this.I([{ manifest: r, extension: i, options: s }])).find(({ identifier: l }) => G(l, { id: o }));
        if (c?.local) return c.local;
        throw c?.error ? c.error : We(new Error(`Unknown error while installing extension ${o}`));
      } finally {
        await n();
      }
    }
    async installFromLocation(e, s) {
      this.F.trace("ExtensionManagementService#installFromLocation", e.toString());
      const i = await this.ab.scanUserExtensionAtLocation(e);
      if (!i || !i.manifest.name || !i.manifest.version) throw new Error(`Cannot find a valid extension from the location ${e.toString()}`);
      return await this.zb([[i, { source: "resource" }]], s), this.F.info("Successfully installed extension", i.identifier.id, s.toString()), i;
    }
    async installExtensionsFromProfile(e, s, i) {
      this.F.trace("ExtensionManagementService#installExtensionsFromProfile", e, s.toString(), i.toString());
      const n = (await this.getInstalled(1, s)).filter((r) => e.some((o) => G(o, r.identifier)));
      if (n.length) {
        const r = await Promise.all(n.map((o) => this.ab.scanMetadata(o, s)));
        await this.zb(
          n.map((o, a) => [o, r[a]]),
          i,
        ),
          this.F.info(
            "Successfully installed extensions",
            n.map((o) => o.identifier.id),
            i.toString(),
          );
      }
      return n;
    }
    async updateMetadata(e, s, i) {
      return (
        this.F.trace("ExtensionManagementService#updateMetadata", e.identifier.id),
        s.isPreReleaseVersion && ((s.preRelease = !0), (s.hasPreReleaseVersion = !0)),
        s.isMachineScoped === !1 && (s.isMachineScoped = void 0),
        s.isBuiltin === !1 && (s.isBuiltin = void 0),
        s.pinned === !1 && (s.pinned = void 0),
        (e = await this.ab.updateMetadata(e, s, i)),
        this.bb.invalidate(i),
        this.w.fire({ local: e, profileLocation: i }),
        e
      );
    }
    async reinstallFromGallery(e) {
      if ((this.F.trace("ExtensionManagementService#reinstallFromGallery", e.identifier.id), !this.z.isEnabled())) throw new Error(w(1860, null));
      const s = await this.getTargetPlatform(),
        [i] = await this.z.getExtensions([{ ...e.identifier, preRelease: e.preRelease }], { targetPlatform: s, compatible: !0 }, J.None);
      if (!i) throw new Error(w(1861, null));
      await this.ab.setUninstalled(e);
      try {
        await this.ab.removeUninstalledExtension(e);
      } catch (n) {
        throw new Error(w(1862, null, Xe(n)));
      }
      return this.installFromGallery(i);
    }
    $(e, s, i, n) {
      return this.ab.copyExtension(e, s, i, n);
    }
    copyExtensions(e, s) {
      return this.ab.copyExtensions(e, s, { version: this.G.version, date: this.G.date });
    }
    markAsUninstalled(...e) {
      return this.ab.setUninstalled(...e);
    }
    async cleanUp() {
      this.F.trace("ExtensionManagementService#cleanUp");
      try {
        await this.ab.cleanUp();
      } catch (e) {
        this.F.error(e);
      }
    }
    async download(e, s, i) {
      const { location: n } = await this.sb(e, s, !i);
      return n;
    }
    async nb(e) {
      if (e.scheme === oe.file) return { location: e, async cleanup() {} };
      this.F.trace("Downloading extension from", e.toString());
      const s = M(this.cb.extensionsDownloadDir, Me());
      return (
        await this.hb.download(e, s),
        this.F.info("Downloaded extension to", s.toString()),
        {
          location: s,
          cleanup: async () => {
            try {
              await this.jb.del(s);
            } catch (n) {
              this.F.error(n);
            }
          },
        }
      );
    }
    X() {
      return this.H.defaultProfile.extensionsResource;
    }
    Y(e, s, i) {
      const n = s instanceof C ? new Tt({ id: ai(e.publisher, e.name) }, e.version) : Tt.create(s);
      return this.ib.createInstance(
        kh,
        n,
        e,
        s,
        i,
        (r, o) => {
          if (s instanceof C) return this.tb(n, s, i, o);
          let a = this.db.get(n.toString());
          return a || (this.db.set(n.toString(), (a = this.rb(n, s, r, i, o))), a.finally(() => this.db.delete(n.toString()))), a;
        },
        this.ab,
      );
    }
    Z(e, s) {
      return new l2(e, s, this.gb);
    }
    async rb(e, s, i, n, r) {
      const { verificationStatus: o, location: a } = await this.sb(s, i, !n.donotVerifySignature, n.context?.[G4]);
      try {
        if (r.isCancellationRequested) throw new ot();
        const c = await bh(a.fsPath);
        if (!new Tt(s.identifier, s.version).equals(new Tt({ id: ai(c.publisher, c.name) }, c.version))) throw new Ne(w(1863, null, s.identifier.id), "Invalid");
        return {
          local: await this.ab.extractUserExtension(
            e,
            a.fsPath,
            {
              id: s.identifier.uuid,
              publisherId: s.publisherId,
              publisherDisplayName: s.publisherDisplayName,
              targetPlatform: s.properties.targetPlatform,
              isApplicationScoped: n.isApplicationScoped,
              isMachineScoped: n.isMachineScoped,
              isBuiltin: n.isBuiltin,
              isPreReleaseVersion: s.properties.isPreReleaseVersion,
              hasPreReleaseVersion: s.properties.isPreReleaseVersion,
              installedTimestamp: Date.now(),
              pinned: n.installGivenVersion ? !0 : !!n.pinned,
              preRelease: Ms(n.preRelease) ? n.preRelease : n.installPreReleaseVersion || s.properties.isPreReleaseVersion,
              source: "gallery",
            },
            !1,
            r,
          ),
          verificationStatus: o,
        };
      } catch (c) {
        try {
          await this.cb.delete(a);
        } catch (l) {
          this.F.warn("Error while deleting the downloaded file", a.toString(), ve(l));
        }
        throw We(c);
      }
    }
    async sb(e, s, i, n) {
      if (i) {
        const a = this.kb.getValue("extensions.verifySignature");
        i = Ms(a) ? a : !0;
      }
      i = !1;
      const { location: r, verificationStatus: o } = await this.cb.download(e, s, i, n);
      if (o !== vt.Success && i && this.eb.isBuilt && !ht) {
        if (!e.isSigned) throw new Ne(w(1864, null), "PackageNotSigned");
        if (!o) throw new Ne(w(1865, null), "SignatureVerificationInternal");
        switch (o) {
          case vt.PackageIntegrityCheckFailed:
          case vt.SignatureIsInvalid:
          case vt.SignatureManifestIsInvalid:
          case vt.SignatureIntegrityCheckFailed:
          case vt.EntryIsMissing:
          case vt.EntryIsTampered:
          case vt.Untrusted:
          case vt.CertificateRevoked:
          case vt.SignatureIsNotValid:
          case vt.SignatureArchiveHasTooManyEntries:
            throw new Ne(w(1866, null, o), "SignatureVerificationFailed");
        }
        throw new Ne(w(1867, null, o), "SignatureVerificationInternal");
      }
      return { location: r, verificationStatus: o };
    }
    async tb(e, s, i, n) {
      return {
        local: await this.ab.extractUserExtension(
          e,
          Ii(s.fsPath),
          { isApplicationScoped: i.isApplicationScoped, isMachineScoped: i.isMachineScoped, isBuiltin: i.isBuiltin, installedTimestamp: Date.now(), pinned: i.installGivenVersion ? !0 : !!i.pinned, source: "vsix" },
          i.keepExisting ?? !0,
          n,
        ),
      };
    }
    async ub(e) {
      const s = async (n) => {
        let r = await he.readdir(n);
        r = r.map((c) => V(n, c));
        const o = await Promise.all(r.map((c) => J5.promises.stat(c)));
        let a = Promise.resolve([]);
        return (
          o.forEach((c, l) => {
            const h = r[l];
            c.isFile() && (a = a.then((u) => [...u, h])), c.isDirectory() && (a = a.then((u) => s(h).then((f) => [...u, ...f])));
          }),
          a
        );
      };
      return (await s(e.location.fsPath)).map((n) => ({ path: `extension/${Od(e.location.fsPath, n)}`, localPath: n }));
    }
    async vb({ added: e, removed: s }) {
      if (s) {
        const i = e && this.D.extUri.isEqual(s.profileLocation, e.profileLocation) ? s.extensions.filter((n) => e.extensions.every((r) => !G(r, n))) : s.extensions;
        for (const n of i) this.F.info("Extensions removed from another source", n.id, s.profileLocation.toString()), this.u.fire({ identifier: n, profileLocation: s.profileLocation });
      }
      if (e) {
        const n = (await this.getInstalled(1, e.profileLocation)).filter((r) => e.extensions.some((o) => G(o, r.identifier)));
        this.s.fire(n.map((r) => (this.F.info("Extensions added from another source", r.identifier.id, e.profileLocation.toString()), { identifier: r.identifier, local: r, profileLocation: e.profileLocation, operation: 1 })));
      }
    }
    async xb() {
      this.B(this.ab.onExtract((s) => this.wb.add(s)));
      const e = await this.jb.resolve(this.fb.userExtensionsLocation);
      for (const s of e.children ?? []) s.isDirectory && this.wb.add(s.resource);
      this.B(this.jb.watch(this.fb.userExtensionsLocation)), this.B(this.jb.onDidFilesChange((s) => this.yb(s)));
    }
    async yb(e) {
      if (!e.affects(this.fb.userExtensionsLocation, 1)) return;
      const s = [];
      for (const i of e.rawAdded) {
        if (
          this.wb.has(i) ||
          !this.D.extUri.isEqual(this.D.extUri.dirname(i), this.fb.userExtensionsLocation) ||
          this.D.extUri.isEqual(i, this.D.extUri.joinPath(this.fb.userExtensionsLocation, ".obsolete")) ||
          this.D.extUri.basename(i).startsWith(".") ||
          !(await this.jb.stat(i)).isDirectory
        )
          continue;
        const n = await this.ab.scanUserExtensionAtLocation(i);
        n && n.installedTimestamp === void 0 && (this.wb.add(i), s.push(n));
      }
      s.length &&
        (await this.zb(
          s.map((i) => [i, void 0]),
          this.H.defaultProfile.extensionsResource,
        ),
        this.F.info(
          "Added extensions to default profile from external source",
          s.map((i) => i.identifier.id),
        ));
    }
    async zb(e, s) {
      const i = e.map((n) => n[0]);
      await this.Ab(i), await this.gb.addExtensionsToProfile(e, s), this.s.fire(i.map((n) => ({ local: n, identifier: n.identifier, operation: 1, profileLocation: s })));
    }
    async Ab(e) {
      const s = await this.ab.getUninstalledExtensions();
      for (const i of e) {
        const n = Tt.create(i);
        s[n.toString()] && (this.F.trace("Removing the extension from uninstalled list:", n.id), await this.ab.setInstalled(n), this.F.info("Removed the extension from uninstalled list:", n.id));
      }
    }
  };
xh = __decorate([__param(0, ps), __param(1, Se), __param(2, ne), __param(3, Zt), __param(4, pa), __param(5, ci), __param(6, jp), __param(7, ds), __param(8, ie), __param(9, Ce), __param(10, Ee), __param(11, ke), __param(12, Te)], xh);
var Ch = class extends O {
  constructor(e, s, i, n, r, o, a) {
    super(),
      (this.n = e),
      (this.s = s),
      (this.t = i),
      (this.u = n),
      (this.w = r),
      (this.y = o),
      (this.z = a),
      (this.h = this.B(new D())),
      (this.onExtract = this.h.event),
      (this.j = new kt()),
      (this.m = new kt()),
      (this.c = M(this.t.userExtensionsLocation, ".obsolete")),
      (this.g = new rr());
  }
  async cleanUp() {
    await this.J(), await this.I();
  }
  async scanExtensions(e, s, i) {
    try {
      const n = { includeInvalid: !0, profileLocation: s, productVersion: i };
      let r = [];
      if (e === null || e === 0) {
        let o = this.j.get(s);
        o || ((o = this.t.scanAllExtensions({ includeInvalid: !0, useCache: !0, language: hs }, n, !1).finally(() => this.j.delete(s))), this.j.set(s, o)), r.push(...(await o));
      } else if (e === 1) {
        let o = this.m.get(s);
        o || ((o = this.t.scanUserExtensions(n).finally(() => this.m.delete(s))), this.m.set(s, o)), r.push(...(await o));
      }
      return (r = e !== null ? r.filter((o) => o.type === e) : r), await Promise.all(r.map((o) => this.H(o)));
    } catch (n) {
      throw We(n, "Scanning");
    }
  }
  async scanAllUserExtensions(e) {
    try {
      const s = await this.t.scanUserExtensions({ includeAllVersions: !e, includeInvalid: !0 });
      return await Promise.all(s.map((i) => this.H(i)));
    } catch (s) {
      throw We(s, "Scanning");
    }
  }
  async scanUserExtensionAtLocation(e) {
    try {
      const s = await this.t.scanExistingExtension(e, 1, { includeInvalid: !0 });
      if (s) return await this.H(s);
    } catch (s) {
      this.z.error(s);
    }
    return null;
  }
  async extractUserExtension(e, s, i, n, r) {
    const o = e.toString(),
      a = C.file(V(this.t.userExtensionsLocation.fsPath, `.${Me()}`)),
      c = C.file(V(this.t.userExtensionsLocation.fsPath, o));
    if (await this.s.exists(c)) {
      if (!n)
        try {
          return await this.scanLocalExtension(c, 1);
        } catch (l) {
          this.z.warn(`Error while scanning the existing extension at ${c.path}. Deleting the existing extension and extracting it.`, ve(l));
        }
      try {
        await this.D(e.id, c, "removeExisting");
      } catch {
        throw new Ne(w(1868, null, c.fsPath, e.id), "Delete");
      }
    }
    try {
      if (r.isCancellationRequested) throw new ot();
      try {
        this.z.trace(`Started extracting the extension from ${s} to ${c.fsPath}`), await e2(s, a.fsPath, { sourcePath: "extension", overwrite: !0 }, r), this.z.info(`Extracted extension to ${c}:`, e.id);
      } catch (l) {
        throw yh(l);
      }
      try {
        await this.t.updateMetadata(a, i);
      } catch (l) {
        throw (this.y.publicLog2("extension:extract", { extensionId: e.id, code: `${ct(l)}` }), We(l, "UpdateMetadata"));
      }
      if (r.isCancellationRequested) throw new ot();
      try {
        this.z.trace(`Started renaming the extension from ${a.fsPath} to ${c.fsPath}`), await this.G(a.fsPath, c.fsPath), this.z.info("Renamed to", c.fsPath);
      } catch (l) {
        if (l.code === "ENOTEMPTY") {
          this.z.info("Rename failed because extension was installed by another source. So ignoring renaming.", e.id);
          try {
            await this.s.del(a, { recursive: !0 });
          } catch {}
        } else throw (this.z.info(`Rename failed because of ${ve(l)}. Deleted from extracted location`, a), l);
      }
      this.h.fire(c);
    } catch (l) {
      try {
        await this.s.del(a, { recursive: !0 });
      } catch {}
      throw l;
    }
    return this.scanLocalExtension(c, 1);
  }
  async scanMetadata(e, s) {
    return s ? (await this.C(e, s))?.metadata : this.t.scanMetadata(e.location);
  }
  async C(e, s) {
    return (await this.u.scanProfileExtensions(s)).find((n) => G(n.identifier, e.identifier));
  }
  async updateMetadata(e, s, i) {
    try {
      i ? await this.u.updateMetadata([[e, s]], i) : await this.t.updateMetadata(e.location, s);
    } catch (n) {
      throw (this.y.publicLog2("extension:extract", { extensionId: e.identifier.id, code: `${ct(n)}`, isProfile: !!i }), We(n, "UpdateMetadata"));
    }
    return this.scanLocalExtension(e.location, e.type, i);
  }
  async getUninstalledExtensions() {
    try {
      return await this.F();
    } catch (e) {
      throw We(e, "ReadUninstalled");
    }
  }
  async setUninstalled(...e) {
    const s = e.map((i) => Tt.create(i));
    await this.F((i) =>
      s.forEach((n) => {
        (i[n.toString()] = !0), this.z.info("Marked extension as uninstalled", n.toString());
      }),
    );
  }
  async setInstalled(e) {
    try {
      await this.F((s) => delete s[e.toString()]);
    } catch (s) {
      throw We(s, "UnsetUninstalled");
    }
  }
  async removeExtension(e, s) {
    if (this.w.extUri.isEqualOrParent(e.location, this.t.userExtensionsLocation)) return this.D(e.identifier.id, e.location, s);
  }
  async removeUninstalledExtension(e) {
    await this.removeExtension(e, "uninstalled"), await this.F((s) => delete s[Tt.create(e).toString()]);
  }
  async copyExtension(e, s, i, n) {
    const r = await this.C(e, s),
      o = await this.C(e, i);
    if (((n = { ...r?.metadata, ...n }), o))
      if (this.w.extUri.isEqual(o.location, e.location)) await this.u.updateMetadata([[e, { ...o.metadata, ...n }]], i);
      else {
        const a = await this.scanLocalExtension(o.location, e.type, i);
        await this.u.removeExtensionFromProfile(a, i), await this.u.addExtensionsToProfile([[e, { ...o.metadata, ...n }]], i);
      }
    else await this.u.addExtensionsToProfile([[e, n]], i);
    return this.scanLocalExtension(e.location, e.type, i);
  }
  async copyExtensions(e, s, i) {
    const n = await this.scanExtensions(1, e, i),
      r = await Promise.all(n.filter((o) => !o.isApplicationScoped).map(async (o) => [o, await this.scanMetadata(o, e)]));
    await this.u.addExtensionsToProfile(r, s);
  }
  async D(e, s, i) {
    this.z.trace(`Deleting ${i} extension from disk`, e, s.fsPath);
    const n = this.w.extUri.joinPath(this.w.extUri.dirname(s), `${this.w.extUri.basename(s)}.${Sn(Me()).toString(16)}${kg}`);
    await this.G(s.fsPath, n.fsPath), await this.s.del(n, { recursive: !0 }), this.z.info(`Deleted ${i} extension from disk`, e, s.fsPath);
  }
  F(e) {
    return this.g.queue(async () => {
      let s;
      try {
        s = (await this.s.readFile(this.c, "utf8")).value.toString();
      } catch (n) {
        if (ct(n) !== 1) throw n;
      }
      let i = {};
      if (s)
        try {
          i = JSON.parse(s);
        } catch {}
      return e && (e(i), Object.keys(i).length ? await this.s.writeFile(this.c, L.fromString(JSON.stringify(i))) : await this.s.del(this.c)), i;
    });
  }
  async G(e, s) {
    try {
      await he.rename(e, s, 2 * 60 * 1e3);
    } catch (i) {
      throw We(i, "Rename");
    }
  }
  async scanLocalExtension(e, s, i) {
    try {
      if (i) {
        const r = (await this.t.scanUserExtensions({ profileLocation: i })).find((o) => this.w.extUri.isEqual(o.location, e));
        if (r) return await this.H(r);
      } else {
        const n = await this.t.scanExistingExtension(e, s, { includeInvalid: !0 });
        if (n) return await this.H(n);
      }
      throw new Ne(w(1869, null, e.path), "ScanningExtension");
    } catch (n) {
      throw We(n, "ScanningExtension");
    }
  }
  async H(e) {
    const s = await this.s.resolve(e.location);
    let i, n;
    return (
      s.children && ((i = s.children.find(({ name: r }) => /^readme(\.txt|\.md|)$/i.test(r))?.resource), (n = s.children.find(({ name: r }) => /^changelog(\.txt|\.md|)$/i.test(r))?.resource)),
      {
        identifier: e.identifier,
        type: e.type,
        isBuiltin: e.isBuiltin || !!e.metadata?.isBuiltin,
        location: e.location,
        manifest: e.manifest,
        targetPlatform: e.targetPlatform,
        validations: e.validations,
        isValid: e.isValid,
        readmeUrl: i,
        changelogUrl: n,
        publisherDisplayName: e.metadata?.publisherDisplayName,
        publisherId: e.metadata?.publisherId || null,
        isApplicationScoped: !!e.metadata?.isApplicationScoped,
        isMachineScoped: !!e.metadata?.isMachineScoped,
        isPreReleaseVersion: !!e.metadata?.isPreReleaseVersion,
        hasPreReleaseVersion: !!e.metadata?.hasPreReleaseVersion,
        preRelease: !!e.metadata?.preRelease,
        installedTimestamp: e.metadata?.installedTimestamp,
        updated: !!e.metadata?.updated,
        pinned: !!e.metadata?.pinned,
        isWorkspaceScoped: !1,
        source: e.metadata?.source ?? (e.identifier.uuid ? "gallery" : "vsix"),
      }
    );
  }
  async I() {
    const e = await this.getUninstalledExtensions();
    if (Object.keys(e).length === 0) {
      this.z.debug("No uninstalled extensions found.");
      return;
    }
    this.z.debug("Removing uninstalled extensions:", Object.keys(e));
    const s = await this.t.scanUserExtensions({ includeAllVersions: !0, includeUninstalled: !0, includeInvalid: !0 }),
      i = new Set();
    for (const r of s) e[Tt.create(r).toString()] || i.add(r.identifier.id.toLowerCase());
    try {
      const r = Hp(s, (o) => o.identifier);
      await Ze.settled(
        r.map(async (o) => {
          const a = o.sort((c, l) => tg(c.manifest.version, l.manifest.version))[0];
          i.has(a.identifier.id.toLowerCase()) || (await this.n(await this.H(a)));
        }),
      );
    } catch (r) {
      this.z.error(r);
    }
    const n = s.filter((r) => r.metadata && e[Tt.create(r).toString()]);
    await Promise.allSettled(n.map((r) => this.removeUninstalledExtension(r)));
  }
  async J() {
    this.z.trace("ExtensionManagementService#removeTempDeleteFolders");
    let e;
    try {
      e = await this.s.resolve(this.t.userExtensionsLocation);
    } catch (s) {
      ct(s) !== 1 && this.z.error(s);
      return;
    }
    if (e?.children)
      try {
        await Promise.allSettled(
          e.children.map(async (s) => {
            if (!(!s.isDirectory || !s.name.endsWith(kg))) {
              this.z.trace("Deleting the temporarily deleted folder", s.resource.toString());
              try {
                await this.s.del(s.resource, { recursive: !0 }), this.z.trace("Deleted the temporarily deleted folder", s.resource.toString());
              } catch (i) {
                ct(i) !== 1 && this.z.error(i);
              }
            }
          }),
        );
      } catch {}
  }
};
Ch = __decorate([__param(1, ie), __param(2, pa), __param(3, ci), __param(4, ke), __param(5, Se), __param(6, ne)], Ch);
var kh = class extends Sg {
  get operation() {
    return this.options.operation ?? this.j;
  }
  get verificationStatus() {
    return this.k;
  }
  constructor(e, s, i, n, r, o, a, c, l, h, u, f) {
    super(),
      (this.l = e),
      (this.manifest = s),
      (this.source = i),
      (this.options = n),
      (this.m = r),
      (this.n = o),
      (this.o = a),
      (this.p = c),
      (this.q = l),
      (this.s = h),
      (this.t = u),
      (this.u = f),
      (this.j = 2),
      (this.identifier = this.l.identifier);
  }
  async h(e) {
    const i = (await this.n.scanExtensions(1, this.options.profileLocation, this.options.productVersion)).find((a) => G(a.identifier, this.identifier));
    i && (this.j = 3);
    const n = {
      isApplicationScoped: this.options.isApplicationScoped || i?.isApplicationScoped,
      isMachineScoped: this.options.isMachineScoped || i?.isMachineScoped,
      isBuiltin: this.options.isBuiltin || i?.isBuiltin,
      isSystem: i?.type === 0 ? !0 : void 0,
      installedTimestamp: Date.now(),
      pinned: this.options.installGivenVersion ? !0 : (this.options.pinned ?? i?.pinned),
      source: this.source instanceof C ? "vsix" : "gallery",
    };
    let r;
    if (this.source instanceof C) {
      if (i && this.l.equals(new Tt(i.identifier, i.manifest.version)))
        try {
          await this.n.removeExtension(i, "existing");
        } catch {
          throw new Error(w(1870, null, this.manifest.displayName || this.manifest.name));
        }
      const a = await this.w(this.l);
      if (a)
        try {
          await this.n.removeExtension(a, "existing");
        } catch {
          throw new Error(w(1871, null, this.manifest.displayName || this.manifest.name));
        }
    } else {
      if (
        ((n.id = this.source.identifier.uuid),
        (n.publisherId = this.source.publisherId),
        (n.publisherDisplayName = this.source.publisherDisplayName),
        (n.targetPlatform = this.source.properties.targetPlatform),
        (n.updated = !!i),
        (n.isPreReleaseVersion = this.source.properties.isPreReleaseVersion),
        (n.hasPreReleaseVersion = i?.hasPreReleaseVersion || this.source.properties.isPreReleaseVersion),
        (n.preRelease = Ms(this.options.preRelease) ? this.options.preRelease : this.options.installPreReleaseVersion || this.source.properties.isPreReleaseVersion || i?.preRelease),
        i && i.type !== 0 && i.manifest.version === this.source.version)
      )
        return this.n.updateMetadata(i, n, this.options.profileLocation);
      r = await this.w(this.l);
    }
    if (e.isCancellationRequested) throw We(new ot());
    if (!r) {
      const a = await this.m(this.operation, e);
      (r = a.local), (this.k = a.verificationStatus);
    }
    if (this.o.extUri.isEqual(this.q.defaultProfile.extensionsResource, this.options.profileLocation))
      try {
        await this.s.initializeDefaultProfileExtensions();
      } catch (a) {
        throw We(a, "IntializeDefaultProfile");
      }
    if (e.isCancellationRequested) throw We(new ot());
    try {
      await this.t.addExtensionsToProfile([[r, n]], this.options.profileLocation, !r.isValid);
    } catch (a) {
      throw We(a, "AddToProfile");
    }
    const o = await this.n.scanLocalExtension(r.location, 1, this.options.profileLocation);
    if (!o) throw new Ne("Cannot find the installed extension", "InstalledExtensionNotFound");
    return this.source instanceof C && this.x(r, e), o;
  }
  async w(e) {
    return (await this.n.getUninstalledExtensions())[e.toString()]
      ? (this.u.trace("Removing the extension from uninstalled list:", e.id),
        await this.n.setInstalled(e),
        this.u.info("Removed the extension from uninstalled list:", e.id),
        (await this.n.scanAllUserExtensions(!0)).find((n) => Tt.create(n).equals(e)))
      : void 0;
  }
  async x(e, s) {
    try {
      let [i] = await this.p.getExtensions([{ id: e.identifier.id, version: e.manifest.version }], s);
      if ((i || ([i] = await this.p.getExtensions([{ id: e.identifier.id }], s)), i)) {
        const n = {
          id: i.identifier.uuid,
          publisherDisplayName: i.publisherDisplayName,
          publisherId: i.publisherId,
          isPreReleaseVersion: i.properties.isPreReleaseVersion,
          hasPreReleaseVersion: e.hasPreReleaseVersion || i.properties.isPreReleaseVersion,
          preRelease: i.properties.isPreReleaseVersion || this.options.installPreReleaseVersion,
        };
        await this.n.updateMetadata(e, n, this.options.profileLocation);
      }
    } catch {}
  }
};
kh = __decorate([__param(6, ke), __param(7, ps), __param(8, Te), __param(9, pa), __param(10, ci), __param(11, ne)], kh);
var l2 = class extends Sg {
    constructor(t, e, s) {
      super(), (this.extension = t), (this.options = e), (this.j = s);
    }
    async h(t) {
      await this.j.removeExtensionFromProfile(this.extension, this.options.profileLocation);
    }
  },
  Dg;
(function (t) {
  (t[(t.FILE = 1)] = "FILE"), (t[(t.WORKSPACE = 2)] = "WORKSPACE"), (t[(t.EXE = 3)] = "EXE");
})(Dg || (Dg = {}));
var Ig;
(function (t) {
  (t.Ignored = "ignored"), (t.Cancelled = "cancelled"), (t.TooMany = "toomany"), (t.IncompatibleWindow = "incompatibleWindow"), (t.Accepted = "reacted");
})(Ig || (Ig = {}));
var Rg = z("IExtensionRecommendationNotificationService");
async function Pg(t, e, s, i, n, r) {
  let o;
  try {
    await h2(t, e, s, i, n, r);
  } catch (a) {
    o = a;
  } finally {
    o && n.errorTransformer && (o = n.errorTransformer(o)), typeof o < "u" && s.error(o), s.end();
  }
}
async function h2(t, e, s, i, n, r) {
  Dh(r);
  const o = await t.open(e, { create: !1 });
  try {
    Dh(r);
    let a = 0,
      c = 0,
      l = n && typeof n.length == "number" ? n.length : void 0,
      h = L.alloc(Math.min(n.bufferSize, typeof l == "number" ? l : n.bufferSize)),
      u = n && typeof n.position == "number" ? n.position : 0,
      f = 0;
    do
      (c = await t.read(o, u, h.buffer, f, h.byteLength - f)),
        (u += c),
        (f += c),
        (a += c),
        typeof l == "number" && (l -= c),
        f === h.byteLength && (await s.write(i(h)), (h = L.alloc(Math.min(n.bufferSize, typeof l == "number" ? l : n.bufferSize))), (f = 0));
    while (c > 0 && (typeof l != "number" || l > 0) && Dh(r) && u2(a, n));
    if (f > 0) {
      let d = f;
      typeof l == "number" && (d = Math.min(f, l)), s.write(i(h.slice(0, d)));
    }
  } catch (a) {
    throw Ti(a);
  } finally {
    await t.close(o);
  }
}
function Dh(t) {
  if (t.isCancellationRequested) throw uo();
  return !0;
}
function u2(t, e) {
  if (typeof e?.limits?.size == "number" && t > e.limits.size) throw Ds(w(1940, null), X.FileTooLarge);
  return !0;
}
var Ih,
  Rh = class extends O {
    static {
      Ih = this;
    }
    set telemetryService(e) {
      (this.b = e),
        this.c.forEach(([s, i]) => {
          e.publicLog2(s, i);
        }),
        (this.c = []);
    }
    f(e, s) {
      this.b ? this.b.publicLog2(e, s) : this.c.push([e, s]);
    }
    constructor(e) {
      super(),
        (this.g = e),
        (this.a = 256 * 1024),
        (this.c = []),
        (this.h = this.B(new D())),
        (this.onDidChangeFileSystemProviderRegistrations = this.h.event),
        (this.j = this.B(new D())),
        (this.onWillActivateFileSystemProvider = this.j.event),
        (this.m = this.B(new D())),
        (this.onDidChangeFileSystemProviderCapabilities = this.m.event),
        (this.n = new Map()),
        (this.u = this.B(new D())),
        (this.onDidRunOperation = this.u.event),
        (this.$ = this.B(new D())),
        (this.ab = this.B(new D())),
        (this.onDidFilesChange = this.ab.event),
        (this.bb = this.B(new D())),
        (this.onDidWatchError = this.bb.event),
        (this.cb = new Map()),
        (this.fb = this.B(new Xd()));
    }
    registerProvider(e, s) {
      if (this.n.has(e)) throw new Error(`A filesystem provider for the scheme '${e}' is already registered.`);
      _i(`code/registerFilesystem/${e}`);
      const i = new ye();
      return (
        this.n.set(e, s),
        this.h.fire({ added: !0, scheme: e, provider: s }),
        i.add(
          s.onDidChangeFile((n) => {
            const r = new ub(n, !this.X(s));
            this.$.fire(r), r.hasCorrelation() || this.ab.fire(r);
          }),
        ),
        typeof s.onDidWatchError == "function" && i.add(s.onDidWatchError((n) => this.bb.fire(new Error(n)))),
        i.add(s.onDidChangeCapabilities(() => this.m.fire({ provider: s, scheme: e }))),
        ue(() => {
          this.h.fire({ added: !1, scheme: e, provider: s }), this.n.delete(e), Xt(i);
        })
      );
    }
    getProvider(e) {
      return this.n.get(e);
    }
    async activateProvider(e) {
      const s = [];
      if (
        (this.j.fire({
          scheme: e,
          join(n) {
            s.push(n);
          },
        }),
        this.n.has(e))
      )
        return;
      const i = new un();
      this.f("fileServiceActivateProvider:start", { time: Date.now(), scheme: e }),
        await Ze.settled(s),
        this.f("fileServiceActivateProvider:end", { scheme: e, elapsed: i.elapsed() }),
        this.g.info(`Activate provider for scheme ${e} took ${i.elapsed()}ms.`);
    }
    async canHandleResource(e) {
      return await this.activateProvider(e.scheme), this.hasProvider(e);
    }
    hasProvider(e) {
      return this.n.has(e.scheme);
    }
    hasCapability(e, s) {
      const i = this.n.get(e.scheme);
      return !!(i && i.capabilities & s);
    }
    listCapabilities() {
      return $i.map(this.n, ([e, s]) => ({ scheme: e, capabilities: s.capabilities }));
    }
    async r(e) {
      if (!hy(e)) throw new et(w(1913, null, this.vb(e)), 8);
      await this.activateProvider(e.scheme);
      const s = this.n.get(e.scheme);
      if (!s) {
        const i = new Si();
        throw ((i.message = w(1914, null, e.toString())), i);
      }
      return s;
    }
    async s(e) {
      const s = await this.r(e);
      if (ni(s) || ns(s) || Cl(s)) return s;
      throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);
    }
    async t(e) {
      const s = await this.r(e);
      if (ni(s) || ns(s)) return s;
      throw new Error(`Filesystem provider for scheme '${e.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);
    }
    async resolve(e, s) {
      try {
        return await this.w(e, s);
      } catch (i) {
        throw Bo(i) === X.FileNotFound ? new et(w(1915, null, this.vb(e)), 1) : Ti(i);
      }
    }
    async w(e, s) {
      const i = await this.r(e),
        n = this.X(i),
        r = s?.resolveTo,
        o = s?.resolveSingleChildDescendants,
        a = s?.resolveMetadata,
        c = s?.cachedStat ?? (await i.stat(e));
      let l;
      return this.z(
        i,
        e,
        c,
        void 0,
        !!a,
        (h, u) => (l || ((l = Cn.forUris(() => !n)), l.set(e, !0), r && l.fill(!0, r)), l.get(h.resource) || l.findSuperstr(h.resource.with({ query: null, fragment: null })) ? !0 : h.isDirectory && o ? u === 1 : !1),
      );
    }
    async z(e, s, i, n, r, o) {
      const { providerExtUri: a } = this.W(e),
        c = {
          resource: s,
          name: a.basename(s),
          isFile: (i.type & Gt.File) !== 0,
          isDirectory: (i.type & Gt.Directory) !== 0,
          isSymbolicLink: (i.type & Gt.SymbolicLink) !== 0,
          mtime: i.mtime,
          ctime: i.ctime,
          size: i.size,
          readonly: !!((i.permissions ?? 0) & kn.Readonly) || !!(e.capabilities & 2048),
          locked: !!((i.permissions ?? 0) & kn.Locked),
          etag: sp({ mtime: i.mtime, size: i.size }),
          children: void 0,
        };
      if (c.isDirectory && o(c, n)) {
        try {
          const l = await e.readdir(s),
            h = await Ze.settled(
              l.map(async ([u, f]) => {
                try {
                  const d = a.joinPath(s, u),
                    p = r ? await e.stat(d) : { type: f };
                  return await this.z(e, d, p, l.length, r, o);
                } catch (d) {
                  return this.g.trace(d), null;
                }
              }),
            );
          c.children = nn(h);
        } catch (l) {
          this.g.trace(l), (c.children = []);
        }
        return c;
      }
      return c;
    }
    async resolveAll(e) {
      return Ze.settled(
        e.map(async (s) => {
          try {
            return { stat: await this.w(s.resource, s.options), success: !0 };
          } catch (i) {
            return this.g.trace(i), { stat: void 0, success: !1 };
          }
        }),
      );
    }
    async stat(e) {
      const s = await this.r(e),
        i = await s.stat(e);
      return this.z(s, e, i, void 0, !0, () => !1);
    }
    async exists(e) {
      const s = await this.r(e);
      try {
        return !!(await s.stat(e));
      } catch {
        return !1;
      }
    }
    async canCreateFile(e, s) {
      try {
        await this.C(e, s);
      } catch (i) {
        return i;
      }
      return !0;
    }
    async C(e, s) {
      if (!s?.overwrite && (await this.exists(e))) throw new et(w(1916, null, this.vb(e)), 3, s);
    }
    async createFile(e, s = L.fromString(""), i) {
      await this.C(e, i);
      const n = await this.writeFile(e, s);
      return this.u.fire(new Dn(e, 0, n)), n;
    }
    async writeFile(e, s, i) {
      const n = this.tb(await this.t(e), e),
        { providerExtUri: r } = this.W(n);
      let o = i;
      if (Q1(n) && !o?.atomic) {
        const a = n.enforceAtomicWriteFile?.(e);
        a && (o = { ...i, atomic: a });
      }
      try {
        (await this.D(n, e, o)) || (await this.Y(n, r.dirname(e)));
        let c;
        if (ns(n) && !(s instanceof L))
          if (Po(s)) {
            const l = await Cy(s, 3);
            l.ended ? (c = L.concat(l.buffer)) : (c = l);
          } else c = xy(s, (l) => L.concat(l), 3);
        else c = s;
        !ni(n) || (ns(n) && c instanceof L) || (ns(n) && Q1(n) && o?.atomic) ? await this.kb(n, e, o, c) : await this.gb(n, e, o, c instanceof L ? Ty(c) : c), this.u.fire(new Dn(e, 4));
      } catch (a) {
        throw new et(w(1917, null, this.vb(e), Ti(a).toString()), ct(a), o);
      }
      return this.resolve(e, { resolveMetadata: !0 });
    }
    async D(e, s, i) {
      const n = !!i?.unlock;
      if (n && !(e.capabilities & 8192)) throw new Error(w(1918, null, this.vb(s)));
      if (!!i?.atomic) {
        if (!(e.capabilities & 32768)) throw new Error(w(1919, null, this.vb(s)));
        if (!(e.capabilities & 2)) throw new Error(w(1920, null, this.vb(s)));
        if (n) throw new Error(w(1921, null, this.vb(s)));
      }
      let o;
      try {
        o = await e.stat(s);
      } catch {
        return;
      }
      if (o.type & Gt.Directory) throw new et(w(1922, null, this.vb(s)), 0, i);
      if ((this.ub(s, o), typeof i?.mtime == "number" && typeof i.etag == "string" && i.etag !== Pl && typeof o.mtime == "number" && typeof o.size == "number" && i.mtime < o.mtime && i.etag !== sp({ mtime: i.mtime, size: o.size })))
        throw new et(w(1923, null), 3, i);
      return o;
    }
    async readFile(e, s, i) {
      const n = await this.s(e);
      return s?.atomic ? this.F(n, e, s, i) : this.G(n, e, s, i);
    }
    async F(e, s, i, n) {
      return new Promise((r, o) => {
        this.fb.queueFor(
          s,
          async () => {
            try {
              const a = await this.G(e, s, i, n);
              r(a);
            } catch (a) {
              o(a);
            }
          },
          this.W(e).providerExtUri,
        );
      });
    }
    async G(e, s, i, n) {
      const r = await this.H(e, s, { ...i, preferUnbuffered: !0 }, n);
      return { ...r, value: await Ai(r.value) };
    }
    async readFileStream(e, s, i) {
      const n = await this.s(e);
      return this.H(n, e, s, i);
    }
    async H(e, s, i, n) {
      const r = new xs(n);
      let o = i;
      kl(e) && e.enforceAtomicReadFile?.(s) && (o = { ...i, atomic: !0 });
      const a = this.N(s, o).then(
        (l) => l,
        (l) => {
          throw (r.dispose(!0), l);
        },
      );
      let c;
      try {
        return (
          typeof o?.etag == "string" && o.etag !== Pl && (await a),
          (o?.atomic && kl(e)) || !(ni(e) || Cl(e)) || (ns(e) && o?.preferUnbuffered) ? (c = this.M(e, s, o)) : Cl(e) ? (c = this.J(e, s, r.token, o)) : (c = this.L(e, s, r.token, o)),
          c.on("end", () => r.dispose()),
          c.on("error", () => r.dispose()),
          { ...(await a), value: c }
        );
      } catch (l) {
        throw (c && (await e1(c)), this.I(l, s, o));
      }
    }
    I(e, s, i) {
      const n = w(1924, null, this.vb(s), Ti(e).toString());
      return e instanceof Rl ? new Rl(n, e.stat, i) : e instanceof Il ? new Il(n, e.fileOperationResult, e.size, e.options) : new et(n, ct(e), i);
    }
    J(e, s, i, n = Object.create(null)) {
      const r = e.readFileStream(s, n, i);
      return t1(r, { data: (o) => (o instanceof L ? o : L.wrap(o)), error: (o) => this.I(o, s, n) }, (o) => L.concat(o));
    }
    L(e, s, i, n = Object.create(null)) {
      const r = My();
      return Pg(e, s, r, (o) => o, { ...n, bufferSize: this.a, errorTransformer: (o) => this.I(o, s, n) }, i), r;
    }
    M(e, s, i) {
      const n = or((r) => L.concat(r));
      return (
        (async () => {
          try {
            let r;
            i?.atomic && kl(e) ? (r = await e.readFile(s, { atomic: !0 })) : (r = await e.readFile(s)),
              typeof i?.position == "number" && (r = r.slice(i.position)),
              typeof i?.length == "number" && (r = r.slice(0, i.length)),
              this.O(s, r.byteLength, i),
              n.end(L.wrap(r));
          } catch (r) {
            n.error(r), n.end();
          }
        })(),
        n
      );
    }
    async N(e, s) {
      const i = await this.resolve(e, { resolveMetadata: !0 });
      if (i.isDirectory) throw new et(w(1925, null, this.vb(e)), 0, s);
      if (typeof s?.etag == "string" && s.etag !== Pl && s.etag === i.etag) throw new Rl(w(1926, null), i, s);
      return this.O(e, i.size, s), i;
    }
    O(e, s, i) {
      if (typeof i?.limits?.size == "number" && s > i.limits.size) throw new Il(w(1927, null, this.vb(e)), 7, s, i);
    }
    async canMove(e, s, i) {
      return this.P(e, s, "move", i);
    }
    async canCopy(e, s, i) {
      return this.P(e, s, "copy", i);
    }
    async P(e, s, i, n) {
      if (e.toString() !== s.toString())
        try {
          const r = i === "move" ? this.tb(await this.t(e), e) : await this.s(e),
            o = this.tb(await this.t(s), s);
          await this.U(r, e, o, s, i, n);
        } catch (r) {
          return r;
        }
      return !0;
    }
    async move(e, s, i) {
      const n = this.tb(await this.t(e), e),
        r = this.tb(await this.t(s), s),
        o = await this.Q(n, e, r, s, "move", !!i),
        a = await this.resolve(s, { resolveMetadata: !0 });
      return this.u.fire(new Dn(e, o === "move" ? 2 : 3, a)), a;
    }
    async copy(e, s, i) {
      const n = await this.s(e),
        r = this.tb(await this.t(s), s),
        o = await this.Q(n, e, r, s, "copy", !!i),
        a = await this.resolve(s, { resolveMetadata: !0 });
      return this.u.fire(new Dn(e, o === "copy" ? 3 : 2, a)), a;
    }
    async Q(e, s, i, n, r, o) {
      if (s.toString() === n.toString()) return r;
      const { exists: a, isSameResourceWithDifferentPathCase: c } = await this.U(e, s, i, n, r, o);
      if ((a && !c && o && (await this.del(n, { recursive: !0 })), await this.Y(i, this.W(i).providerExtUri.dirname(n)), r === "copy")) {
        if (e === i && xl(e)) await e.copy(s, n, { overwrite: o });
        else {
          const l = await this.resolve(s);
          l.isDirectory ? await this.S(e, l, i, n) : await this.R(e, s, i, n);
        }
        return r;
      } else return e === i ? (await e.rename(s, n, { overwrite: o }), r) : (await this.Q(e, s, i, n, "copy", o), await this.del(s, { recursive: !0 }), "copy");
    }
    async R(e, s, i, n) {
      if (ni(e) && ni(i)) return this.mb(e, s, i, n);
      if (ni(e) && ns(i)) return this.sb(e, s, i, n);
      if (ns(e) && ni(i)) return this.qb(e, s, i, n);
      if (ns(e) && ns(i)) return this.ob(e, s, i, n);
    }
    async S(e, s, i, n) {
      await i.mkdir(n),
        Array.isArray(s.children) &&
          (await Ze.settled(
            s.children.map(async (r) => {
              const o = this.W(i).providerExtUri.joinPath(n, r.name);
              return r.isDirectory ? this.S(e, await this.resolve(r.resource), i, o) : this.R(e, r.resource, i, o);
            }),
          ));
    }
    async U(e, s, i, n, r, o) {
      let a = !1;
      if (e === i) {
        const { providerExtUri: l, isPathCaseSensitive: h } = this.W(e);
        if ((h || (a = l.isEqual(s, n)), a && r === "copy")) throw new Error(w(1928, null, this.vb(s), this.vb(n)));
        if (!a && l.isEqualOrParent(n, s)) throw new Error(w(1929, null, this.vb(s), this.vb(n)));
      }
      const c = await this.exists(n);
      if (c && !a) {
        if (!o) throw new et(w(1930, null, this.vb(s), this.vb(n)), 4);
        if (e === i) {
          const { providerExtUri: l } = this.W(e);
          if (l.isEqualOrParent(s, n)) throw new Error(w(1931, null, this.vb(s), this.vb(n)));
        }
      }
      return { exists: c, isSameResourceWithDifferentPathCase: a };
    }
    W(e) {
      const s = this.X(e);
      return { providerExtUri: s ? ge : ay, isPathCaseSensitive: s };
    }
    X(e) {
      return !!(e.capabilities & 1024);
    }
    async createFolder(e) {
      const s = this.tb(await this.r(e), e);
      await this.Y(s, e);
      const i = await this.resolve(e, { resolveMetadata: !0 });
      return this.u.fire(new Dn(e, 0, i)), i;
    }
    async Y(e, s) {
      const i = [],
        { providerExtUri: n } = this.W(e);
      for (; !n.isEqual(s, n.dirname(s)); )
        try {
          if (!((await e.stat(s)).type & Gt.Directory)) throw new Error(w(1932, null, this.vb(s)));
          break;
        } catch (r) {
          if (Bo(r) !== X.FileNotFound) throw r;
          i.push(n.basename(s)), (s = n.dirname(s));
        }
      for (let r = i.length - 1; r >= 0; r--) {
        s = n.joinPath(s, i[r]);
        try {
          await e.mkdir(s);
        } catch (o) {
          if (Bo(o) !== X.FileExists) throw o;
        }
      }
    }
    async canDelete(e, s) {
      try {
        await this.Z(e, s);
      } catch (i) {
        return i;
      }
      return !0;
    }
    async Z(e, s) {
      const i = this.tb(await this.r(e), e),
        n = !!s?.useTrash;
      if (n && !(i.capabilities & 4096)) throw new Error(w(1933, null, this.vb(e)));
      const r = s?.atomic;
      if (r && !(i.capabilities & 65536)) throw new Error(w(1934, null, this.vb(e)));
      if (n && r) throw new Error(w(1935, null, this.vb(e)));
      let o;
      try {
        o = await i.stat(e);
      } catch {}
      if (o) this.ub(e, o);
      else throw new et(w(1936, null, this.vb(e)), 1);
      if (!!!s?.recursive) {
        const c = await this.resolve(e);
        if (c.isDirectory && Array.isArray(c.children) && c.children.length > 0) throw new Error(w(1937, null, this.vb(e)));
      }
      return i;
    }
    async del(e, s) {
      const i = await this.Z(e, s);
      let n = s;
      if (lb(i) && !n?.atomic) {
        const c = i.enforceAtomicDelete?.(e);
        c && (n = { ...s, atomic: c });
      }
      const r = !!n?.useTrash,
        o = !!n?.recursive,
        a = n?.atomic ?? !1;
      await i.delete(e, { recursive: o, useTrash: r, atomic: a }), this.u.fire(new Dn(e, 1));
    }
    async cloneFile(e, s) {
      const i = await this.r(e),
        n = this.tb(await this.t(s), s);
      if (!(i === n && this.W(i).providerExtUri.isEqual(e, s)))
        return i === n && X1(i)
          ? i.cloneFile(e, s)
          : (await this.Y(n, this.W(n).providerExtUri.dirname(s)),
            i === n && xl(i) ? this.fb.queueFor(e, () => i.copy(e, s, { overwrite: !0 }), this.W(i).providerExtUri) : this.fb.queueFor(e, () => this.R(i, e, n, s), this.W(i).providerExtUri));
    }
    static {
      this.db = 0;
    }
    createWatcher(e, s) {
      return this.watch(e, { ...s, correlationId: Ih.db++ });
    }
    watch(e, s = { recursive: !1, excludes: [] }) {
      const i = new ye();
      let n = !1,
        r = () => {
          n = !0;
        };
      i.add(ue(() => r())),
        (async () => {
          try {
            const a = await this.eb(e, s);
            n ? Xt(a) : (r = () => Xt(a));
          } catch (a) {
            this.g.error(a);
          }
        })();
      const o = s.correlationId;
      if (typeof o == "number") {
        const a = i.add(new D());
        return (
          i.add(
            this.$.event((l) => {
              l.correlates(o) && a.fire(l);
            }),
          ),
          { onDidChange: a.event, dispose: () => i.dispose() }
        );
      }
      return i;
    }
    async eb(e, s) {
      const i = await this.r(e),
        n = Sn([this.W(i).providerExtUri.getComparisonKey(e), s]);
      let r = this.cb.get(n);
      return (
        r || ((r = { count: 0, disposable: i.watch(e, s) }), this.cb.set(n, r)),
        (r.count += 1),
        ue(() => {
          r && (r.count--, r.count === 0 && (Xt(r.disposable), this.cb.delete(n)));
        })
      );
    }
    dispose() {
      super.dispose();
      for (const [, e] of this.cb) Xt(e.disposable);
      this.cb.clear();
    }
    async gb(e, s, i, n) {
      return this.fb.queueFor(
        s,
        async () => {
          const r = await e.open(s, { create: !0, unlock: i?.unlock ?? !1 });
          try {
            Po(n) || Kc(n) ? await this.hb(e, r, n) : await this.ib(e, r, n);
          } catch (o) {
            throw Ti(o);
          } finally {
            await e.close(r);
          }
        },
        this.W(e).providerExtUri,
      );
    }
    async hb(e, s, i) {
      let n = 0,
        r;
      if (Kc(i)) {
        if (i.buffer.length > 0) {
          const o = L.concat(i.buffer);
          await this.jb(e, s, o, o.byteLength, n, 0), (n += o.byteLength);
        }
        if (i.ended) return;
        r = i.stream;
      } else r = i;
      return new Promise((o, a) => {
        Ao(r, {
          onData: async (c) => {
            r.pause();
            try {
              await this.jb(e, s, c, c.byteLength, n, 0);
            } catch (l) {
              return a(l);
            }
            (n += c.byteLength), setTimeout(() => r.resume());
          },
          onError: (c) => a(c),
          onEnd: () => o(),
        });
      });
    }
    async ib(e, s, i) {
      let n = 0,
        r;
      for (; (r = i.read()) !== null; ) await this.jb(e, s, r, r.byteLength, n, 0), (n += r.byteLength);
    }
    async jb(e, s, i, n, r, o) {
      let a = 0;
      for (; a < n; ) {
        const c = await e.write(s, r + a, i.buffer, o + a, n - a);
        a += c;
      }
    }
    async kb(e, s, i, n) {
      return this.fb.queueFor(s, () => this.lb(e, s, i, n), this.W(e).providerExtUri);
    }
    async lb(e, s, i, n) {
      let r;
      n instanceof L ? (r = n) : Po(n) ? (r = await Ai(n)) : Kc(n) ? (r = await jy(n)) : (r = Ny(n)), await e.writeFile(s, r.buffer, { create: !0, overwrite: !0, unlock: i?.unlock ?? !1, atomic: i?.atomic ?? !1 });
    }
    async mb(e, s, i, n) {
      return this.fb.queueFor(n, () => this.nb(e, s, i, n), this.W(i).providerExtUri);
    }
    async nb(e, s, i, n) {
      let r, o;
      try {
        (r = await e.open(s, { create: !1 })), (o = await i.open(n, { create: !0, unlock: !1 }));
        const a = L.alloc(this.a);
        let c = 0,
          l = 0,
          h = 0;
        do (h = await e.read(r, c, a.buffer, l, a.byteLength - l)), await this.jb(i, o, a, h, c, l), (c += h), (l += h), l === a.byteLength && (l = 0);
        while (h > 0);
      } catch (a) {
        throw Ti(a);
      } finally {
        await Ze.settled([typeof r == "number" ? e.close(r) : Promise.resolve(), typeof o == "number" ? i.close(o) : Promise.resolve()]);
      }
    }
    async ob(e, s, i, n) {
      return this.fb.queueFor(n, () => this.pb(e, s, i, n), this.W(i).providerExtUri);
    }
    async pb(e, s, i, n) {
      return i.writeFile(n, await e.readFile(s), { create: !0, overwrite: !0, unlock: !1, atomic: !1 });
    }
    async qb(e, s, i, n) {
      return this.fb.queueFor(n, () => this.rb(e, s, i, n), this.W(i).providerExtUri);
    }
    async rb(e, s, i, n) {
      const r = await i.open(n, { create: !0, unlock: !1 });
      try {
        const o = await e.readFile(s);
        await this.jb(i, r, L.wrap(o), o.byteLength, 0, 0);
      } catch (o) {
        throw Ti(o);
      } finally {
        await i.close(r);
      }
    }
    async sb(e, s, i, n) {
      const r = await Ai(this.L(e, s, J.None));
      await this.kb(i, n, void 0, r);
    }
    tb(e, s) {
      if (e.capabilities & 2048) throw new et(w(1938, null, this.vb(s)), 6);
      return e;
    }
    ub(e, s) {
      if ((s.permissions ?? 0) & kn.Readonly) throw new et(w(1939, null, this.vb(e)), 6);
    }
    vb(e) {
      return e.scheme === oe.file ? e.fsPath : e.toString(!0);
    }
  };
Rh = Ih = __decorate([__param(0, ne)], Rh);
import { promises as li } from "fs";
var Nr = "**",
  Ag = "/",
  wa = "[/\\\\]",
  va = "[^/\\\\]",
  f2 = /\//g;
function Og(t, e) {
  switch (t) {
    case 0:
      return "";
    case 1:
      return `${va}*?`;
    default:
      return `(?:${wa}|${va}+${wa}${e ? `|${wa}${va}+` : ""})*?`;
  }
}
function Lg(t, e) {
  if (!t) return [];
  const s = [];
  let i = !1,
    n = !1,
    r = "";
  for (const o of t) {
    switch (o) {
      case e:
        if (!i && !n) {
          s.push(r), (r = "");
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        n = !0;
        break;
      case "]":
        n = !1;
        break;
    }
    r += o;
  }
  return r && s.push(r), s;
}
function Ng(t) {
  if (!t) return "";
  let e = "";
  const s = Lg(t, Ag);
  if (s.every((i) => i === Nr)) e = ".*";
  else {
    let i = !1;
    s.forEach((n, r) => {
      if (n === Nr) {
        if (i) return;
        e += Og(2, r === s.length - 1);
      } else {
        let o = !1,
          a = "",
          c = !1,
          l = "";
        for (const h of n) {
          if (h !== "}" && o) {
            a += h;
            continue;
          }
          if (c && (h !== "]" || !l)) {
            let u;
            h === "-" ? (u = h) : (h === "^" || h === "!") && !l ? (u = "^") : h === Ag ? (u = "") : (u = dn(h)), (l += u);
            continue;
          }
          switch (h) {
            case "{":
              o = !0;
              continue;
            case "[":
              c = !0;
              continue;
            case "}": {
              const f = `(?:${Lg(a, ",")
                .map((d) => Ng(d))
                .join("|")})`;
              (e += f), (o = !1), (a = "");
              break;
            }
            case "]": {
              (e += "[" + l + "]"), (c = !1), (l = "");
              break;
            }
            case "?":
              e += va;
              continue;
            case "*":
              e += Og(1);
              continue;
            default:
              e += dn(h);
          }
        }
        r < s.length - 1 && (s[r + 1] !== Nr || r + 2 < s.length) && (e += wa);
      }
      i = n === Nr;
    });
  }
  return e;
}
var d2 = /^\*\*\/\*\.[\w\.-]+$/,
  p2 = /^\*\*\/([\w\.-]+)\/?$/,
  g2 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,
  m2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,
  w2 = /^\*\*((\/[\w\.-]+)+)\/?$/,
  v2 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/,
  Tg = new Dc(1e4),
  jg = function () {
    return !1;
  },
  Rs = function () {
    return null;
  };
function Ph(t, e) {
  if (!t) return Rs;
  let s;
  typeof t != "string" ? (s = t.pattern) : (s = t), (s = s.trim());
  const i = `${s}_${!!e.trimForExclusions}`;
  let n = Tg.get(i);
  if (n) return Fg(n, t);
  let r;
  return (
    d2.test(s)
      ? (n = y2(s.substr(4), s))
      : (r = p2.exec(Ah(s, e)))
        ? (n = b2(r[1], s))
        : (e.trimForExclusions ? m2 : g2).test(s)
          ? (n = E2(s, e))
          : (r = w2.exec(Ah(s, e)))
            ? (n = Mg(r[1].substr(1), s, !0))
            : (r = v2.exec(Ah(s, e)))
              ? (n = Mg(r[1], s, !1))
              : (n = S2(s)),
    Tg.set(i, n),
    Fg(n, t)
  );
}
function Fg(t, e) {
  if (typeof e == "string") return t;
  const s = function (i, n) {
    return ir(i, e.base, !ht) ? t($d(i.substr(e.base.length), Vt), n) : null;
  };
  return (s.allBasenames = t.allBasenames), (s.allPaths = t.allPaths), (s.basenames = t.basenames), (s.patterns = t.patterns), s;
}
function Ah(t, e) {
  return e.trimForExclusions && t.endsWith("/**") ? t.substr(0, t.length - 2) : t;
}
function y2(t, e) {
  return function (s, i) {
    return typeof s == "string" && s.endsWith(t) ? e : null;
  };
}
function b2(t, e) {
  const s = `/${t}`,
    i = `\\${t}`,
    n = function (o, a) {
      return typeof o != "string" ? null : a ? (a === t ? e : null) : o === t || o.endsWith(s) || o.endsWith(i) ? e : null;
    },
    r = [t];
  return (n.basenames = r), (n.patterns = [e]), (n.allBasenames = r), n;
}
function E2(t, e) {
  const s = Ug(
      t
        .slice(1, -1)
        .split(",")
        .map((a) => Ph(a, e))
        .filter((a) => a !== Rs),
      t,
    ),
    i = s.length;
  if (!i) return Rs;
  if (i === 1) return s[0];
  const n = function (a, c) {
      for (let l = 0, h = s.length; l < h; l++) if (s[l](a, c)) return t;
      return null;
    },
    r = s.find((a) => !!a.allBasenames);
  r && (n.allBasenames = r.allBasenames);
  const o = s.reduce((a, c) => (c.allPaths ? a.concat(c.allPaths) : a), []);
  return o.length && (n.allPaths = o), n;
}
function Mg(t, e, s) {
  const i = Vt === be.sep,
    n = i ? t : t.replace(f2, Vt),
    r = Vt + n,
    o = be.sep + t;
  let a;
  return (
    s
      ? (a = function (c, l) {
          return typeof c == "string" && (c === n || c.endsWith(r) || (!i && (c === t || c.endsWith(o)))) ? e : null;
        })
      : (a = function (c, l) {
          return typeof c == "string" && (c === n || (!i && c === t)) ? e : null;
        }),
    (a.allPaths = [(s ? "*/" : "./") + t]),
    a
  );
}
function S2(t) {
  try {
    const e = new RegExp(`^${Ng(t)}$`);
    return function (s) {
      return (e.lastIndex = 0), typeof s == "string" && e.test(s) ? t : null;
    };
  } catch {
    return Rs;
  }
}
function $2(t, e = {}) {
  if (!t) return jg;
  if (typeof t == "string" || x2(t)) {
    const s = Ph(t, e);
    if (s === Rs) return jg;
    const i = function (n, r) {
      return !!s(n, r);
    };
    return s.allBasenames && (i.allBasenames = s.allBasenames), s.allPaths && (i.allPaths = s.allPaths), i;
  }
  return C2(t, e);
}
function x2(t) {
  const e = t;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function C2(t, e) {
  const s = Ug(
      Object.getOwnPropertyNames(t)
        .map((a) => k2(a, t[a], e))
        .filter((a) => a !== Rs),
    ),
    i = s.length;
  if (!i) return Rs;
  if (!s.some((a) => !!a.requiresSiblings)) {
    if (i === 1) return s[0];
    const a = function (h, u) {
        let f;
        for (let d = 0, p = s.length; d < p; d++) {
          const g = s[d](h, u);
          if (typeof g == "string") return g;
          Hc(g) && (f || (f = []), f.push(g));
        }
        return f
          ? (async () => {
              for (const d of f) {
                const p = await d;
                if (typeof p == "string") return p;
              }
              return null;
            })()
          : null;
      },
      c = s.find((h) => !!h.allBasenames);
    c && (a.allBasenames = c.allBasenames);
    const l = s.reduce((h, u) => (u.allPaths ? h.concat(u.allPaths) : h), []);
    return l.length && (a.allPaths = l), a;
  }
  const n = function (a, c, l) {
      let h, u;
      for (let f = 0, d = s.length; f < d; f++) {
        const p = s[f];
        p.requiresSiblings && l && (c || (c = Ot(a)), h || (h = c.substr(0, c.length - Mv(a).length)));
        const g = p(a, c, h, l);
        if (typeof g == "string") return g;
        Hc(g) && (u || (u = []), u.push(g));
      }
      return u
        ? (async () => {
            for (const f of u) {
              const d = await f;
              if (typeof d == "string") return d;
            }
            return null;
          })()
        : null;
    },
    r = s.find((a) => !!a.allBasenames);
  r && (n.allBasenames = r.allBasenames);
  const o = s.reduce((a, c) => (c.allPaths ? a.concat(c.allPaths) : a), []);
  return o.length && (n.allPaths = o), n;
}
function k2(t, e, s) {
  if (e === !1) return Rs;
  const i = Ph(t, s);
  if (i === Rs) return Rs;
  if (typeof e == "boolean") return i;
  if (e) {
    const n = e.when;
    if (typeof n == "string") {
      const r = (o, a, c, l) => {
        if (!l || !i(o, a)) return null;
        const h = n.replace("$(basename)", () => c),
          u = l(h);
        return Hc(u) ? u.then((f) => (f ? t : null)) : u ? t : null;
      };
      return (r.requiresSiblings = !0), r;
    }
  }
  return i;
}
function Ug(t, e) {
  const s = t.filter((a) => !!a.basenames);
  if (s.length < 2) return t;
  const i = s.reduce((a, c) => {
    const l = c.basenames;
    return l ? a.concat(l) : a;
  }, []);
  let n;
  if (e) {
    n = [];
    for (let a = 0, c = i.length; a < c; a++) n.push(e);
  } else
    n = s.reduce((a, c) => {
      const l = c.patterns;
      return l ? a.concat(l) : a;
    }, []);
  const r = function (a, c) {
    if (typeof a != "string") return null;
    if (!c) {
      let h;
      for (h = a.length; h > 0; h--) {
        const u = a.charCodeAt(h - 1);
        if (u === 47 || u === 92) break;
      }
      c = a.substr(h);
    }
    const l = i.indexOf(c);
    return l !== -1 ? n[l] : null;
  };
  (r.basenames = i), (r.patterns = n), (r.allBasenames = i);
  const o = t.filter((a) => !a.basenames);
  return o.push(r), o;
}
function _g(t, e) {
  return _t(t, e, (s, i) => (typeof s == "string" && typeof i == "string" ? s === i : typeof s != "string" && typeof i != "string" ? s.base === i.base && s.pattern === i.pattern : !1));
}
function Bg(t) {
  return typeof t.correlationId == "number";
}
function D2(t) {
  return t.recursive === !0;
}
var zg = class uw extends O {
    static {
      this.a = 5;
    }
    constructor(e, s, i, n) {
      super(), (this.h = e), (this.j = s), (this.m = i), (this.n = n), (this.c = this.B(new Es())), (this.f = void 0), (this.g = 0);
    }
    s() {
      const e = new ye();
      (this.c.value = e), (this.b = this.r(e)), this.b.setVerboseLogging(this.m), e.add(this.b.onDidChangeFile((s) => this.h(s))), e.add(this.b.onDidLogMessage((s) => this.j(s))), e.add(this.b.onDidError((s) => this.t(s.error, s.request)));
    }
    t(e, s) {
      this.u(e, s) ? (this.g < uw.a && this.f ? (this.y(`restarting watcher after unexpected error: ${e}`), this.w(this.f)) : this.y(`gave up attempting to restart watcher after unexpected error: ${e}`)) : this.y(e);
    }
    u(e, s) {
      return !(!this.n.restartOnError || s || e.indexOf("No space left on device") !== -1 || e.indexOf("EMFILE") !== -1);
    }
    w(e) {
      this.g++, this.s(), this.watch(e);
    }
    async watch(e) {
      (this.f = e), await this.b?.watch(e);
    }
    async setVerboseLogging(e) {
      (this.m = e), await this.b?.setVerboseLogging(e);
    }
    y(e) {
      this.j({ type: "error", message: `[File Watcher (${this.n.type})] ${e}` });
    }
    z(e) {
      this.j({ type: "trace", message: `[File Watcher (${this.n.type})] ${e}` });
    }
    dispose() {
      return (this.b = void 0), super.dispose();
    }
  },
  I2 = class extends zg {
    constructor(t, e, s) {
      super(t, e, s, { type: "node.js", restartOnError: !1 });
    }
  },
  R2 = class extends zg {
    constructor(t, e, s) {
      super(t, e, s, { type: "universal", restartOnError: !0 });
    }
  };
function Oh(t) {
  return t.map((e) => ({ type: e.type, resource: C.revive(e.resource), cId: e.cId }));
}
function P2(t) {
  const e = new O2();
  for (const s of t) e.processEvent(s);
  return e.coalesce();
}
function A2(t, e) {
  return typeof e == "string" && !e.startsWith(Nr) && !xo(e) ? { base: t, pattern: e } : e;
}
function qg(t, e) {
  const s = [];
  for (const i of e) s.push($2(A2(t, i)));
  return s;
}
var O2 = class {
  constructor() {
    (this.a = new Set()), (this.b = new Map());
  }
  c(t) {
    return ht ? t.resource.fsPath : t.resource.fsPath.toLowerCase();
  }
  processEvent(t) {
    const e = this.b.get(this.c(t));
    let s = !1;
    if (e) {
      const i = e.type,
        n = t.type;
      e.resource.fsPath !== t.resource.fsPath && (t.type === 2 || t.type === 1) ? (s = !0) : i === 1 && n === 2 ? (this.b.delete(this.c(t)), this.a.delete(e)) : i === 2 && n === 1 ? (e.type = 0) : (i === 1 && n === 0) || (e.type = n);
    } else s = !0;
    s && (this.a.add(t), this.b.set(this.c(t), t));
  }
  coalesce() {
    const t = [],
      e = [];
    return Array.from(this.a)
      .filter((s) => (s.type !== 2 ? (t.push(s), !1) : !0))
      .sort((s, i) => s.resource.fsPath.length - i.resource.fsPath.length)
      .filter((s) => (e.some((i) => fb(s.resource.fsPath, i, !ht)) ? !1 : (e.push(s.resource.fsPath), !0)))
      .concat(t);
  }
};
function L2(t, e) {
  if (typeof e == "number")
    switch (t.type) {
      case 1:
        return (e & 4) === 0;
      case 2:
        return (e & 8) === 0;
      case 0:
        return (e & 2) === 0;
    }
  return !1;
}
function N2(t) {
  if (typeof t == "number") {
    const e = [];
    return t & 4 && e.push("Added"), t & 8 && e.push("Deleted"), t & 2 && e.push("Updated"), e.length === 0 ? "<all>" : `[${e.join(", ")}]`;
  }
  return "<none>";
}
var T2 = class extends O {
  constructor(t, e) {
    super(),
      (this.a = t),
      (this.b = e),
      (this.c = this.B(new D())),
      (this.onDidChangeFile = this.c.event),
      (this.g = this.B(new D())),
      (this.onDidWatchError = this.g.event),
      (this.j = []),
      (this.m = this.B(new Ri(0))),
      (this.y = []),
      (this.z = this.B(new Ri(0)));
  }
  watch(t, e) {
    return e.recursive || this.b?.watcher?.forceUniversal ? this.n(t, e) : this.C(t, e);
  }
  n(t, e) {
    const s = this.r(t, e),
      i = qf(this.j, s);
    return (
      this.s(),
      ue(() => {
        i(), this.s();
      })
    );
  }
  r(t, e) {
    const s = { path: this.L(t), excludes: e.excludes, includes: e.includes, recursive: e.recursive, filter: e.filter, correlationId: e.correlationId };
    if (D2(s)) {
      const i = this.b?.watcher?.recursive?.usePolling;
      i === !0 ? (s.pollingInterval = this.b?.watcher?.recursive?.pollingInterval ?? 5e3) : Array.isArray(i) && i.includes(s.path) && (s.pollingInterval = this.b?.watcher?.recursive?.pollingInterval ?? 5e3);
    }
    return s;
  }
  s() {
    this.m.trigger(() => this.t()).catch((t) => rt(t));
  }
  t() {
    return (
      this.h ||
        ((this.h = this.B(
          this.u(
            (t) => this.c.fire(Oh(t)),
            (t) => this.H(t),
            this.a.getLevel() === te.Trace,
          ),
        )),
        this.B(
          this.a.onDidChangeLogLevel(() => {
            this.h?.setVerboseLogging(this.a.getLevel() === te.Trace);
          }),
        )),
      this.h.watch(this.j)
    );
  }
  C(t, e) {
    const s = { path: this.L(t), excludes: e.excludes, includes: e.includes, recursive: !1, filter: e.filter, correlationId: e.correlationId },
      i = qf(this.y, s);
    return (
      this.D(),
      ue(() => {
        i(), this.D();
      })
    );
  }
  D() {
    this.z.trigger(() => this.F()).catch((t) => rt(t));
  }
  F() {
    return (
      this.w ||
        ((this.w = this.B(
          this.G(
            (t) => this.c.fire(Oh(t)),
            (t) => this.H(t),
            this.a.getLevel() === te.Trace,
          ),
        )),
        this.B(
          this.a.onDidChangeLogLevel(() => {
            this.w?.setVerboseLogging(this.a.getLevel() === te.Trace);
          }),
        )),
      this.w.watch(this.y)
    );
  }
  H(t) {
    t.type === "error" && this.g.fire(t.message), this.I(t);
  }
  I(t) {
    this.a[t.type](t.message);
  }
  J(t) {
    return Di(t.fsPath);
  }
  L(t) {
    const e = this.J(t);
    return ty(e);
  }
};
import { fork as j2 } from "child_process";
function F2(t) {
  const e = t;
  return e && typeof e.type == "string" && typeof e.severity == "string";
}
function M2(t) {
  const e = [];
  let s;
  try {
    const i = JSON.parse(t.arguments),
      n = i[i.length - 1];
    n && n.__$stack && (i.pop(), (s = n.__$stack)), e.push(...i);
  } catch {
    e.push("Unable to log remote console arguments", t.arguments);
  }
  return { args: e, stack: s };
}
function U2(t) {
  if (!t) return t;
  const e = t.indexOf(`
`);
  return e === -1 ? t : t.substring(0, e);
}
function _2(t, e) {
  const { args: s, stack: i } = M2(t),
    n = typeof s[0] == "string" && s.length === 1;
  let r = U2(i);
  r && (r = `(${r.trim()})`);
  let o = [];
  if (
    (typeof s[0] == "string" ? (r && n ? (o = [`%c[${e}] %c${s[0]} %c${r}`, Tn("blue"), Tn(""), Tn("grey")]) : (o = [`%c[${e}] %c${s[0]}`, Tn("blue"), Tn(""), ...s.slice(1)])) : (o = [`%c[${e}]%`, Tn("blue"), ...s]),
    r && !n && o.push(r),
    typeof console[t.severity] != "function")
  )
    throw new Error("Unknown console method");
  z2(o) || console[t.severity].apply(console, o);
}
function Tn(t) {
  return `color: ${t}`;
}
var B2 = ["/opt/tiger/consul_deploy"];
function z2(t) {
  try {
    return !!t.filter((s) => B2.some((i) => s.includes(i)));
  } catch {
    return !1;
  }
}
import { promises as Vg } from "fs";
var Wg;
(function (t) {
  (t[(t.stdout = 0)] = "stdout"), (t[(t.stderr = 1)] = "stderr");
})(Wg || (Wg = {}));
var Hg;
(function (t) {
  (t[(t.Success = 0)] = "Success"), (t[(t.Unknown = 1)] = "Unknown"), (t[(t.AccessDenied = 2)] = "AccessDenied"), (t[(t.ProcessNotFound = 3)] = "ProcessNotFound");
})(Hg || (Hg = {}));
function q2(t) {
  t && (delete t.DEBUG, ht && delete t.LD_PRELOAD);
}
function V2(t = Y) {
  return t.comspec || "cmd.exe";
}
function W2(t) {
  let e = [],
    s = !1;
  const i = function (n) {
    if (s) {
      e.push(n);
      return;
    }
    (!t.send(n, (o) => {
      if ((o && console.error(o), (s = !1), e.length > 0)) {
        const a = e.slice(0);
        (e = []), a.forEach((c) => i(c));
      }
    }) ||
      Be) &&
      (s = !0);
  };
  return { send: i };
}
var Gg;
(function (t) {
  async function e(s, i, n) {
    if (xo(s)) return s;
    if ((i === void 0 && (i = sr()), Yt(s) !== "." || (n === void 0 && _e(Y.PATH) && (n = Y.PATH.split(Uv)), n === void 0 || n.length === 0))) return V(i, s);
    async function o(a) {
      if (await he.exists(a)) {
        let c;
        try {
          c = await Vg.stat(a);
        } catch (l) {
          l.message.startsWith("EACCES") && (c = await Vg.lstat(a));
        }
        return c ? !c.isDirectory() : !1;
      }
      return !1;
    }
    for (const a of n) {
      let c;
      if ((xo(a) ? (c = V(a, s)) : (c = V(i, a, s)), await o(c))) return c;
      let l = c + ".com";
      if ((await o(l)) || ((l = c + ".exe"), await o(l))) return l;
    }
    return V(i, s);
  }
  t.findExecutable = e;
})(Gg || (Gg = {}));
var Jg = class {
    constructor(t, e) {
      (this.i = t), (this.j = e), (this.c = new Set()), (this.g = new Map()), (this.h = new D()), (this.onDidProcessExit = this.h.event);
      const s = e && e.timeout ? e.timeout : 6e4;
      (this.b = new Gc(s)), (this.d = null), (this.f = null);
    }
    getChannel(t) {
      const e = this;
      return {
        call(s, i, n) {
          return e.k(t, s, i, n);
        },
        listen(s, i) {
          return e.l(t, s, i);
        },
      };
    }
    k(t, e, s, i = J.None) {
      if (!this.b) return Promise.reject(new Error("disposed"));
      if (i.isCancellationRequested) return Promise.reject(uo());
      this.b.cancel();
      const n = this.n(t),
        r = wt((c) => n.call(e, s, c)),
        o = i.onCancellationRequested(() => r.cancel()),
        a = ue(() => r.cancel());
      return (
        this.c.add(a),
        r.finally(() => {
          o.dispose(), this.c.delete(a), this.c.size === 0 && this.b && this.b.trigger(() => this.o());
        }),
        r
      );
    }
    l(t, e, s) {
      if (!this.b) return T.None;
      this.b.cancel();
      let i;
      const n = new D({
        onWillAddFirstListener: () => {
          (i = this.n(t).listen(e, s)(n.fire, n)), this.c.add(i);
        },
        onDidRemoveLastListener: () => {
          this.c.delete(i), i.dispose(), this.c.size === 0 && this.b && this.b.trigger(() => this.o());
        },
      });
      return n.event;
    }
    get m() {
      if (!this.f) {
        const t = this.j && this.j.args ? this.j.args : [],
          e = Object.create(null);
        (e.env = { ...rs(process.env), VSCODE_PARENT_PID: String(process.pid) }),
          this.j && this.j.env && (e.env = { ...e.env, ...this.j.env }),
          this.j && this.j.freshExecArgv && (e.execArgv = []),
          this.j && typeof this.j.debug == "number" && (e.execArgv = ["--nolazy", "--inspect=" + this.j.debug]),
          this.j && typeof this.j.debugBrk == "number" && (e.execArgv = ["--nolazy", "--inspect-brk=" + this.j.debugBrk]),
          e.execArgv === void 0 && (e.execArgv = process.execArgv.filter((h) => !/^--inspect(-brk)?=/.test(h)).filter((h) => !h.startsWith("--vscode-"))),
          q2(e.env),
          (this.d = j2(this.i, t, e));
        const s = new D(),
          n = T.fromNodeEventEmitter(
            this.d,
            "message",
            (h) => h,
          )((h) => {
            if (F2(h)) {
              _2(h, `IPC Library: ${this.j.serverName}`);
              return;
            }
            s.fire(L.wrap(Buffer.from(h, "base64")));
          }),
          r = this.j.useQueue ? W2(this.d) : this.d,
          o = (h) => this.d && this.d.connected && r.send(h.buffer.toString("base64")),
          a = s.event,
          c = { send: o, onMessage: a };
        this.f = new Zc(c);
        const l = () => this.o();
        process.once("exit", l),
          this.d.on("error", (h) => console.warn('IPC "' + this.j.serverName + '" errored with ' + h)),
          this.d.on("exit", (h, u) => {
            process.removeListener("exit", l),
              n.dispose(),
              this.c.forEach((f) => Xt(f)),
              this.c.clear(),
              h !== 0 && u !== "SIGTERM" && console.warn('IPC "' + this.j.serverName + '" crashed with exit code ' + h + " and signal " + u),
              this.b?.cancel(),
              this.o(),
              this.h.fire({ code: h, signal: u });
          });
      }
      return this.f;
    }
    n(t) {
      let e = this.g.get(t);
      return e || ((e = this.m.getChannel(t)), this.g.set(t, e)), e;
    }
    o() {
      this.f && (this.d && (this.d.kill(), (this.d = null)), (this.f = null), this.g.clear());
    }
    dispose() {
      this.h.dispose(), this.b?.cancel(), (this.b = void 0), this.o(), this.c.clear();
    }
  },
  H2 = class extends R2 {
    constructor(t, e, s) {
      super(t, e, s), this.s();
    }
    r(t) {
      const e = t.add(
        new Jg(Cs.asFileUri("bootstrap-fork").fsPath, {
          serverName: "File Watcher",
          args: ["--type=fileWatcher"],
          env: { VSCODE_ESM_ENTRYPOINT: "vs/platform/files/node/watcher/watcherMain", VSCODE_PIPE_LOGGING: "true", VSCODE_VERBOSE_LOGGING: "true" },
        }),
      );
      return t.add(e.onDidProcessExit(({ code: s, signal: i }) => this.t(`terminated by itself with code ${s}, signal: ${i} (ETERM)`))), It.toService(Ky(e.getChannel("watcher")));
    }
  };
import { watchFile as G2, unwatchFile as J2 } from "fs";
var K2 = class extends O {
  constructor() {
    super(),
      (this.a = this.B(new D())),
      (this.onDidChangeFile = this.a.event),
      (this.b = this.B(new D())),
      (this.onDidLogMessage = this.b.event),
      (this.c = this.B(new D())),
      (this.f = this.c.event),
      (this.g = new Map()),
      (this.h = new Map()),
      (this.j = this.B(new po())),
      (this.m = new Set()),
      (this.n = this.B(new Ri(this.y()))),
      (this.r = 5007),
      (this.s = new Ro()),
      (this.R = !1),
      this.B(this.f((t) => this.z({ id: this.u(t), correlationId: this.t(t) ? t.correlationId : void 0, path: t.path })));
  }
  t(t) {
    return Bg(t);
  }
  u(t) {
    return this.t(t) ? t.correlationId : Sn(t);
  }
  async watch(t) {
    this.s.isSettled || this.s.complete(), (this.s = new Ro());
    try {
      this.g.clear(), this.h.clear();
      for (const e of t) this.t(e) ? this.g.set(e.correlationId, e) : this.h.set(this.u(e), e);
      for (const [e] of this.j) !this.h.has(e) && !this.g.has(e) && (this.j.deleteAndDispose(e), this.m.delete(e));
      return await this.w(!1);
    } finally {
      this.s.complete();
    }
  }
  w(t) {
    const e = [];
    for (const [s, i] of [...this.h, ...this.g]) this.j.has(s) || e.push(i);
    return this.n.trigger(() => this.N(e), t ? this.y() : 0).catch((s) => rt(s));
  }
  y() {
    return 800;
  }
  isSuspended(t) {
    const e = this.u(t);
    return this.m.has(e) ? "polling" : this.j.has(e);
  }
  async z(t) {
    if (this.j.has(t.id)) return;
    const e = new ye();
    this.j.set(t.id, e), await this.s.p, !e.isDisposed && (this.D(t, e), this.w(!0));
  }
  C(t) {
    this.j.deleteAndDispose(t.id), this.m.delete(t.id), this.w(!1);
  }
  D(t, e) {
    this.F(t, e) ? (this.P(`reusing an existing recursive watcher to monitor ${t.path}`), this.m.delete(t.id)) : (this.G(t, e), this.m.add(t.id));
  }
  F(t, e) {
    const s = this.O?.subscribe(t.path, (i, n) => {
      e.isDisposed || (i ? this.D(t, e) : n?.type === 1 && this.H(t));
    });
    return s ? (e.add(s), !0) : !1;
  }
  G(t, e) {
    let s = !1;
    const i = (n, r) => {
      if (e.isDisposed) return;
      const o = this.I(n),
        a = this.I(r),
        c = s;
      (s = o), !o && (a || c) && this.H(t);
    };
    this.P(`starting fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`);
    try {
      G2(t.path, { persistent: !1, interval: this.r }, i);
    } catch (n) {
      this.Q(`fs.watchFile() failed with error ${n} on path ${t.path} (correlationId: ${t.correlationId})`);
    }
    e.add(
      ue(() => {
        this.P(`stopping fs.watchFile() on ${t.path} (correlationId: ${t.correlationId})`);
        try {
          J2(t.path, i);
        } catch (n) {
          this.Q(`fs.unwatchFile() failed with error ${n} on path ${t.path} (correlationId: ${t.correlationId})`);
        }
      }),
    );
  }
  H(t) {
    this.P(`detected ${t.path} exists again, resuming watcher (correlationId: ${t.correlationId})`);
    const e = { resource: C.file(t.path), type: 1, cId: t.correlationId };
    this.a.fire([e]), this.J(e, t), this.C(t);
  }
  I(t) {
    return t.ctimeMs === 0 && t.ino === 0;
  }
  async stop() {
    this.j.clearAndDisposeAll(), this.m.clear();
  }
  J(t, e) {
    if (this.R) {
      const s = ` >> normalized ${t.type === 1 ? "[ADDED]" : t.type === 2 ? "[DELETED]" : "[CHANGED]"} ${t.resource.fsPath}`;
      this.L(s, e);
    }
  }
  L(t, e) {
    this.R && this.P(`${t}${typeof e.correlationId == "number" ? ` <${e.correlationId}> ` : ""}`);
  }
  M(t) {
    return `${t.path} (excludes: ${t.excludes.length > 0 ? t.excludes : "<none>"}, includes: ${t.includes && t.includes.length > 0 ? JSON.stringify(t.includes) : "<all>"}, filter: ${N2(t.filter)}, correlationId: ${typeof t.correlationId == "number" ? t.correlationId : "<none>"})`;
  }
  async setVerboseLogging(t) {
    this.R = t;
  }
};
import { watch as X2, promises as Q2 } from "fs";
import "fs";
async function Lh(t, e) {
  if (ht) return t;
  const s = Yt(t);
  if (t === s) return t;
  const i = (Ot(t) || t).toLowerCase();
  try {
    if (e?.isCancellationRequested) return null;
    const r = (await he.readdir(s)).filter((o) => o.toLowerCase() === i);
    if (r.length === 1) {
      const o = await Lh(s, e);
      if (o) return V(o, r[0]);
    } else if (r.length > 1) {
      const o = r.indexOf(i);
      if (o >= 0) {
        const a = await Lh(s, e);
        if (a) return V(a, r[o]);
      }
    }
  } catch {}
  return null;
}
var Y2 = class pc extends O {
    static {
      this.a = 100;
    }
    static {
      this.b = 75;
    }
    get isReusingRecursiveWatcher() {
      return this.n;
    }
    get failed() {
      return this.r;
    }
    constructor(e, s, i, n, r, o) {
      super(),
        (this.s = e),
        (this.t = s),
        (this.u = i),
        (this.w = n),
        (this.y = r),
        (this.z = o),
        (this.c = this.B(new vy({ maxWorkChunkSize: 100, throttleDelay: 200, maxBufferedWork: 1e4 }, (a) => this.u(a)))),
        (this.f = this.B(new wy((a) => this.M(a), pc.b))),
        (this.g = qg(this.s.path, this.s.excludes)),
        (this.h = this.s.includes ? qg(this.s.path, this.s.includes) : void 0),
        (this.j = Bg(this.s) ? this.s.filter : void 0),
        (this.m = new xs()),
        (this.ready = this.C()),
        (this.n = !1),
        (this.r = !1);
    }
    async C() {
      try {
        const e = await this.F(this.s);
        if (this.m.token.isCancellationRequested) return;
        const s = await Q2.stat(e);
        if (this.m.token.isCancellationRequested) return;
        this.B(await this.G(e, s.isDirectory()));
      } catch (e) {
        e.code !== "ENOENT" ? this.O(e) : this.Q(`ignoring a path for watching who's stat info failed to resolve: ${this.s.path} (error: ${e})`), this.D();
      }
    }
    D() {
      (this.r = !0), this.w?.();
    }
    async F(e) {
      let s = e.path;
      try {
        (s = await he.realpath(e.path)),
          e.path === s && (s = (await Lh(e.path, this.m.token)) ?? e.path),
          e.path !== s && this.Q(`correcting a path to watch that seems to be a symbolic link or wrong casing (original: ${e.path}, real: ${s})`);
      } catch {}
      return s;
    }
    async G(e, s) {
      const i = new ye();
      return this.H(e, s, i) ? (this.Q(`reusing an existing recursive watcher for ${this.s.path}`), (this.n = !0)) : ((this.n = !1), await this.I(e, s, i)), i;
    }
    H(e, s, i) {
      if (s) return !1;
      const n = C.file(this.s.path),
        r = this.t?.subscribe(this.s.path, async (o, a) => {
          if (!i.isDisposed)
            if (o) {
              const c = await this.G(e, s);
              i.isDisposed ? c.dispose() : i.add(c);
            } else a && (typeof a.cId == "number" || typeof this.s.correlationId == "number") && this.L({ resource: n, type: a.type, cId: this.s.correlationId }, !0);
        });
      return r ? (i.add(r), !0) : !1;
    }
    async I(e, s, i) {
      if (Ss && ir(e, "/Volumes/", !0)) {
        this.O(`Refusing to watch ${e} for changes using fs.watch() for possibly being a network share where watching is unreliable and unstable.`);
        return;
      }
      const n = new xs(this.m.token);
      i.add(ue(() => n.dispose(!0)));
      const r = new ye();
      i.add(r);
      try {
        const o = C.file(this.s.path),
          a = Ot(e),
          c = X2(e);
        r.add(
          ue(() => {
            c.removeAllListeners(), c.close();
          }),
        ),
          this.Q(`Started watching: '${e}'`);
        const l = new Set();
        if (s)
          try {
            for (const u of await he.readdir(e)) l.add(u);
          } catch (u) {
            this.O(u);
          }
        if (n.token.isCancellationRequested) return;
        const h = new Map();
        r.add(
          ue(() => {
            for (const [, u] of h) u.dispose();
            h.clear();
          }),
        ),
          c.on("error", (u, f) => {
            n.token.isCancellationRequested || (this.O(`Failed to watch ${e} for changes using fs.watch() (${u}, ${f})`), this.D());
          }),
          c.on("change", (u, f) => {
            if (n.token.isCancellationRequested) return;
            this.z && this.R(`[raw] ["${u}"] ${f}`);
            let d = "";
            if ((f && ((d = f.toString()), Ss && (d = el(d))), !(!d || (u !== "change" && u !== "rename"))))
              if (s)
                if (u === "rename") {
                  h.get(d)?.dispose();
                  const p = setTimeout(async () => {
                    if ((h.delete(d), d === a && !(await he.exists(e)))) {
                      this.J(o);
                      return;
                    }
                    if (n.token.isCancellationRequested) return;
                    const g = await this.N(V(e, d));
                    if (n.token.isCancellationRequested) return;
                    let m;
                    g ? (l.has(d) ? (m = 0) : ((m = 1), l.add(d))) : (l.delete(d), (m = 2)), this.L({ resource: M(o, d), type: m, cId: this.s.correlationId });
                  }, pc.a);
                  h.set(
                    d,
                    ue(() => clearTimeout(p)),
                  );
                } else {
                  let p;
                  l.has(d) ? (p = 0) : ((p = 1), l.add(d)), this.L({ resource: M(o, d), type: p, cId: this.s.correlationId });
                }
              else if (u === "rename" || d !== a) {
                const p = setTimeout(async () => {
                  const g = await he.exists(e);
                  n.token.isCancellationRequested || (g ? (this.L({ resource: o, type: 0, cId: this.s.correlationId }, !0), r.add(await this.G(e, !1))) : this.J(o));
                }, pc.a);
                r.clear(), r.add(ue(() => clearTimeout(p)));
              } else this.L({ resource: o, type: 0, cId: this.s.correlationId }, !0);
          });
      } catch (o) {
        n.token.isCancellationRequested || this.O(`Failed to watch ${e} for changes using fs.watch() (${o.toString()})`), this.D();
      }
    }
    J(e) {
      this.P("Watcher shutdown because watched path got deleted"), this.L({ resource: e, type: 2, cId: this.s.correlationId }, !0), this.f.flush(), this.D();
    }
    L(e, s = !1) {
      this.m.token.isCancellationRequested ||
        (this.z && this.R(`${e.type === 1 ? "[ADDED]" : e.type === 2 ? "[DELETED]" : "[CHANGED]"} ${e.resource.fsPath}`),
        !s && this.g.some((i) => i(e.resource.fsPath))
          ? this.z && this.R(` >> ignored (excluded) ${e.resource.fsPath}`)
          : !s && this.h && this.h.length > 0 && !this.h.some((i) => i(e.resource.fsPath))
            ? this.z && this.R(` >> ignored (not included) ${e.resource.fsPath}`)
            : this.f.work(e));
    }
    M(e) {
      const s = P2(e),
        i = [];
      for (const r of s) {
        if (L2(r, this.j)) {
          this.z && this.R(` >> ignored (filtered) ${r.resource.fsPath}`);
          continue;
        }
        i.push(r);
      }
      if (i.length === 0) return;
      if (this.z) for (const r of i) this.R(` >> normalized ${r.type === 1 ? "[ADDED]" : r.type === 2 ? "[DELETED]" : "[CHANGED]"} ${r.resource.fsPath}`);
      this.c.work(i)
        ? this.c.pending > 0 &&
          this.Q(
            `started throttling events due to large amount of file change events at once (pending: ${this.c.pending}, most recent change: ${i[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
          )
        : this.P(
            `started ignoring events due to too many file change events at once (incoming: ${i.length}, most recent change: ${i[0].resource.fsPath}). Use 'files.watcherExclude' setting to exclude folders with lots of changing files (e.g. compilation output).`,
          );
    }
    async N(e) {
      if (ht) return he.exists(e);
      try {
        const s = Ot(e);
        return (await he.readdir(Yt(e))).some((n) => n === s);
      } catch (s) {
        return this.Q(s), !1;
      }
    }
    setVerboseLogging(e) {
      this.z = e;
    }
    O(e) {
      this.m.token.isCancellationRequested || this.y?.({ type: "error", message: `[File Watcher (node.js)] ${e}` });
    }
    P(e) {
      this.m.token.isCancellationRequested || this.y?.({ type: "warn", message: `[File Watcher (node.js)] ${e}` });
    }
    Q(e) {
      !this.m.token.isCancellationRequested && this.z && this.y?.({ type: "trace", message: `[File Watcher (node.js)] ${e}` });
    }
    R(e) {
      !this.m.token.isCancellationRequested && this.z && this.Q(`${e}${typeof this.s.correlationId == "number" ? ` <${this.s.correlationId}> ` : ""}`);
    }
    dispose() {
      this.m.dispose(!0), super.dispose();
    }
  },
  Z2 = class extends K2 {
    constructor(t) {
      super(), (this.O = t), (this.onDidError = T.None), (this.watchers = new Set());
    }
    async N(t) {
      t = this.Z(t);
      const e = [],
        s = new Set(Array.from(this.watchers));
      for (const i of t) {
        const n = this.W(i);
        n && _g(n.request.excludes, i.excludes) && _g(n.request.includes, i.includes) ? s.delete(n) : e.push(i);
      }
      e.length && this.P(`Request to start watching: ${e.map((i) => this.M(i)).join(",")}`),
        s.size &&
          this.P(
            `Request to stop watching: ${Array.from(s)
              .map((i) => this.M(i.request))
              .join(",")}`,
          );
      for (const i of s) this.Y(i);
      for (const i of e) this.X(i);
    }
    W(t) {
      for (const e of this.watchers)
        if (typeof t.correlationId == "number" || typeof e.request.correlationId == "number") {
          if (e.request.correlationId === t.correlationId) return e;
        } else if (Vc(e.request.path, t.path, !ht)) return e;
    }
    X(t) {
      const e = new Y2(
          t,
          this.O,
          (i) => this.a.fire(i),
          () => this.c.fire(t),
          (i) => this.b.fire(i),
          this.R,
        ),
        s = { request: t, instance: e };
      this.watchers.add(s);
    }
    async stop() {
      await super.stop();
      for (const t of this.watchers) this.Y(t);
    }
    Y(t) {
      this.P("stopping file watcher", t), this.watchers.delete(t), t.instance.dispose();
    }
    Z(t) {
      const e = new Map();
      for (const s of t) {
        const i = ht ? s.path : s.path.toLowerCase();
        let n = e.get(s.correlationId);
        n || ((n = new Map()), e.set(s.correlationId, n)), n.has(i) && this.P(`ignoring a request for watching who's path is already watched: ${this.M(s)}`), n.set(i, s);
      }
      return Array.from(e.values())
        .map((s) => Array.from(s.values()))
        .flat();
    }
    async setVerboseLogging(t) {
      super.setVerboseLogging(t);
      for (const e of this.watchers) e.instance.setVerboseLogging(t);
    }
    P(t, e) {
      this.R && this.b.fire({ type: "trace", message: this.bb(t, e) });
    }
    Q(t) {
      this.b.fire({ type: "warn", message: this.bb(t) });
    }
    bb(t, e) {
      return e ? `[File Watcher (node.js)] ${t} (${this.M(e.request)})` : `[File Watcher (node.js)] ${t}`;
    }
  },
  e7 = class extends I2 {
    constructor(t, e, s) {
      super(t, e, s), this.s();
    }
    r(t) {
      return t.add(new Z2(void 0));
    }
  },
  t7 = class so extends T2 {
    static {
      this.M = !1;
    }
    constructor(e, s) {
      super(e, s), (this.onDidChangeCapabilities = T.None), (this.Q = new kt((i) => Wc.getComparisonKey(i))), (this.Y = new Map()), (this.Z = new Map()), (this.$ = new Map());
    }
    get capabilities() {
      return this.N || ((this.N = 253982), ht && (this.N |= 1024)), this.N;
    }
    async stat(e) {
      try {
        const { stat: s, symbolicLink: i } = await Wt.stat(this.J(e));
        return { type: this.P(s, i), ctime: s.birthtime.getTime(), mtime: s.mtime.getTime(), size: s.size, permissions: s.mode & 128 ? void 0 : kn.Locked };
      } catch (s) {
        throw this.ib(s);
      }
    }
    async O(e) {
      try {
        return await this.stat(e);
      } catch {
        return;
      }
    }
    async readdir(e) {
      try {
        const s = await he.readdir(this.J(e), { withFileTypes: !0 }),
          i = [];
        return (
          await Promise.all(
            s.map(async (n) => {
              try {
                let r;
                n.isSymbolicLink() ? (r = (await this.stat(M(e, n.name))).type) : (r = this.P(n)), i.push([n.name, r]);
              } catch (r) {
                this.a.trace(r);
              }
            }),
          ),
          i
        );
      } catch (s) {
        throw this.ib(s);
      }
    }
    P(e, s) {
      let i;
      return s?.dangling ? (i = Gt.Unknown) : e.isFile() ? (i = Gt.File) : e.isDirectory() ? (i = Gt.Directory) : (i = Gt.Unknown), s && (i |= Gt.SymbolicLink), i;
    }
    async R(e) {
      const s = this.J(e);
      this.S(`[Disk FileSystemProvider]: createResourceLock() - request to acquire resource lock (${s})`);
      let i;
      for (; (i = this.Q.get(e)); ) this.S(`[Disk FileSystemProvider]: createResourceLock() - waiting for resource lock to be released (${s})`), await i.wait();
      const n = new Jc();
      return (
        this.Q.set(e, n),
        this.S(`[Disk FileSystemProvider]: createResourceLock() - new resource lock created (${s})`),
        ue(() => {
          this.S(`[Disk FileSystemProvider]: createResourceLock() - resource lock dispose() (${s})`),
            this.Q.get(e) === n && (this.S(`[Disk FileSystemProvider]: createResourceLock() - resource lock removed from resource-lock map (${s})`), this.Q.delete(e)),
            this.S(`[Disk FileSystemProvider]: createResourceLock() - resource lock barrier open() (${s})`),
            n.open();
        })
      );
    }
    async readFile(e, s) {
      let i;
      try {
        s?.atomic && (this.S(`[Disk FileSystemProvider]: atomic read operation started (${this.J(e)})`), (i = await this.R(e)));
        const n = this.J(e);
        return await li.readFile(n);
      } catch (n) {
        throw this.ib(n);
      } finally {
        i?.dispose();
      }
    }
    S(e) {
      so.M && this.a.trace(e);
    }
    readFileStream(e, s, i) {
      const n = or((r) => L.concat(r.map((o) => L.wrap(o))).buffer);
      return Pg(this, e, n, (r) => r.buffer, { ...s, bufferSize: 256 * 1024 }, i), n;
    }
    async writeFile(e, s, i) {
      return i?.atomic !== !1 && i?.atomic?.postfix && (await this.U(e)) ? this.W(e, M(Wd(e), `${nr(e)}${i.atomic.postfix}`), s, i) : this.X(e, s, i);
    }
    async U(e) {
      try {
        const s = this.J(e),
          { symbolicLink: i } = await Wt.stat(s);
        if (i) return !1;
      } catch {}
      return !0;
    }
    async W(e, s, i, n) {
      const r = new ye();
      try {
        r.add(await this.R(e)), r.add(await this.R(s)), await this.X(s, i, n, !0);
        try {
          await this.rename(s, e, { overwrite: !0 });
        } catch (o) {
          try {
            await this.delete(s, { recursive: !1, useTrash: !1, atomic: !1 });
          } catch {}
          throw o;
        }
      } finally {
        r.dispose();
      }
    }
    async X(e, s, i, n) {
      let r;
      try {
        const o = this.J(e);
        if (!i.create || !i.overwrite) {
          if (await he.exists(o)) {
            if (!i.overwrite) throw Ds(w(1943, null), X.FileExists);
          } else if (!i.create) throw Ds(w(1944, null), X.FileNotFound);
        }
        (r = await this.open(e, { create: !0, unlock: i.unlock }, n)), await this.write(r, 0, s, 0, s.byteLength);
      } catch (o) {
        throw await this.jb(e, o);
      } finally {
        typeof r == "number" && (await this.close(r));
      }
    }
    static {
      this.ab = !0;
    }
    static configureFlushOnWrite(e) {
      so.ab = e;
    }
    async open(e, s, i) {
      const n = this.J(e);
      let r;
      mr(s) && !i && (r = await this.R(e));
      let o;
      try {
        if (mr(s) && s.unlock)
          try {
            const { stat: c } = await Wt.stat(n);
            c.mode & 128 || (await li.chmod(n, c.mode | 128));
          } catch (c) {
            c.code !== "ENOENT" && this.a.trace(c);
          }
        let a;
        if (mr(s)) {
          if (Be)
            try {
              await li.truncate(n, 0), (a = "r+");
            } catch (c) {
              c.code !== "ENOENT" && this.a.trace(c);
            }
          a || (a = "w");
        } else a = "r";
        o = await he.open(n, a);
      } catch (a) {
        throw (r?.dispose(), mr(s) ? await this.jb(e, a) : this.ib(a));
      }
      if ((this.Y.set(o, 0), mr(s) && this.$.set(o, e), r)) {
        const a = this.Z.get(o);
        this.S(`[Disk FileSystemProvider]: open() - storing lock for handle ${o} (${n})`),
          this.Z.set(o, r),
          a && (this.S(`[Disk FileSystemProvider]: open() - disposing a previous lock that was still stored on same handle ${o} (${n})`), a.dispose());
      }
      return o;
    }
    async close(e) {
      const s = this.Z.get(e);
      try {
        if ((this.Y.delete(e), this.$.delete(e) && so.ab))
          try {
            await he.fdatasync(e);
          } catch (i) {
            so.configureFlushOnWrite(!1), this.a.error(i);
          }
        return await he.close(e);
      } catch (i) {
        throw this.ib(i);
      } finally {
        s &&
          (this.Z.get(e) === s && (this.S(`[Disk FileSystemProvider]: close() - resource lock removed from handle-lock map ${e}`), this.Z.delete(e)),
          this.S(`[Disk FileSystemProvider]: close() - disposing lock for handle ${e}`),
          s.dispose());
      }
    }
    async read(e, s, i, n, r) {
      const o = this.bb(e, s);
      let a = null;
      try {
        a = (await he.read(e, i, n, r, o)).bytesRead;
      } catch (c) {
        throw this.ib(c);
      } finally {
        this.cb(e, o, a);
      }
      return a;
    }
    bb(e, s) {
      return s === this.Y.get(e) ? null : s;
    }
    cb(e, s, i) {
      const n = this.Y.get(e);
      typeof n == "number" && (typeof s == "number" || (typeof i == "number" ? this.Y.set(e, n + i) : this.Y.delete(e)));
    }
    async write(e, s, i, n, r) {
      return Ey(() => this.db(e, s, i, n, r), 100, 3);
    }
    async db(e, s, i, n, r) {
      const o = this.bb(e, s);
      let a = null;
      try {
        a = (await he.write(e, i, n, r, o)).bytesWritten;
      } catch (c) {
        throw await this.jb(this.$.get(e), c);
      } finally {
        this.cb(e, o, a);
      }
      return a;
    }
    async mkdir(e) {
      try {
        await li.mkdir(this.J(e));
      } catch (s) {
        throw this.ib(s);
      }
    }
    async delete(e, s) {
      try {
        const i = this.J(e);
        if (s.recursive) {
          let n;
          s?.atomic !== !1 && s.atomic.postfix && (n = V(Yt(i), `${Ot(i)}${s.atomic.postfix}`)), await he.rm(i, En.MOVE, n);
        } else
          try {
            await li.unlink(i);
          } catch (n) {
            if (n.code === "EPERM" || n.code === "EISDIR") {
              let r = !1;
              try {
                const { stat: o, symbolicLink: a } = await Wt.stat(i);
                r = o.isDirectory() && !a;
              } catch {}
              if (r) await li.rmdir(i);
              else throw n;
            } else throw n;
          }
      } catch (i) {
        throw this.ib(i);
      }
    }
    async rename(e, s, i) {
      const n = this.J(e),
        r = this.J(s);
      if (n !== r)
        try {
          await this.eb(e, s, "move", i.overwrite), await he.rename(n, r);
        } catch (o) {
          throw ((o.code === "EINVAL" || o.code === "EBUSY" || o.code === "ENAMETOOLONG") && (o = new Error(w(1945, null, Ot(n), Ot(Yt(r)), o.toString()))), this.ib(o));
        }
    }
    async copy(e, s, i) {
      const n = this.J(e),
        r = this.J(s);
      if (n !== r)
        try {
          await this.eb(e, s, "copy", i.overwrite), await he.copy(n, r, { preserveSymlinks: !0 });
        } catch (o) {
          throw ((o.code === "EINVAL" || o.code === "EBUSY" || o.code === "ENAMETOOLONG") && (o = new Error(w(1946, null, Ot(n), Ot(Yt(r)), o.toString()))), this.ib(o));
        }
    }
    async eb(e, s, i, n) {
      const r = this.J(e),
        o = this.J(s);
      let a = !1;
      if ((!!(this.capabilities & 1024) || (a = Vc(r, o, !0)), a)) {
        if (i === "copy") throw Ds(w(1947, null), X.FileExists);
        if (i === "move") return;
      }
      const l = await this.O(e);
      if (!l) throw Ds(w(1948, null), X.FileNotFound);
      const h = await this.O(s);
      if (h) {
        if (!n) throw Ds(w(1949, null), X.FileExists);
        (l.type & Gt.File && h.type & Gt.File) || (await this.delete(s, { recursive: !0, useTrash: !1, atomic: !1 }));
      }
    }
    async cloneFile(e, s) {
      return this.fb(e, s, !1);
    }
    async fb(e, s, i) {
      const n = this.J(e),
        r = this.J(s),
        o = !!(this.capabilities & 1024);
      if (Vc(n, r, !o)) return;
      const a = new ye();
      try {
        a.add(await this.R(e)), a.add(await this.R(s)), i && (await li.mkdir(Yt(r), { recursive: !0 })), await li.copyFile(n, r);
      } catch (c) {
        if (c.code === "ENOENT" && !i) return this.fb(e, s, !0);
        throw this.ib(c);
      } finally {
        a.dispose();
      }
    }
    u(e, s, i) {
      return new H2(
        (n) => e(n),
        (n) => s(n),
        i,
      );
    }
    G(e, s, i) {
      return new e7(
        (n) => e(n),
        (n) => s(n),
        i,
      );
    }
    ib(e) {
      if (e instanceof Dl) return e;
      let s = e,
        i;
      switch (e.code) {
        case "ENOENT":
          i = X.FileNotFound;
          break;
        case "EISDIR":
          i = X.FileIsADirectory;
          break;
        case "ENOTDIR":
          i = X.FileNotADirectory;
          break;
        case "EEXIST":
          i = X.FileExists;
          break;
        case "EPERM":
        case "EACCES":
          i = X.NoPermissions;
          break;
        case "ERR_UNC_HOST_NOT_ALLOWED":
          (s = `${e.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`), (i = X.Unknown);
          break;
        default:
          i = X.Unknown;
      }
      return Ds(s, i);
    }
    async jb(e, s) {
      let i = this.ib(s);
      if (e && i.code === X.NoPermissions)
        try {
          const { stat: n } = await Wt.stat(this.J(e));
          n.mode & 128 || (i = Ds(s, X.FileWriteLocked));
        } catch (n) {
          this.a.trace(n);
        }
      return i;
    }
  },
  de = class {
    constructor(t, e = [], s = !1) {
      (this.ctor = t), (this.staticArguments = e), (this.supportsDelayedInstantiation = s);
    }
  },
  s7 = class {
    constructor(t, e) {
      (this.key = t), (this.data = e), (this.incoming = new Map()), (this.outgoing = new Map());
    }
  },
  Kg = class {
    constructor(t) {
      (this.b = t), (this.a = new Map());
    }
    roots() {
      const t = [];
      for (const e of this.a.values()) e.outgoing.size === 0 && t.push(e);
      return t;
    }
    insertEdge(t, e) {
      const s = this.lookupOrInsertNode(t),
        i = this.lookupOrInsertNode(e);
      s.outgoing.set(i.key, i), i.incoming.set(s.key, s);
    }
    removeNode(t) {
      const e = this.b(t);
      this.a.delete(e);
      for (const s of this.a.values()) s.outgoing.delete(e), s.incoming.delete(e);
    }
    lookupOrInsertNode(t) {
      const e = this.b(t);
      let s = this.a.get(e);
      return s || ((s = new s7(e, t)), this.a.set(e, s)), s;
    }
    lookup(t) {
      return this.a.get(this.b(t));
    }
    isEmpty() {
      return this.a.size === 0;
    }
    toString() {
      const t = [];
      for (const [e, s] of this.a)
        t.push(`${e}
	(-> incoming)[${[...s.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...s.outgoing.keys()].join(",")}]
`);
      return t.join(`
`);
    }
    findCycleSlow() {
      for (const [t, e] of this.a) {
        const s = new Set([t]),
          i = this.c(e, s);
        if (i) return i;
      }
    }
    c(t, e) {
      for (const [s, i] of t.outgoing) {
        if (e.has(s)) return [...e, s].join(" -> ");
        e.add(s);
        const n = this.c(i, e);
        if (n) return n;
        e.delete(s);
      }
    }
  },
  Nh = class {
    constructor(...t) {
      this.a = new Map();
      for (const [e, s] of t) this.set(e, s);
    }
    set(t, e) {
      const s = this.a.get(t);
      return this.a.set(t, e), s;
    }
    has(t) {
      return this.a.has(t);
    }
    get(t) {
      return this.a.get(t);
    }
  },
  i7 = !1,
  Xg = class extends Error {
    constructor(t) {
      super("cyclic dependency between services"),
        (this.message =
          t.findCycleSlow() ??
          `UNABLE to detect cycle, dumping graph: 
${t.toString()}`);
    }
  },
  n7 = class Of {
    constructor(e = new Nh(), s = !1, i, n = i7) {
      (this.i = e), (this.j = s), (this.k = i), (this.l = n), (this.f = !1), (this.g = new Set()), (this.h = new Set()), (this.t = new Set()), this.i.set(ds, this), (this._globalGraph = n ? (i?._globalGraph ?? new Kg((r) => r)) : void 0);
    }
    dispose() {
      if (!this.f) {
        (this.f = !0), Xt(this.h), this.h.clear();
        for (const e of this.g) td(e) && e.dispose();
        this.g.clear();
      }
    }
    m() {
      if (this.f) throw new Error("InstantiationService has been disposed");
    }
    createChild(e, s) {
      this.m();
      const i = this,
        n = new (class extends Of {
          dispose() {
            i.h.delete(n), super.dispose();
          }
        })(e, this.j, this, this.l);
      return this.h.add(n), s?.add(n), n;
    }
    invokeFunction(e, ...s) {
      this.m();
      const i = Th.traceInvocation(this.l, e);
      let n = !1;
      try {
        return e(
          {
            get: (o) => {
              if (n) throw zf("service accessor is only valid during the invocation of its target method");
              const a = this.s(o, i);
              if (!a) throw new Error(`[invokeFunction] unknown service '${o}'`);
              return a;
            },
          },
          ...s,
        );
      } finally {
        (n = !0), i.stop();
      }
    }
    createInstance(e, ...s) {
      this.m();
      let i, n;
      return e instanceof de ? ((i = Th.traceCreation(this.l, e.ctor)), (n = this.o(e.ctor, e.staticArguments.concat(s), i))) : ((i = Th.traceCreation(this.l, e)), (n = this.o(e, s, i))), i.stop(), n;
    }
    o(e, s = [], i) {
      const n = fs.getServiceDependencies(e).sort((a, c) => a.index - c.index),
        r = [];
      for (const a of n) {
        const c = this.s(a.id, i);
        c || this.y(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), r.push(c);
      }
      const o = n.length > 0 ? n[0].index : s.length;
      if (s.length !== o) {
        console.trace(`[createInstance] First service dependency of ${e.name} at position ${o + 1} conflicts with ${s.length} static arguments`);
        const a = o - s.length;
        a > 0 ? (s = s.concat(new Array(a))) : (s = s.slice(0, o));
      }
      return Reflect.construct(e, s.concat(r));
    }
    q(e, s) {
      if (this.i.get(e) instanceof de) this.i.set(e, s);
      else if (this.k) this.k.q(e, s);
      else throw new Error("illegalState - setting UNKNOWN service instance");
    }
    r(e) {
      const s = this.i.get(e);
      return !s && this.k ? this.k.r(e) : s;
    }
    s(e, s) {
      this._globalGraph && this.c && this._globalGraph.insertEdge(this.c, String(e));
      const i = this.r(e);
      return i instanceof de ? this.u(e, i, s.branch(e, !0)) : (s.branch(e, !1), i);
    }
    u(e, s, i) {
      if (this.t.has(e)) throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
      this.t.add(e);
      try {
        return this.v(e, s, i);
      } finally {
        this.t.delete(e);
      }
    }
    v(e, s, i) {
      const n = new Kg((c) => c.id.toString());
      let r = 0;
      const o = [{ id: e, desc: s, _trace: i }],
        a = new Set();
      for (; o.length; ) {
        const c = o.pop();
        if (!a.has(String(c.id))) {
          if ((a.add(String(c.id)), n.lookupOrInsertNode(c), r++ > 1e3)) throw new Xg(n);
          for (const l of fs.getServiceDependencies(c.desc.ctor)) {
            const h = this.r(l.id);
            if ((h || this.y(`[createInstance] ${e} depends on ${l.id} which is NOT registered.`, !0), this._globalGraph?.insertEdge(String(c.id), String(l.id)), h instanceof de)) {
              const u = { id: l.id, desc: h, _trace: c._trace.branch(l.id, !0) };
              n.insertEdge(c, u), o.push(u);
            }
          }
        }
      }
      for (;;) {
        const c = n.roots();
        if (c.length === 0) {
          if (!n.isEmpty()) throw new Xg(n);
          break;
        }
        for (const { data: l } of c) {
          if (this.r(l.id) instanceof de) {
            const u = this.w(l.id, l.desc.ctor, l.desc.staticArguments, l.desc.supportsDelayedInstantiation, l._trace);
            this.q(l.id, u);
          }
          n.removeNode(l);
        }
      }
      return this.r(e);
    }
    w(e, s, i = [], n, r) {
      if (this.i.get(e) instanceof de) return this.x(e, s, i, n, r, this.g);
      if (this.k) return this.k.w(e, s, i, n, r);
      throw new Error(`illegalState - creating UNKNOWN service instance ${s.name}`);
    }
    x(e, s, i = [], n, r, o) {
      if (n) {
        const a = new Of(void 0, this.j, this, this.l);
        a.c = String(e);
        const c = new Map(),
          l = new by(() => {
            const h = a.o(s, i, r);
            for (const [u, f] of c) {
              const d = h[u];
              if (typeof d == "function") for (const p of f) p.disposable = d.apply(h, p.listener);
            }
            return c.clear(), o.add(h), h;
          });
        return new Proxy(Object.create(null), {
          get(h, u) {
            if (!l.isInitialized && typeof u == "string" && (u.startsWith("onDid") || u.startsWith("onWill"))) {
              let p = c.get(u);
              return (
                p || ((p = new Nc()), c.set(u, p)),
                (m, v, b) => {
                  if (l.isInitialized) return l.value[u](m, v, b);
                  {
                    const E = { listener: [m, v, b], disposable: void 0 },
                      $ = p.push(E);
                    return ue(() => {
                      $(), E.disposable?.dispose();
                    });
                  }
                }
              );
            }
            if (u in h) return h[u];
            const f = l.value;
            let d = f[u];
            return typeof d != "function" || ((d = d.bind(f)), (h[u] = d)), d;
          },
          set(h, u, f) {
            return (l.value[u] = f), !0;
          },
          getPrototypeOf(h) {
            return s.prototype;
          },
        });
      } else {
        const a = this.o(s, i, r);
        return o.add(a), a;
      }
    }
    y(e, s) {
      if ((s && console.warn(e), this.j)) throw new Error(e);
    }
  },
  Qg;
(function (t) {
  (t[(t.None = 0)] = "None"), (t[(t.Creation = 1)] = "Creation"), (t[(t.Invocation = 2)] = "Invocation"), (t[(t.Branch = 3)] = "Branch");
})(Qg || (Qg = {}));
var Th = class Os {
  static {
    this.all = new Set();
  }
  static {
    this.c = new (class extends Os {
      constructor() {
        super(0, null);
      }
      stop() {}
      branch() {
        return this;
      }
    })();
  }
  static traceInvocation(e, s) {
    return e
      ? new Os(
          2,
          s.name ||
            new Error().stack
              .split(
                `
`,
              )
              .slice(3, 4).join(`
`),
        )
      : Os.c;
  }
  static traceCreation(e, s) {
    return e ? new Os(1, s.name) : Os.c;
  }
  static {
    this.f = 0;
  }
  constructor(e, s) {
    (this.type = e), (this.name = s), (this.g = Date.now()), (this.h = []);
  }
  branch(e, s) {
    const i = new Os(3, e.toString());
    return this.h.push([e, s, i]), i;
  }
  stop() {
    const e = Date.now() - this.g;
    Os.f += e;
    let s = !1;
    function i(r, o) {
      const a = [],
        c = new Array(r + 1).join("	");
      for (const [l, h, u] of o.h)
        if (h && u) {
          (s = !0), a.push(`${c}CREATES -> ${l}`);
          const f = i(r + 1, u);
          f && a.push(f);
        } else a.push(`${c}uses -> ${l}`);
      return a.join(`
`);
    }
    const n = [`${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`, `${i(1, this)}`, `DONE, took ${e.toFixed(2)}ms (grand total ${Os.f.toFixed(2)}ms)`];
    (e > 2 || s) &&
      Os.all.add(
        n.join(`
`),
      );
  }
};
import * as r7 from "fs";
import { createHash as o7 } from "crypto";
var jh = class extends bl {
  constructor(e, s, i, n) {
    super(i), (this.h = e), (this.j = n), (this.g = this.B(new Fh(s, n))), this.h.registerParticipant({ postInstall: async (r) => this.m(r), postUninstall: async (r) => this.n(r) });
  }
  async getBuiltInExtensionTranslationsUri(e, s) {
    const n = (await this.g.getLanguagePacks())[s];
    if (!n) {
      this.j.warn(`No language pack found for ${s}`);
      return;
    }
    const r = n.translations[e];
    return r ? C.file(r) : void 0;
  }
  async getInstalledLanguages() {
    const e = await this.g.getLanguagePacks(),
      s = Object.keys(e).map((i) => {
        const n = e[i];
        return { ...this.f(i, n.label), extensionId: n.extensions[0].extensionIdentifier.id };
      });
    return s.push(this.f("en", "English")), s.sort((i, n) => i.label.localeCompare(n.label)), s;
  }
  async m(e) {
    e && e.manifest && e.manifest.contributes && e.manifest.contributes.localizations && e.manifest.contributes.localizations.length && (this.j.info("Adding language packs from the extension", e.identifier.id), await this.update());
  }
  async n(e) {
    const s = await this.g.getLanguagePacks();
    Object.keys(s).some((i) => s[i] && s[i].extensions.some((n) => G(n.extensionIdentifier, e.identifier))) && (this.j.info("Removing language packs from the extension", e.identifier.id), await this.update());
  }
  async update() {
    const [e, s] = await Promise.all([this.g.getLanguagePacks(), this.h.getInstalled()]),
      i = await this.g.update(s);
    return !_t(Object.keys(e), Object.keys(i));
  }
};
jh = __decorate([__param(0, Vs), __param(1, Zt), __param(2, ps), __param(3, ne)], jh);
var Fh = class extends O {
  constructor(e, s) {
    super(), (this.j = s), (this.c = {}), (this.f = V(e.userDataPath, "languagepacks.json")), (this.g = new rr());
  }
  getLanguagePacks() {
    return this.g.size || !this.h ? this.s().then(() => this.c) : Promise.resolve(this.c);
  }
  update(e) {
    return this.s((s) => {
      Object.keys(s).forEach((i) => delete s[i]), this.m(s, ...e);
    }).then(() => this.c);
  }
  m(e, ...s) {
    for (const i of s) i && i.manifest && i.manifest.contributes && i.manifest.contributes.localizations && i.manifest.contributes.localizations.length && this.n(e, i);
    Object.keys(e).forEach((i) => this.r(e[i]));
  }
  n(e, s) {
    const i = s.identifier,
      n = s.manifest.contributes && s.manifest.contributes.localizations ? s.manifest.contributes.localizations : [];
    for (const r of n)
      if (s.location.scheme === oe.file && a7(r)) {
        let o = e[r.languageId];
        o || ((o = { hash: "", extensions: [], translations: {}, label: r.localizedLanguageName ?? r.languageName }), (e[r.languageId] = o));
        const a = o.extensions.filter((c) => G(c.extensionIdentifier, i))[0];
        a ? (a.version = s.manifest.version) : o.extensions.push({ extensionIdentifier: i, version: s.manifest.version });
        for (const c of r.translations) o.translations[c.id] = V(s.location.fsPath, c.path);
      }
  }
  r(e) {
    if (e) {
      const s = o7("md5");
      for (const i of e.extensions) s.update(i.extensionIdentifier.uuid || i.extensionIdentifier.id).update(i.version);
      e.hash = s.digest("hex");
    }
  }
  s(e = () => null) {
    return this.g.queue(() => {
      let s = null;
      return r7.promises
        .readFile(this.f, "utf8")
        .then(void 0, (i) => (i.code === "ENOENT" ? Promise.resolve("{}") : Promise.reject(i)))
        .then((i) => {
          try {
            return JSON.parse(i);
          } catch {
            return {};
          }
        })
        .then((i) => ((s = e(i)), i))
        .then((i) => {
          for (const r of Object.keys(i)) i[r] || delete i[r];
          (this.c = i), (this.h = !0);
          const n = JSON.stringify(this.c);
          return this.j.debug("Writing language packs", n), he.writeFile(this.f, n);
        })
        .then(
          () => s,
          (i) => this.j.error(i),
        );
    });
  }
};
Fh = __decorate([__param(0, Zt), __param(1, ne)], Fh);
function a7(t) {
  if (typeof t.languageId != "string" || !Array.isArray(t.translations) || t.translations.length === 0) return !1;
  for (const e of t.translations) if (typeof e.id != "string" || typeof e.path != "string") return !1;
  return !((t.languageName && typeof t.languageName != "string") || (t.localizedLanguageName && typeof t.localizedLanguageName != "string"));
}
var c7 = class extends B4 {
    constructor(t, e, s, i, n) {
      super(e, s, i),
        (this.r = t),
        (this.t = n),
        this.B(
          n.listen(
            "onDidChangeLogLevel",
            t,
          )((r) => {
            j4(r) ? super.setLogLevel(r) : super.setLogLevel(C.revive(r[0]), r[1]);
          }),
        ),
        this.B(n.listen("onDidChangeVisibility", t)(([r, o]) => super.setVisibility(C.revive(r), o))),
        this.B(
          n.listen(
            "onDidChangeLoggers",
            t,
          )(({ added: r, removed: o }) => {
            for (const a of r) super.registerLogger({ ...a, resource: C.revive(a.resource) });
            for (const a of o) super.deregisterLogger(a.resource);
          }),
        );
    }
    createConsoleMainLogger() {
      return new U4({
        log: (t, e) => {
          this.t.call("consoleLog", [t, e]);
        },
      });
    }
    registerLogger(t) {
      super.registerLogger(t), this.t.call("registerLogger", [t, this.r]);
    }
    deregisterLogger(t) {
      super.deregisterLogger(t), this.t.call("deregisterLogger", [t, this.r]);
    }
    setLogLevel(t, e) {
      super.setLogLevel(t, e), this.t.call("setLogLevel", [t, e]);
    }
    setVisibility(t, e) {
      super.setVisibility(t, e), this.t.call("setVisibility", [this.n(t), e]);
    }
    s(t, e, s) {
      return new l7(this.t, t, e, s, this.r);
    }
    static setLogLevel(t, e, s) {
      return t.call("setLogLevel", [e, s]);
    }
  },
  l7 = class extends F4 {
    constructor(t, e, s, i, n) {
      super(i?.logLevel === "always"),
        (this.r = t),
        (this.s = e),
        (this.m = !1),
        (this.n = []),
        this.setLevel(s),
        this.r.call("createLogger", [e, i, n]).then(() => {
          this.u(this.n), (this.m = !0);
        });
    }
    g(t, e) {
      const s = [[t, e]];
      this.m ? this.u(s) : this.n.push(...s);
    }
    u(t) {
      this.r.call("log", [this.s, t]);
    }
  },
  st,
  Mh = globalThis.vscode;
if (typeof Mh < "u" && typeof Mh.context < "u") {
  const t = Mh.context.configuration();
  if (t) st = t.product;
  else throw new Error("Sandbox: unable to resolve product configuration from preload script.");
} else if (globalThis._VSCODE_PRODUCT_JSON && globalThis._VSCODE_PACKAGE_JSON) {
  if (
    ((st = globalThis._VSCODE_PRODUCT_JSON),
    Y.VSCODE_DEV &&
      Object.assign(st, {
        nameShort: `${st.nameShort} - Local`,
        nameLong: `${st.nameLong} - Local`,
        dataFolderName: `${st.dataFolderName}-local`,
        serverDataFolderName: st.serverDataFolderName ? `${st.serverDataFolderName}-local` : void 0,
      }),
    !st.version)
  ) {
    const t = globalThis._VSCODE_PACKAGE_JSON;
    Object.assign(st, { version: t.version });
  }
  Y.ICUBE_EXTENSIONS_GALLERY && Object.assign(st, { extensionsGallery: JSON.parse(Y.ICUBE_EXTENSIONS_GALLERY) });
} else
  (st = {}),
    Object.keys(st).length === 0 &&
      Object.assign(st, {
        version: "1.95.0-dev",
        nameShort: "Code - OSS Dev",
        nameLong: "Code - OSS Dev",
        applicationName: "code-oss",
        dataFolderName: ".vscode-oss",
        urlProtocol: "code-oss",
        reportIssueUrl: "https://github.com/microsoft/vscode/issues/new",
        licenseName: "MIT",
        licenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
        serverLicenseUrl: "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
      });
if (Y.IDE_ENVIRONMENT_ID) {
  const e = {
    id: Y.IDE_ENVIRONMENT_ID || "",
    owner: Y.IDE_OWNER || "",
    ideLang: Y.IDE_LANG || "",
    ideTemplate: Y.IDE_TEMPLATE || "",
    isBOE: (Y.CLOUDIDE_APISERVER_BASE_URL || "").includes("-boe."),
    apiServerBaseUrl: Y.IDE_APISERVER_BASE_URL || "",
    isBuilt: !Y.VSCODE_DEV,
    workspacePath: Y.CLOUDIDE_WORKSPACEPATH || "",
  };
  Object.assign(st, { devSpaceInfo: e });
}
st.iCubeApp || Object.assign(st, { iCubeApp: {} }), Object.assign(st.iCubeApp, { envInfo: { ...st.iCubeApp?.envInfo, sessionID: Me() } }), Object.assign(st, { _onDidChangeConfig: new D() });
var Js = st,
  h7 = class {
    constructor(t) {
      this.b = t;
    }
    listen(t, e) {
      throw new Error(`Event not found: ${e}`);
    }
    call(t, e, { eventName: s, data: i }) {
      return this.b.forEach((n) => n.log(s, i)), Promise.resolve(null);
    }
  },
  u7 = class {
    constructor(t) {
      this.b = t;
    }
    log(t, e) {
      return this.b.call("log", { eventName: t, data: e }).then(void 0, (s) => `Failed to log telemetry: ${console.warn(s)}`), Promise.resolve(null);
    }
    flush() {
      return Promise.resolve();
    }
  },
  ya = class extends O {
    constructor(e, s, i, n, r = "") {
      super(), (this.b = r);
      const o = s.getLogger(Zl);
      if (o) this.a = this.B(o);
      else {
        const c = zp(n, i) ? " (Not Sent)" : "",
          l = () => eh(n, i) && e.getLevel() === te.Trace;
        (this.a = this.B(s.createLogger(Zl, { name: w(2158, null, c), hidden: !l() }))),
          this.B(e.onDidChangeLogLevel(() => s.setVisibility(Zl, l()))),
          this.a.info("Below are logs for every telemetry event sent from VS Code once the log level is set to trace."),
          this.a.info("===========================================================");
      }
    }
    flush() {
      return Promise.resolve();
    }
    log(e, s) {
      this.a.trace(`${this.b}telemetry/${e}`, Vp(s));
    }
  };
ya = __decorate([__param(0, ne), __param(1, $n), __param(2, fe), __param(3, Ee)], ya);
var ba = class {
  static {
    this.IDLE_START_EVENT_NAME = "UserIdleStart";
  }
  static {
    this.IDLE_STOP_EVENT_NAME = "UserIdleStop";
  }
  constructor(e, s, i) {
    (this.k = s),
      (this.l = i),
      (this.d = {}),
      (this.i = new ye()),
      (this.j = []),
      (this.b = e.appenders),
      (this.c = e.commonProperties ?? Object.create(null)),
      (this.sessionId = this.c.sessionID),
      (this.machineId = this.c["common.machineId"]),
      (this.sqmId = this.c["common.sqmId"]),
      (this.devDeviceId = this.c["common.devDeviceId"]),
      (this.firstSessionDate = this.c["common.firstSessionDate"]),
      (this.msftInternal = this.c["common.msftInternal"]),
      (this.f = e.piiPaths || []),
      (this.g = 3),
      (this.h = !!e.sendErrorTelemetry),
      (this.j = [/(vscode-)?file:\/\/\/.*?\/resources\/app\//gi]);
    for (const n of this.f) this.j.push(new RegExp(dn(n), "gi")), n.indexOf("\\") >= 0 && this.j.push(new RegExp(dn(n.replace(/\\/g, "/")), "gi"));
    this.m(),
      this.i.add(
        this.k.onDidChangeConfiguration((n) => {
          (n.affectsConfiguration(Zo) || n.affectsConfiguration(Vl) || n.affectsConfiguration(Op)) && this.m();
        }),
      );
  }
  setExperimentProperty(e, s) {
    this.d[e] = s;
  }
  m() {
    let e = qp(this.k);
    const s = this.l.enabledTelemetryLevels;
    if (s) {
      this.h = this.sendErrorTelemetry ? s.error : !1;
      const i = s.usage ? 3 : s.error ? 2 : 0;
      e = Math.min(e, i);
    }
    this.g = e;
  }
  get sendErrorTelemetry() {
    return this.h;
  }
  get telemetryLevel() {
    return this.g;
  }
  dispose() {
    this.i.dispose();
  }
  n(e, s, i) {
    this.g < s || ((i = br(i, this.d)), (i = h5(i, this.j)), (i = br(i, this.c)), (i = br(i, { build_version: this.l.tronBuildVersion })), this.b.forEach((n) => n.log(e, i)));
  }
  publicLog(e, s) {
    this.n(e, 3, s);
  }
  publicLog2(e, s) {
    this.publicLog(e, s);
  }
  publicLogError(e, s) {
    this.h && this.n(e, 2, s);
  }
  publicLogError2(e, s) {
    this.publicLogError(e, s);
  }
};
ba = __decorate([__param(1, Ce), __param(2, Ee)], ba);
function f7() {
  const t = w(2159, null, Js.nameLong),
    e = Js.privacyStatementUrl ? w(2161, null, "https://aka.ms/vscode-telemetry", Js.privacyStatementUrl) : w(2160, null, "https://aka.ms/vscode-telemetry"),
    s = Qe ? "" : w(2162, null),
    i = w(2163, null),
    n = w(2164, null),
    r = w(2165, null),
    o = w(2166, null),
    a = `
|       | ${i} | ${n} | ${r} |
|:------|:---------------------:|:---------------:|:--------------:|
| all   |            \u2713          |        \u2713        |        \u2713       |
| error |            \u2713          |        \u2713        |        -       |
| crash |            \u2713          |        -        |        -       |
| off   |            -          |        -        |        -       |
`,
    c = w(2167, null);
  return `
${t} ${e} ${s}

&nbsp;

${o}
${a}

&nbsp;

${c}
`;
}
yt.as(Jt.Configuration).registerConfiguration({
  id: Ap,
  order: 1,
  type: "object",
  title: w(2168, null),
  properties: {
    [Zo]: {
      type: "string",
      enum: ["all", "error", "crash", "off"],
      enumDescriptions: [w(2169, null), w(2170, null), w(2171, null), w(2172, null)],
      markdownDescription: f7(),
      default: "all",
      restricted: !0,
      scope: 1,
      tags: ["usesOnlineServices", "telemetry"],
    },
  },
}),
  yt.as(Jt.Configuration).registerConfiguration({
    id: Ap,
    order: 110,
    type: "object",
    title: w(2173, null),
    properties: {
      [Vl]: {
        type: "boolean",
        markdownDescription: Js.privacyStatementUrl ? w(2175, null, Js.nameLong, Js.privacyStatementUrl) : w(2174, null, Js.nameLong),
        default: !0,
        restricted: !0,
        markdownDeprecationMessage: w(2176, null, `\`#${Zo}#\``),
        scope: 1,
        tags: ["usesOnlineServices", "telemetry"],
      },
    },
  });
var Uh = class {
  constructor(e, s, i, n, r, o) {
    (this.b = e), (this.c = s), (this.d = i), (this.e = n), (this.f = r), (this.g = o), (this.a = new Map());
  }
  h(e) {
    if (!this.a.has(e.id)) {
      const s = Object.create(null);
      (s["common.vscodemachineid"] = this.c.machineId), (s["common.vscodesessionid"] = this.c.sessionId);
      const i = [e.id, JSON.stringify(s), e.aiKey],
        r = new Jg(Cs.asFileUri("bootstrap-fork").fsPath, {
          serverName: "Debug Telemetry",
          timeout: 1e3 * 60 * 5,
          args: i,
          env: { ELECTRON_RUN_AS_NODE: 1, VSCODE_PIPE_LOGGING: "true", VSCODE_ESM_ENTRYPOINT: "vs/workbench/contrib/debug/node/telemetryApp" },
        }).getChannel("telemetryAppender"),
        o = [new u7(r), new ya(this.d, this.e, this.f, this.g, `[${e.id}] `)];
      this.a.set(e.id, new ba({ appenders: o, sendErrorTelemetry: e.sendErrorTelemetry }, this.b, this.g));
    }
    return this.a.get(e.id);
  }
  publicLog(e, s, i) {
    this.h(e).publicLog(s, i);
  }
  publicLogError(e, s, i) {
    this.h(e).publicLogError(s, i);
  }
};
Uh = __decorate([__param(0, Ce), __param(1, Se), __param(2, ne), __param(3, $n), __param(4, fe), __param(5, Ee)], Uh);
var Ps,
  _h = z("IExtensionStorageService"),
  d7 = /^extensionKeys\/([^.]+\..+)@(\d+\.\d+\.\d+(-.*)?)$/,
  Tr = class extends O {
    static {
      Ps = this;
    }
    static {
      this.a = 512 * 1024;
    }
    static b(e) {
      return `extensionKeys/${kr(e.id)}@${e.version}`;
    }
    static c(e) {
      const s = d7.exec(e);
      if (s && s[1]) return { id: s[1], version: s[2] };
    }
    static async removeOutdatedExtensionVersions(e, s) {
      const i = await e.getInstalled(),
        n = [];
      for (const [r, o] of Ps.f(s)) {
        const a = i.find((c) => G(c.identifier, { id: r }))?.manifest.version;
        for (const c of o) a !== c && n.push(Ps.b({ id: r, version: c }));
      }
      for (const r of n) s.remove(r, 0);
    }
    static f(e) {
      const s = new Map(),
        i = e.keys(0, 1);
      for (const n of i) {
        const r = Ps.c(n);
        if (r) {
          let o = s.get(r.id.toLowerCase());
          o || s.set(r.id.toLowerCase(), (o = [])), o.push(r.version);
        }
      }
      return s;
    }
    constructor(e, s, i) {
      super(),
        (this.j = e),
        (this.m = s),
        (this.n = i),
        (this.g = this.B(new D())),
        (this.onDidChangeExtensionStorageToSync = this.g.event),
        (this.h = Ps.f(e)),
        this.B(this.j.onDidChangeValue(0, void 0, this.B(new ye()))((n) => this.r(n)));
    }
    r(e) {
      if (this.h.has(e.key.toLowerCase())) {
        this.g.fire();
        return;
      }
      const s = Ps.c(e.key);
      if (s) {
        if (this.j.get(e.key, 0) === void 0) this.h.delete(s.id.toLowerCase());
        else {
          let i = this.h.get(s.id.toLowerCase());
          i || this.h.set(s.id.toLowerCase(), (i = [])), i.push(s.version), this.g.fire();
        }
        return;
      }
    }
    s(e) {
      if (_e(e)) return e;
      const s = e.manifest ? e.manifest.publisher : e.publisher,
        i = e.manifest ? e.manifest.name : e.name;
      return ea(s, i);
    }
    getExtensionState(e, s) {
      const i = this.s(e),
        n = this.getExtensionStateRaw(e, s);
      if (n)
        try {
          return JSON.parse(n);
        } catch (r) {
          this.n.error(`[mainThreadStorage] unexpected error parsing storage contents (extensionId: ${i}, global: ${s}): ${r}`);
        }
    }
    getExtensionStateRaw(e, s) {
      const i = this.s(e),
        n = this.j.get(i, s ? 0 : 1);
      return (
        n &&
          n?.length > Ps.a &&
          this.n.warn(`[mainThreadStorage] large extension state detected (extensionId: ${i}, global: ${s}): ${n.length / 1024}kb. Consider to use 'storageUri' or 'globalStorageUri' to store this data on disk instead.`),
        n
      );
    }
    setExtensionState(e, s, i) {
      const n = this.s(e);
      s === void 0 ? this.j.remove(n, i ? 0 : 1) : this.j.store(n, JSON.stringify(s), i ? 0 : 1, 1);
    }
    setKeysForSync(e, s) {
      this.j.store(Ps.b(e), JSON.stringify(s), 0, 1);
    }
    getKeysForSync(e) {
      const s = this.m.extensionSyncedKeys?.[e.id.toLowerCase()],
        i = this.j.get(Ps.b(e), 0),
        n = i ? JSON.parse(i) : void 0;
      return n && s ? Bt([...n, ...s]) : n || s;
    }
    addToMigrationList(e, s) {
      if (e !== s) {
        const i = this.t.filter((n) => !n.includes(e) && !n.includes(s));
        i.push([e, s]), (this.t = i);
      }
    }
    getSourceExtensionToMigrate(e) {
      const s = this.t.find(([, i]) => e === i);
      return s ? s[0] : void 0;
    }
    get t() {
      const e = this.j.get("extensionStorage.migrationList", -1, "[]");
      try {
        const s = JSON.parse(e);
        if (Array.isArray(s)) return s;
      } catch {}
      return [];
    }
    set t(e) {
      e.length ? this.j.store("extensionStorage.migrationList", JSON.stringify(e), -1, 1) : this.j.remove("extensionStorage.migrationList", -1);
    }
  };
Tr = Ps = __decorate([__param(0, ae), __param(1, Ee), __param(2, ne)], Tr);
var Ea = z("IIgnoredExtensionsManagementService"),
  Bh = class {
    constructor(e) {
      this.a = e;
    }
    hasToNeverSyncExtension(e) {
      return this.b().includes(e.toLowerCase());
    }
    hasToAlwaysSyncExtension(e) {
      return this.b().includes(`-${e.toLowerCase()}`);
    }
    updateIgnoredExtensions(e, s) {
      let i = [...this.a.getValue("settingsSync.ignoredExtensions")].map((n) => n.toLowerCase());
      return (i = i.filter((n) => n !== e && n !== `-${e}`)), s && i.push(e.toLowerCase()), this.a.updateValue("settingsSync.ignoredExtensions", i.length ? i : void 0, 2);
    }
    updateSynchronizedExtensions(e, s) {
      let i = [...this.a.getValue("settingsSync.ignoredExtensions")].map((n) => n.toLowerCase());
      return (i = i.filter((n) => n !== e && n !== `-${e}`)), s && i.push(`-${e.toLowerCase()}`), this.a.updateValue("settingsSync.ignoredExtensions", i.length ? i : void 0, 2);
    }
    getIgnoredExtensions(e) {
      const s = e.filter((o) => o.isMachineScoped).map((o) => o.identifier.id.toLowerCase()),
        i = this.b().map((o) => o.toLowerCase()),
        n = [],
        r = [];
      if (Array.isArray(i)) for (const o of i) o.startsWith("-") ? r.push(o.substring(1)) : n.push(o);
      return Bt([...s, ...n].filter((o) => !r.includes(o)));
    }
    b() {
      let e = this.a.inspect("settingsSync.ignoredExtensions").userValue;
      return e !== void 0 || ((e = this.a.inspect("sync.ignoredExtensions").userValue), e !== void 0) ? e : (this.a.getValue("settingsSync.ignoredExtensions") || []).map((s) => s.toLowerCase());
    }
  };
Bh = __decorate([__param(0, Ce)], Bh);
function zh() {
  const t = yt.as(Jt.Configuration).getConfigurationProperties();
  return Object.keys(t).filter((e) => !!t[e].disallowSyncIgnore);
}
function p7(t = !1) {
  const e = yt.as(Jt.Configuration).getConfigurationProperties(),
    s = Zg(e, t),
    i = zh();
  return Bt([...s, ...i]);
}
function Yg(t) {
  if (!t.contributes?.configuration) return [];
  const e = Array.isArray(t.contributes.configuration) ? t.contributes.configuration : [t.contributes.configuration];
  if (!e.length) return [];
  const s = Ep(e);
  return Zg(s, !1);
}
function Zg(t, e) {
  const s = new Set();
  for (const i in t) {
    if (e && t[i].source) continue;
    const n = _e(t[i].scope) ? Pb(t[i].scope) : t[i].scope;
    (t[i].ignoreSync || n === 2 || n === 6) && s.add(i);
  }
  return [...s.values()];
}
var Sa = "settingsSync",
  qh = "settingsSync.keybindingsPerPlatform";
function g7() {
  const t = "vscode://schemas/ignoredSettings",
    e = yt.as(Jt.Configuration);
  e.registerConfiguration({
    id: "settingsSync",
    order: 30,
    title: w(2759, null),
    type: "object",
    properties: {
      [qh]: { type: "boolean", description: w(2760, null), default: !0, scope: 1, tags: ["sync", "usesOnlineServices"] },
      "settingsSync.ignoredExtensions": {
        type: "array",
        markdownDescription: w(2761, null),
        items: [{ type: "string", pattern: D1, errorMessage: w(2762, null) }],
        default: [],
        scope: 1,
        uniqueItems: !0,
        disallowSyncIgnore: !0,
        tags: ["sync", "usesOnlineServices"],
      },
      "settingsSync.ignoredSettings": { type: "array", description: w(2763, null), default: [], scope: 1, $ref: t, additionalProperties: !0, uniqueItems: !0, disallowSyncIgnore: !0, tags: ["sync", "usesOnlineServices"] },
    },
  });
  const s = yt.as(_l.JSONContribution),
    i = () => {
      const n = zh(),
        r = p7(),
        o = Object.keys(Er.properties).filter((l) => !r.includes(l)),
        a = r.filter((l) => !n.includes(l)),
        c = { items: { type: "string", enum: [...o, ...a.map((l) => `-${l}`)] } };
      s.registerSchema(t, c);
    };
  return e.onDidUpdateConfiguration(() => i());
}
var e0;
(function (t) {
  (t.Settings = "settings"), (t.Keybindings = "keybindings"), (t.Snippets = "snippets"), (t.Tasks = "tasks"), (t.Extensions = "extensions"), (t.GlobalState = "globalState"), (t.Profiles = "profiles"), (t.WorkspaceState = "workspaceState");
})(e0 || (e0 = {}));
var jn = ["settings", "keybindings", "snippets", "tasks", "extensions", "globalState", "profiles"];
function t0(t, ...e) {
  return t ? [t, ...e] : e;
}
function s0(t, e, s, i) {
  return i.joinPath(s.userDataSyncHome, ...t0(t, e, `lastSync${e}.json`));
}
var hi = z("IUserDataSyncStoreManagementService"),
  St = z("IUserDataSyncStoreService"),
  ts = z("IUserDataSyncLocalStoreService"),
  Ks = "x-operation-id",
  i0 = "X-Execution-Id";
function Fn(t) {
  const e = {};
  return (e[i0] = t), e;
}
var n0;
(function (t) {
  (t.Unauthorized = "Unauthorized"),
    (t.Forbidden = "Forbidden"),
    (t.NotFound = "NotFound"),
    (t.MethodNotFound = "MethodNotFound"),
    (t.Conflict = "Conflict"),
    (t.Gone = "Gone"),
    (t.PreconditionFailed = "PreconditionFailed"),
    (t.TooLarge = "TooLarge"),
    (t.UpgradeRequired = "UpgradeRequired"),
    (t.PreconditionRequired = "PreconditionRequired"),
    (t.TooManyRequests = "RemoteTooManyRequests"),
    (t.TooManyRequestsAndRetryAfter = "TooManyRequestsAndRetryAfter"),
    (t.RequestFailed = "RequestFailed"),
    (t.RequestCanceled = "RequestCanceled"),
    (t.RequestTimeout = "RequestTimeout"),
    (t.RequestProtocolNotSupported = "RequestProtocolNotSupported"),
    (t.RequestPathNotEscaped = "RequestPathNotEscaped"),
    (t.RequestHeadersNotObject = "RequestHeadersNotObject"),
    (t.NoCollection = "NoCollection"),
    (t.NoRef = "NoRef"),
    (t.EmptyResponse = "EmptyResponse"),
    (t.TurnedOff = "TurnedOff"),
    (t.SessionExpired = "SessionExpired"),
    (t.ServiceChanged = "ServiceChanged"),
    (t.DefaultServiceChanged = "DefaultServiceChanged"),
    (t.LocalTooManyProfiles = "LocalTooManyProfiles"),
    (t.LocalTooManyRequests = "LocalTooManyRequests"),
    (t.LocalPreconditionFailed = "LocalPreconditionFailed"),
    (t.LocalInvalidContent = "LocalInvalidContent"),
    (t.LocalError = "LocalError"),
    (t.IncompatibleLocalContent = "IncompatibleLocalContent"),
    (t.IncompatibleRemoteContent = "IncompatibleRemoteContent"),
    (t.Unknown = "Unknown");
})(n0 || (n0 = {}));
var De = class extends Error {
    constructor(t, e, s, i) {
      super(t), (this.code = e), (this.resource = s), (this.operationId = i), (this.name = `${this.code} (UserDataSyncError) syncResource:${this.resource || "unknown"} operationId:${this.operationId || "unknown"}`);
    }
  },
  Le = class extends De {
    constructor(t, e, s, i, n) {
      super(t, s, void 0, n), (this.url = e), (this.serverCode = i);
    }
  },
  Xs = class extends De {
    constructor(t, e) {
      super(t, e);
    }
  };
(function (t) {
  function e(s) {
    if (s instanceof t) return s;
    const i = /^(.+) \(UserDataSyncError\) syncResource:(.+) operationId:(.+)$/.exec(s.name);
    if (i && i[1]) {
      const n = i[2] === "unknown" ? void 0 : i[2],
        r = i[3] === "unknown" ? void 0 : i[3];
      return new t(s.message, i[1], n, r);
    }
    return new t(s.message, "Unknown");
  }
  t.toUserDataSyncError = e;
})(De || (De = {}));
var r0;
(function (t) {
  (t.Uninitialized = "uninitialized"), (t.Idle = "idle"), (t.Syncing = "syncing"), (t.HasConflicts = "hasConflicts");
})(r0 || (r0 = {}));
var o0;
(function (t) {
  (t[(t.None = 0)] = "None"), (t[(t.Added = 1)] = "Added"), (t[(t.Modified = 2)] = "Modified"), (t[(t.Deleted = 3)] = "Deleted");
})(o0 || (o0 = {}));
var a0;
(function (t) {
  (t.Preview = "preview"), (t.Conflict = "conflict"), (t.Accepted = "accepted");
})(a0 || (a0 = {}));
var ui = "sync.store.url.type";
function $a(t) {
  return `sync.enable.${t}`;
}
var jt = z("IUserDataSyncEnablementService"),
  xa = z("IUserDataSyncService"),
  Vh = z("IUserDataSyncResourceProviderService"),
  XE = z("IUserDataAutoSyncService"),
  Ca = z("IUserDataSyncUtilService"),
  Pe = z("IUserDataSyncLogService"),
  c0 = "userDataSync",
  _ = "vscode-userdata-sync",
  m7 = "preview",
  ka = z("IUserDataSyncAccountService"),
  Wh = class extends O {
    get account() {
      return this.a;
    }
    constructor(e, s) {
      super(),
        (this.g = e),
        (this.h = s),
        (this.b = this.B(new D())),
        (this.onDidChangeAccount = this.b.event),
        (this.c = this.B(new D())),
        (this.onTokenFailed = this.c.event),
        (this.f = !1),
        this.B(
          e.onTokenFailed((i) => {
            this.h.info("Settings Sync auth token failed", this.account?.authenticationProviderId, this.f, i), this.updateAccount(void 0), i === "Forbidden" ? this.c.fire(!0) : this.c.fire(this.f), (this.f = !0);
          }),
        ),
        this.B(e.onTokenSucceed(() => (this.f = !1)));
    }
    async updateAccount(e) {
      (e && this.a ? e.token !== this.a.token || e.authenticationProviderId !== this.a.authenticationProviderId : e !== this.a) && ((this.a = e), this.a && this.g.setAuthToken(this.a.token, this.a.authenticationProviderId), this.b.fire(e));
    }
  };
Wh = __decorate([__param(0, St), __param(1, Pe)], Wh);
var w7 = 60,
  v7 = w7 * 60,
  Hh = v7 * 24,
  YE = Hh * 7,
  ZE = Hh * 30,
  eS = Hh * 365;
function Da(t) {
  return (
    t.getFullYear() +
    "-" +
    String(t.getMonth() + 1).padStart(2, "0") +
    "-" +
    String(t.getDate()).padStart(2, "0") +
    "T" +
    String(t.getHours()).padStart(2, "0") +
    ":" +
    String(t.getMinutes()).padStart(2, "0") +
    ":" +
    String(t.getSeconds()).padStart(2, "0") +
    "." +
    (t.getMilliseconds() / 1e3).toFixed(3).slice(2, 5) +
    "Z"
  );
}
var Gh = class extends O {
  constructor(e, s, i, n, r) {
    super(), (this.a = e), (this.b = s), (this.c = i), (this.f = n), (this.g = r), this.h();
  }
  async h() {
    for (const s of this.g.profiles)
      for (const i of jn)
        try {
          await this.m(this.j(i, s.isDefault ? void 0 : s.id));
        } catch (n) {
          this.f.error(n);
        }
    let e;
    try {
      e = await this.b.resolve(this.a.userDataSyncHome);
    } catch (s) {
      ct(s) !== 1 && this.f.error(s);
      return;
    }
    if (e.children) {
      for (const s of e.children)
        if (s.isDirectory && !jn.includes(s.name) && !this.g.profiles.some((i) => i.id === s.name))
          try {
            this.f.info("Deleting non existing profile from backup", s.resource.path), await this.b.del(s.resource, { recursive: !0 });
          } catch (i) {
            this.f.error(i);
          }
    }
  }
  async getAllResourceRefs(e, s, i) {
    const n = this.j(e, s, i);
    try {
      const r = await this.b.resolve(n);
      if (r.children)
        return r.children
          .filter((a) => a.isFile && !a.name.startsWith("lastSync"))
          .sort()
          .reverse()
          .map((a) => ({ ref: a.name, created: this.n(a) }));
    } catch (r) {
      if (ct(r) !== 1) throw r;
    }
    return [];
  }
  async resolveResourceContent(e, s, i, n) {
    const r = this.j(e, i, n),
      o = M(r, s);
    try {
      return (await this.b.readFile(o)).value.toString();
    } catch (a) {
      return this.f.error(a), null;
    }
  }
  async writeResource(e, s, i, n, r) {
    const o = this.j(e, n, r),
      a = M(o, `${Da(i).replace(/-|:|\.\d+Z$/g, "")}.json`);
    try {
      await this.b.writeFile(a, L.fromString(s));
    } catch (c) {
      this.f.error(c);
    }
  }
  j(e, s, i = this.a.userDataSyncHome) {
    return M(i, ...(s ? [s, e] : [e]));
  }
  async m(e) {
    try {
      try {
        if (!(await this.b.exists(e))) return;
      } catch {
        return;
      }
      const s = await this.b.resolve(e);
      if (s.children) {
        const i = s.children.filter((a) => a.isFile && /^\d{8}T\d{6}(\.json)?$/.test(a.name)).sort(),
          n = 1e3 * 60 * 60 * 24 * (this.c.getValue("sync.localBackupDuration") || 30);
        let r = i.filter((a) => Date.now() - this.n(a) > n);
        const o = i.length - r.length;
        o < 10 && (r = r.slice(10 - o)),
          await Ze.settled(
            r.map(async (a) => {
              this.f.info("Deleting from backup", a.resource.path), await this.b.del(a.resource);
            }),
          );
      }
    } catch (s) {
      this.f.error(s);
    }
  }
  n(e) {
    return new Date(
      parseInt(e.name.substring(0, 4)),
      parseInt(e.name.substring(4, 6)) - 1,
      parseInt(e.name.substring(6, 8)),
      parseInt(e.name.substring(9, 11)),
      parseInt(e.name.substring(11, 13)),
      parseInt(e.name.substring(13, 15)),
    ).getTime();
  }
};
Gh = __decorate([__param(0, fe), __param(1, ie), __param(2, Ce), __param(3, Pe), __param(4, Te)], Gh);
var Jh = Object.freeze({ text: "text/plain", binary: "application/octet-stream", unknown: "application/unknown", markdown: "text/markdown", latex: "text/latex", uriList: "text/uri-list" }),
  l0 = "configurationSync.store",
  Kh = "sync.previous.store",
  Xh = "sync.donot-make-requests-until",
  Ia = "sync.user-session-id",
  Qh = "sync.machine-session-id",
  y7 = 100,
  b7 = 1e3 * 60 * 5,
  Ra = class extends O {
    get userDataSyncStore() {
      return this.b;
    }
    get c() {
      return this.h.get(ui, -1);
    }
    set c(e) {
      this.h.store(ui, e, -1, Qe ? 0 : 1);
    }
    constructor(e, s, i) {
      super(), (this.f = e), (this.g = s), (this.h = i), (this.a = this.B(new D())), (this.onDidChangeUserDataSyncStore = this.a.event), this.j();
      const n = this.B(new ye());
      this.B(T.filter(i.onDidChangeValue(-1, ui, n), () => this.c !== this.userDataSyncStore?.type, n)(() => this.j()));
    }
    j() {
      (this.b = this.m(this.f[l0])), this.a.fire();
    }
    m(e) {
      if (e && ((e = Qe && e.web ? { ...e, ...e.web } : e), _e(e.url) && Ke(e.authenticationProviders) && Object.keys(e.authenticationProviders).every((s) => Array.isArray(e.authenticationProviders[s].scopes)))) {
        const s = e,
          i = !!s.canSwitch,
          n = s.url === s.insidersUrl ? "insiders" : "stable",
          r = (i ? this.c : void 0) || n,
          o = r === "insiders" ? s.insidersUrl : r === "stable" ? s.stableUrl : s.url;
        return {
          url: C.parse(o),
          type: r,
          defaultType: n,
          defaultUrl: C.parse(s.url),
          stableUrl: C.parse(s.stableUrl),
          insidersUrl: C.parse(s.insidersUrl),
          canSwitch: i,
          authenticationProviders: Object.keys(s.authenticationProviders).reduce((a, c) => (a.push({ id: c, scopes: s.authenticationProviders[c].scopes }), a), []),
        };
      }
    }
  };
Ra = __decorate([__param(0, Ee), __param(1, Ce), __param(2, ae)], Ra);
var Yh = class extends Ra {
  constructor(e, s, i) {
    super(e, s, i);
    const n = this.h.get(Kh, -1);
    n && (this.n = JSON.parse(n));
    const r = this.f[l0];
    r ? this.h.store(Kh, JSON.stringify(r), -1, 1) : this.h.remove(Kh, -1);
  }
  async switch(e) {
    e !== this.c && ((this.c = e), this.j());
  }
  async getPreviousUserDataSyncStore() {
    return this.m(this.n);
  }
};
Yh = __decorate([__param(0, Ee), __param(1, Ce), __param(2, ae)], Yh);
var Zh = class extends O {
  get donotMakeRequestsUntil() {
    return this.j;
  }
  constructor(e, s, i, n, r, o, a) {
    super(),
      (this.n = i),
      (this.r = n),
      (this.s = a),
      (this.g = this.B(new D())),
      (this.onTokenFailed = this.g.event),
      (this.h = this.B(new D())),
      (this.onTokenSucceed = this.h.event),
      (this.j = void 0),
      (this.m = this.B(new D())),
      (this.onDidChangeDonotMakeRequestsUntil = this.m.event),
      (this.w = void 0),
      this.t(e),
      (this.c = On(r, o, a).then((c) => {
        const l = { "X-Client-Name": `${s.applicationName}${Qe ? "-web" : ""}`, "X-Client-Version": s.version };
        return s.commit && (l["X-Client-Commit"] = s.commit), l;
      })),
      (this.f = new E7(y7, b7, this.n, this.r)),
      this.u(),
      this.B(
        ue(() => {
          this.w && (this.w.cancel(), (this.w = void 0));
        }),
      );
  }
  setAuthToken(e, s) {
    this.b = { token: e, type: s };
  }
  t(e) {
    this.a = e ? M(e, "v1") : void 0;
  }
  u() {
    const e = this.s.getNumber(Xh, -1);
    e && Date.now() < e && this.y(new Date(e));
  }
  y(e) {
    this.j?.getTime() !== e?.getTime() &&
      ((this.j = e),
      this.w && (this.w.cancel(), (this.w = void 0)),
      this.j ? (this.s.store(Xh, this.j.getTime(), -1, 1), (this.w = wt((s) => Pi(this.j.getTime() - Date.now(), s).then(() => this.y(void 0)))), this.w.then(null, (s) => null)) : this.s.remove(Xh, -1),
      this.m.fire());
  }
  async getAllCollections(e = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const s = M(this.a, "collection").toString();
    (e = { ...e }), (e["Content-Type"] = "application/json");
    const i = await this.D(s, { type: "GET", headers: e }, [], J.None);
    return (await Ui(i))?.map(({ id: n }) => n) || [];
  }
  async createCollection(e = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const s = M(this.a, "collection").toString();
    (e = { ...e }), (e["Content-Type"] = Jh.text);
    const i = await this.D(s, { type: "POST", headers: e }, [], J.None),
      n = await Is(i);
    if (!n) throw new Le("Server did not return the collection id", s, "NoCollection", i.res.statusCode, i.res.headers[Ks]);
    return n;
  }
  async deleteCollection(e, s = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const i = e ? M(this.a, "collection", e).toString() : M(this.a, "collection").toString();
    (s = { ...s }), await this.D(i, { type: "DELETE", headers: s }, [], J.None);
  }
  async getAllResourceRefs(e, s) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const i = this.z(this.a, s, e),
      n = {},
      r = await this.D(i.toString(), { type: "GET", headers: n }, [], J.None);
    return ((await Ui(r)) || []).map(({ url: a, created: c }) => ({ ref: ly(i, i.with({ path: a })), created: c * 1e3 }));
  }
  async resolveResourceContent(e, s, i, n = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const r = M(this.z(this.a, i, e), s).toString();
    (n = { ...n }), (n["Cache-Control"] = "no-cache");
    const o = await this.D(r, { type: "GET", headers: n }, [], J.None);
    return await Is(o);
  }
  async deleteResource(e, s, i) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const n = s !== null ? M(this.z(this.a, i, e), s).toString() : this.z(this.a, i, e).toString(),
      r = {};
    await this.D(n, { type: "DELETE", headers: r }, [], J.None);
  }
  async deleteResources() {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const e = M(this.a, "resource").toString(),
      s = { "Content-Type": Jh.text };
    await this.D(e, { type: "DELETE", headers: s }, [], J.None);
  }
  async readResource(e, s, i, n = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const r = M(this.z(this.a, i, e), "latest").toString();
    (n = { ...n }), (n["Cache-Control"] = "no-cache"), s && (n["If-None-Match"] = s.ref);
    const o = await this.D(r, { type: "GET", headers: n }, [304], J.None);
    let a = null;
    if ((o.res.statusCode === 304 && (a = s), a === null)) {
      const c = o.res.headers.etag;
      if (!c) throw new Le("Server did not return the ref", r, "NoRef", o.res.statusCode, o.res.headers[Ks]);
      const l = await Is(o);
      if (!l && o.res.statusCode === 304) throw new Le("Empty response", r, "EmptyResponse", o.res.statusCode, o.res.headers[Ks]);
      a = { ref: c, content: l };
    }
    return a.ref && (a.ref = a.ref.replace(/W\/"(.*)"/, "$1")), a;
  }
  async writeResource(e, s, i, n, r = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const o = this.z(this.a, n, e).toString();
    (r = { ...r }), (r["Content-Type"] = Jh.text), i && (r["If-Match"] = i);
    const a = await this.D(o, { type: "POST", data: s, headers: r }, [], J.None),
      c = a.res.headers.etag;
    if (!c) throw new Le("Server did not return the ref", o, "NoRef", a.res.statusCode, a.res.headers[Ks]);
    return c;
  }
  async manifest(e, s = {}) {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const i = M(this.a, "manifest").toString();
    (s = { ...s }), (s["Content-Type"] = "application/json"), e && (s["If-None-Match"] = e.ref);
    const n = await this.D(i, { type: "GET", headers: s }, [304], J.None);
    let r = null;
    if ((n.res.statusCode === 304 && (r = e), !r)) {
      const a = n.res.headers.etag;
      if (!a) throw new Le("Server did not return the ref", i, "NoRef", n.res.statusCode, n.res.headers[Ks]);
      const c = await Is(n);
      if (!c && n.res.statusCode === 304) throw new Le("Empty response", i, "EmptyResponse", n.res.statusCode, n.res.headers[Ks]);
      c && (r = { ...JSON.parse(c), ref: a });
    }
    const o = this.s.get(Ia, -1);
    return o && r && o !== r.session && this.C(), r === null && o && this.C(), r && this.s.store(Ia, r.session, -1, 1), r;
  }
  async clear() {
    if (!this.a) throw new Error("No settings sync store url configured.");
    await this.deleteCollection(), await this.deleteResources(), this.C();
  }
  async getActivityData() {
    if (!this.a) throw new Error("No settings sync store url configured.");
    const e = M(this.a, "download").toString(),
      s = {},
      i = await this.D(e, { type: "GET", headers: s }, [], J.None);
    if (!Cr(i)) throw new Le("Server returned " + i.res.statusCode, e, "EmptyResponse", i.res.statusCode, i.res.headers[Ks]);
    if (Jl(i)) throw new Le("Empty response", e, "EmptyResponse", i.res.statusCode, i.res.headers[Ks]);
    return i.stream;
  }
  z(e, s, i) {
    return s ? M(e, "collection", s, "resource", i) : M(e, "resource", i);
  }
  C() {
    this.s.remove(Ia, -1), this.s.remove(Qh, -1);
  }
  async D(e, s, i, n) {
    if (!this.b) throw new Le("No Auth Token Available", e, "Unauthorized", void 0, void 0);
    if (this.j && Date.now() < this.j.getTime()) throw new Le(`${s.type} request '${e}' failed because of too many requests (429).`, e, "TooManyRequestsAndRetryAfter", void 0, void 0);
    this.y(void 0);
    const r = await this.c;
    (s.headers = { ...(s.headers || {}), ...r, "X-Account-Type": this.b.type, authorization: `Bearer ${this.b.token}` }),
      this.F(s.headers),
      this.r.trace("Sending request to server", { url: e, type: s.type, headers: { ...s.headers, authorization: void 0 } });
    let o;
    try {
      o = await this.f.request(e, s, n);
    } catch (u) {
      if (!(u instanceof Le)) {
        let f = "RequestFailed";
        const d = ve(u).toLowerCase();
        d.includes("xhr timeout")
          ? (f = "RequestTimeout")
          : d.includes("protocol") && d.includes("not supported")
            ? (f = "RequestProtocolNotSupported")
            : d.includes("request path contains unescaped characters")
              ? (f = "RequestPathNotEscaped")
              : d.includes("headers must be an object")
                ? (f = "RequestHeadersNotObject")
                : Fs(u) && (f = "RequestCanceled"),
          (u = new Le(`Connection refused for the request '${e}'.`, e, f, void 0, void 0));
      }
      throw (this.r.info("Request failed", e), u);
    }
    const a = o.res.headers[Ks],
      c = { url: e, status: o.res.statusCode, "execution-id": s.headers[i0], "operation-id": a },
      l = Cr(o) || (o.res.statusCode && i.includes(o.res.statusCode));
    let h = "";
    if ((l ? this.r.trace("Request succeeded", c) : ((h = (await Fp(o)) || ""), this.r.info("Request failed", c, h)), o.res.statusCode === 401 || o.res.statusCode === 403)) {
      if (((this.b = void 0), o.res.statusCode === 401)) throw (this.g.fire("Unauthorized"), new Le(`${s.type} request '${e}' failed because of Unauthorized (401).`, e, "Unauthorized", o.res.statusCode, a));
      if (o.res.statusCode === 403) throw (this.g.fire("Forbidden"), new Le(`${s.type} request '${e}' failed because the access is forbidden (403).`, e, "Forbidden", o.res.statusCode, a));
    }
    if ((this.h.fire(), o.res.statusCode === 404)) throw new Le(`${s.type} request '${e}' failed because the requested resource is not found (404).`, e, "NotFound", o.res.statusCode, a);
    if (o.res.statusCode === 405) throw new Le(`${s.type} request '${e}' failed because the requested endpoint is not found (405). ${h}`, e, "MethodNotFound", o.res.statusCode, a);
    if (o.res.statusCode === 409) throw new Le(`${s.type} request '${e}' failed because of Conflict (409). There is new data for this resource. Make the request again with latest data.`, e, "Conflict", o.res.statusCode, a);
    if (o.res.statusCode === 410) throw new Le(`${s.type} request '${e}' failed because the requested resource is not longer available (410).`, e, "Gone", o.res.statusCode, a);
    if (o.res.statusCode === 412)
      throw new Le(`${s.type} request '${e}' failed because of Precondition Failed (412). There is new data for this resource. Make the request again with latest data.`, e, "PreconditionFailed", o.res.statusCode, a);
    if (o.res.statusCode === 413) throw new Le(`${s.type} request '${e}' failed because of too large payload (413).`, e, "TooLarge", o.res.statusCode, a);
    if (o.res.statusCode === 426) throw new Le(`${s.type} request '${e}' failed with status Upgrade Required (426). Please upgrade the client and try again.`, e, "UpgradeRequired", o.res.statusCode, a);
    if (o.res.statusCode === 429) {
      const u = o.res.headers["retry-after"];
      throw u
        ? (this.y(new Date(Date.now() + parseInt(u) * 1e3)), new Le(`${s.type} request '${e}' failed because of too many requests (429).`, e, "TooManyRequestsAndRetryAfter", o.res.statusCode, a))
        : new Le(`${s.type} request '${e}' failed because of too many requests (429).`, e, "RemoteTooManyRequests", o.res.statusCode, a);
    }
    if (!l) throw new Le("Server returned " + o.res.statusCode, e, "Unknown", o.res.statusCode, a);
    return o;
  }
  F(e) {
    let s = this.s.get(Qh, -1);
    s === void 0 && ((s = Me()), this.s.store(Qh, s, -1, 1)), (e["X-Machine-Session-Id"] = s);
    const i = this.s.get(Ia, -1);
    i !== void 0 && (e["X-User-Session-Id"] = i);
  }
};
Zh = __decorate([__param(1, Ee), __param(2, oi), __param(3, Pe), __param(4, fe), __param(5, ie), __param(6, ae)], Zh);
var eu = class extends Zh {
  constructor(e, s, i, n, r, o, a) {
    super(e.userDataSyncStore?.url, s, i, n, r, o, a), this.B(e.onDidChangeUserDataSyncStore(() => this.t(e.userDataSyncStore?.url)));
  }
};
eu = __decorate([__param(0, hi), __param(1, Ee), __param(2, oi), __param(3, Pe), __param(4, fe), __param(5, ie), __param(6, ae)], eu);
var E7 = class {
    constructor(t, e, s, i) {
      (this.c = t), (this.d = e), (this.f = s), (this.g = i), (this.a = []), (this.b = void 0);
    }
    request(t, e, s) {
      if ((this.h() && this.i(), (e.url = t), this.a.length >= this.c))
        throw (this.g.info("Too many requests", ...this.a), new Le(`Too many requests. Only ${this.c} requests allowed in ${this.d / (1e3 * 60)} minutes.`, t, "LocalTooManyRequests", void 0, void 0));
      return (this.b = this.b || new Date()), this.a.push(t), this.f.request(e, s);
    }
    h() {
      return this.b !== void 0 && new Date().getTime() - this.b.getTime() > this.d;
    }
    i() {
      (this.a = []), (this.b = void 0);
    }
  },
  S7 = class {
    constructor(t) {
      this.a = t;
    }
    listen(t, e) {
      switch (e) {
        case "onDidChangeAccount":
          return this.a.onDidChangeAccount;
        case "onTokenFailed":
          return this.a.onTokenFailed;
      }
      throw new Error(`[UserDataSyncAccountServiceChannel] Event not found: ${e}`);
    }
    call(t, e, s) {
      switch (e) {
        case "_getInitialData":
          return Promise.resolve(this.a.account);
        case "updateAccount":
          return this.a.updateAccount(s);
      }
      throw new Error("Invalid call");
    }
  },
  $7 = class {
    constructor(t) {
      this.a = t;
    }
    listen(t, e) {
      switch (e) {
        case "onDidChangeUserDataSyncStore":
          return this.a.onDidChangeUserDataSyncStore;
      }
      throw new Error(`[UserDataSyncStoreManagementServiceChannel] Event not found: ${e}`);
    }
    call(t, e, s) {
      switch (e) {
        case "switch":
          return this.a.switch(s[0]);
        case "getPreviousUserDataSyncStore":
          return this.a.getPreviousUserDataSyncStore();
      }
      throw new Error("Invalid call");
    }
  },
  h0 = class extends Ra {
    constructor(e, s, i, n) {
      super(s, i, n), (this.n = e), this.B(this.n.listen("onDidChangeUserDataSyncStore")(() => this.j()));
    }
    async switch(e) {
      return this.n.call("switch", [e]);
    }
    async getPreviousUserDataSyncStore() {
      const e = await this.n.call("getPreviousUserDataSyncStore");
      return this.r(e);
    }
    r(e) {
      return { url: C.revive(e.url), type: e.type, defaultUrl: C.revive(e.defaultUrl), insidersUrl: C.revive(e.insidersUrl), stableUrl: C.revive(e.stableUrl), canSwitch: e.canSwitch, authenticationProviders: e.authenticationProviders };
    }
  };
h0 = __decorate([__param(1, Ee), __param(2, Ce), __param(3, ae)], h0);
var tu = class extends dr {
  constructor(e, s) {
    super(), (this.g = this.B(e.createLogger(M(s.logsHome, `${c0}.log`), { id: c0, name: w(2764, null) })));
  }
  trace(e, ...s) {
    this.g.trace(e, ...s);
  }
  debug(e, ...s) {
    this.g.debug(e, ...s);
  }
  info(e, ...s) {
    this.g.info(e, ...s);
  }
  warn(e, ...s) {
    this.g.warn(e, ...s);
  }
  error(e, ...s) {
    this.g.error(e, ...s);
  }
  flush() {
    this.g.flush();
  }
};
tu = __decorate([__param(0, $n), __param(1, fe)], tu);
var zi,
  Pa = z("IUserDataSyncMachinesService"),
  u0 = "sync.currentMachineName",
  x7 = "Safari",
  C7 = "Chrome",
  k7 = "Edge",
  D7 = "Firefox",
  I7 = "Android";
function f0() {
  return wd ? x7 : Lc ? C7 : vd ? k7 : md ? D7 : lv ? I7 : Oc(Qe ? 0 : ln);
}
var su = class extends O {
  static {
    zi = this;
  }
  static {
    this.a = 1;
  }
  static {
    this.b = "machines";
  }
  constructor(e, s, i, n, r, o) {
    super(), (this.h = i), (this.j = n), (this.m = r), (this.n = o), (this.c = this.B(new D())), (this.onDidChange = this.c.event), (this.g = null), (this.f = On(e, s, i));
  }
  async getMachines(e) {
    const s = await this.f;
    return (await this.s(e)).machines.map((n) => ({ ...n, isCurrent: n.id === s }));
  }
  async addCurrentMachine(e) {
    const s = await this.f,
      i = await this.s(e);
    i.machines.some(({ id: n }) => n === s) || (i.machines.push({ id: s, name: this.r(i.machines), platform: f0() }), await this.t(i));
  }
  async removeCurrentMachine(e) {
    const s = await this.f,
      i = await this.s(e),
      n = i.machines.filter(({ id: r }) => r !== s);
    n.length !== i.machines.length && ((i.machines = n), await this.t(i));
  }
  async renameMachine(e, s, i) {
    const n = await this.s(i),
      r = n.machines.find(({ id: o }) => o === e);
    if (r) {
      (r.name = s), await this.t(n);
      const o = await this.f;
      e === o && this.h.store(u0, s, -1, 1);
    }
  }
  async setEnablements(e) {
    const s = await this.s();
    for (const [i, n] of e) {
      const r = s.machines.find((o) => o.id === i);
      r && (r.disabled = n ? void 0 : !0);
    }
    await this.t(s);
  }
  r(e) {
    const s = this.h.get(u0, -1);
    if (s) return s;
    const i = `${this.n.embedderIdentifier ? `${this.n.embedderIdentifier} - ` : ""}${f0()} (${this.n.nameShort})`,
      n = new RegExp(`${dn(i)}\\s#(\\d+)`);
    let r = 0;
    for (const o of e) {
      const a = n.exec(o.name),
        c = a ? parseInt(a[1]) : 0;
      r = c > r ? c : r;
    }
    return `${i} #${r + 1}`;
  }
  async s(e) {
    this.g = await this.u(e);
    const s = this.w(this.g);
    if (s.version !== zi.a) throw new Error(w(2765, null, this.n.nameLong));
    return s;
  }
  async t(e) {
    const s = JSON.stringify(e),
      i = await this.j.writeResource(zi.b, s, this.g?.ref || null);
    (this.g = { ref: i, content: s }), this.c.fire();
  }
  async u(e) {
    if (this.g) {
      const s = e && e.latest ? e.latest[zi.b] : void 0;
      if (this.g.ref === s) return this.g;
      if (s === void 0 && this.g.content === null) return this.g;
    }
    return this.j.readResource(zi.b, this.g);
  }
  w(e) {
    if (e.content !== null)
      try {
        return JSON.parse(e.content);
      } catch (s) {
        this.m.error(s);
      }
    return { version: zi.a, machines: [] };
  }
};
su = zi = __decorate([__param(0, fe), __param(1, ie), __param(2, ae), __param(3, St), __param(4, Pe), __param(5, Ee)], su);
var Aa = "sync.enable",
  iu = class extends O {
    constructor(e, s, i, n) {
      super(),
        (this.c = e),
        (this.f = s),
        (this.g = i),
        (this.h = n),
        (this.a = new D()),
        (this.onDidChangeEnablement = this.a.event),
        (this.b = new D()),
        (this.onDidChangeResourceEnablement = this.b.event),
        this.B(e.onDidChangeValue(-1, void 0, this.B(new ye()))((r) => this.m(r)));
    }
    isEnabled() {
      switch (this.g.sync) {
        case "on":
          return !0;
        case "off":
          return !1;
      }
      return this.c.getBoolean(Aa, -1, !1);
    }
    canToggleEnablement() {
      return this.h.userDataSyncStore !== void 0 && this.g.sync === void 0;
    }
    setEnablement(e) {
      (e && !this.canToggleEnablement()) || (this.f.publicLog2(Aa, { enabled: e }), this.c.store(Aa, e, -1, 1));
    }
    isResourceEnabled(e) {
      return this.c.getBoolean($a(e), -1, !0);
    }
    setResourceEnablement(e, s) {
      if (this.isResourceEnabled(e) !== s) {
        const i = $a(e);
        this.j(i, s);
      }
    }
    getResourceSyncStateVersion(e) {}
    j(e, s) {
      this.c.store(e, s, -1, Qe ? 0 : 1);
    }
    m(e) {
      if (Aa === e.key) {
        this.a.fire(this.isEnabled());
        return;
      }
      const s = jn.filter((i) => $a(i) === e.key)[0];
      if (s) {
        this.b.fire([s, this.isResourceEnabled(s)]);
        return;
      }
    }
  };
iu = __decorate([__param(0, ae), __param(1, Se), __param(2, fe), __param(3, hi)], iu);
function R7(t) {
  return !!(t && t.ref !== void 0 && typeof t.ref == "string" && t.ref !== "" && t.syncData !== void 0 && (t.syncData === null || jr(t.syncData)));
}
function jr(t) {
  return !!(
    t &&
    t.version !== void 0 &&
    typeof t.version == "number" &&
    t.content !== void 0 &&
    typeof t.content == "string" &&
    (Object.keys(t).length === 2 || (Object.keys(t).length === 3 && t.machineId !== void 0 && typeof t.machineId == "string"))
  );
}
function Oa(t, e) {
  return `${Iv(t)}${e.isDefault ? "" : ` (${e.name})`}`;
}
var qi = class extends O {
  get status() {
    return this.m;
  }
  get conflicts() {
    return { ...this.syncResource, conflicts: this.s };
  }
  constructor(e, s, i, n, r, o, a, c, l, h, u, f) {
    super(),
      (this.syncResource = e),
      (this.collection = s),
      (this.G = i),
      (this.H = n),
      (this.I = r),
      (this.J = o),
      (this.L = a),
      (this.M = c),
      (this.N = l),
      (this.O = h),
      (this.P = u),
      (this.c = null),
      (this.m = "idle"),
      (this.n = this.B(new D())),
      (this.onDidChangeStatus = this.n.event),
      (this.s = []),
      (this.t = this.B(new D())),
      (this.onDidChangeConflicts = this.t.event),
      (this.u = this.B(new Ri(50))),
      (this.w = this.B(new D())),
      (this.onDidChangeLocal = this.w.event),
      (this.z = `${this.collection ? `${this.collection}.` : ""}${this.syncResource.syncResource}.lastSyncUserData`),
      (this.C = !1),
      (this.F = {}),
      (this.resource = this.syncResource.syncResource),
      (this.D = Oa(e.syncResource, e.profile)),
      (this.h = f.extUri),
      (this.f = this.h.joinPath(n.userDataSyncHome, ...t0(e.profile.isDefault ? void 0 : e.profile.id, e.syncResource))),
      (this.g = this.h.joinPath(this.f, m7)),
      (this.y = s0(e.profile.isDefault ? void 0 : e.profile.id, e.syncResource, n, this.h)),
      (this.j = On(n, i, r));
  }
  Q() {
    this.u.trigger(() => this.R());
  }
  async R() {
    if (this.status === "hasConflicts") {
      this.O.info(`${this.D}: In conflicts state and local change detected. Syncing again...`);
      const e = await this.c;
      this.c = null;
      const s = await this.Y(e.remoteUserData, e.lastSyncUserData, !0, this.ob());
      this.S(s);
    } else {
      this.O.trace(`${this.D}: Checking for local changes...`);
      const e = await this.getLastSyncUserData();
      (e ? await this.ub(e) : !0) && this.w.fire();
    }
  }
  S(e) {
    this.m !== e && ((this.m = e), this.n.fire(e));
  }
  async sync(e, s = {}) {
    await this.U(e, !0, this.ob(), s);
  }
  async preview(e, s, i = {}) {
    return this.U(e, !1, s, i);
  }
  async apply(e, s = {}) {
    try {
      this.F = { ...s };
      const i = await this.ab(e);
      return this.S(i), this.c;
    } finally {
      this.F = {};
    }
  }
  async U(e, s, i, n) {
    try {
      if (((this.F = { ...n }), this.status === "hasConflicts")) return this.O.info(`${this.D}: Skipped synchronizing ${this.resource.toLowerCase()} as there are conflicts.`), this.c;
      if (this.status === "syncing") return this.O.info(`${this.D}: Skipped synchronizing ${this.resource.toLowerCase()} as it is running already.`), this.c;
      this.O.trace(`${this.D}: Started synchronizing ${this.resource.toLowerCase()}...`), this.S("syncing");
      let r = "idle";
      try {
        const o = await this.getLastSyncUserData(),
          a = await this.X(e, o);
        return (
          (r = await this.Y(a, o, s, i)),
          r === "hasConflicts" ? this.O.info(`${this.D}: Detected conflicts while synchronizing ${this.resource.toLowerCase()}.`) : r === "idle" && this.O.trace(`${this.D}: Finished synchronizing ${this.resource.toLowerCase()}.`),
          this.c || null
        );
      } finally {
        this.S(r);
      }
    } finally {
      this.F = {};
    }
  }
  async replace(e) {
    const s = this.kb(e);
    if (!s) return !1;
    await this.stop();
    try {
      this.O.trace(`${this.D}: Started resetting ${this.resource.toLowerCase()}...`), this.S("syncing");
      const i = await this.getLastSyncUserData(),
        n = await this.X(null, i),
        r = await this.W(n),
        o = await this.qb({ ref: n.ref, syncData: s }, i, r, this.ob(), J.None),
        a = [];
      for (const c of o) {
        const l = await this.sb(c, c.remoteResource, void 0, J.None),
          { remoteChange: h } = await this.sb(c, c.previewResource, c.remoteContent, J.None);
        a.push([c, { ...l, remoteChange: h !== 0 ? h : 2 }]);
      }
      await this.tb(n, i, a, !1), this.O.info(`${this.D}: Finished resetting ${this.resource.toLowerCase()}.`);
    } finally {
      this.S("idle");
    }
    return !0;
  }
  async W(e) {
    const s = await this.j;
    return !!e.syncData?.machineId && e.syncData.machineId === s;
  }
  async X(e, s) {
    if (s) {
      const i = e ? e[this.resource] : void 0;
      if (s.ref === i || (i === void 0 && s.syncData === null)) return s;
    }
    return this.getRemoteUserData(s);
  }
  async Y(e, s, i, n) {
    if (e.syncData && e.syncData.version > this.pb) throw (this.N.publicLog2("sync/incompatible", { source: this.resource }), new De(w(2747, null, this.resource, this.pb, e.syncData.version), "IncompatibleLocalContent", this.resource));
    try {
      return await this.Z(e, s, i, n);
    } catch (r) {
      if (r instanceof De)
        switch (r.code) {
          case "LocalPreconditionFailed":
            return this.O.info(`${this.D}: Failed to synchronize ${this.D} as there is a new local version available. Synchronizing again...`), this.Y(e, s, i, n);
          case "Conflict":
          case "PreconditionFailed":
            return this.O.info(`${this.D}: Failed to synchronize as there is a new remote version available. Synchronizing again...`), (e = await this.getRemoteUserData(null)), (s = await this.getLastSyncUserData()), this.Y(e, s, i, n);
        }
      throw r;
    }
  }
  async Z(e, s, i, n) {
    try {
      const r = await this.W(e),
        o = !r && s === null && this.gb() !== void 0,
        a = i && !o;
      this.c || (this.c = wt((l) => this.eb(e, s, r, a, n, l)));
      let c = await this.c;
      if (i && o) {
        this.O.info(`${this.D}: Accepting remote because it was synced before and the last sync data is not available.`);
        for (const l of c.resourcePreviews) c = (await this.accept(l.remoteResource)) || c;
      }
      return this.cb(c.resourcePreviews), c.resourcePreviews.some(({ mergeState: l }) => l === "conflict") ? "hasConflicts" : i ? await this.ab(!1) : "syncing";
    } catch (r) {
      throw ((this.c = null), r);
    }
  }
  async merge(e) {
    return (
      await this.$(e, async (s) => {
        const i = await this.rb(s, J.None);
        await this.G.writeFile(s.previewResource, L.fromString(i?.content || ""));
        const n = i && !i.hasConflicts ? await this.sb(s, s.previewResource, void 0, J.None) : void 0;
        return (s.acceptResult = n), (s.mergeState = i.hasConflicts ? "conflict" : n ? "accepted" : "preview"), (s.localChange = n ? n.localChange : i.localChange), (s.remoteChange = n ? n.remoteChange : i.remoteChange), s;
      }),
      this.c
    );
  }
  async accept(e, s) {
    return (
      await this.$(e, async (i) => {
        const n = await this.sb(i, e, s, J.None);
        return (i.acceptResult = n), (i.mergeState = "accepted"), (i.localChange = n.localChange), (i.remoteChange = n.remoteChange), i;
      }),
      this.c
    );
  }
  async discard(e) {
    return (
      await this.$(e, async (s) => {
        const i = await this.rb(s, J.None);
        return await this.G.writeFile(s.previewResource, L.fromString(i.content || "")), (s.acceptResult = void 0), (s.mergeState = "preview"), (s.localChange = i.localChange), (s.remoteChange = i.remoteChange), s;
      }),
      this.c
    );
  }
  async $(e, s) {
    if (!this.c) return;
    let i = await this.c;
    const n = i.resourcePreviews.findIndex(({ localResource: r, remoteResource: o, previewResource: a }) => this.h.isEqual(r, e) || this.h.isEqual(o, e) || this.h.isEqual(a, e));
    n !== -1 &&
      ((this.c = wt(async (r) => {
        const o = [...i.resourcePreviews];
        return (o[n] = await s(o[n])), { ...i, resourcePreviews: o };
      })),
      (i = await this.c),
      this.cb(i.resourcePreviews),
      i.resourcePreviews.some(({ mergeState: r }) => r === "conflict") ? this.S("hasConflicts") : this.S("syncing"));
  }
  async ab(e) {
    if (!this.c) return "idle";
    const s = await this.c;
    return s.resourcePreviews.some(({ mergeState: i }) => i === "conflict")
      ? "hasConflicts"
      : s.resourcePreviews.some(({ mergeState: i }) => i !== "accepted")
        ? "syncing"
        : (await this.tb(
            s.remoteUserData,
            s.lastSyncUserData,
            s.resourcePreviews.map((i) => [i, i.acceptResult]),
            e,
          ),
          (this.c = null),
          await this.bb(),
          "idle");
  }
  async bb() {
    try {
      await this.G.del(this.g, { recursive: !0 });
    } catch {}
  }
  cb(e) {
    const s = e.filter(({ mergeState: i }) => i === "conflict");
    _t(this.s, s, (i, n) => this.h.isEqual(i.previewResource, n.previewResource)) || ((this.s = s), this.t.fire(this.conflicts));
  }
  async hasPreviouslySynced() {
    const e = await this.getLastSyncUserData();
    return !!e && e.syncData !== null;
  }
  async db(e) {
    const s = this.c ? await this.c : null;
    if (s)
      for (const i of s.resourcePreviews) {
        if (this.h.isEqual(i.acceptedResource, e)) return i.acceptResult ? i.acceptResult.content : null;
        if (this.h.isEqual(i.remoteResource, e)) return i.remoteContent;
        if (this.h.isEqual(i.localResource, e)) return i.localContent;
        if (this.h.isEqual(i.baseResource, e)) return i.baseContent;
      }
    return null;
  }
  async resetLocal() {
    this.I.remove(this.z, -1);
    try {
      await this.G.del(this.y);
    } catch (e) {
      ct(e) !== 1 && this.O.error(e);
    }
  }
  async eb(e, s, i, n, r, o) {
    const a = await this.qb(e, s, i, r, o),
      c = [];
    for (const l of a) {
      const h = l.previewResource.with({ scheme: _, authority: "accepted" });
      if (l.localChange === 0 && l.remoteChange === 0) c.push({ ...l, acceptedResource: h, acceptResult: { content: null, localChange: 0, remoteChange: 0 }, mergeState: "accepted" });
      else {
        const u = n ? await this.rb(l, o) : void 0;
        if (o.isCancellationRequested) break;
        await this.G.writeFile(l.previewResource, L.fromString(u?.content || ""));
        const f = u && !u.hasConflicts ? await this.sb(l, l.previewResource, void 0, o) : void 0;
        c.push({
          ...l,
          acceptResult: f,
          mergeState: u?.hasConflicts ? "conflict" : f ? "accepted" : "preview",
          localChange: f ? f.localChange : u ? u.localChange : l.localChange,
          remoteChange: f ? f.remoteChange : u ? u.remoteChange : l.remoteChange,
        });
      }
    }
    return { syncResource: this.resource, profile: this.syncResource.profile, remoteUserData: e, lastSyncUserData: s, resourcePreviews: c, isLastSyncFromCurrentMachine: i };
  }
  async getLastSyncUserData() {
    let e = this.gb();
    if ((e || (e = await this.jb()), !e)) return this.O.info(`${this.D}: Last sync data state does not exist.`), null;
    const s = JSON.parse(e),
      i = this.M.getResourceSyncStateVersion(this.resource);
    if (((this.C = !!s.version && !!i && s.version !== i), this.C))
      return this.O.info(`${this.D}: Reset last sync state because last sync state version ${s.version} is not compatible with current sync state version ${i}.`), await this.resetLocal(), null;
    let n,
      r = 1;
    for (; n === void 0 && r++ < 6; )
      try {
        const o = await this.hb();
        o && (o.ref === s.ref ? (n = o.syncData) : this.O.info(`${this.D}: Last sync data stored locally is not same as the last sync state.`));
        break;
      } catch (o) {
        if (o instanceof et && o.fileOperationResult === 1) {
          this.O.info(`${this.D}: Last sync resource does not exist locally.`);
          break;
        } else {
          if (o instanceof De) throw o;
          this.O.error(o, r);
        }
      }
    if (n === void 0)
      try {
        const o = await this.J.resolveResourceContent(this.resource, s.ref, this.collection, this.F);
        (n = o === null ? null : this.kb(o)), await this.ib({ ref: s.ref, syncData: n });
      } catch (o) {
        if (o instanceof De && o.code === "NotFound") this.O.info(`${this.D}: Last sync resource does not exist remotely.`);
        else throw o;
      }
    return n === void 0 ? null : { ...s, syncData: n };
  }
  async fb(e, s = {}) {
    if (s.ref || s.version) throw new Error("Cannot have core properties as additional");
    const i = this.M.getResourceSyncStateVersion(this.resource),
      n = { ref: e.ref, version: i, ...s };
    this.I.store(this.z, JSON.stringify(n), -1, 1), await this.ib(e);
  }
  gb() {
    return this.I.get(this.z, -1);
  }
  async hb() {
    const e = (await this.G.readFile(this.y)).value.toString();
    try {
      const s = e ? JSON.parse(e) : void 0;
      if (R7(s)) return s;
    } catch (s) {
      this.O.error(s);
    }
  }
  async ib(e) {
    await this.G.writeFile(this.y, L.fromString(JSON.stringify(e)));
  }
  async jb() {
    try {
      const e = await this.G.readFile(this.y),
        s = JSON.parse(e.value.toString());
      await this.G.del(this.y),
        s.ref && s.content !== void 0
          ? (this.I.store(this.z, JSON.stringify({ ...s, content: void 0 }), -1, 1), await this.ib({ ref: s.ref, syncData: s.content === null ? null : JSON.parse(s.content) }))
          : this.O.info(`${this.D}: Migrating last sync user data. Invalid data.`, s);
    } catch (e) {
      e instanceof et && e.fileOperationResult === 1 ? this.O.info(`${this.D}: Migrating last sync user data. Resource does not exist.`) : this.O.error(e);
    }
    return this.I.get(this.z, -1);
  }
  async getRemoteUserData(e) {
    const { ref: s, content: i } = await this.lb(e);
    let n = null;
    return i !== null && (n = this.kb(i)), { ref: s, syncData: n };
  }
  kb(e) {
    try {
      const s = JSON.parse(e);
      if (jr(s)) return s;
    } catch (s) {
      this.O.error(s);
    }
    throw new De(w(2748, null), "IncompatibleRemoteContent", this.resource);
  }
  async lb(e) {
    const s = e ? { ref: e.ref, content: e.syncData ? JSON.stringify(e.syncData) : null } : null;
    return this.J.readResource(this.resource, s, this.collection, this.F);
  }
  async mb(e, s) {
    const i = await this.j,
      n = { version: this.pb, machineId: i, content: e };
    try {
      return (s = await this.J.writeResource(this.resource, JSON.stringify(n), s, this.collection, this.F)), { ref: s, syncData: n };
    } catch (r) {
      throw (r instanceof De && r.code === "TooLarge" && (r = new De(r.message, r.code, this.resource)), r);
    }
  }
  async nb(e) {
    const s = { version: this.pb, content: e };
    return this.L.writeResource(this.resource, JSON.stringify(s), new Date(), this.syncResource.profile.isDefault ? void 0 : this.syncResource.profile.id);
  }
  async stop() {
    this.status !== "idle" &&
      (this.O.trace(`${this.D}: Stopping synchronizing ${this.resource.toLowerCase()}.`),
      this.c && (this.c.cancel(), (this.c = null)),
      this.cb([]),
      await this.bb(),
      this.S("idle"),
      this.O.info(`${this.D}: Stopped synchronizing ${this.resource.toLowerCase()}.`));
  }
  ob() {
    return this.P.getValue(Sa);
  }
};
qi = __decorate([__param(2, ie), __param(3, fe), __param(4, ae), __param(5, St), __param(6, ts), __param(7, jt), __param(8, Se), __param(9, Pe), __param(10, Ce), __param(11, ke)], qi);
var La = class extends qi {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f, d) {
    super(s, i, n, r, o, a, c, l, h, u, f, d), (this.r = e), this.B(this.G.watch(this.h.dirname(e))), this.B(this.G.onDidFilesChange((p) => this.yb(p)));
  }
  async vb() {
    try {
      return await this.G.readFile(this.r);
    } catch {
      return null;
    }
  }
  async wb(e, s, i) {
    try {
      s ? await this.G.writeFile(this.r, L.fromString(e), i ? void 0 : s) : await this.G.createFile(this.r, L.fromString(e), { overwrite: i });
    } catch (n) {
      throw (n instanceof et && n.fileOperationResult === 1) || (n instanceof et && n.fileOperationResult === 3) ? new De(n.message, "LocalPreconditionFailed") : n;
    }
  }
  async xb() {
    try {
      await this.G.del(this.r);
    } catch (e) {
      if (!(e instanceof et && e.fileOperationResult === 1)) throw e;
    }
  }
  yb(e) {
    e.contains(this.r) && this.Q();
  }
};
La = __decorate([__param(3, ie), __param(4, fe), __param(5, ae), __param(6, St), __param(7, ts), __param(8, jt), __param(9, Se), __param(10, Pe), __param(11, Ce), __param(12, ke)], La);
var Na = class extends La {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f, d, p) {
    super(e, s, i, n, r, o, a, c, l, h, u, d, p), (this.zb = f), (this.Bb = void 0);
  }
  Ab(e, s) {
    const i = [],
      n = it(e, i, { allowEmptyContent: !0, allowTrailingComma: !0 });
    return i.length > 0 || (!Ct(n) && s !== Array.isArray(n));
  }
  Cb() {
    return this.Bb || (this.Bb = this.zb.resolveFormattingOptions(this.r)), this.Bb;
  }
};
Na = __decorate([__param(3, ie), __param(4, fe), __param(5, ae), __param(6, St), __param(7, ts), __param(8, jt), __param(9, Se), __param(10, Pe), __param(11, Ca), __param(12, Ce), __param(13, ke)], Na);
var fi = class {
  constructor(e, s, i, n, r, o, a) {
    (this.resource = e), (this.g = s), (this.h = i), (this.j = n), (this.k = r), (this.l = o), (this.d = a.extUri), (this.f = s0(void 0, this.resource, i, this.d));
  }
  async initialize({ ref: e, content: s }) {
    if (!s) {
      this.j.info("Remote content does not exist.", this.resource);
      return;
    }
    const i = this.m(s);
    if (i)
      try {
        await this.o({ ref: e, syncData: i });
      } catch (n) {
        this.j.error(n);
      }
  }
  m(e) {
    try {
      const s = JSON.parse(e);
      if (jr(s)) return s;
    } catch (s) {
      this.j.error(s);
    }
    this.j.info("Cannot parse sync data as it is not compatible with the current version.", this.resource);
  }
  async n(e, s = {}) {
    if (s.ref || s.version) throw new Error("Cannot have core properties as additional");
    const i = { ref: e.ref, version: void 0, ...s };
    this.l.store(`${this.resource}.lastSyncUserData`, JSON.stringify(i), -1, 1), await this.k.writeFile(this.f, L.fromString(JSON.stringify(e)));
  }
};
fi = __decorate([__param(1, Te), __param(2, fe), __param(3, ne), __param(4, ie), __param(5, ae), __param(6, ke)], fi);
function Ta(t, e, s, i, n, r) {
  const o = [],
    a = [],
    c = [];
  if (!e) {
    const k = t.filter(({ identifier: I }) => n.every((H) => H.toLowerCase() !== I.id.toLowerCase()));
    return { local: { added: o, removed: a, updated: c }, remote: k.length > 0 ? { added: k, updated: [], removed: [], all: k } : null };
  }
  (t = t.map(ru)), (e = e.map(ru)), (s = s ? s.map(ru) : null);
  const l = new Map(),
    h = (k) => {
      k.uuid && l.set(k.id.toLowerCase(), k.uuid);
    };
  t.forEach(({ identifier: k }) => h(k)), e.forEach(({ identifier: k }) => h(k)), s?.forEach(({ identifier: k }) => h(k)), i?.forEach(({ identifier: k }) => h(k)), r?.forEach((k) => h(k));
  const u = (k) => {
      const I = k.identifier.uuid || l.get(k.identifier.id.toLowerCase());
      return I ? `uuid:${I}` : `id:${k.identifier.id.toLowerCase()}`;
    },
    f = (k, I) => (k.set(u(I), I), k),
    d = t.reduce(f, new Map()),
    p = e.reduce(f, new Map()),
    g = e.reduce((k, I) => f(k, rs(I)), new Map()),
    m = s ? s.reduce(f, new Map()) : null,
    v = i.reduce(f, new Map()),
    b = n.reduce((k, I) => {
      const H = l.get(I.toLowerCase());
      return k.add(H ? `uuid:${H}` : `id:${I.toLowerCase()}`);
    }, new Set()),
    E = r ? r.reduce((k, { id: I, uuid: H }) => ((H = H ?? l.get(I.toLowerCase())), k.add(H ? `uuid:${H}` : `id:${I.toLowerCase()}`)), new Set()) : null,
    $ = ja(d, p, b, !1);
  if ($.added.size > 0 || $.removed.size > 0 || $.updated.size > 0) {
    const k = ja(m, d, b, !1),
      I = ja(m, p, b, !0),
      H = (B, j, Z, A) => {
        let R, F, N;
        return (
          j.installed ? ((R = A.pinned), (N = A.preRelease), R && (F = A.version)) : ((R = Z.pinned), (N = Z.preRelease), R && (F = Z.version)),
          R === void 0 && ((R = j.pinned), R && (F = j.version)),
          N === void 0 && (N = j.preRelease),
          { ...A, installed: j.installed || Z.installed, pinned: R, preRelease: N, version: F ?? (Z.version && (!j.installed || aa(Z.version, j.version)) ? Z.version : j.version), state: P7(j, Z, m?.get(B)) }
        );
      };
    for (const B of I.removed.values()) {
      const j = d.get(B);
      if (!j) continue;
      const Z = ls(m?.get(B)),
        A = E && !E.has(B) && Z.installed;
      j.installed && A ? a.push(j.identifier) : g.set(B, j);
    }
    for (const B of I.added.values()) {
      const j = ls(p.get(B)),
        Z = d.get(B);
      if (Z) {
        if ($.updated.has(B)) {
          const A = H(B, Z, j, j);
          d0(Z, j, !1, !1) || c.push(Fr(A, B)), g.set(B, A);
        }
      } else j.installed && o.push(Fr(j, B));
    }
    for (const B of I.updated.values()) {
      const j = ls(p.get(B)),
        Z = ls(m?.get(B)),
        A = d.get(B);
      if (A)
        if (E && !E.has(B) && Z.installed && A.installed && !j.installed) a.push(A.identifier);
        else {
          const F = H(B, A, j, j);
          c.push(Fr(F, B)), g.set(B, F);
        }
      else j.installed && o.push(Fr(j, B));
    }
    for (const B of k.added.values()) I.added.has(B) || g.set(B, ls(d.get(B)));
    for (const B of k.updated.values()) {
      if (I.removed.has(B) || I.updated.has(B)) continue;
      const j = ls(d.get(B)),
        Z = ls(p.get(B));
      g.set(B, H(B, j, Z, j));
    }
    for (const B of k.removed.values()) I.updated.has(B) || I.removed.has(B) || v.has(B) || (ls(p.get(B)).installed && E && (E.has(B) || !ls(m?.get(B)).installed || g.delete(B)));
  }
  const P = [],
    U = ja(p, g, new Set(), !0),
    Q = U.added.size > 0 || U.updated.size > 0 || U.removed.size > 0;
  return (
    Q && g.forEach((k, I) => P.push(Fr(k, I))),
    { local: { added: o, removed: a, updated: c }, remote: Q ? { added: [...U.added].map((k) => g.get(k)), updated: [...U.updated].map((k) => g.get(k)), removed: [...U.removed].map((k) => p.get(k)), all: P } : null }
  );
}
function ja(t, e, s, i) {
  const n = t ? [...t.keys()].filter((l) => !s.has(l)) : [],
    r = [...e.keys()].filter((l) => !s.has(l)),
    o = r.filter((l) => !n.includes(l)).reduce((l, h) => (l.add(h), l), new Set()),
    a = n.filter((l) => !r.includes(l)).reduce((l, h) => (l.add(h), l), new Set()),
    c = new Set();
  for (const l of n) {
    if (a.has(l)) continue;
    const h = t.get(l),
      u = e.get(l);
    (!u || !d0(h, u, i, !0)) && c.add(l);
  }
  return { added: o, removed: a, updated: c };
}
function d0(t, e, s, i) {
  return !(
    t.disabled !== e.disabled ||
    !!t.isApplicationScoped != !!e.isApplicationScoped ||
    (i && t.installed !== e.installed) ||
    (t.installed && e.installed && (t.preRelease !== e.preRelease || t.pinned !== e.pinned || (e.pinned && t.version !== e.version))) ||
    !A7(t.state, e.state) ||
    (s && t.version !== e.version)
  );
}
function P7(t, e, s) {
  const i = t.state,
    n = e.state,
    r = s?.state;
  if (!e.version || (i && aa(t.version, e.version))) return i;
  if ((n && aa(e.version, t.version)) || !i) return n;
  if (!n) return i;
  const o = rs(i),
    a = r ? nu(r, n) : { added: Object.keys(n).reduce((l, h) => (l.add(h), l), new Set()), removed: new Set(), updated: new Set() },
    c = r ? nu(r, i) : { added: Object.keys(i).reduce((l, h) => (l.add(h), l), new Set()), removed: new Set(), updated: new Set() };
  for (const l of [...a.added.values(), ...a.updated.values()]) o[l] = n[l];
  for (const l of a.removed.values()) c.updated.has(l) || delete o[l];
  return o;
}
function nu(t, e) {
  const s = Object.keys(t),
    i = Object.keys(e),
    n = i.filter((a) => !s.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    r = s.filter((a) => !i.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    o = new Set();
  for (const a of s) {
    if (r.has(a)) continue;
    const c = t[a],
      l = e[a];
    Rt(c, l) || o.add(a);
  }
  return { added: n, removed: r, updated: o };
}
function A7(t = {}, e = {}) {
  const { added: s, removed: i, updated: n } = nu(t, e);
  return s.size === 0 && i.size === 0 && n.size === 0;
}
function ru(t) {
  return { ...t, disabled: !!t.disabled, installed: !!t.installed };
}
function Fr(t, e) {
  const s = { ...t, identifier: { id: t.identifier.id, uuid: e.startsWith("uuid:") ? e.substring(5) : void 0 }, preRelease: !!t.preRelease, pinned: !!t.pinned };
  return t.disabled || delete s.disabled, t.installed || delete s.installed, t.state || delete s.state, t.isApplicationScoped || delete s.isApplicationScoped, s;
}
var Mr = z("IUserDataProfileStorageService"),
  ou = class extends O {
    constructor(e, s) {
      super(), (this.b = s), e && (this.a = this.B(new po()));
    }
    async readStorageData(e) {
      return this.withProfileScopedStorageService(e, async (s) => this.c(s));
    }
    async updateStorageData(e, s, i) {
      return this.withProfileScopedStorageService(e, async (n) => this.f(n, s, i));
    }
    async withProfileScopedStorageService(e, s) {
      if (this.b.hasScope(e)) return s(this.b);
      let i = this.a?.get(e.id);
      if (!i) {
        (i = new L7(this.g(e))), this.a?.set(e.id, i);
        try {
          await i.initialize();
        } catch (n) {
          throw (this.a?.has(e.id) ? this.a.deleteAndDispose(e.id) : i.dispose(), n);
        }
      }
      try {
        const n = await s(i);
        return await i.flush(), n;
      } finally {
        this.a?.has(e.id) || i.dispose();
      }
    }
    c(e) {
      const s = new Map(),
        i = (n) => {
          for (const r of e.keys(0, n)) s.set(r, { value: e.get(r, 0), target: n });
        };
      return i(0), i(1), s;
    }
    f(e, s, i) {
      e.storeAll(
        Array.from(s.entries()).map(([n, r]) => ({ key: n, value: r, scope: 0, target: i })),
        !0,
      );
    }
  };
ou = __decorate([__param(1, ae)], ou);
var O7 = class extends ou {
    constructor(t, e, s, i, n) {
      super(t, i), (this.j = e);
      const r = e.getChannel("profileStorageListener"),
        o = this.B(new Es());
      (this.h = this.B(
        new D({
          onWillAddFirstListener: () => {
            o.value = r.listen("onDidChange")((a) => {
              n.trace("profile storage changes", a),
                this.h.fire({ targetChanges: a.targetChanges.map((c) => es(c, s.profilesHome.scheme)), valueChanges: a.valueChanges.map((c) => ({ ...c, profile: es(c.profile, s.profilesHome.scheme) })) });
            });
          },
          onDidRemoveLastListener: () => (o.value = void 0),
        }),
      )),
        (this.onDidChange = this.h.event);
    }
    async g(t) {
      const e = this.j.getChannel("storage");
      return na(t) ? new _1(e) : new B1(e, t);
    }
  },
  L7 = class extends eg {
    constructor(t) {
      super({ flushInterval: 100 }), (this.X = t);
    }
    async Q() {
      const t = await this.X,
        e = new ta(t);
      return (
        this.B(
          e.onDidChangeStorage((s) => {
            this.u(0, s);
          }),
        ),
        this.B(
          ue(() => {
            e.close(), e.dispose(), td(t) && t.dispose();
          }),
        ),
        (this.s = e),
        this.s.init()
      );
    }
    R(t) {
      return t === 0 ? this.s : void 0;
    }
    S() {}
    async U() {}
    async W() {}
    hasScope() {
      return !1;
    }
  };
async function Fa(t, e) {
  const s = JSON.parse(t.content);
  if (t.version === 1 || t.version === 2) {
    const i = (await e.getInstalled(0)).filter((n) => n.isBuiltin);
    for (const n of s) t.version === 1 && (n.enabled === !1 && (n.disabled = !0), delete n.enabled), t.version === 2 && i.every((r) => !G(r.identifier, n.identifier)) && (n.installed = !0);
  }
  return s;
}
function N7(t) {
  return JSON.parse(t.content);
}
function au(t, e) {
  return t.sort((s, i) => (!s.identifier.uuid && i.identifier.uuid ? -1 : s.identifier.uuid && !i.identifier.uuid ? 1 : Eo(s.identifier.id, i.identifier.id))), e ? yr(t, {}) : JSON.stringify(t);
}
var cu = class extends qi {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f, d, p, g, m, v) {
    super({ syncResource: "extensions", profile: e }, s, n, i, r, o, a, f, d, h, u, g),
      (this.Cb = c),
      (this.Db = l),
      (this.Eb = v),
      (this.pb = 6),
      (this.wb = this.h.joinPath(this.g, "extensions.json")),
      (this.xb = this.wb.with({ scheme: _, authority: "base" })),
      (this.yb = this.wb.with({ scheme: _, authority: "local" })),
      (this.zb = this.wb.with({ scheme: _, authority: "remote" })),
      (this.Ab = this.wb.with({ scheme: _, authority: "accepted" })),
      (this.Bb = this.Eb.createInstance(Ma)),
      this.B(
        T.any(
          T.filter(this.Cb.onDidInstallExtensions, (b) => b.some(({ local: E }) => !!E)),
          T.filter(this.Cb.onDidUninstallExtension, (b) => !b.error),
          T.filter(m.onDidChange, (b) => b.valueChanges.some(({ profile: E, changes: $ }) => this.syncResource.profile.id === E.id && $.some((P) => P.key === vl))),
          p.onDidChangeExtensionStorageToSync,
        )(() => this.Q()),
      );
  }
  async qb(e, s) {
    const i = e.syncData ? await Fa(e.syncData, this.Cb) : null,
      n = s?.skippedExtensions ?? [],
      r = s?.builtinExtensions ?? null,
      o = s?.syncData ? await Fa(s.syncData, this.Cb) : null,
      { localExtensions: a, ignoredExtensions: c } = await this.Bb.getLocalExtensions(this.syncResource.profile);
    i ? this.O.trace(`${this.D}: Merging remote extensions with local extensions...`) : this.O.trace(`${this.D}: Remote extensions does not exist. Synchronizing extensions for the first time.`);
    const { local: l, remote: h } = Ta(a, i, o, n, c, r),
      u = { local: l, remote: h, content: this.Hb(a, l.added, l.updated, l.removed), localChange: l.added.length > 0 || l.removed.length > 0 || l.updated.length > 0 ? 2 : 0, remoteChange: h !== null ? 2 : 0 },
      f = this.Ob(a, !1);
    return [
      {
        skippedExtensions: n,
        builtinExtensions: r,
        baseResource: this.xb,
        baseContent: o ? this.Ob(o, !1) : f,
        localResource: this.yb,
        localContent: f,
        localExtensions: a,
        remoteResource: this.zb,
        remoteExtensions: i,
        remoteContent: i ? this.Ob(i, !1) : null,
        previewResource: this.wb,
        previewResult: u,
        localChange: u.localChange,
        remoteChange: u.remoteChange,
        acceptedResource: this.Ab,
      },
    ];
  }
  async ub(e) {
    const s = e.syncData ? await Fa(e.syncData, this.Cb) : null,
      { localExtensions: i, ignoredExtensions: n } = await this.Bb.getLocalExtensions(this.syncResource.profile),
      { remote: r } = Ta(i, s, s, e.skippedExtensions || [], n, e.builtinExtensions || []);
    return r !== null;
  }
  Hb(e, s, i, n) {
    const r = [...s, ...i],
      o = new Set(),
      a = (c) => {
        o.add(c.id.toLowerCase()), c.uuid && o.add(c.uuid);
      };
    r.forEach(({ identifier: c }) => a(c)), n.forEach(a);
    for (const c of e) o.has(c.identifier.id.toLowerCase()) || (c.identifier.uuid && o.has(c.identifier.uuid)) || r.push(c);
    return this.Ob(r, !1);
  }
  async rb(e, s) {
    return { ...e.previewResult, hasConflicts: !1 };
  }
  async sb(e, s, i, n) {
    if (this.h.isEqual(s, this.yb)) return this.Kb(e);
    if (this.h.isEqual(s, this.zb)) return this.Lb(e);
    if (this.h.isEqual(s, this.wb)) return e.previewResult;
    throw new Error(`Invalid Resource: ${s.toString()}`);
  }
  async Kb(e) {
    const s = await this.Cb.getInstalled(void 0, this.syncResource.profile.extensionsResource),
      i = this.Db.getIgnoredExtensions(s),
      n = Ta(e.localExtensions, null, null, e.skippedExtensions, i, e.builtinExtensions),
      { local: r, remote: o } = n;
    return { content: e.localContent, local: r, remote: o, localChange: r.added.length > 0 || r.removed.length > 0 || r.updated.length > 0 ? 2 : 0, remoteChange: o !== null ? 2 : 0 };
  }
  async Lb(e) {
    const s = await this.Cb.getInstalled(void 0, this.syncResource.profile.extensionsResource),
      i = this.Db.getIgnoredExtensions(s),
      n = e.remoteContent ? JSON.parse(e.remoteContent) : null;
    if (n !== null) {
      const r = Ta(e.localExtensions, n, e.localExtensions, [], i, e.builtinExtensions),
        { local: o, remote: a } = r;
      return { content: e.remoteContent, local: o, remote: a, localChange: o.added.length > 0 || o.removed.length > 0 || o.updated.length > 0 ? 2 : 0, remoteChange: a !== null ? 2 : 0 };
    } else return { content: e.remoteContent, local: { added: [], removed: [], updated: [] }, remote: null, localChange: 0, remoteChange: 0 };
  }
  async tb(e, s, i, n) {
    let { skippedExtensions: r, builtinExtensions: o, localExtensions: a } = i[0][0];
    const { local: c, remote: l, localChange: h, remoteChange: u } = i[0][1];
    if (
      (h === 0 && u === 0 && this.O.info(`${this.D}: No changes found during synchronizing extensions.`),
      h !== 0 && (await this.nb(JSON.stringify(a)), (r = await this.Bb.updateLocalExtensions(c.added, c.removed, c.updated, r, this.syncResource.profile))),
      l)
    ) {
      this.O.trace(`${this.D}: Updating remote extensions...`);
      const f = JSON.stringify(l.all);
      (e = await this.mb(f, n ? null : e.ref)),
        this.O.info(
          `${this.D}: Updated remote extensions.${l.added.length ? ` Added: ${JSON.stringify(l.added.map((d) => d.identifier.id))}.` : ""}${l.updated.length ? ` Updated: ${JSON.stringify(l.updated.map((d) => d.identifier.id))}.` : ""}${l.removed.length ? ` Removed: ${JSON.stringify(l.removed.map((d) => d.identifier.id))}.` : ""}`,
        );
    }
    s?.ref !== e.ref &&
      (this.O.trace(`${this.D}: Updating last synchronized extensions...`),
      (o = this.Nb(a, o)),
      await this.fb(e, { skippedExtensions: r, builtinExtensions: o }),
      this.O.info(`${this.D}: Updated last synchronized extensions.${r.length ? ` Skipped: ${JSON.stringify(r.map((f) => f.identifier.id))}.` : ""}`));
  }
  Nb(e, s) {
    const i = new Set(),
      n = [];
    for (const r of e) i.add(r.identifier.id.toLowerCase()), r.installed || n.push(r.identifier);
    if (s) for (const r of s) i.has(r.id.toLowerCase()) || n.push(r);
    return n;
  }
  async resolveContent(e) {
    if (this.h.isEqual(this.zb, e) || this.h.isEqual(this.xb, e) || this.h.isEqual(this.yb, e) || this.h.isEqual(this.Ab, e)) {
      const s = await this.db(e);
      return s && this.Ob(JSON.parse(s), !0);
    }
    return null;
  }
  Ob(e, s) {
    return au(e, s);
  }
  async hasLocalData() {
    try {
      const { localExtensions: e } = await this.Bb.getLocalExtensions(this.syncResource.profile);
      if (e.some((s) => s.installed || s.disabled)) return !0;
    } catch {}
    return !1;
  }
};
cu = __decorate(
  [
    __param(2, fe),
    __param(3, ie),
    __param(4, ae),
    __param(5, St),
    __param(6, ts),
    __param(7, Vs),
    __param(8, Ea),
    __param(9, Pe),
    __param(10, Ce),
    __param(11, jt),
    __param(12, Se),
    __param(13, _h),
    __param(14, ke),
    __param(15, Mr),
    __param(16, ds),
  ],
  cu,
);
var Ma = class {
  constructor(e, s, i, n, r, o) {
    (this.a = e), (this.b = s), (this.c = i), (this.d = n), (this.f = r), (this.g = o);
  }
  async getLocalExtensions(e) {
    const s = await this.a.getInstalled(void 0, e.extensionsResource),
      i = this.d.getIgnoredExtensions(s);
    return {
      localExtensions: await this.j(e, async (r, o) => {
        const a = r.getDisabledExtensions();
        return s.map((c) => {
          const { identifier: l, isBuiltin: h, manifest: u, preRelease: f, pinned: d, isApplicationScoped: p } = c,
            g = { identifier: l, preRelease: f, version: u.version, pinned: !!d };
          p && !Ql(u) && (g.isApplicationScoped = p), a.some((m) => G(m, l)) && (g.disabled = !0), h || (g.installed = !0);
          try {
            const m = o.getKeysForSync({ id: l.id, version: u.version });
            if (m) {
              const v = o.getExtensionState(c, !0) || {};
              g.state = Object.keys(v).reduce((b, E) => (m.includes(E) && (b[E] = v[E]), b), {});
            }
          } catch (m) {
            this.g.info(`${Oa("extensions", e)}: Error while parsing extension state`, ve(m));
          }
          return g;
        });
      }),
      ignoredExtensions: i,
    };
  }
  async updateLocalExtensions(e, s, i, n, r) {
    const o = Oa("extensions", r),
      a = [],
      c = new Map(),
      l = [],
      h = [],
      u = await this.a.getInstalled(void 0, r.extensionsResource);
    if (
      ((e.length || i.length) &&
        (await this.j(r, async (p, g) => {
          await Ze.settled(
            [...e, ...i].map(async (m) => {
              const v = u.find(($) => G($.identifier, m.identifier));
              if (v && v.isBuiltin) {
                m.state && v.manifest.version === m.version && this.h(m.state, v, v.manifest.version, g),
                  p.getDisabledExtensions().some((P) => G(P, m.identifier)) !== !!m.disabled &&
                    (m.disabled
                      ? (this.g.trace(`${o}: Disabling extension...`, m.identifier.id), await p.disableExtension(m.identifier), this.g.info(`${o}: Disabled extension`, m.identifier.id))
                      : (this.g.trace(`${o}: Enabling extension...`, m.identifier.id), await p.enableExtension(m.identifier), this.g.info(`${o}: Enabled extension`, m.identifier.id))),
                  l.push(m.identifier);
                return;
              }
              const b = m.pinned ? m.version : void 0,
                E = (await this.c.getExtensions([{ ...m.identifier, version: b, preRelease: b ? void 0 : m.preRelease }], J.None))[0];
              if ((m.state && (v ? v.manifest.version === m.version : E) && this.h(m.state, v || E, v?.manifest.version, g), E))
                try {
                  p.getDisabledExtensions().some((P) => G(P, m.identifier)) !== !!m.disabled &&
                    (m.disabled
                      ? (this.g.trace(`${o}: Disabling extension...`, m.identifier.id, E.version), await p.disableExtension(E.identifier), this.g.info(`${o}: Disabled extension`, m.identifier.id, E.version))
                      : (this.g.trace(`${o}: Enabling extension...`, m.identifier.id, E.version), await p.enableExtension(E.identifier), this.g.info(`${o}: Enabled extension`, m.identifier.id, E.version))),
                    (!v || v.preRelease !== m.preRelease || v.pinned !== m.pinned || (b && v.manifest.version !== b)) &&
                      ((await this.a.canInstall(E))
                        ? (a.push({
                            extension: E,
                            options: {
                              isMachineScoped: !1,
                              donotIncludePackAndDependencies: !0,
                              installGivenVersion: m.pinned && !!m.version,
                              pinned: m.pinned,
                              installPreReleaseVersion: m.preRelease,
                              profileLocation: r.extensionsResource,
                              isApplicationScoped: m.isApplicationScoped,
                              context: { [W4]: !0, [ml]: "settingsSync" },
                            },
                          }),
                          c.set(E.identifier.id.toLowerCase(), m))
                        : (this.g.info(`${o}: Skipped synchronizing extension because it cannot be installed.`, E.displayName || E.identifier.id), h.push(m)));
                } catch ($) {
                  h.push(m), this.g.error($), this.g.info(`${o}: Skipped synchronizing extension`, E.displayName || E.identifier.id);
                }
              else h.push(m), this.g.info(`${o}: Skipped synchronizing extension because the extension is not found.`, m.identifier.id);
            }),
          );
        })),
      s.length)
    ) {
      const p = u.filter(({ identifier: g, isBuiltin: m }) => !m && s.some((v) => G(g, v)));
      await Ze.settled(
        p.map(async (g) => {
          this.g.trace(`${o}: Uninstalling local extension...`, g.identifier.id),
            await this.a.uninstall(g, { donotIncludePack: !0, donotCheckDependents: !0, profileLocation: r.extensionsResource }),
            this.g.info(`${o}: Uninstalled local extension.`, g.identifier.id),
            l.push(g.identifier);
        }),
      );
    }
    const f = await this.a.installGalleryExtensions(a);
    for (const { identifier: p, local: g, error: m, source: v } of f) {
      const b = v;
      if (g) this.g.info(`${o}: Installed extension.`, p.id, b.version), l.push(p);
      else {
        const E = c.get(p.id.toLowerCase());
        E && (h.push(E), this.g.info(`${o}: Skipped synchronizing extension`, b.displayName || b.identifier.id)),
          m instanceof Ne && ["Incompatible", "IncompatibleApi", "IncompatibleTargetPlatform"].includes(m.code)
            ? this.g.info(`${o}: Skipped synchronizing extension because the compatible extension is not found.`, b.displayName || b.identifier.id)
            : m && this.g.error(m);
      }
    }
    const d = [];
    for (const p of n) l.some((g) => G(g, p.identifier)) || d.push(p);
    for (const p of h) d.some((g) => G(g.identifier, p.identifier)) || d.push(p);
    return d;
  }
  h(e, s, i, n) {
    const r = n.getExtensionState(s, !0) || {},
      o = i ? n.getKeysForSync({ id: s.identifier.id, version: i }) : void 0;
    o
      ? o.forEach((a) => {
          r[a] = e[a];
        })
      : Object.keys(e).forEach((a) => (r[a] = e[a])),
      n.setExtensionState(s, r, !0);
  }
  async j(e, s) {
    return this.b.withProfileScopedStorageService(e, async (i) => {
      const n = new ye(),
        r = n.add(this.f.createChild(new Nh([ae, i]))),
        o = n.add(r.createInstance(ra)),
        a = n.add(r.createInstance(Tr));
      try {
        return await s(o, a);
      } finally {
        n.dispose();
      }
    });
  }
};
Ma = __decorate([__param(0, Vs), __param(1, Mr), __param(2, ps), __param(3, Ea), __param(4, ds), __param(5, Pe)], Ma);
var p0 = class extends fi {
  constructor(e, s, i, n, r, o, a, c) {
    super("extensions", n, r, o, i, a, c), (this.p = e), (this.q = s);
  }
  async t(e) {
    return e.syncData ? await Fa(e.syncData, this.p) : null;
  }
  u(e, s) {
    const i = [],
      n = [],
      r = [];
    for (const o of e) {
      if (this.q.hasToNeverSyncExtension(o.identifier.id)) continue;
      const a = s.find((c) => G(c.identifier, o.identifier));
      a ? (i.push(a), o.disabled && r.push(o.identifier)) : o.installed && (n.push({ ...o.identifier, preRelease: !!o.preRelease }), o.disabled && r.push(o.identifier));
    }
    return { installedExtensions: i, newExtensions: n, disabledExtensions: r, remoteExtensions: e };
  }
};
p0 = __decorate([__param(0, Vs), __param(1, Ea), __param(2, ie), __param(3, Te), __param(4, fe), __param(5, ne), __param(6, ae), __param(7, ke)], p0);
function Kt(t, e, s, i) {
  const n = jl(t, e, s, i)[0];
  return n && (t = t.substring(0, n.offset) + n.content + t.substring(n.offset + n.length)), t;
}
function lu(t, e, s, i, n) {
  if (!e) return { remote: { added: Object.keys(t), removed: [], updated: [], all: Object.keys(t).length > 0 ? t : null }, local: { added: {}, removed: [], updated: {} } };
  const r = Ua(t, e);
  if (r.added.size === 0 && r.removed.size === 0 && r.updated.size === 0) return { remote: { added: [], removed: [], updated: [], all: null }, local: { added: {}, removed: [], updated: {} } };
  const o = s ? Ua(s, e) : { added: Object.keys(e).reduce((f, d) => (f.add(d), f), new Set()), removed: new Set(), updated: new Set() },
    a = s ? Ua(s, t) : { added: Object.keys(t).reduce((f, d) => (f.add(d), f), new Set()), removed: new Set(), updated: new Set() },
    c = { added: {}, removed: [], updated: {} },
    l = rs(e),
    h = !s;
  for (const f of a.added.values()) (f !== ui && h && o.added.has(f)) || (l[f] = t[f]);
  for (const f of a.updated.values()) l[f] = t[f];
  for (const f of a.removed.values()) i.unregistered.includes(f) || delete l[f];
  for (const f of o.added.values()) {
    const d = e[f];
    if (i.machine.includes(f)) {
      n.info(`GlobalState: Skipped adding ${f} in local storage because it is declared as machine scoped.`);
      continue;
    }
    if (s && a.added.has(f)) continue;
    const p = t[f];
    (p && p.value === d.value) || (f === ui && h && a.added.has(f)) || (p ? (c.updated[f] = d) : (c.added[f] = d));
  }
  for (const f of o.updated.values()) {
    const d = e[f];
    if (i.machine.includes(f)) {
      n.info(`GlobalState: Skipped updating ${f} in local storage because it is declared as machine scoped.`);
      continue;
    }
    if (a.updated.has(f) || a.removed.has(f)) continue;
    const p = t[f];
    (p && p.value === d.value) || (c.updated[f] = d);
  }
  for (const f of o.removed.values()) {
    if (i.machine.includes(f)) {
      n.trace(`GlobalState: Skipped removing ${f} in local storage because it is declared as machine scoped.`);
      continue;
    }
    a.updated.has(f) || a.removed.has(f) || c.removed.push(f);
  }
  const u = Ua(e, l);
  return { local: c, remote: { added: [...u.added], updated: [...u.updated], removed: [...u.removed], all: u.added.size === 0 && u.removed.size === 0 && u.updated.size === 0 ? null : l } };
}
function Ua(t, e) {
  const s = Object.keys(t),
    i = Object.keys(e),
    n = i.filter((a) => !s.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    r = s.filter((a) => !i.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    o = new Set();
  for (const a of s) {
    if (r.has(a)) continue;
    const c = t[a],
      l = e[a];
    Rt(c, l) || o.add(a);
  }
  return { added: n, removed: r, updated: o };
}
var Vi = "globalState.argv.",
  T7 = ["locale"];
function Wi(t, e) {
  const s = t.storage ? Object.keys(t.storage).sort() : [],
    i = {};
  return s.forEach((n) => (i[n] = t.storage[n])), (t.storage = i), e ? yr(t, {}) : JSON.stringify(t);
}
var hu = 1,
  uu = class extends qi {
    constructor(e, s, i, n, r, o, a, c, l, h, u, f, d, p) {
      super({ syncResource: "globalState", profile: e }, s, n, c, f, r, o, l, h, a, u, d),
        (this.Bb = i),
        (this.pb = hu),
        (this.vb = this.h.joinPath(this.g, "globalState.json")),
        (this.wb = this.vb.with({ scheme: _, authority: "base" })),
        (this.xb = this.vb.with({ scheme: _, authority: "local" })),
        (this.yb = this.vb.with({ scheme: _, authority: "remote" })),
        (this.zb = this.vb.with({ scheme: _, authority: "accepted" })),
        (this.Ab = p.createInstance(_a)),
        this.B(n.watch(this.h.dirname(this.H.argvResource))),
        this.B(
          T.any(
            T.filter(n.onDidFilesChange, (g) => g.contains(this.H.argvResource)),
            T.filter(
              i.onDidChange,
              (g) => !!(g.targetChanges.some((m) => this.syncResource.profile.id === m.id) || g.valueChanges.some(({ profile: m, changes: v }) => this.syncResource.profile.id === m.id && v.some((b) => b.target === 0))),
            ),
          )(() => this.Q()),
        );
    }
    async qb(e, s, i) {
      const n = e.syncData ? JSON.parse(e.syncData.content) : null;
      s = s === null && i ? e : s;
      const r = s && s.syncData ? JSON.parse(s.syncData.content) : null,
        o = await this.Ab.getLocalGlobalState(this.syncResource.profile);
      n ? this.O.trace(`${this.D}: Merging remote ui state with local ui state...`) : this.O.trace(`${this.D}: Remote ui state does not exist. Synchronizing ui state for the first time.`);
      const a = await this.Jb(r),
        { local: c, remote: l } = lu(o.storage, n ? n.storage : null, r ? r.storage : null, a, this.O),
        h = { content: null, local: c, remote: l, localChange: Object.keys(c.added).length > 0 || Object.keys(c.updated).length > 0 || c.removed.length > 0 ? 2 : 0, remoteChange: l.all !== null ? 2 : 0 },
        u = Wi(o, !1);
      return [
        {
          baseResource: this.wb,
          baseContent: r ? Wi(r, !1) : u,
          localResource: this.xb,
          localContent: u,
          localUserData: o,
          remoteResource: this.yb,
          remoteContent: n ? Wi(n, !1) : null,
          previewResource: this.vb,
          previewResult: h,
          localChange: h.localChange,
          remoteChange: h.remoteChange,
          acceptedResource: this.zb,
          storageKeys: a,
        },
      ];
    }
    async ub(e) {
      const s = e.syncData ? JSON.parse(e.syncData.content) : null;
      if (s === null) return !0;
      const i = await this.Ab.getLocalGlobalState(this.syncResource.profile),
        n = await this.Jb(s),
        { remote: r } = lu(i.storage, s.storage, s.storage, n, this.O);
      return r.all !== null;
    }
    async rb(e, s) {
      return { ...e.previewResult, hasConflicts: !1 };
    }
    async sb(e, s, i, n) {
      if (this.h.isEqual(s, this.xb)) return this.Gb(e);
      if (this.h.isEqual(s, this.yb)) return this.Hb(e);
      if (this.h.isEqual(s, this.vb)) return e.previewResult;
      throw new Error(`Invalid Resource: ${s.toString()}`);
    }
    async Gb(e) {
      return { content: e.localContent, local: { added: {}, removed: [], updated: {} }, remote: { added: Object.keys(e.localUserData.storage), removed: [], updated: [], all: e.localUserData.storage }, localChange: 0, remoteChange: 2 };
    }
    async Hb(e) {
      if (e.remoteContent !== null) {
        const s = JSON.parse(e.remoteContent),
          { local: i, remote: n } = lu(e.localUserData.storage, s.storage, null, e.storageKeys, this.O);
        return { content: e.remoteContent, local: i, remote: n, localChange: Object.keys(i.added).length > 0 || Object.keys(i.updated).length > 0 || i.removed.length > 0 ? 2 : 0, remoteChange: n !== null ? 2 : 0 };
      } else return { content: e.remoteContent, local: { added: {}, removed: [], updated: {} }, remote: { added: [], removed: [], updated: [], all: null }, localChange: 0, remoteChange: 0 };
    }
    async tb(e, s, i, n) {
      const { localUserData: r } = i[0][0],
        { local: o, remote: a, localChange: c, remoteChange: l } = i[0][1];
      if (
        (c === 0 && l === 0 && this.O.info(`${this.D}: No changes found during synchronizing ui state.`),
        c !== 0 && (this.O.trace(`${this.D}: Updating local ui state...`), await this.nb(JSON.stringify(r)), await this.Ab.writeLocalGlobalState(o, this.syncResource.profile), this.O.info(`${this.D}: Updated local ui state`)),
        l !== 0)
      ) {
        this.O.trace(`${this.D}: Updating remote ui state...`);
        const h = JSON.stringify({ storage: a.all });
        (e = await this.mb(h, n ? null : e.ref)),
          this.O.info(`${this.D}: Updated remote ui state.${a.added.length ? ` Added: ${a.added}.` : ""}${a.updated.length ? ` Updated: ${a.updated}.` : ""}${a.removed.length ? ` Removed: ${a.removed}.` : ""}`);
      }
      s?.ref !== e.ref && (this.O.trace(`${this.D}: Updating last synchronized ui state...`), await this.fb(e), this.O.info(`${this.D}: Updated last synchronized ui state`));
    }
    async resolveContent(e) {
      if (this.h.isEqual(this.yb, e) || this.h.isEqual(this.wb, e) || this.h.isEqual(this.xb, e) || this.h.isEqual(this.zb, e)) {
        const s = await this.db(e);
        return s && Wi(JSON.parse(s), !0);
      }
      return null;
    }
    async hasLocalData() {
      try {
        const { storage: e } = await this.Ab.getLocalGlobalState(this.syncResource.profile);
        if (Object.keys(e).length > 1 || e[`${Vi}.locale`]?.value !== "en") return !0;
      } catch {}
      return !1;
    }
    async Jb(e) {
      const s = await this.Bb.readStorageData(this.syncResource.profile),
        i = [],
        n = [];
      for (const [a, c] of s) c.target === 0 ? i.push(a) : c.target === 1 && n.push(a);
      const r = [...i, ...n],
        o = e?.storage ? Object.keys(e.storage).filter((a) => !a.startsWith(Vi) && !r.includes(a) && s.get(a) !== void 0) : [];
      if (!Qe) {
        const a = [...jn.map((c) => $a(c)), ui];
        o.push(...a), n.push(...a);
      }
      return { user: i, machine: n, unregistered: o };
    }
  };
uu = __decorate([__param(2, Mr), __param(3, ie), __param(4, St), __param(5, ts), __param(6, Pe), __param(7, fe), __param(8, jt), __param(9, Se), __param(10, Ce), __param(11, ae), __param(12, ke), __param(13, ds)], uu);
var _a = class {
  constructor(e, s, i, n) {
    (this.a = e), (this.b = s), (this.c = i), (this.d = n);
  }
  async getLocalGlobalState(e) {
    const s = {};
    if (e.isDefault) {
      const n = await this.f(),
        r = it(n);
      for (const o of T7) r[o] !== void 0 && (s[`${Vi}${o}`] = { version: 1, value: r[o] });
    }
    const i = await this.c.readStorageData(e);
    for (const [n, r] of i) r.value && r.target === 0 && (s[n] = { version: 1, value: r.value });
    return { storage: s };
  }
  async f() {
    try {
      this.d.debug("GlobalStateSync#getLocalArgvContent", this.b.argvResource);
      const e = await this.a.readFile(this.b.argvResource);
      return this.d.debug("GlobalStateSync#getLocalArgvContent - Resolved", this.b.argvResource), e.value.toString();
    } catch (e) {
      this.d.debug(ve(e));
    }
    return "{}";
  }
  async writeLocalGlobalState({ added: e, removed: s, updated: i }, n) {
    const r = Oa("globalState", n),
      o = {},
      a = new Map(),
      c = await this.c.readStorageData(n),
      l = (h, u) => {
        for (const f of h) {
          if (f.startsWith(Vi)) {
            o[f.substring(Vi.length)] = u ? u[f].value : void 0;
            continue;
          }
          if (u) {
            const d = u[f];
            d.value !== c.get(f)?.value && a.set(f, d.value);
          } else c.get(f) !== void 0 && a.set(f, void 0);
        }
      };
    if ((l(Object.keys(e), e), l(Object.keys(i), i), l(s), Object.keys(o).length)) {
      this.d.trace(`${r}: Updating locale...`);
      const h = await this.f();
      let u = h;
      for (const f of Object.keys(o)) u = Kt(u, [f], o[f], {});
      h !== u && (this.d.trace(`${r}: Updating locale...`), await this.a.writeFile(this.b.argvResource, L.fromString(u)), this.d.info(`${r}: Updated locale.`)), this.d.info(`${r}: Updated locale`);
    }
    a.size && (this.d.trace(`${r}: Updating global state...`), await this.c.updateStorageData(n, a, 0), this.d.info(`${r}: Updated global state`, [...a.keys()]));
  }
};
_a = __decorate([__param(0, ie), __param(1, fe), __param(2, Mr), __param(3, Pe)], _a);
var g0 = class extends fi {
  constructor(e, s, i, n, r, o) {
    super("globalState", i, n, r, s, e, o);
  }
  async o(e) {
    const s = e.syncData ? JSON.parse(e.syncData.content) : null;
    if (!s) {
      this.j.info("Skipping initializing global state because remote global state does not exist.");
      return;
    }
    const i = {},
      n = {};
    for (const r of Object.keys(s.storage)) r.startsWith(Vi) ? (i[r.substring(Vi.length)] = s.storage[r].value) : this.l.get(r, 0) === void 0 && (n[r] = s.storage[r].value);
    if (Object.keys(i).length) {
      let r = "{}";
      try {
        r = (await this.k.readFile(this.h.argvResource)).value.toString();
      } catch {}
      for (const o of Object.keys(i)) r = Kt(r, [o], i[o], {});
      await this.k.writeFile(this.h.argvResource, L.fromString(r));
    }
    if (Object.keys(n).length) {
      const r = [];
      for (const o of Object.keys(n)) r.push({ key: o, value: n[o], scope: 0, target: 0 });
      this.l.storeAll(r, !0);
    }
  }
};
g0 = __decorate([__param(0, ae), __param(1, ie), __param(2, Te), __param(3, fe), __param(4, Pe), __param(5, ke)], g0);
var m0 = class {
  constructor(e, s, i, n, r) {
    (this.a = e), (this.b = s), (this.c = i), (this.d = n), (this.f = r);
  }
  getSyncStoreType(e) {
    return this.h(e)?.storage[ui]?.value;
  }
  async sync(e) {
    const s = Fn(Me());
    try {
      return await this.g(e, s);
    } catch (i) {
      if (i instanceof De)
        switch (i.code) {
          case "PreconditionFailed":
            return this.f.info("Failed to synchronize UserDataSyncStoreType as there is a new remote version available. Synchronizing again..."), this.g(e, s);
        }
      throw i;
    }
  }
  async g(e, s) {
    const i = await this.a.readResource("globalState", null, void 0, s),
      n = this.h(i) || { storage: {} };
    n.storage[ui] = { value: e, version: hu };
    const r = await On(this.c, this.d, this.b),
      o = { version: hu, machineId: r, content: Wi(n, !1) };
    await this.a.writeResource("globalState", JSON.stringify(o), i.ref, void 0, s);
  }
  h({ content: e }) {
    if (!e) return null;
    const s = JSON.parse(e);
    if (jr(s)) return s ? JSON.parse(s.content) : null;
    throw new Error("Invalid remote data");
  }
};
m0 = __decorate([__param(1, ae), __param(2, fe), __param(3, ie), __param(4, ne)], m0);
function Ur(t) {
  return it(t) || [];
}
async function w0(t, e, s, i, n) {
  const r = Ur(t),
    o = Ur(e),
    a = s ? Ur(s) : null,
    c = [...r, ...o, ...(a || [])].map((E) => E.key),
    l = await n.resolveUserBindings(c),
    h = j7(r, o, a, l);
  if (!h.hasLocalForwarded && !h.hasRemoteForwarded) return { mergeContent: t, hasChanges: !1, hasConflicts: !1 };
  if (!h.hasLocalForwarded && h.hasRemoteForwarded) return { mergeContent: e, hasChanges: !0, hasConflicts: !1 };
  if (h.hasLocalForwarded && !h.hasRemoteForwarded) return { mergeContent: t, hasChanges: !0, hasConflicts: !1 };
  const u = du(r),
    f = du(o),
    d = a ? du(a) : null,
    p = gu(u, f, l),
    g = d ? gu(d, u, l) : { added: [...u.keys()].reduce((E, $) => (E.add($), E), new Set()), removed: new Set(), updated: new Set() },
    m = d ? gu(d, f, l) : { added: [...f.keys()].reduce((E, $) => (E.add($), E), new Set()), removed: new Set(), updated: new Set() },
    v = v0(p, g, m);
  let b = t;
  for (const E of v.removed.values()) v.conflicts.has(E) || (b = U7(b, E, i));
  for (const E of v.added.values()) {
    if (v.conflicts.has(E)) continue;
    const $ = f.get(E);
    if ($.some((P) => P.command !== `-${E}` && h.conflicts.has(l[P.key]))) {
      v.conflicts.add(E);
      continue;
    }
    b = M7(b, $, i);
  }
  for (const E of v.updated.values()) {
    if (v.conflicts.has(E)) continue;
    const $ = f.get(E);
    if ($.some((P) => P.command !== `-${E}` && h.conflicts.has(l[P.key]))) {
      v.conflicts.add(E);
      continue;
    }
    b = _7(b, E, $, i);
  }
  return { mergeContent: b, hasChanges: !0, hasConflicts: v.conflicts.size > 0 };
}
function v0(t, e, s) {
  const i = new Set(),
    n = new Set(),
    r = new Set(),
    o = new Set();
  for (const a of e.removed.values()) s.updated.has(a) && o.add(a);
  for (const a of s.removed.values()) o.has(a) || (e.updated.has(a) ? o.add(a) : n.add(a));
  for (const a of e.added.values()) o.has(a) || (s.added.has(a) && t.updated.has(a) && o.add(a));
  for (const a of s.added.values()) o.has(a) || (e.added.has(a) ? t.updated.has(a) && o.add(a) : i.add(a));
  for (const a of e.updated.values()) o.has(a) || (s.updated.has(a) && t.updated.has(a) && o.add(a));
  for (const a of s.updated.values()) o.has(a) || (e.updated.has(a) ? t.updated.has(a) && o.add(a) : r.add(a));
  return { added: i, removed: n, updated: r, conflicts: o };
}
function j7(t, e, s, i) {
  const n = new Set(),
    r = fu(t, i),
    o = fu(e, i),
    a = s ? fu(s, i) : null,
    c = pu(r, o);
  if (c.added.size === 0 && c.removed.size === 0 && c.updated.size === 0) return { hasLocalForwarded: !1, hasRemoteForwarded: !1, added: n, removed: n, updated: n, conflicts: n };
  const l = a ? pu(a, r) : { added: [...r.keys()].reduce((g, m) => (g.add(m), g), new Set()), removed: new Set(), updated: new Set() };
  if (l.added.size === 0 && l.removed.size === 0 && l.updated.size === 0) return { hasLocalForwarded: !1, hasRemoteForwarded: !0, added: n, removed: n, updated: n, conflicts: n };
  const h = a ? pu(a, o) : { added: [...o.keys()].reduce((g, m) => (g.add(m), g), new Set()), removed: new Set(), updated: new Set() };
  if (h.added.size === 0 && h.removed.size === 0 && h.updated.size === 0) return { hasLocalForwarded: !0, hasRemoteForwarded: !1, added: n, removed: n, updated: n, conflicts: n };
  const { added: u, removed: f, updated: d, conflicts: p } = v0(c, l, h);
  return { hasLocalForwarded: !0, hasRemoteForwarded: !0, added: u, removed: f, updated: d, conflicts: p };
}
function fu(t, e) {
  const s = new Map();
  for (const i of t) {
    const n = e[i.key];
    let r = s.get(n);
    r || ((r = []), s.set(n, r)), r.push(i);
  }
  return s;
}
function du(t) {
  const e = new Map();
  for (const s of t) {
    const i = s.command[0] === "-" ? s.command.substring(1) : s.command;
    let n = e.get(i);
    n || ((n = []), e.set(i, n)), n.push(s);
  }
  return e;
}
function pu(t, e) {
  const s = [...t.keys()],
    i = [...e.keys()],
    n = i.filter((a) => !s.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    r = s.filter((a) => !i.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    o = new Set();
  for (const a of s) {
    if (r.has(a)) continue;
    const c = t.get(a).map((h) => ({ ...h, key: a })),
      l = e.get(a).map((h) => ({ ...h, key: a }));
    _t(c, l, (h, u) => mu(h, u)) || o.add(a);
  }
  return { added: n, removed: r, updated: o };
}
function gu(t, e, s) {
  const i = [...t.keys()],
    n = [...e.keys()],
    r = n.filter((c) => !i.includes(c)).reduce((c, l) => (c.add(l), c), new Set()),
    o = i.filter((c) => !n.includes(c)).reduce((c, l) => (c.add(l), c), new Set()),
    a = new Set();
  for (const c of i) {
    if (o.has(c)) continue;
    const l = t.get(c).map((u) => ({ ...u, key: s[u.key] })),
      h = e.get(c).map((u) => ({ ...u, key: s[u.key] }));
    F7(l, h) || a.add(c);
  }
  return { added: r, removed: o, updated: a };
}
function F7(t, e) {
  return !(
    !_t(
      t.filter(({ command: s }) => s[0] !== "-"),
      e.filter(({ command: s }) => s[0] !== "-"),
      (s, i) => mu(s, i),
    ) ||
    !_t(
      t.filter(({ command: s }) => s[0] === "-"),
      e.filter(({ command: s }) => s[0] === "-"),
      (s, i) => mu(s, i),
    )
  );
}
function mu(t, e) {
  if (t.command !== e.command || t.key !== e.key) return !1;
  const s = ft.deserialize(t.when),
    i = ft.deserialize(e.when);
  return !((s && !i) || (!s && i) || (s && i && !s.equals(i)) || !Rt(t.args, e.args));
}
function M7(t, e, s) {
  for (const i of e) t = Kt(t, [-1], i, s);
  return t;
}
function U7(t, e, s) {
  const i = Ur(t);
  for (let n = i.length - 1; n >= 0; n--) (i[n].command === e || i[n].command === `-${e}`) && (t = Kt(t, [n], void 0, s));
  return t;
}
function _7(t, e, s, i) {
  const n = Ur(t),
    r = n.findIndex((o) => o.command === e || o.command === `-${e}`);
  for (let o = n.length - 1; o >= 0; o--) (n[o].command === e || n[o].command === `-${e}`) && (t = Kt(t, [o], void 0, i));
  for (let o = s.length - 1; o >= 0; o--) t = Kt(t, [r], s[o], i);
  return t;
}
function Ba(t, e, s) {
  try {
    const i = JSON.parse(t);
    if (!e) return Ct(i.all) ? null : i.all;
    switch (hn) {
      case 2:
        return Ct(i.mac) ? null : i.mac;
      case 3:
        return Ct(i.linux) ? null : i.linux;
      case 1:
        return Ct(i.windows) ? null : i.windows;
    }
  } catch (i) {
    return s.error(i), null;
  }
}
var wu = class extends Na {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f, d) {
    super(e.keybindingsResource, { syncResource: "keybindings", profile: e }, s, c, l, h, i, n, a, f, r, u, o, d),
      (this.pb = 2),
      (this.Eb = this.h.joinPath(this.g, "keybindings.json")),
      (this.Fb = this.Eb.with({ scheme: _, authority: "base" })),
      (this.Gb = this.Eb.with({ scheme: _, authority: "local" })),
      (this.Hb = this.Eb.with({ scheme: _, authority: "remote" })),
      (this.Ib = this.Eb.with({ scheme: _, authority: "accepted" })),
      this.B(T.filter(o.onDidChangeConfiguration, (p) => p.affectsConfiguration("settingsSync.keybindingsPerPlatform"))(() => this.Q()));
  }
  async qb(e, s, i, n) {
    const r = e.syncData ? Ba(e.syncData.content, n.keybindingsPerPlatform ?? this.Qb(), this.O) : null;
    s = s === null && i ? e : s;
    const o = s ? this.Ob(s) : null,
      a = await this.vb(),
      c = await this.Cb();
    let l = null,
      h = !1,
      u = !1,
      f = !1;
    if (r) {
      let g = a ? a.value.toString() : "[]";
      if (((g = g || "[]"), this.Ab(g, !0))) throw new De(w(2749, null), "LocalInvalidContent", this.resource);
      if (!o || o !== g || o !== r) {
        this.O.trace(`${this.D}: Merging remote keybindings with local keybindings...`);
        const m = await w0(g, r, o, c, this.zb);
        m.hasChanges && ((l = m.mergeContent), (f = m.hasConflicts), (h = f || m.mergeContent !== g), (u = f || m.mergeContent !== r));
      }
    } else a && (this.O.trace(`${this.D}: Remote keybindings does not exist. Synchronizing keybindings for the first time.`), (l = a.value.toString()), (u = !0));
    const d = { content: f ? o : l, localChange: h ? (a ? 2 : 1) : 0, remoteChange: u ? 2 : 0, hasConflicts: f },
      p = a ? a.value.toString() : null;
    return [
      {
        fileContent: a,
        baseResource: this.Fb,
        baseContent: o,
        localResource: this.Gb,
        localContent: p,
        localChange: d.localChange,
        remoteResource: this.Hb,
        remoteContent: r,
        remoteChange: d.remoteChange,
        previewResource: this.Eb,
        previewResult: d,
        acceptedResource: this.Ib,
      },
    ];
  }
  async ub(e) {
    const s = this.Ob(e);
    if (s === null) return !0;
    const i = await this.vb(),
      n = i ? i.value.toString() : "",
      r = await this.Cb(),
      o = await w0(n || "[]", s, s, r, this.zb);
    return o.hasConflicts || o.mergeContent !== s;
  }
  async rb(e, s) {
    return e.previewResult;
  }
  async sb(e, s, i, n) {
    if (this.h.isEqual(s, this.Gb)) return { content: e.fileContent ? e.fileContent.value.toString() : null, localChange: 0, remoteChange: 2 };
    if (this.h.isEqual(s, this.Hb)) return { content: e.remoteContent, localChange: 2, remoteChange: 0 };
    if (this.h.isEqual(s, this.Eb)) return i === void 0 ? { content: e.previewResult.content, localChange: e.previewResult.localChange, remoteChange: e.previewResult.remoteChange } : { content: i, localChange: 2, remoteChange: 2 };
    throw new Error(`Invalid Resource: ${s.toString()}`);
  }
  async tb(e, s, i, n) {
    const { fileContent: r } = i[0][0];
    let { content: o, localChange: a, remoteChange: c } = i[0][1];
    if ((a === 0 && c === 0 && this.O.info(`${this.D}: No changes found during synchronizing keybindings.`), o !== null && ((o = o.trim()), (o = o || "[]"), this.Ab(o, !0))))
      throw new De(w(2750, null), "LocalInvalidContent", this.resource);
    if ((a !== 0 && (this.O.trace(`${this.D}: Updating local keybindings...`), r && (await this.nb(this.Pb(r.value.toString()))), await this.wb(o || "[]", r, n), this.O.info(`${this.D}: Updated local keybindings`)), c !== 0)) {
      this.O.trace(`${this.D}: Updating remote keybindings...`);
      const l = this.Pb(o || "[]", e.syncData?.content);
      (e = await this.mb(l, n ? null : e.ref)), this.O.info(`${this.D}: Updated remote keybindings`);
    }
    try {
      await this.G.del(this.Eb);
    } catch {}
    s?.ref !== e.ref && (this.O.trace(`${this.D}: Updating last synchronized keybindings...`), await this.fb(e, { platformSpecific: this.Qb() }), this.O.info(`${this.D}: Updated last synchronized keybindings`));
  }
  async hasLocalData() {
    try {
      const e = await this.vb();
      if (e) {
        const s = it(e.value.toString());
        if (Xn(s)) return !0;
      }
    } catch (e) {
      if (e.fileOperationResult !== 1) return !0;
    }
    return !1;
  }
  async resolveContent(e) {
    return this.h.isEqual(this.Hb, e) || this.h.isEqual(this.Fb, e) || this.h.isEqual(this.Gb, e) || this.h.isEqual(this.Ib, e) ? this.db(e) : null;
  }
  Ob(e) {
    return !e.syncData || (e.platformSpecific !== void 0 && e.platformSpecific !== this.Qb()) ? null : Ba(e.syncData.content, this.Qb(), this.O);
  }
  Pb(e, s) {
    let i = {};
    try {
      i = JSON.parse(s || "{}");
    } catch (n) {
      this.O.error(n);
    }
    switch ((this.Qb() ? delete i.all : (i.all = e), hn)) {
      case 2:
        i.mac = e;
        break;
      case 3:
        i.linux = e;
        break;
      case 1:
        i.windows = e;
        break;
    }
    return JSON.stringify(i);
  }
  Qb() {
    return !!this.P.getValue(qh);
  }
};
wu = __decorate([__param(2, St), __param(3, ts), __param(4, Pe), __param(5, Ce), __param(6, jt), __param(7, ie), __param(8, fe), __param(9, ae), __param(10, Ca), __param(11, Se), __param(12, ke)], wu);
var y0 = class extends fi {
  constructor(e, s, i, n, r, o) {
    super("keybindings", s, i, n, e, r, o);
  }
  async o(e) {
    const s = e.syncData ? this.p(e.syncData.content) : null;
    if (!s) {
      this.j.info("Skipping initializing keybindings because remote keybindings does not exist.");
      return;
    }
    if (!(await this.i())) {
      this.j.info("Skipping initializing keybindings because local keybindings exist.");
      return;
    }
    await this.k.writeFile(this.g.defaultProfile.keybindingsResource, L.fromString(s)), await this.n(e);
  }
  async i() {
    try {
      const e = await this.k.readFile(this.g.defaultProfile.settingsResource),
        s = it(e.value.toString());
      return !Xn(s);
    } catch (e) {
      return e.fileOperationResult === 1;
    }
  }
  p(e) {
    try {
      return Ba(e, !0, this.j);
    } catch (s) {
      return this.j.error(s), null;
    }
  }
};
y0 = __decorate([__param(0, ie), __param(1, Te), __param(2, fe), __param(3, Pe), __param(4, ae), __param(5, ke)], y0);
function B7(t, e, s) {
  let i = [];
  s ? (i = q7(s)) : (i = z7(e));
  const n = [],
    r = [...zh()];
  if (Array.isArray(i)) for (const o of i) o.startsWith("-") ? r.push(o.substring(1)) : n.push(o);
  return Bt([...t, ...n].filter((o) => !r.includes(o)));
}
function z7(t) {
  let e = t.inspect("settingsSync.ignoredSettings").userValue;
  return e !== void 0 || ((e = t.inspect("sync.ignoredSettings").userValue), e !== void 0) ? e : t.getValue("settingsSync.ignoredSettings") || [];
}
function q7(t) {
  const e = it(t);
  return e ? e["settingsSync.ignoredSettings"] || e["sync.ignoredSettings"] || [] : [];
}
function Qs(t, e, s, i) {
  if (s.length) {
    const n = Un(e),
      r = it(e) || {},
      o = it(t);
    if (!o) return t;
    const a = [];
    for (const c of s) {
      const l = r[c],
        h = o[c];
      l === void 0 ? (t = Kt(t, [c], void 0, i)) : h !== void 0 ? (t = Kt(t, [c], l, i)) : a.push(_r(c, n));
    }
    a.sort((c, l) => c.startOffset - l.startOffset), a.forEach((c) => (t = bu(c.setting.key, e, t, i)));
  }
  return t;
}
function b0(t, e, s, i, n, r) {
  const o = Qs(t, e, i, r),
    a = s !== o,
    c = s !== e;
  if (!a && !c) return { conflictsSettings: [], localContent: null, remoteContent: null, hasConflicts: !1 };
  if (a && !c) return { conflictsSettings: [], localContent: null, remoteContent: o, hasConflicts: !1 };
  if (c && !a) return { conflictsSettings: [], localContent: Qs(e, t, i, r), remoteContent: null, hasConflicts: !1 };
  if (s === null && vu(t)) {
    const k = za(t, e, i) ? null : Qs(e, t, i, r);
    return { conflictsSettings: [], localContent: k, remoteContent: null, hasConflicts: !1 };
  }
  let l = t,
    h = e;
  const u = it(t),
    f = it(e),
    d = s ? it(s) : null,
    p = i.reduce((k, I) => (k.add(I), k), new Set()),
    g = yu(u, f, p),
    m = yu(d, u, p),
    v = yu(d, f, p),
    b = new Map(),
    E = new Set(),
    $ = (k) => {
      E.add(k);
      const I = n.filter(({ key: H }) => H === k)[0];
      I ? ((l = Kt(l, [k], I.value, r)), (h = Kt(h, [k], I.value, r))) : b.set(k, { key: k, localValue: u[k], remoteValue: f[k] });
    };
  for (const k of m.removed.values()) v.updated.has(k) ? $(k) : (h = Kt(h, [k], void 0, r));
  for (const k of v.removed.values()) E.has(k) || (m.updated.has(k) ? $(k) : (l = Kt(l, [k], void 0, r)));
  for (const k of m.updated.values()) E.has(k) || (v.updated.has(k) ? g.updated.has(k) && $(k) : (h = Kt(h, [k], u[k], r)));
  for (const k of v.updated.values()) E.has(k) || (m.updated.has(k) ? g.updated.has(k) && $(k) : (l = Kt(l, [k], f[k], r)));
  for (const k of m.added.values()) E.has(k) || (v.added.has(k) ? g.updated.has(k) && $(k) : (h = bu(k, l, h, r)));
  for (const k of v.added.values()) E.has(k) || (m.added.has(k) ? g.updated.has(k) && $(k) : (l = bu(k, h, l, r)));
  const P = b.size > 0 || !za(l, h, i),
    U = P || !za(l, t, []),
    Q = P || !za(h, e, []);
  return { localContent: U ? l : null, remoteContent: Q ? h : null, conflictsSettings: [...b.values()], hasConflicts: P };
}
function za(t, e, s) {
  if (t === e) return !0;
  const i = it(t),
    n = it(e),
    r = s.reduce((c, l) => (c.add(l), c), new Set()),
    o = Un(t).filter((c) => !(c.setting && r.has(c.setting.key))),
    a = Un(e).filter((c) => !(c.setting && r.has(c.setting.key)));
  if (o.length !== a.length) return !1;
  for (let c = 0; c < o.length; c++) {
    const l = o[c],
      h = a[c];
    if (l.setting && h.setting) {
      if (l.setting.key !== h.setting.key || !Rt(i[l.setting.key], n[l.setting.key])) return !1;
    } else if (!l.setting && !h.setting) {
      if (l.value !== h.value) return !1;
    } else return !1;
  }
  return !0;
}
function vu(t) {
  return t ? Un(t).length === 0 : !0;
}
function yu(t, e, s) {
  const i = t ? Object.keys(t).filter((c) => !s.has(c)) : [],
    n = Object.keys(e).filter((c) => !s.has(c)),
    r = n.filter((c) => !i.includes(c)).reduce((c, l) => (c.add(l), c), new Set()),
    o = i.filter((c) => !n.includes(c)).reduce((c, l) => (c.add(l), c), new Set()),
    a = new Set();
  if (t)
    for (const c of i) {
      if (o.has(c)) continue;
      const l = t[c],
        h = e[c];
      Rt(l, h) || a.add(c);
    }
  return { added: r, removed: o, updated: a };
}
function bu(t, e, s, i) {
  const n = it(e),
    r = Un(e),
    o = Un(s),
    a = V7(t, r, o);
  return W7(s, t, n[t], a, o, i);
}
function V7(t, e, s) {
  const i = e.findIndex((r) => r.setting?.key === t),
    n = e[i - 1];
  if (n) {
    if (n.setting) {
      const o = _r(n.setting.key, s);
      if (o) return { index: s.indexOf(o), insertAfter: !0 };
    } else {
      const o = Eu(i, e);
      if (o) {
        const a = _r(o.setting.key, s);
        if (a) {
          const c = qa(s.indexOf(a), s),
            l = Mn(e, o, e[i]);
          if (c) {
            const h = Mn(s, a, c),
              u = Va(l, h);
            return u ? { index: s.indexOf(u), insertAfter: !0 } : { index: s.indexOf(c), insertAfter: !1 };
          } else {
            const h = Mn(s, a, s[s.length - 1]),
              u = Va(l, h);
            return u ? { index: s.indexOf(u), insertAfter: !0 } : { index: s.length - 1, insertAfter: !0 };
          }
        }
      }
    }
    const r = e[i + 1];
    if (r)
      if (r.setting) {
        const o = _r(r.setting.key, s);
        if (o) return { index: s.indexOf(o), insertAfter: !1 };
      } else {
        const o = qa(i, e);
        if (o) {
          const a = _r(o.setting.key, s);
          if (a) {
            const c = Eu(s.indexOf(a), s),
              l = Mn(e, e[i], o);
            if (c) {
              const h = Mn(s, c, a),
                u = Va(l.reverse(), h.reverse());
              return u ? { index: s.indexOf(u), insertAfter: !1 } : { index: s.indexOf(c), insertAfter: !0 };
            } else {
              const h = Mn(s, s[0], a),
                u = Va(l.reverse(), h.reverse());
              return u ? { index: s.indexOf(u), insertAfter: !1 } : { index: 0, insertAfter: !1 };
            }
          }
        }
      }
  }
  return { index: s.length - 1, insertAfter: !0 };
}
function W7(t, e, s, i, n, r) {
  let o;
  return i.index === -1 ? (o = jl(t, [e], s, r)) : (o = H7(t, e, s, i, n, r).map((a) => ji(t, a, r)[0])), dp(t, o);
}
function H7(t, e, s, i, n, r) {
  const o = `${JSON.stringify(e)}: ${JSON.stringify(s)}`,
    a = fp(r, t),
    c = n[i.index];
  if (i.insertAfter) {
    const l = [];
    if (c.setting) l.push({ offset: c.endOffset, length: 0, content: "," + o });
    else {
      const h = qa(i.index, n),
        u = Eu(i.index, n),
        f = u?.setting?.commaOffset;
      u && f === void 0 && l.push({ offset: u.endOffset, length: 0, content: "," });
      const d = f !== void 0 && f > c.endOffset;
      l.push({ offset: d ? f + 1 : c.endOffset, length: 0, content: h ? a + o + "," : a + o });
    }
    return l;
  } else {
    if (c.setting) return [{ offset: c.startOffset, length: 0, content: o + "," }];
    const l = (n[i.index - 1] && !n[i.index - 1].setting ? a : "") + o + (qa(i.index, n) ? "," : "") + a;
    return [{ offset: c.startOffset, length: 0, content: l }];
  }
}
function _r(t, e) {
  return e.filter((s) => s.setting?.key === t)[0];
}
function Eu(t, e) {
  for (let s = t - 1; s >= 0; s--) if (e[s].setting) return e[s];
}
function qa(t, e) {
  for (let s = t + 1; s < e.length; s++) if (e[s].setting) return e[s];
}
function Mn(t, e, s) {
  const i = t.indexOf(e),
    n = t.indexOf(s);
  return t.filter((r, o) => i < o && o < n);
}
function Va(t, e) {
  if (t.length && e.length) {
    let s = 0;
    for (; s < e.length && s < t.length; s++) if (t[s].value !== e[s].value) return e[s - 1];
    return e[s - 1];
  }
}
function Un(t) {
  const e = [];
  let s = -1,
    i,
    n;
  return (
    Vo(t, {
      onObjectBegin: (o) => {
        s++;
      },
      onObjectProperty: (o, a, c) => {
        s === 0 && ((i = a), (n = o));
      },
      onObjectEnd: (o, a) => {
        s--, s === 0 && e.push({ startOffset: i, endOffset: o + a, value: t.substring(i, o + a), setting: { key: n, commaOffset: void 0 } });
      },
      onArrayBegin: (o, a) => {
        s++;
      },
      onArrayEnd: (o, a) => {
        s--, s === 0 && e.push({ startOffset: i, endOffset: o + a, value: t.substring(i, o + a), setting: { key: n, commaOffset: void 0 } });
      },
      onLiteralValue: (o, a, c) => {
        s === 0 && e.push({ startOffset: i, endOffset: a + c, value: t.substring(i, a + c), setting: { key: n, commaOffset: void 0 } });
      },
      onSeparator: (o, a, c) => {
        if (s === 0 && o === ",") {
          let l = e.length - 1;
          for (; l >= 0 && !e[l].setting; l--);
          const h = e[l];
          h && e.splice(l, 1, { startOffset: h.startOffset, endOffset: h.endOffset, value: h.value, setting: { key: h.setting.key, commaOffset: a } });
        }
      },
      onComment: (o, a) => {
        s === 0 && e.push({ startOffset: o, endOffset: o + a, value: t.substring(o, o + a) });
      },
    }),
    e
  );
}
function G7(t) {
  return t && t.settings && typeof t.settings == "string" && Object.keys(t).length === 1;
}
function Su(t) {
  const e = JSON.parse(t);
  return G7(e) ? e : { settings: t };
}
var Wa = class extends Na {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f, d, p) {
    super(e.settingsResource, { syncResource: "settings", profile: e }, s, i, n, r, o, a, u, f, c, l, h, p),
      (this.Eb = e),
      (this.Fb = d),
      (this.pb = 2),
      (this.previewResource = this.h.joinPath(this.g, "settings.json")),
      (this.baseResource = this.previewResource.with({ scheme: _, authority: "base" })),
      (this.localResource = this.previewResource.with({ scheme: _, authority: "local" })),
      (this.remoteResource = this.previewResource.with({ scheme: _, authority: "remote" })),
      (this.acceptedResource = this.previewResource.with({ scheme: _, authority: "accepted" })),
      (this.Pb = void 0),
      (this.Qb = void 0),
      (this.Rb = void 0);
  }
  async getRemoteUserDataSyncConfiguration(e) {
    const s = await this.getLastSyncUserData(),
      i = await this.X(e, s),
      n = this.Mb(i),
      r = new Bl(Sa, this.O);
    return n?.settings && r.parse(n.settings), r.configurationModel.getValue(Sa) || {};
  }
  async qb(e, s, i) {
    const n = await this.vb(),
      r = await this.Cb(),
      o = this.Mb(e);
    s = s === null && i ? e : s;
    const a = s ? this.Mb(s) : null,
      c = await this.Sb();
    let l = null,
      h = !1,
      u = !1,
      f = !1;
    if (o) {
      let m = n ? n.value.toString().trim() : "{}";
      (m = m || "{}"), this.Vb(m), this.O.trace(`${this.D}: Merging remote settings with local settings...`);
      const v = b0(m, o.settings, a ? a.settings : null, c, [], r);
      (l = v.localContent || v.remoteContent), (h = v.localContent !== null), (u = v.remoteContent !== null), (f = v.hasConflicts);
    } else n && (this.O.trace(`${this.D}: Remote settings does not exist. Synchronizing settings for the first time.`), (l = n.value.toString().trim() || "{}"), this.Vb(l), (u = !0));
    const d = n ? n.value.toString() : null,
      p = a?.settings ?? null,
      g = { content: f ? p : l, localChange: h ? 2 : 0, remoteChange: u ? 2 : 0, hasConflicts: f };
    return [
      {
        fileContent: n,
        baseResource: this.baseResource,
        baseContent: p,
        localResource: this.localResource,
        localContent: d,
        localChange: g.localChange,
        remoteResource: this.remoteResource,
        remoteContent: o ? o.settings : null,
        remoteChange: g.remoteChange,
        previewResource: this.previewResource,
        previewResult: g,
        acceptedResource: this.acceptedResource,
      },
    ];
  }
  async ub(e) {
    const s = this.Mb(e);
    if (s === null) return !0;
    const i = await this.vb(),
      n = i ? i.value.toString().trim() : "",
      r = await this.Sb(),
      o = await this.Cb();
    return b0(n || "{}", s.settings, s.settings, r, [], o).remoteContent !== null;
  }
  async rb(e, s) {
    const i = await this.Cb(),
      n = await this.Sb();
    return { ...e.previewResult, content: e.previewResult.content ? Qs(e.previewResult.content, "{}", n, i) : null };
  }
  async sb(e, s, i, n) {
    const r = await this.Cb(),
      o = await this.Sb();
    if (this.h.isEqual(s, this.localResource)) return { content: e.fileContent ? Qs(e.fileContent.value.toString(), "{}", o, r) : null, localChange: 0, remoteChange: 2 };
    if (this.h.isEqual(s, this.remoteResource)) return { content: e.remoteContent !== null ? Qs(e.remoteContent, e.fileContent ? e.fileContent.value.toString() : "{}", o, r) : null, localChange: 2, remoteChange: 0 };
    if (this.h.isEqual(s, this.previewResource))
      return i === void 0
        ? { content: e.previewResult.content, localChange: e.previewResult.localChange, remoteChange: e.previewResult.remoteChange }
        : { content: i !== null ? Qs(i, e.fileContent ? e.fileContent.value.toString() : "{}", o, r) : null, localChange: 2, remoteChange: 2 };
    throw new Error(`Invalid Resource: ${s.toString()}`);
  }
  async tb(e, s, i, n) {
    const { fileContent: r } = i[0][0];
    let { content: o, localChange: a, remoteChange: c } = i[0][1];
    if (
      (a === 0 && c === 0 && this.O.info(`${this.D}: No changes found during synchronizing settings.`),
      (o = o ? o.trim() : "{}"),
      (o = o || "{}"),
      this.Vb(o),
      a !== 0 &&
        (this.O.trace(`${this.D}: Updating local settings...`),
        r && (await this.nb(JSON.stringify(this.Ob(r.value.toString())))),
        await this.wb(o, r, n),
        await this.P.reloadConfiguration(3),
        this.O.info(`${this.D}: Updated local settings`)),
      c !== 0)
    ) {
      const l = await this.Cb(),
        h = this.Mb(e),
        u = await this.Sb(o);
      (o = Qs(o, h ? h.settings : "{}", u, l)), this.O.trace(`${this.D}: Updating remote settings...`), (e = await this.mb(JSON.stringify(this.Ob(o)), n ? null : e.ref)), this.O.info(`${this.D}: Updated remote settings`);
    }
    try {
      await this.G.del(this.previewResource);
    } catch {}
    s?.ref !== e.ref && (this.O.trace(`${this.D}: Updating last synchronized settings...`), await this.fb(e), this.O.info(`${this.D}: Updated last synchronized settings`));
  }
  async hasLocalData() {
    try {
      const e = await this.vb();
      if (e) return !vu(e.value.toString());
    } catch (e) {
      if (e.fileOperationResult !== 1) return !0;
    }
    return !1;
  }
  async resolveContent(e) {
    return this.h.isEqual(this.remoteResource, e) || this.h.isEqual(this.localResource, e) || this.h.isEqual(this.acceptedResource, e) || this.h.isEqual(this.baseResource, e) ? this.db(e) : null;
  }
  async db(e) {
    let s = await super.db(e);
    if (s) {
      const i = await this.Cb(),
        n = await this.Sb();
      s = Qs(s, "{}", n, i);
    }
    return s;
  }
  Mb(e) {
    return e.syncData ? this.Nb(e.syncData.content) : null;
  }
  Nb(e) {
    try {
      return Su(e);
    } catch (s) {
      this.O.error(s);
    }
    return null;
  }
  Ob(e) {
    return { settings: e };
  }
  async Sb(e) {
    if ((this.Pb || (this.Pb = this.zb.resolveDefaultCoreIgnoredSettings()), this.Qb || (this.Qb = this.Tb()), !this.Rb)) {
      this.Rb = this.Ub();
      const i = this.B(
        T.any(
          T.filter(this.Fb.onDidInstallExtensions, (n) => n.some(({ local: r }) => !!r)),
          T.filter(this.Fb.onDidUninstallExtension, (n) => !n.error),
        )(() => {
          i.dispose(), (this.Rb = void 0);
        }),
      );
    }
    const s = (await Promise.all([this.Pb, this.Qb, this.Rb])).flat();
    return B7(s, this.P, e);
  }
  async Tb() {
    const e = await this.Fb.getInstalled(0);
    return Bt(e.map((s) => Yg(s.manifest)).flat());
  }
  async Ub() {
    const e = await this.Fb.getInstalled(1, this.Eb.extensionsResource);
    return Bt(e.map((s) => Yg(s.manifest)).flat());
  }
  Vb(e) {
    if (this.Ab(e, !1)) throw new De(w(2751, null), "LocalInvalidContent", this.resource);
  }
};
Wa = __decorate([__param(2, ie), __param(3, fe), __param(4, ae), __param(5, St), __param(6, ts), __param(7, Pe), __param(8, Ca), __param(9, Ce), __param(10, jt), __param(11, Se), __param(12, Vs), __param(13, ke)], Wa);
var E0 = class extends fi {
  constructor(e, s, i, n, r, o) {
    super("settings", s, i, n, e, r, o);
  }
  async o(e) {
    const s = e.syncData ? this.p(e.syncData.content) : null;
    if (!s) {
      this.j.info("Skipping initializing settings because remote settings does not exist.");
      return;
    }
    if (!(await this.i())) {
      this.j.info("Skipping initializing settings because local settings exist.");
      return;
    }
    await this.k.writeFile(this.g.defaultProfile.settingsResource, L.fromString(s.settings)), await this.n(e);
  }
  async i() {
    try {
      const e = await this.k.readFile(this.g.defaultProfile.settingsResource);
      return vu(e.value.toString().trim());
    } catch (e) {
      return e.fileOperationResult === 1;
    }
  }
  p(e) {
    try {
      return Su(e);
    } catch (s) {
      this.j.error(s);
    }
    return null;
  }
};
E0 = __decorate([__param(0, ie), __param(1, Te), __param(2, fe), __param(3, Pe), __param(4, ae), __param(5, ke)], E0);
function S0(t, e, s) {
  const i = {},
    n = {},
    r = new Set();
  if (!e) return { local: { added: i, updated: n, removed: [...r.values()] }, remote: { added: t, updated: {}, removed: [] }, conflicts: [] };
  const o = Ha(t, e);
  if (o.added.size === 0 && o.removed.size === 0 && o.updated.size === 0) return { local: { added: i, updated: n, removed: [...r.values()] }, remote: { added: {}, updated: {}, removed: [] }, conflicts: [] };
  const a = Ha(s, t),
    c = Ha(s, e),
    l = {},
    h = {},
    u = new Set(),
    f = new Set();
  for (const d of a.removed.values()) c.updated.has(d) ? (i[d] = e[d]) : u.add(d);
  for (const d of c.removed.values()) f.has(d) || (a.updated.has(d) ? f.add(d) : r.add(d));
  for (const d of a.updated.values()) f.has(d) || (c.updated.has(d) ? o.updated.has(d) && f.add(d) : (h[d] = t[d]));
  for (const d of c.updated.values()) f.has(d) || (a.updated.has(d) ? o.updated.has(d) && f.add(d) : t[d] !== void 0 && (n[d] = e[d]));
  for (const d of a.added.values()) f.has(d) || (c.added.has(d) ? o.updated.has(d) && f.add(d) : (l[d] = t[d]));
  for (const d of c.added.values()) f.has(d) || (a.added.has(d) ? o.updated.has(d) && f.add(d) : (i[d] = e[d]));
  return { local: { added: i, removed: [...r.values()], updated: n }, remote: { added: l, removed: [...u.values()], updated: h }, conflicts: [...f.values()] };
}
function Ha(t, e) {
  const s = t ? Object.keys(t) : [],
    i = e ? Object.keys(e) : [],
    n = i.filter((a) => !s.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    r = s.filter((a) => !i.includes(a)).reduce((a, c) => (a.add(c), a), new Set()),
    o = new Set();
  for (const a of s) {
    if (r.has(a)) continue;
    const c = t[a],
      l = e[a];
    c !== l && o.add(a);
  }
  return { added: n, removed: r, updated: o };
}
function J7(t, e) {
  const { added: s, removed: i, updated: n } = Ha(t, e);
  return s.size === 0 && i.size === 0 && n.size === 0;
}
function $u(t) {
  return JSON.parse(t.content);
}
var xu = class extends qi {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f) {
    super({ syncResource: "snippets", profile: e }, s, n, i, r, o, a, h, u, c, l, f),
      (this.pb = 1),
      (this.vb = e.snippetsHome),
      this.B(this.G.watch(i.userRoamingDataHome)),
      this.B(this.G.watch(this.vb)),
      this.B(T.filter(this.G.onDidFilesChange, (d) => d.affects(this.vb))(() => this.Q()));
  }
  async qb(e, s, i) {
    const n = await this.Hb(),
      r = this.Gb(n),
      o = e.syncData ? this.Fb(e.syncData) : null;
    s = s === null && i ? e : s;
    const a = s && s.syncData ? this.Fb(s.syncData) : null;
    o ? this.O.trace(`${this.D}: Merging remote snippets with local snippets...`) : this.O.trace(`${this.D}: Remote snippets does not exist. Synchronizing snippets for the first time.`);
    const c = S0(r, o, a);
    return this.Bb(c, n, o || {}, a || {});
  }
  async ub(e) {
    const s = e.syncData ? this.Fb(e.syncData) : null;
    if (s === null) return !0;
    const i = await this.Hb(),
      n = this.Gb(i),
      r = S0(n, s, s);
    return Object.keys(r.remote.added).length > 0 || Object.keys(r.remote.updated).length > 0 || r.remote.removed.length > 0 || r.conflicts.length > 0;
  }
  async rb(e, s) {
    return e.previewResult;
  }
  async sb(e, s, i, n) {
    if (this.h.isEqualOrParent(s, this.g.with({ scheme: _, authority: "local" })))
      return { content: e.fileContent ? e.fileContent.value.toString() : null, localChange: 0, remoteChange: e.fileContent ? (e.remoteContent !== null ? 2 : 1) : 3 };
    if (this.h.isEqualOrParent(s, this.g.with({ scheme: _, authority: "remote" }))) return { content: e.remoteContent, localChange: e.remoteContent !== null ? (e.fileContent ? 2 : 1) : 3, remoteChange: 0 };
    if (this.h.isEqualOrParent(s, this.g))
      return i === void 0
        ? { content: e.previewResult.content, localChange: e.previewResult.localChange, remoteChange: e.previewResult.remoteChange }
        : { content: i, localChange: i === null ? (e.fileContent !== null ? 3 : 0) : 2, remoteChange: i === null ? (e.remoteContent !== null ? 3 : 0) : 2 };
    throw new Error(`Invalid Resource: ${s.toString()}`);
  }
  async tb(e, s, i, n) {
    const r = i.map(([o, a]) => ({ ...o, acceptResult: a }));
    r.every(({ localChange: o, remoteChange: a }) => o === 0 && a === 0) && this.O.info(`${this.D}: No changes found during synchronizing snippets.`),
      r.some(({ localChange: o }) => o !== 0) && (await this.Cb(r), await this.Db(r, n)),
      r.some(({ remoteChange: o }) => o !== 0) && (e = await this.Eb(r, e, n)),
      s?.ref !== e.ref && (this.O.trace(`${this.D}: Updating last synchronized snippets...`), await this.fb(e), this.O.info(`${this.D}: Updated last synchronized snippets`));
    for (const { previewResource: o } of r)
      try {
        await this.G.del(o);
      } catch {}
  }
  Bb(e, s, i, n) {
    const r = new Map();
    for (const o of Object.keys(e.local.added)) {
      const a = { content: e.local.added[o], hasConflicts: !1, localChange: 1, remoteChange: 0 };
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: null,
        fileContent: null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        localContent: null,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: i[o],
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of Object.keys(e.local.updated)) {
      const a = { content: e.local.updated[o], hasConflicts: !1, localChange: 2, remoteChange: 0 },
        c = s[o] ? s[o].value.toString() : null;
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: n[o] ?? null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        fileContent: s[o],
        localContent: c,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: i[o],
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of e.local.removed) {
      const a = { content: null, hasConflicts: !1, localChange: 3, remoteChange: 0 },
        c = s[o] ? s[o].value.toString() : null;
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: n[o] ?? null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        fileContent: s[o],
        localContent: c,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: null,
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of Object.keys(e.remote.added)) {
      const a = { content: e.remote.added[o], hasConflicts: !1, localChange: 0, remoteChange: 1 },
        c = s[o] ? s[o].value.toString() : null;
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: n[o] ?? null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        fileContent: s[o],
        localContent: c,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: null,
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of Object.keys(e.remote.updated)) {
      const a = { content: e.remote.updated[o], hasConflicts: !1, localChange: 0, remoteChange: 2 },
        c = s[o] ? s[o].value.toString() : null;
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: n[o] ?? null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        fileContent: s[o],
        localContent: c,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: i[o],
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of e.remote.removed) {
      const a = { content: null, hasConflicts: !1, localChange: 0, remoteChange: 3 };
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: n[o] ?? null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        fileContent: null,
        localContent: null,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: i[o],
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of e.conflicts) {
      const a = { content: n[o] ?? null, hasConflicts: !0, localChange: s[o] ? 2 : 1, remoteChange: i[o] ? 2 : 1 },
        c = s[o] ? s[o].value.toString() : null;
      r.set(o, {
        baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
        baseContent: n[o] ?? null,
        localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
        fileContent: s[o] || null,
        localContent: c,
        remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
        remoteContent: i[o] || null,
        previewResource: this.h.joinPath(this.g, o),
        previewResult: a,
        localChange: a.localChange,
        remoteChange: a.remoteChange,
        acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
      });
    }
    for (const o of Object.keys(s))
      if (!r.has(o)) {
        const a = { content: s[o] ? s[o].value.toString() : null, hasConflicts: !1, localChange: 0, remoteChange: 0 },
          c = s[o] ? s[o].value.toString() : null;
        r.set(o, {
          baseResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "base" }),
          baseContent: n[o] ?? null,
          localResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "local" }),
          fileContent: s[o] || null,
          localContent: c,
          remoteResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "remote" }),
          remoteContent: i[o] || null,
          previewResource: this.h.joinPath(this.g, o),
          previewResult: a,
          localChange: a.localChange,
          remoteChange: a.remoteChange,
          acceptedResource: this.h.joinPath(this.g, o).with({ scheme: _, authority: "accepted" }),
        });
      }
    return [...r.values()];
  }
  async resolveContent(e) {
    return this.h.isEqualOrParent(e, this.g.with({ scheme: _, authority: "remote" })) ||
      this.h.isEqualOrParent(e, this.g.with({ scheme: _, authority: "local" })) ||
      this.h.isEqualOrParent(e, this.g.with({ scheme: _, authority: "base" })) ||
      this.h.isEqualOrParent(e, this.g.with({ scheme: _, authority: "accepted" }))
      ? this.db(e)
      : null;
  }
  async hasLocalData() {
    try {
      const e = await this.Hb();
      if (Object.keys(e).length) return !0;
    } catch {}
    return !1;
  }
  async Cb(e) {
    const s = {};
    for (const i of e) i.fileContent && (s[this.h.basename(i.localResource)] = i.fileContent);
    await this.nb(JSON.stringify(this.Gb(s)));
  }
  async Db(e, s) {
    for (const { fileContent: i, acceptResult: n, localResource: r, remoteResource: o, localChange: a } of e)
      if (a !== 0) {
        const c = o ? this.h.basename(o) : this.h.basename(r),
          l = this.h.joinPath(this.vb, c);
        a === 3
          ? (this.O.trace(`${this.D}: Deleting snippet...`, this.h.basename(l)), await this.G.del(l), this.O.info(`${this.D}: Deleted snippet`, this.h.basename(l)))
          : a === 1
            ? (this.O.trace(`${this.D}: Creating snippet...`, this.h.basename(l)), await this.G.createFile(l, L.fromString(n.content), { overwrite: s }), this.O.info(`${this.D}: Created snippet`, this.h.basename(l)))
            : (this.O.trace(`${this.D}: Updating snippet...`, this.h.basename(l)), await this.G.writeFile(l, L.fromString(n.content), s ? void 0 : i), this.O.info(`${this.D}: Updated snippet`, this.h.basename(l)));
      }
  }
  async Eb(e, s, i) {
    const n = s.syncData ? this.Fb(s.syncData) : {},
      r = rs(n);
    for (const { acceptResult: o, localResource: a, remoteResource: c, remoteChange: l } of e)
      if (l !== 0) {
        const h = a ? this.h.basename(a) : this.h.basename(c);
        l === 3 ? delete r[h] : (r[h] = o.content);
      }
    return J7(n, r) || (this.O.trace(`${this.D}: Updating remote snippets...`), (s = await this.mb(JSON.stringify(r), i ? null : s.ref)), this.O.info(`${this.D}: Updated remote snippets`)), s;
  }
  Fb(e) {
    return $u(e);
  }
  Gb(e) {
    const s = {};
    for (const i of Object.keys(e)) s[i] = e[i].value.toString();
    return s;
  }
  async Hb() {
    const e = {};
    let s;
    try {
      s = await this.G.resolve(this.vb);
    } catch (i) {
      if (i instanceof et && i.fileOperationResult === 1) return e;
      throw i;
    }
    for (const i of s.children || []) {
      const n = i.resource,
        r = this.h.extname(n);
      if (r === ".json" || r === ".code-snippets") {
        const o = this.h.relativePath(this.vb, n),
          a = await this.G.readFile(n);
        e[o] = a;
      }
    }
    return e;
  }
};
xu = __decorate([__param(2, fe), __param(3, ie), __param(4, ae), __param(5, St), __param(6, ts), __param(7, Pe), __param(8, Ce), __param(9, jt), __param(10, Se), __param(11, ke)], xu);
var $0 = class extends fi {
  constructor(e, s, i, n, r, o) {
    super("snippets", s, i, n, e, r, o);
  }
  async o(e) {
    const s = e.syncData ? JSON.parse(e.syncData.content) : null;
    if (!s) {
      this.j.info("Skipping initializing snippets because remote snippets does not exist.");
      return;
    }
    if (!(await this.i())) {
      this.j.info("Skipping initializing snippets because local snippets exist.");
      return;
    }
    for (const n of Object.keys(s)) {
      const r = s[n];
      if (r) {
        const o = this.d.joinPath(this.g.defaultProfile.snippetsHome, n);
        await this.k.createFile(o, L.fromString(r)), this.j.info("Created snippet", this.d.basename(o));
      }
    }
    await this.n(e);
  }
  async i() {
    try {
      return !(await this.k.resolve(this.g.defaultProfile.snippetsHome)).children?.length;
    } catch (e) {
      return e.fileOperationResult === 1;
    }
  }
};
$0 = __decorate([__param(0, ie), __param(1, Te), __param(2, fe), __param(3, Pe), __param(4, ae), __param(5, ke)], $0);
function Br(t, e) {
  try {
    return JSON.parse(t).tasks ?? null;
  } catch (s) {
    return e.error(s), null;
  }
}
var Cu = class extends La {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f) {
    super(e.tasksResource, { syncResource: "tasks", profile: e }, s, c, l, h, i, n, a, u, r, o, f),
      (this.pb = 1),
      (this.Ab = this.h.joinPath(this.g, "tasks.json")),
      (this.Bb = this.Ab.with({ scheme: _, authority: "base" })),
      (this.Cb = this.Ab.with({ scheme: _, authority: "local" })),
      (this.Db = this.Ab.with({ scheme: _, authority: "remote" })),
      (this.Eb = this.Ab.with({ scheme: _, authority: "accepted" }));
  }
  async qb(e, s, i, n) {
    const r = e.syncData ? Br(e.syncData.content, this.O) : null;
    s = s === null && i ? e : s;
    const o = s?.syncData ? Br(s.syncData.content, this.O) : null,
      a = await this.vb();
    let c = null,
      l = !1,
      h = !1,
      u = !1;
    if (e.syncData) {
      const p = a ? a.value.toString() : null;
      if (!o || o !== p || o !== r) {
        this.O.trace(`${this.D}: Merging remote tasks with local tasks...`);
        const g = C0(p, r, o);
        (c = g.content), (u = g.hasConflicts), (l = g.hasLocalChanged), (h = g.hasRemoteChanged);
      }
    } else a && (this.O.trace(`${this.D}: Remote tasks does not exist. Synchronizing tasks for the first time.`), (c = a.value.toString()), (h = !0));
    const f = { content: u ? o : c, localChange: l ? (a ? 2 : 1) : 0, remoteChange: h ? 2 : 0, hasConflicts: u },
      d = a ? a.value.toString() : null;
    return [
      {
        fileContent: a,
        baseResource: this.Bb,
        baseContent: o,
        localResource: this.Cb,
        localContent: d,
        localChange: f.localChange,
        remoteResource: this.Db,
        remoteContent: r,
        remoteChange: f.remoteChange,
        previewResource: this.Ab,
        previewResult: f,
        acceptedResource: this.Eb,
      },
    ];
  }
  async ub(e) {
    const s = e?.syncData ? Br(e.syncData.content, this.O) : null;
    if (s === null) return !0;
    const i = await this.vb(),
      n = i ? i.value.toString() : null,
      r = C0(n, s, s);
    return r.hasLocalChanged || r.hasRemoteChanged;
  }
  async rb(e, s) {
    return e.previewResult;
  }
  async sb(e, s, i, n) {
    if (this.h.isEqual(s, this.Cb)) return { content: e.fileContent ? e.fileContent.value.toString() : null, localChange: 0, remoteChange: 2 };
    if (this.h.isEqual(s, this.Db)) return { content: e.remoteContent, localChange: 2, remoteChange: 0 };
    if (this.h.isEqual(s, this.Ab)) return i === void 0 ? { content: e.previewResult.content, localChange: e.previewResult.localChange, remoteChange: e.previewResult.remoteChange } : { content: i, localChange: 2, remoteChange: 2 };
    throw new Error(`Invalid Resource: ${s.toString()}`);
  }
  async tb(e, s, i, n) {
    const { fileContent: r } = i[0][0],
      { content: o, localChange: a, remoteChange: c } = i[0][1];
    if (
      (a === 0 && c === 0 && this.O.info(`${this.D}: No changes found during synchronizing tasks.`),
      a !== 0 && (this.O.trace(`${this.D}: Updating local tasks...`), r && (await this.nb(JSON.stringify(this.Kb(r.value.toString())))), o ? await this.wb(o, r, n) : await this.xb(), this.O.info(`${this.D}: Updated local tasks`)),
      c !== 0)
    ) {
      this.O.trace(`${this.D}: Updating remote tasks...`);
      const l = JSON.stringify(this.Kb(o));
      (e = await this.mb(l, n ? null : e.ref)), this.O.info(`${this.D}: Updated remote tasks`);
    }
    try {
      await this.G.del(this.Ab);
    } catch {}
    s?.ref !== e.ref && (this.O.trace(`${this.D}: Updating last synchronized tasks...`), await this.fb(e), this.O.info(`${this.D}: Updated last synchronized tasks`));
  }
  async hasLocalData() {
    return this.G.exists(this.r);
  }
  async resolveContent(e) {
    return this.h.isEqual(this.Db, e) || this.h.isEqual(this.Bb, e) || this.h.isEqual(this.Cb, e) || this.h.isEqual(this.Eb, e) ? this.db(e) : null;
  }
  Kb(e) {
    return e ? { tasks: e } : {};
  }
};
Cu = __decorate([__param(2, St), __param(3, ts), __param(4, Pe), __param(5, Ce), __param(6, jt), __param(7, ie), __param(8, fe), __param(9, ae), __param(10, Se), __param(11, ke)], Cu);
var x0 = class extends fi {
  constructor(e, s, i, n, r, o) {
    super("tasks", s, i, n, e, r, o), (this.c = this.g.defaultProfile.tasksResource);
  }
  async o(e) {
    const s = e.syncData ? Br(e.syncData.content, this.j) : null;
    if (!s) {
      this.j.info("Skipping initializing tasks because remote tasks does not exist.");
      return;
    }
    if (!(await this.p())) {
      this.j.info("Skipping initializing tasks because local tasks exist.");
      return;
    }
    await this.k.writeFile(this.c, L.fromString(s)), await this.n(e);
  }
  async p() {
    return this.k.exists(this.c);
  }
};
x0 = __decorate([__param(0, ie), __param(1, Te), __param(2, fe), __param(3, Pe), __param(4, ae), __param(5, ke)], x0);
function C0(t, e, s) {
  if (t === null && e === null && s === null) return { content: null, hasLocalChanged: !1, hasRemoteChanged: !1, hasConflicts: !1 };
  if (t === e) return { content: null, hasLocalChanged: !1, hasRemoteChanged: !1, hasConflicts: !1 };
  const i = s !== t,
    n = s !== e;
  return !i && !n
    ? { content: null, hasLocalChanged: !1, hasRemoteChanged: !1, hasConflicts: !1 }
    : i && !n
      ? { content: t, hasRemoteChanged: !0, hasLocalChanged: !1, hasConflicts: !1 }
      : n && !i
        ? { content: e, hasLocalChanged: !0, hasRemoteChanged: !1, hasConflicts: !1 }
        : { content: t, hasLocalChanged: !0, hasRemoteChanged: !0, hasConflicts: !0 };
}
function Ga(t, e, s, i) {
  const n = { added: [], removed: [], updated: [] };
  let r = { added: [], removed: [], updated: [] };
  if (!e) {
    const a = t.filter(({ id: c }) => !i.includes(c));
    return a.length ? (r.added = a) : (r = null), { local: n, remote: r };
  }
  const o = ku(t, e, i);
  if (o.added.length > 0 || o.removed.length > 0 || o.updated.length > 0) {
    const a = ku(s, t, i),
      c = ku(s, e, i);
    for (const l of c.removed) {
      const h = t.find((u) => u.id === l);
      h && n.removed.push(h);
    }
    for (const l of c.added) {
      const h = e.find((u) => u.id === l);
      a.added.includes(l) ? o.updated.includes(l) && n.updated.push(h) : n.added.push(h);
    }
    for (const l of c.updated) n.updated.push(e.find((h) => h.id === l));
    for (const l of a.added) c.added.includes(l) || r.added.push(t.find((h) => h.id === l));
    for (const l of a.updated) c.removed.includes(l) || c.updated.includes(l) || r.updated.push(t.find((h) => h.id === l));
    for (const l of a.removed) {
      const h = e.find((u) => u.id === l);
      h && r.removed.push(h);
    }
  }
  return r.added.length === 0 && r.removed.length === 0 && r.updated.length === 0 && (r = null), { local: n, remote: r };
}
function ku(t, e, s) {
  (t = t ? t.filter(({ id: c }) => !s.includes(c)) : []), (e = e.filter(({ id: c }) => !s.includes(c)));
  const i = t.map(({ id: c }) => c),
    n = e.map(({ id: c }) => c),
    r = n.filter((c) => !i.includes(c)),
    o = i.filter((c) => !n.includes(c)),
    a = [];
  for (const { id: c, name: l, icon: h, useDefaultFlags: u } of t) {
    if (o.includes(c)) continue;
    const f = e.find((d) => d.id === c);
    (!f || f.name !== l || f.icon !== h || !Rt(f.useDefaultFlags, u)) && a.push(c);
  }
  return { added: r, removed: o, updated: a };
}
var zr = class extends qi {
  constructor(e, s, i, n, r, o, a, c, l, h, u, f, d) {
    super({ syncResource: "profiles", profile: e }, s, n, r, o, a, c, u, f, l, h, d),
      (this.vb = i),
      (this.pb = 2),
      (this.previewResource = this.h.joinPath(this.g, "profiles.json")),
      (this.baseResource = this.previewResource.with({ scheme: _, authority: "base" })),
      (this.localResource = this.previewResource.with({ scheme: _, authority: "local" })),
      (this.remoteResource = this.previewResource.with({ scheme: _, authority: "remote" })),
      (this.acceptedResource = this.previewResource.with({ scheme: _, authority: "accepted" })),
      this.B(i.onDidChangeProfiles(() => this.Q()));
  }
  async getLastSyncedProfiles() {
    const e = await this.getLastSyncUserData();
    return e?.syncData ? Hi(e.syncData) : null;
  }
  async getRemoteSyncedProfiles(e) {
    const s = await this.getLastSyncUserData(),
      i = await this.X(e, s);
    return i?.syncData ? Hi(i.syncData) : null;
  }
  async qb(e, s, i) {
    const n = e.syncData ? Hi(e.syncData) : null,
      r = s?.syncData ? Hi(s.syncData) : null,
      o = this.Db(),
      { local: a, remote: c } = Ga(o, n, r, []),
      l = { local: a, remote: c, content: r ? this.Eb(r) : null, localChange: a.added.length > 0 || a.removed.length > 0 || a.updated.length > 0 ? 2 : 0, remoteChange: c !== null ? 2 : 0 },
      h = Du(o, !1);
    return [
      {
        baseResource: this.baseResource,
        baseContent: r ? this.Eb(r) : null,
        localResource: this.localResource,
        localContent: h,
        remoteResource: this.remoteResource,
        remoteContent: n ? this.Eb(n) : null,
        remoteProfiles: n,
        previewResource: this.previewResource,
        previewResult: l,
        localChange: l.localChange,
        remoteChange: l.remoteChange,
        acceptedResource: this.acceptedResource,
      },
    ];
  }
  async ub(e) {
    const s = e?.syncData ? Hi(e.syncData) : null,
      i = this.Db(),
      { remote: n } = Ga(i, s, s, []);
    return !!n?.added.length || !!n?.removed.length || !!n?.updated.length;
  }
  async rb(e, s) {
    return { ...e.previewResult, hasConflicts: !1 };
  }
  async sb(e, s, i, n) {
    if (this.h.isEqual(s, this.localResource)) return this.Ab(e);
    if (this.h.isEqual(s, this.remoteResource)) return this.Bb(e);
    if (this.h.isEqual(s, this.previewResource)) return e.previewResult;
    throw new Error(`Invalid Resource: ${s.toString()}`);
  }
  async Ab(e) {
    const s = this.Db(),
      i = Ga(s, null, null, []),
      { local: n, remote: r } = i;
    return { content: e.localContent, local: n, remote: r, localChange: n.added.length > 0 || n.removed.length > 0 || n.updated.length > 0 ? 2 : 0, remoteChange: r !== null ? 2 : 0 };
  }
  async Bb(e) {
    const s = e.remoteContent ? JSON.parse(e.remoteContent) : null,
      i = [],
      n = [];
    for (const r of this.Db()) {
      const o = s?.find((a) => a.id === r.id);
      o && (i.push({ id: r.id, name: r.name, collection: o.collection }), n.push(r));
    }
    if (s !== null) {
      const r = Ga(n, s, i, []),
        { local: o, remote: a } = r;
      return { content: e.remoteContent, local: o, remote: a, localChange: o.added.length > 0 || o.removed.length > 0 || o.updated.length > 0 ? 2 : 0, remoteChange: a !== null ? 2 : 0 };
    } else return { content: e.remoteContent, local: { added: [], removed: [], updated: [] }, remote: null, localChange: 0, remoteChange: 0 };
  }
  async tb(e, s, i, n) {
    const { local: r, remote: o, localChange: a, remoteChange: c } = i[0][1];
    a === 0 && c === 0 && this.O.info(`${this.D}: No changes found during synchronizing profiles.`);
    const l = i[0][0].remoteProfiles || [];
    if (l.length + (o?.added.length ?? 0) - (o?.removed.length ?? 0) > 20) throw new De("Too many profiles to sync. Please remove some profiles and try again.", "LocalTooManyProfiles");
    if (
      (a !== 0 &&
        (await this.nb(Du(this.Db(), !1)),
        await Promise.all(
          r.removed.map(async (h) => {
            this.O.trace(`${this.D}: Removing '${h.name}' profile...`), await this.vb.removeProfile(h), this.O.info(`${this.D}: Removed profile '${h.name}'.`);
          }),
        ),
        await Promise.all(
          r.added.map(async (h) => {
            this.O.trace(`${this.D}: Creating '${h.name}' profile...`), await this.vb.createProfile(h.id, h.name, { icon: h.icon, useDefaultFlags: h.useDefaultFlags }), this.O.info(`${this.D}: Created profile '${h.name}'.`);
          }),
        ),
        await Promise.all(
          r.updated.map(async (h) => {
            const u = this.vb.profiles.find((f) => f.id === h.id);
            u
              ? (this.O.trace(`${this.D}: Updating '${h.name}' profile...`), await this.vb.updateProfile(u, { name: h.name, icon: h.icon, useDefaultFlags: h.useDefaultFlags }), this.O.info(`${this.D}: Updated profile '${h.name}'.`))
              : this.O.info(`${this.D}: Could not find profile with id '${h.id}' to update.`);
          }),
        )),
      c !== 0)
    ) {
      this.O.trace(`${this.D}: Updating remote profiles...`);
      const h = [],
        u = l.length + (o?.added.length ?? 0) <= 20;
      if (u)
        for (const f of o?.added || []) {
          const d = await this.J.createCollection(this.F);
          h.push(d), l.push({ id: f.id, name: f.name, collection: d, icon: f.icon, useDefaultFlags: f.useDefaultFlags });
        }
      else this.O.info(`${this.D}: Could not create remote profiles as there are too many profiles.`);
      for (const f of o?.removed || [])
        l.splice(
          l.findIndex(({ id: d }) => f.id === d),
          1,
        );
      for (const f of o?.updated || []) {
        const d = l.find(({ id: p }) => f.id === p);
        d && l.splice(l.indexOf(d), 1, { ...d, id: f.id, name: f.name, icon: f.icon, useDefaultFlags: f.useDefaultFlags });
      }
      try {
        (e = await this.updateRemoteProfiles(l, n ? null : e.ref)),
          this.O.info(
            `${this.D}: Updated remote profiles.${u && o?.added.length ? ` Added: ${JSON.stringify(o.added.map((f) => f.name))}.` : ""}${o?.updated.length ? ` Updated: ${JSON.stringify(o.updated.map((f) => f.name))}.` : ""}${o?.removed.length ? ` Removed: ${JSON.stringify(o.removed.map((f) => f.name))}.` : ""}`,
          );
      } catch (f) {
        if (h.length) {
          this.O.info(`${this.D}: Failed to update remote profiles. Cleaning up added collections...`);
          for (const d of h) await this.J.deleteCollection(d, this.F);
        }
        throw f;
      }
      for (const f of o?.removed || []) await this.J.deleteCollection(f.collection, this.F);
    }
    s?.ref !== e.ref && (this.O.trace(`${this.D}: Updating last synchronized profiles...`), await this.fb(e), this.O.info(`${this.D}: Updated last synchronized profiles.`));
  }
  async updateRemoteProfiles(e, s) {
    return this.mb(this.Eb(e), s);
  }
  async hasLocalData() {
    return this.Db().length > 0;
  }
  async resolveContent(e) {
    if (this.h.isEqual(this.remoteResource, e) || this.h.isEqual(this.baseResource, e) || this.h.isEqual(this.localResource, e) || this.h.isEqual(this.acceptedResource, e)) {
      const s = await this.db(e);
      return s && yr(JSON.parse(s), {});
    }
    return null;
  }
  Db() {
    return this.vb.profiles.filter((e) => !e.isDefault && !e.isTransient);
  }
  Eb(e) {
    return JSON.stringify([...e].sort((s, i) => s.name.localeCompare(i.name)));
  }
};
zr = __decorate([__param(2, Te), __param(3, ie), __param(4, fe), __param(5, ae), __param(6, St), __param(7, ts), __param(8, Pe), __param(9, Ce), __param(10, jt), __param(11, Se), __param(12, ke)], zr);
function Du(t, e) {
  const s = [...t].sort((i, n) => i.name.localeCompare(n.name)).map((i) => ({ id: i.id, name: i.name }));
  return e ? yr(s, {}) : JSON.stringify(s);
}
function Hi(t) {
  return JSON.parse(t.content);
}
var Iu = "sync.lastSyncTime",
  Ru = class extends O {
    get status() {
      return this.f;
    }
    get conflicts() {
      return this.j;
    }
    get lastSyncTime() {
      return this.t;
    }
    constructor(e, s, i, n, r, o, a, c, l, h, u) {
      super(),
        (this.C = e),
        (this.D = s),
        (this.F = i),
        (this.G = n),
        (this.H = r),
        (this.I = o),
        (this.J = a),
        (this.L = c),
        (this.M = l),
        (this.N = h),
        (this.O = u),
        (this.f = "uninitialized"),
        (this.g = this.B(new D())),
        (this.onDidChangeStatus = this.g.event),
        (this.h = this.B(new D())),
        (this.onDidChangeLocal = this.h.event),
        (this.j = []),
        (this.m = this.B(new D())),
        (this.onDidChangeConflicts = this.m.event),
        (this.n = []),
        (this.r = this.B(new D())),
        (this.onSyncErrors = this.r.event),
        (this.t = void 0),
        (this.u = this.B(new D())),
        (this.onDidChangeLastSyncTime = this.u.event),
        (this.w = this.B(new D())),
        (this.onDidResetLocal = this.w.event),
        (this.y = this.B(new D())),
        (this.onDidResetRemote = this.y.event),
        (this.z = new Map()),
        (this.f = i.userDataSyncStore ? "idle" : "uninitialized"),
        (this.t = this.J.getNumber(Iu, -1, void 0)),
        this.B(ue(() => this.cb())),
        this.B(new ks(() => this.W(), 5 * 1e3)).schedule();
    }
    async createSyncTask(e, s) {
      this.db(), this.H.info("Sync started.");
      const i = new Date().getTime(),
        n = Me();
      try {
        const c = Fn(n);
        s && (c["Cache-Control"] = "no-cache"), (e = await this.D.manifest(e, c));
      } catch (c) {
        const l = De.toUserDataSyncError(c);
        throw (Ja(l, n, this.F, this.I), l);
      }
      const r = !1,
        o = this;
      let a;
      return {
        manifest: e,
        async run() {
          if (r) throw new Error("Can run a task only once");
          (a = wt((c) => o.P(e, !1, n, c))), await a.finally(() => (a = void 0)), o.H.info(`Sync done. Took ${new Date().getTime() - i}ms`), o.ab();
        },
        stop() {
          return a?.cancel(), o.U();
        },
      };
    }
    async createManualSyncTask() {
      if ((this.db(), this.L.isEnabled())) throw new De("Cannot start manual sync when sync is enabled", "LocalError");
      this.H.info("Sync started.");
      const e = new Date().getTime(),
        s = Me(),
        i = Fn(s);
      let n;
      try {
        n = await this.D.manifest(null, i);
      } catch (a) {
        const c = De.toUserDataSyncError(a);
        throw (Ja(c, s, this.F, this.I), c);
      }
      await this.resetLocal();
      const r = this,
        o = new xs();
      return {
        id: s,
        async merge() {
          return r.P(n, !0, s, o.token);
        },
        async apply() {
          try {
            try {
              await r.R(n, s, o.token);
            } catch (a) {
              if (De.toUserDataSyncError(a).code === "MethodNotFound") r.H.info("Client is making invalid requests. Cleaning up data..."), await r.cleanUpRemoteData(), r.H.info("Applying manual sync again..."), await r.R(n, s, o.token);
              else throw a;
            }
          } catch (a) {
            throw (r.H.error(a), a);
          }
          r.H.info(`Sync done. Took ${new Date().getTime() - e}ms`), r.ab();
        },
        async stop() {
          o.cancel(), await r.U(), await r.resetLocal();
        },
      };
    }
    async P(e, s, i, n) {
      this.n = [];
      try {
        this.status !== "hasConflicts" && this.Z("syncing");
        const r = this.getOrCreateActiveProfileSynchronizer(this.M.defaultProfile, void 0);
        this.n.push(...(await this.S(r, e, s, i, n)));
        const o = r.enabled.find((a) => a.resource === "profiles");
        if (o) {
          const a = (await o.getLastSyncedProfiles()) || [];
          if (n.isCancellationRequested) return;
          await this.Q(a, e, s, i, n);
        }
      } finally {
        this.status !== "hasConflicts" && this.Z("idle"), this.r.fire(this.n);
      }
    }
    async Q(e, s, i, n, r) {
      for (const o of e) {
        if (r.isCancellationRequested) return;
        const a = this.M.profiles.find((l) => l.id === o.id);
        if (!a) {
          this.H.error(`Profile with id:${o.id} and name: ${o.name} does not exist locally to sync.`);
          continue;
        }
        this.H.info("Syncing profile.", o.name);
        const c = this.getOrCreateActiveProfileSynchronizer(a, o);
        this.n.push(...(await this.S(c, s, i, n, r)));
      }
      for (const [o, a] of this.z.entries()) this.M.profiles.some((c) => c.id === a[0].profile.id) || (await a[0].resetLocal(), a[1].dispose(), this.z.delete(o));
    }
    async R(e, s, i) {
      try {
        this.Z("syncing");
        const n = this.bb();
        for (const l of n) {
          if (i.isCancellationRequested) return;
          await l.apply(s, i);
        }
        const r = n.find((l) => l.profile.isDefault);
        if (!r) return;
        const o = r.enabled.find((l) => l.resource === "profiles");
        if (!o) return;
        const c = ((await o.getRemoteSyncedProfiles(e?.latest ?? null)) || []).filter((l) => n.every((h) => h.profile.id !== l.id));
        c.length && (await this.Q(c, e, !1, s, i));
      } finally {
        this.Z("idle");
      }
    }
    async S(e, s, i, n, r) {
      return (await e.sync(s, i, n, r)).map(([a, c]) => ({ profile: e.profile, syncResource: a, error: c }));
    }
    async U() {
      this.status !== "idle" && (await Promise.allSettled(this.bb().map((e) => e.stop())));
    }
    async resolveContent(e) {
      const s = await this.N.resolveContent(e);
      if (s) return s;
      for (const i of this.bb())
        for (const n of i.enabled) {
          const r = await n.resolveContent(e);
          if (r) return r;
        }
      return null;
    }
    async replace(e) {
      this.db();
      const s = this.N.resolveUserDataSyncResource(e);
      if (!s) return;
      const i = await this.resolveContent(e.uri);
      i &&
        (await this.X(s.profile, async (n) => {
          if (s.syncResource === n.resource) return await n.replace(i), !0;
        }));
    }
    async accept(e, s, i, n) {
      this.db(),
        await this.X(e.profile, async (r) => {
          if (e.syncResource === r.resource) return await r.accept(s, i), n && (await r.apply(Ms(n) ? !1 : n.force, Fn(Me()))), !0;
        });
    }
    async hasLocalData() {
      return !!(await this.X(this.M.defaultProfile, async (s) => {
        if (s.resource !== "globalState" && (await s.hasLocalData())) return !0;
      }));
    }
    async hasPreviouslySynced() {
      return !!(await this.X(this.M.defaultProfile, async (s) => {
        if (await s.hasPreviouslySynced()) return !0;
      }));
    }
    async reset() {
      this.db(), await this.resetRemote(), await this.resetLocal();
    }
    async resetRemote() {
      this.db();
      try {
        await this.D.clear(), this.H.info("Cleared data on server");
      } catch (e) {
        this.H.error(e);
      }
      this.y.fire();
    }
    async resetLocal() {
      this.db(), (this.t = void 0), this.J.remove(Iu, -1);
      for (const [e] of this.z.values())
        try {
          await e.resetLocal();
        } catch (s) {
          this.H.error(s);
        }
      this.cb(), this.w.fire(), this.H.info("Did reset the local sync state.");
    }
    async W() {
      const e = this.J.keys(-1, 1),
        s = [];
      for (const n of e) {
        if (!n.endsWith(".lastSyncUserData")) continue;
        const r = n.split(".");
        r.length === 3 && s.push([n, r[0]]);
      }
      if (!s.length) return;
      const i = new ye();
      try {
        let n = this.z.get(this.M.defaultProfile.id)?.[0];
        n || (n = i.add(this.G.createInstance(_n, this.M.defaultProfile, void 0)));
        const r = n.enabled.find((c) => c.resource === "profiles");
        if (!r) return;
        const a = (await r.getLastSyncedProfiles())?.map((c) => c.collection) ?? [];
        for (const [c, l] of s) a.includes(l) || (this.H.info(`Removing last sync state for stale profile: ${l}`), this.J.remove(c, -1));
      } finally {
        i.dispose();
      }
    }
    async cleanUpRemoteData() {
      const e = await this.N.getRemoteSyncedProfiles(),
        s = e.map((o) => o.collection),
        i = await this.D.getAllCollections(),
        n = i.filter((o) => !s.includes(o));
      n.length && (this.H.info(`Deleting ${n.length} redundant collections on server`), await Promise.allSettled(n.map((o) => this.D.deleteCollection(o))), this.H.info("Deleted redundant collections on server"));
      const r = e.filter((o) => i.includes(o.collection));
      if (r.length !== e.length) {
        const o = this.G.createInstance(zr, this.M.defaultProfile, void 0);
        try {
          this.H.info("Resetting the last synced state of profiles"),
            await o.resetLocal(),
            this.H.info("Did reset the last synced state of profiles"),
            this.H.info("Updating remote profiles with invalid collections on server"),
            await o.updateRemoteProfiles(r, null),
            this.H.info("Updated remote profiles on server");
        } finally {
          o.dispose();
        }
      }
    }
    async saveRemoteActivityData(e) {
      this.db();
      const s = await this.D.getActivityData();
      await this.C.writeFile(e, s);
    }
    async extractActivityData(e, s) {
      const i = (await this.C.readFile(e)).value.toString(),
        n = JSON.parse(i);
      if (n.resources) for (const r in n.resources) for (const o of n.resources[r]) await this.O.writeResource(r, o.content, new Date(o.created * 1e3), void 0, s);
      if (n.collections) for (const r in n.collections) for (const o in n.collections[r].resources) for (const a of n.collections[r].resources?.[o] ?? []) await this.O.writeResource(o, a.content, new Date(a.created * 1e3), r, s);
    }
    async X(e, s) {
      const i = new ye();
      try {
        const n = this.z.get(e.id);
        if (n) {
          const l = await this.Y(n[0], s, i);
          return Ct(l) ? null : l;
        }
        if (e.isDefault) {
          const l = i.add(this.G.createInstance(_n, e, void 0)),
            h = await this.Y(l, s, i);
          return Ct(h) ? null : h;
        }
        const r = i.add(this.G.createInstance(zr, e, void 0)),
          o = await this.D.manifest(null),
          c = ((await r.getRemoteSyncedProfiles(o?.latest ?? null)) || []).find((l) => l.id === e.id);
        if (c) {
          const l = i.add(this.G.createInstance(_n, e, c.collection)),
            h = await this.Y(l, s, i);
          return Ct(h) ? null : h;
        }
        return null;
      } finally {
        i.dispose();
      }
    }
    async Y(e, s, i) {
      const n = [...e.enabled, ...e.disabled.reduce((r, o) => (o !== "workspaceState" && r.push(i.add(e.createSynchronizer(o))), r), [])];
      for (const r of n) {
        const o = await s(r);
        if (!Ct(o)) return o;
      }
    }
    Z(e) {
      const s = this.f;
      this.f !== e && ((this.f = e), this.g.fire(e), s === "hasConflicts" && this.ab());
    }
    $() {
      const e = this.bb()
        .map((s) => s.conflicts)
        .flat();
      _t(this.j, e, (s, i) => s.profile.id === i.profile.id && s.syncResource === i.syncResource && _t(s.conflicts, i.conflicts, (n, r) => zs(n.previewResource, r.previewResource))) || ((this.j = e), this.m.fire(e));
    }
    ab() {
      this.status === "idle" && ((this.t = new Date().getTime()), this.J.store(Iu, this.t, -1, 1), this.u.fire(this.t));
    }
    getOrCreateActiveProfileSynchronizer(e, s) {
      let i = this.z.get(e.id);
      if ((i && i[0].collection !== s?.collection && (this.H.error("Profile synchronizer collection does not match with the remote sync profile collection"), i[1].dispose(), (i = void 0), this.z.delete(e.id)), !i)) {
        const n = new ye(),
          r = n.add(this.G.createInstance(_n, e, s?.collection));
        n.add(r.onDidChangeStatus((o) => this.Z(o))), n.add(r.onDidChangeConflicts((o) => this.$())), n.add(r.onDidChangeLocal((o) => this.h.fire(o))), this.z.set(e.id, (i = [r, n]));
      }
      return i[0];
    }
    bb() {
      const e = [];
      for (const [s] of this.z.values()) e.push(s);
      return e;
    }
    cb() {
      this.z.forEach(([, e]) => e.dispose()), this.z.clear();
    }
    db() {
      if (!this.F.userDataSyncStore) throw new Error("Not enabled");
    }
  };
Ru = __decorate([__param(0, ie), __param(1, St), __param(2, hi), __param(3, ds), __param(4, Pe), __param(5, Se), __param(6, ae), __param(7, jt), __param(8, Te), __param(9, Vh), __param(10, ts)], Ru);
var _n = class extends O {
  get enabled() {
    return this.f.sort((e, s) => e[1] - s[1]).map(([e]) => e);
  }
  get disabled() {
    return jn.filter((e) => !this.r.isResourceEnabled(e));
  }
  get status() {
    return this.g;
  }
  get conflicts() {
    return this.m;
  }
  constructor(e, s, i, n, r, o, a, c, l) {
    super(),
      (this.profile = e),
      (this.collection = s),
      (this.r = i),
      (this.t = n),
      (this.u = r),
      (this.w = o),
      (this.y = a),
      (this.z = c),
      (this.C = l),
      (this.f = []),
      (this.g = "idle"),
      (this.h = this.B(new D())),
      (this.onDidChangeStatus = this.h.event),
      (this.j = this.B(new D())),
      (this.onDidChangeLocal = this.j.event),
      (this.m = []),
      (this.n = this.B(new D())),
      (this.onDidChangeConflicts = this.n.event),
      this.B(i.onDidChangeResourceEnablement(([h, u]) => this.D(h, u))),
      this.B(ue(() => this.f.splice(0, this.f.length).forEach(([, , h]) => h.dispose())));
    for (const h of jn) i.isResourceEnabled(h) && this.F(h);
  }
  D(e, s) {
    s ? this.F(e) : this.G(e);
  }
  F(e) {
    if (this.f.some(([r]) => r.resource === e)) return;
    if (e === "extensions" && !this.u.isEnabled()) {
      this.z.info("Skipping extensions sync because gallery is not configured");
      return;
    }
    if ((e === "profiles" && !this.profile.isDefault) || e === "workspaceState") return;
    if (e !== "profiles" && this.profile.useDefaultFlags?.[e]) {
      this.z.debug(`Skipping syncing ${e} in ${this.profile.name} because it is already synced by default profile`);
      return;
    }
    const s = new ye(),
      i = s.add(this.createSynchronizer(e));
    s.add(i.onDidChangeStatus(() => this.J())), s.add(i.onDidChangeConflicts(() => this.L())), s.add(i.onDidChangeLocal(() => this.j.fire(e)));
    const n = this.M(e);
    this.f.push([i, n, s]);
  }
  G(e) {
    const s = this.f.findIndex(([i]) => i.resource === e);
    if (s !== -1) {
      const [[i, , n]] = this.f.splice(s, 1);
      n.dispose(), this.J(), i.stop().then(null, (r) => this.z.error(r));
    }
  }
  createSynchronizer(e) {
    switch (e) {
      case "settings":
        return this.t.createInstance(Wa, this.profile, this.collection);
      case "keybindings":
        return this.t.createInstance(wu, this.profile, this.collection);
      case "snippets":
        return this.t.createInstance(xu, this.profile, this.collection);
      case "tasks":
        return this.t.createInstance(Cu, this.profile, this.collection);
      case "globalState":
        return this.t.createInstance(uu, this.profile, this.collection);
      case "extensions":
        return this.t.createInstance(cu, this.profile, this.collection);
      case "profiles":
        return this.t.createInstance(zr, this.profile, this.collection);
    }
  }
  async sync(e, s, i, n) {
    if (n.isCancellationRequested) return [];
    const r = this.enabled;
    if (!r.length) return [];
    try {
      const o = [],
        a = Fn(i),
        c = (this.collection ? e?.collections?.[this.collection]?.latest : e?.latest) ?? null,
        l = s ? await this.H(c) : {};
      for (const h of r) {
        if (n.isCancellationRequested) return [];
        if (!this.r.isResourceEnabled(h.resource)) return [];
        try {
          if (s) {
            const u = await h.preview(c, l, a);
            if (u) for (const f of u.resourcePreviews) (f.localChange !== 0 || f.remoteChange !== 0) && f.mergeState === "preview" && (await h.merge(f.previewResource));
          } else await h.sync(c, a);
        } catch (u) {
          const f = De.toUserDataSyncError(u);
          if ((Ja(f, i, this.w, this.y), k0(u))) throw f;
          this.z.error(u), this.z.error(`${h.resource}: ${Xe(u)}`), o.push([h.resource, f]);
        }
      }
      return o;
    } finally {
      this.J();
    }
  }
  async apply(e, s) {
    const i = Fn(e);
    for (const n of this.enabled) {
      if (s.isCancellationRequested) return;
      try {
        await n.apply(!1, i);
      } catch (r) {
        const o = De.toUserDataSyncError(r);
        if ((Ja(o, e, this.w, this.y), k0(r))) throw o;
        this.z.error(r), this.z.error(`${n.resource}: ${Xe(r)}`);
      }
    }
  }
  async stop() {
    for (const e of this.enabled)
      try {
        e.status !== "idle" && (await e.stop());
      } catch (s) {
        this.z.error(s);
      }
  }
  async resetLocal() {
    for (const e of this.enabled)
      try {
        await e.resetLocal();
      } catch (s) {
        this.z.error(`${e.resource}: ${Xe(s)}`), this.z.error(s);
      }
  }
  async H(e) {
    if (!this.profile.isDefault) return {};
    const s = this.C.getValue(Sa),
      i = this.enabled.find((n) => n instanceof Wa);
    if (i) {
      const n = await i.getRemoteUserDataSyncConfiguration(e);
      return { ...s, ...n };
    }
    return s;
  }
  I(e) {
    this.g !== e && ((this.g = e), this.h.fire(e));
  }
  J() {
    return this.L(), this.enabled.some((e) => e.status === "hasConflicts") ? this.I("hasConflicts") : this.enabled.some((e) => e.status === "syncing") ? this.I("syncing") : this.I("idle");
  }
  L() {
    const e = this.enabled
      .filter((s) => s.status === "hasConflicts")
      .filter((s) => s.conflicts.conflicts.length > 0)
      .map((s) => s.conflicts);
    _t(this.m, e, (s, i) => s.syncResource === i.syncResource && _t(s.conflicts, i.conflicts, (n, r) => zs(n.previewResource, r.previewResource))) || ((this.m = e), this.n.fire(e));
  }
  M(e) {
    switch (e) {
      case "settings":
        return 0;
      case "keybindings":
        return 1;
      case "snippets":
        return 2;
      case "tasks":
        return 3;
      case "globalState":
        return 4;
      case "extensions":
        return 5;
      case "profiles":
        return 6;
      case "workspaceState":
        return 7;
    }
  }
};
_n = __decorate([__param(2, jt), __param(3, ds), __param(4, ps), __param(5, hi), __param(6, Se), __param(7, Pe), __param(8, Ce)], _n);
function k0(t) {
  if (t instanceof De)
    switch (t.code) {
      case "MethodNotFound":
      case "TooLarge":
      case "RemoteTooManyRequests":
      case "TooManyRequestsAndRetryAfter":
      case "LocalTooManyRequests":
      case "LocalTooManyProfiles":
      case "Gone":
      case "UpgradeRequired":
      case "IncompatibleRemoteContent":
      case "IncompatibleLocalContent":
        return !0;
    }
  return !1;
}
function Ja(t, e, s, i) {
  i.publicLog2("sync/error", { code: t.code, serverCode: t instanceof Le ? String(t.serverCode) : void 0, url: t instanceof Le ? t.url : void 0, resource: t.resource, executionId: e, service: s.userDataSyncStore.url.toString() });
}
function K7(t, e) {
  return { ...t, profile: es(t.profile, e.profilesHome.scheme) };
}
function X7(t) {
  return { created: t.created, uri: C.revive(t.uri) };
}
var Q7 = class {
    constructor(t, e, s) {
      (this.c = t), (this.d = e), (this.f = s), (this.a = new Map()), (this.b = new D());
    }
    listen(t, e) {
      switch (e) {
        case "onDidChangeStatus":
          return this.c.onDidChangeStatus;
        case "onDidChangeConflicts":
          return this.c.onDidChangeConflicts;
        case "onDidChangeLocal":
          return this.c.onDidChangeLocal;
        case "onDidChangeLastSyncTime":
          return this.c.onDidChangeLastSyncTime;
        case "onSyncErrors":
          return this.c.onSyncErrors;
        case "onDidResetLocal":
          return this.c.onDidResetLocal;
        case "onDidResetRemote":
          return this.c.onDidResetRemote;
        case "manualSync/onSynchronizeResources":
          return this.b.event;
      }
      throw new Error(`[UserDataSyncServiceChannel] Event not found: ${e}`);
    }
    async call(t, e, s) {
      try {
        return await this.g(t, e, s);
      } catch (i) {
        throw (this.f.error(i), i);
      }
    }
    async g(t, e, s) {
      switch (e) {
        case "_getInitialData":
          return Promise.resolve([this.c.status, this.c.conflicts, this.c.lastSyncTime]);
        case "reset":
          return this.c.reset();
        case "resetRemote":
          return this.c.resetRemote();
        case "resetLocal":
          return this.c.resetLocal();
        case "hasPreviouslySynced":
          return this.c.hasPreviouslySynced();
        case "hasLocalData":
          return this.c.hasLocalData();
        case "resolveContent":
          return this.c.resolveContent(C.revive(s[0]));
        case "accept":
          return this.c.accept(K7(s[0], this.d), C.revive(s[1]), s[2], s[3]);
        case "replace":
          return this.c.replace(X7(s[0]));
        case "cleanUpRemoteData":
          return this.c.cleanUpRemoteData();
        case "getRemoteActivityData":
          return this.c.saveRemoteActivityData(C.revive(s[0]));
        case "extractActivityData":
          return this.c.extractActivityData(C.revive(s[0]), C.revive(s[1]));
        case "createManualSyncTask":
          return this.i();
      }
      if (e.startsWith("manualSync/")) {
        const i = e.substring(11),
          n = s[0],
          r = this.h(n);
        switch (((s = s.slice(1)), i)) {
          case "merge":
            return r.merge();
          case "apply":
            return r.apply().then(() => this.a.delete(this.j(r.id)));
          case "stop":
            return r.stop().finally(() => this.a.delete(this.j(r.id)));
        }
      }
      throw new Error("Invalid call");
    }
    h(t) {
      const e = this.a.get(this.j(t));
      if (!e) throw new Error(`Manual sync taks not found: ${t}`);
      return e;
    }
    async i() {
      const t = await this.c.createManualSyncTask();
      return this.a.set(this.j(t.id), t), t.id;
    }
    j(t) {
      return `manualSyncTask-${t}`;
    }
  },
  D0 = class extends O {
    get status() {
      return this.b;
    }
    get onDidChangeLocal() {
      return this.a.listen("onDidChangeLocal");
    }
    get conflicts() {
      return this.f;
    }
    get lastSyncTime() {
      return this.h;
    }
    get onDidResetLocal() {
      return this.a.listen("onDidResetLocal");
    }
    get onDidResetRemote() {
      return this.a.listen("onDidResetRemote");
    }
    constructor(e, s) {
      super(),
        (this.n = s),
        (this.b = "uninitialized"),
        (this.c = this.B(new D())),
        (this.onDidChangeStatus = this.c.event),
        (this.f = []),
        (this.g = this.B(new D())),
        (this.onDidChangeConflicts = this.g.event),
        (this.h = void 0),
        (this.j = this.B(new D())),
        (this.onDidChangeLastSyncTime = this.j.event),
        (this.m = this.B(new D())),
        (this.onSyncErrors = this.m.event),
        (this.a = {
          call(i, n, r) {
            return e.call(i, n, r).then(null, (o) => {
              throw De.toUserDataSyncError(o);
            });
          },
          listen(i, n) {
            return e.listen(i, n);
          },
        }),
        this.a.call("_getInitialData").then(([i, n, r]) => {
          this.s(i), this.t(n), r && this.u(r), this.B(this.a.listen("onDidChangeStatus")((o) => this.s(o))), this.B(this.a.listen("onDidChangeLastSyncTime")((o) => this.u(o)));
        }),
        this.B(this.a.listen("onDidChangeConflicts")((i) => this.t(i))),
        this.B(this.a.listen("onSyncErrors")((i) => this.m.fire(i.map((n) => ({ ...n, error: De.toUserDataSyncError(n.error) })))));
    }
    createSyncTask() {
      throw new Error("not supported");
    }
    async createManualSyncTask() {
      const e = await this.a.call("createManualSyncTask"),
        s = this;
      return new Y7(e, {
        async call(n, r, o) {
          return s.a.call(`manualSync/${n}`, [e, ...(Array.isArray(r) ? r : [r])], o);
        },
        listen() {
          throw new Error("not supported");
        },
      });
    }
    reset() {
      return this.a.call("reset");
    }
    resetRemote() {
      return this.a.call("resetRemote");
    }
    resetLocal() {
      return this.a.call("resetLocal");
    }
    hasPreviouslySynced() {
      return this.a.call("hasPreviouslySynced");
    }
    hasLocalData() {
      return this.a.call("hasLocalData");
    }
    accept(e, s, i, n) {
      return this.a.call("accept", [e, s, i, n]);
    }
    resolveContent(e) {
      return this.a.call("resolveContent", [e]);
    }
    cleanUpRemoteData() {
      return this.a.call("cleanUpRemoteData");
    }
    replace(e) {
      return this.a.call("replace", [e]);
    }
    saveRemoteActivityData(e) {
      return this.a.call("getRemoteActivityData", [e]);
    }
    extractActivityData(e, s) {
      return this.a.call("extractActivityData", [e, s]);
    }
    async s(e) {
      (this.b = e), this.c.fire(e);
    }
    async t(e) {
      (this.f = e.map((s) => ({
        syncResource: s.syncResource,
        profile: es(s.profile, this.n.profilesHome.scheme),
        conflicts: s.conflicts.map((i) => ({ ...i, baseResource: C.revive(i.baseResource), localResource: C.revive(i.localResource), remoteResource: C.revive(i.remoteResource), previewResource: C.revive(i.previewResource) })),
      }))),
        this.g.fire(this.f);
    }
    u(e) {
      this.h !== e && ((this.h = e), this.j.fire(e));
    }
  };
D0 = __decorate([__param(1, Te)], D0);
var Y7 = class extends O {
    constructor(t, e) {
      super(), (this.id = t), (this.a = e);
    }
    async merge() {
      return this.a.call("merge");
    }
    async apply() {
      return this.a.call("apply");
    }
    stop() {
      return this.a.call("stop");
    }
    dispose() {
      this.a.call("dispose"), super.dispose();
    }
  },
  Pu = class extends O7 {
    constructor(e, s, i, n) {
      super(!0, e, s, i, n);
    }
  };
Pu = __decorate([__param(0, gr), __param(1, Te), __param(2, ae), __param(3, ne)], Pu);
var Z7 = class extends O {
    constructor({ onDidOpenMainWindow: t, onDidFocusMainWindow: e, getActiveWindowId: s }) {
      super(),
        (this.a = this.B(new ye())),
        T.latch(T.any(t, e))(this.f, this, this.a),
        (this.b = wt(() => s())),
        (async () => {
          try {
            const n = await this.b;
            this.c = typeof this.c == "number" ? this.c : n;
          } catch {
          } finally {
            this.b = void 0;
          }
        })();
    }
    f(t) {
      this.b && (this.b.cancel(), (this.b = void 0)), (this.c = t);
    }
    async getActiveClientId() {
      return `window:${this.b ? await this.b : this.c}`;
    }
  },
  e9 = "signService",
  Ka = z(e9),
  t9 = class fw {
    constructor() {
      this.b = new Map();
    }
    static {
      this.a = 1;
    }
    async createNewMessage(e) {
      try {
        const s = await this.c();
        if (s) {
          const i = String(fw.a++);
          return this.b.set(i, s), { id: i, data: s.createNewMessage(e) };
        }
      } catch {}
      return { id: "", data: e };
    }
    async validate(e, s) {
      if (!e.id) return !0;
      const i = this.b.get(e.id);
      if (!i) return !1;
      this.b.delete(e.id);
      try {
        return i.validate(s) === "ok";
      } catch {
        return !1;
      } finally {
        i.dispose?.();
      }
    }
    async sign(e) {
      try {
        return await this.d(e);
      } catch {}
      return e;
    }
  },
  s9 = class extends t9 {
    c() {
      return this.h().then((t) => new t.validator());
    }
    d(t) {
      return this.h().then((e) => new e.signer().sign(t));
    }
    async h() {
      const t = "vsda",
        { default: e } = await import(t);
      return e;
    }
  },
  TS = z("tunnelService"),
  I0 = z("sharedTunnelsService"),
  R0;
(function (t) {
  (t.Http = "http"), (t.Https = "https");
})(R0 || (R0 = {}));
var Xa;
(function (t) {
  (t.ConstantPrivate = "constantPrivate"), (t.Private = "private"), (t.Public = "public");
})(Xa || (Xa = {}));
function i9(t) {
  return !!t.forwardPort;
}
var P0;
(function (t) {
  (t[(t.Notify = 1)] = "Notify"), (t[(t.OpenBrowser = 2)] = "OpenBrowser"), (t[(t.OpenPreview = 3)] = "OpenPreview"), (t[(t.Silent = 4)] = "Silent"), (t[(t.Ignore = 5)] = "Ignore"), (t[(t.OpenBrowserOnce = 6)] = "OpenBrowserOnce");
})(P0 || (P0 = {}));
function n9(t) {
  if (t.scheme !== "http" && t.scheme !== "https") return;
  const e = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(t.authority);
  if (e) return { address: e[1], port: +e[2] };
}
var Au = ["localhost", "127.0.0.1", "0:0:0:0:0:0:0:1", "::1"];
function Ou(t) {
  return Au.indexOf(t) >= 0;
}
var Lu = ["0.0.0.0", "0:0:0:0:0:0:0:0", "::"];
function qr(t) {
  return Lu.indexOf(t) >= 0;
}
function r9(t, e, s, i) {
  if (s === 1) return !1;
  if (s === 2 && qr(e)) {
    const n = /(\d+)\.(\d+)\.(\d+)/g.exec(i);
    if (n?.length === 4 && parseInt(n[1]) >= 18) return !1;
  }
  return t < 1024;
}
var Nu = class extends O {
  constructor(e, s) {
    super(),
      (this.r = e),
      (this.s = s),
      (this.a = new D()),
      (this.onTunnelOpened = this.a.event),
      (this.b = new D()),
      (this.onTunnelClosed = this.b.event),
      (this.c = new D()),
      (this.onAddedTunnelProvider = this.c.event),
      (this.f = new Map()),
      (this.h = !1),
      (this.j = !0),
      (this.m = []),
      (this.n = new Set());
  }
  get hasTunnelProvider() {
    return !!this.g;
  }
  get t() {
    const e = this.s.getValue("remote.localPortHost");
    return !e || e === "localhost" ? "127.0.0.1" : "0.0.0.0";
  }
  setTunnelProvider(e) {
    return (
      (this.g = e),
      e
        ? (this.c.fire(),
          {
            dispose: () => {
              (this.g = void 0), (this.h = !1), (this.m = []);
            },
          })
        : ((this.h = !1), (this.m = []), this.c.fire(), { dispose: () => {} })
    );
  }
  setTunnelFeatures(e) {
    (this.h = e.elevation), (this.m = e.privacyOptions), (this.j = e.protocol);
  }
  get canChangeProtocol() {
    return this.j;
  }
  get canElevate() {
    return this.h;
  }
  get canChangePrivacy() {
    return this.m.length > 0;
  }
  get privacyOptions() {
    return this.m;
  }
  get tunnels() {
    return this.u();
  }
  async u() {
    const e = [],
      s = Array.from(this.f.values());
    for (const i of s) {
      const n = Array.from(i.values());
      for (const r of n) {
        const o = await r.value;
        o && typeof o != "string" && e.push(o);
      }
    }
    return e;
  }
  async dispose() {
    super.dispose();
    for (const e of this.f.values()) {
      for (const { value: s } of e.values()) await s.then((i) => (typeof i != "string" ? i?.dispose() : void 0));
      e.clear();
    }
    this.f.clear();
  }
  setEnvironmentTunnel(e, s, i, n, r) {
    this.z(e, s, Promise.resolve({ tunnelRemoteHost: e, tunnelRemotePort: s, localAddress: i, privacy: n, protocol: r, dispose: () => Promise.resolve() }));
  }
  async getExistingTunnel(e, s) {
    (qr(e) || Ou(e)) && (e = Au[0]);
    const i = this.D(e, s);
    if (i) return ++i.refcount, i.value;
  }
  openTunnel(e, s, i, n, r, o = !1, a, c) {
    this.r.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${s}:${i} on local port ${r}.`);
    const l = this.g ?? e;
    if (!l) return;
    if ((s || (s = "localhost"), n || (n = this.t), this.g && this.n.has(i))) {
      this.r.debug("ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.");
      return;
    }
    const h = this.F(l, s, i, n, r, o, a, c);
    return h
      ? h.then((u) => {
          if (u) {
            if (typeof u == "string") return this.r.trace("ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel."), this.C(s, i), u;
          } else {
            this.r.trace("ForwardedPorts: (TunnelService) New tunnel is undefined."), this.C(s, i);
            return;
          }
          this.r.trace("ForwardedPorts: (TunnelService) New tunnel established.");
          const f = this.w(u);
          return (
            (u.tunnelRemoteHost !== s || u.tunnelRemotePort !== i) && this.r.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch."),
            a && u.privacy !== a && this.r.warn("ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch."),
            this.a.fire(f),
            f
          );
        })
      : (this.r.trace("ForwardedPorts: (TunnelService) Tunnel was not created."), h);
  }
  w(e) {
    return {
      tunnelRemotePort: e.tunnelRemotePort,
      tunnelRemoteHost: e.tunnelRemoteHost,
      tunnelLocalPort: e.tunnelLocalPort,
      localAddress: e.localAddress,
      privacy: e.privacy,
      protocol: e.protocol,
      dispose: async () => {
        this.r.trace(`ForwardedPorts: (TunnelService) dispose request for ${e.tunnelRemoteHost}:${e.tunnelRemotePort} `);
        const s = this.f.get(e.tunnelRemoteHost);
        if (s) {
          const i = s.get(e.tunnelRemotePort);
          i && (i.refcount--, await this.y(e.tunnelRemoteHost, e.tunnelRemotePort, i));
        }
      },
    };
  }
  async y(e, s, i) {
    if (i.refcount <= 0) {
      this.r.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${e}:${s}.`);
      const n = i.value.then(async (r) => {
        r && typeof r != "string" && (await r.dispose(!0), this.b.fire({ host: r.tunnelRemoteHost, port: r.tunnelRemotePort }));
      });
      return this.f.has(e) && this.f.get(e).delete(s), n;
    }
  }
  async closeTunnel(e, s) {
    this.r.trace(`ForwardedPorts: (TunnelService) close request for ${e}:${s} `);
    const i = this.f.get(e);
    if (i && i.has(s)) {
      const n = i.get(s);
      (n.refcount = 0), await this.y(e, s, n);
    }
  }
  z(e, s, i) {
    this.f.has(e) || this.f.set(e, new Map()), this.f.get(e).set(s, { refcount: 1, value: i });
  }
  async C(e, s) {
    const i = this.f.get(e);
    if (i) {
      const n = i.get(s),
        r = n ? await n.value : void 0;
      (!r || typeof r == "string") && i.delete(s), i.size === 0 && this.f.delete(e);
    }
  }
  D(e, s) {
    const i = [e];
    Ou(e) ? (i.push(...Au), i.push(...Lu)) : qr(e) && i.push(...Lu);
    const n = i.map((r) => this.f.get(r));
    for (const r of n) {
      const o = r?.get(s);
      if (o) return o;
    }
  }
  canTunnel(e) {
    return !!n9(e);
  }
  G(e, s, i, n, r, o, a) {
    this.r.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${s}:${i} on local port ${n}.`);
    const c = i;
    this.n.add(c);
    const l = n === void 0 ? i : n,
      h = { elevationRequired: r ? this.isPortPrivileged(l) : !1 },
      u = { remoteAddress: { host: s, port: i }, localAddressPort: n, privacy: o, public: o ? o !== Xa.Private : void 0, protocol: a },
      f = e.forwardPort(u, h);
    return (
      f
        ? (this.z(s, i, f),
          f.finally(() => {
            this.r.trace("ForwardedPorts: (TunnelService) Tunnel created by provider."), this.n.delete(c);
          }))
        : this.n.delete(c),
      f
    );
  }
};
Nu = __decorate([__param(0, ne), __param(1, Ce)], Nu);
import * as o9 from "net";
import * as a9 from "os";
import * as c9 from "net";
var A0 = {
  1: !0,
  7: !0,
  9: !0,
  11: !0,
  13: !0,
  15: !0,
  17: !0,
  19: !0,
  20: !0,
  21: !0,
  22: !0,
  23: !0,
  25: !0,
  37: !0,
  42: !0,
  43: !0,
  53: !0,
  69: !0,
  77: !0,
  79: !0,
  87: !0,
  95: !0,
  101: !0,
  102: !0,
  103: !0,
  104: !0,
  109: !0,
  110: !0,
  111: !0,
  113: !0,
  115: !0,
  117: !0,
  119: !0,
  123: !0,
  135: !0,
  137: !0,
  139: !0,
  143: !0,
  161: !0,
  179: !0,
  389: !0,
  427: !0,
  465: !0,
  512: !0,
  513: !0,
  514: !0,
  515: !0,
  526: !0,
  530: !0,
  531: !0,
  532: !0,
  540: !0,
  548: !0,
  554: !0,
  556: !0,
  563: !0,
  587: !0,
  601: !0,
  636: !0,
  989: !0,
  990: !0,
  993: !0,
  995: !0,
  1719: !0,
  1720: !0,
  1723: !0,
  2049: !0,
  3659: !0,
  4045: !0,
  5060: !0,
  5061: !0,
  6e3: !0,
  6566: !0,
  6665: !0,
  6666: !0,
  6667: !0,
  6668: !0,
  6669: !0,
  6697: !0,
  10080: !0,
};
function l9(t, e, s, i = "127.0.0.1") {
  let n = !1,
    r,
    o = 1;
  const a = c9.createServer({ pauseOnConnect: !0 });
  function c(l, h) {
    n || ((n = !0), a.removeAllListeners(), a.close(), r && clearTimeout(r), h(l));
  }
  return new Promise((l) => {
    (r = setTimeout(() => {
      c(0, l);
    }, s)),
      a.on("listening", () => {
        c(t, l);
      }),
      a.on("error", (h) => {
        h && (h.code === "EADDRINUSE" || h.code === "EACCES") && o < e ? (t++, o++, a.listen(t, i)) : c(0, l);
      }),
      a.on("close", () => {
        c(0, l);
      }),
      a.listen(t, i);
  });
}
import "crypto";
import "net";
import "os";
import "zlib";
var O0;
(function (t) {
  (t.Created = "created"),
    (t.Read = "read"),
    (t.Write = "write"),
    (t.Open = "open"),
    (t.Error = "error"),
    (t.Close = "close"),
    (t.BrowserWebSocketBlobReceived = "browserWebSocketBlobReceived"),
    (t.NodeEndReceived = "nodeEndReceived"),
    (t.NodeEndSent = "nodeEndSent"),
    (t.NodeDrainBegin = "nodeDrainBegin"),
    (t.NodeDrainEnd = "nodeDrainEnd"),
    (t.zlibInflateError = "zlibInflateError"),
    (t.zlibInflateData = "zlibInflateData"),
    (t.zlibInflateInitialWrite = "zlibInflateInitialWrite"),
    (t.zlibInflateInitialFlushFired = "zlibInflateInitialFlushFired"),
    (t.zlibInflateWrite = "zlibInflateWrite"),
    (t.zlibInflateFlushFired = "zlibInflateFlushFired"),
    (t.zlibDeflateError = "zlibDeflateError"),
    (t.zlibDeflateData = "zlibDeflateData"),
    (t.zlibDeflateWrite = "zlibDeflateWrite"),
    (t.zlibDeflateFlushFired = "zlibDeflateFlushFired"),
    (t.WebSocketNodeSocketWrite = "webSocketNodeSocketWrite"),
    (t.WebSocketNodeSocketPeekedHeader = "webSocketNodeSocketPeekedHeader"),
    (t.WebSocketNodeSocketReadHeader = "webSocketNodeSocketReadHeader"),
    (t.WebSocketNodeSocketReadData = "webSocketNodeSocketReadData"),
    (t.WebSocketNodeSocketUnmaskedData = "webSocketNodeSocketUnmaskedData"),
    (t.WebSocketNodeSocketDrainBegin = "webSocketNodeSocketDrainBegin"),
    (t.WebSocketNodeSocketDrainEnd = "webSocketNodeSocketDrainEnd"),
    (t.ProtocolHeaderRead = "protocolHeaderRead"),
    (t.ProtocolMessageRead = "protocolMessageRead"),
    (t.ProtocolHeaderWrite = "protocolHeaderWrite"),
    (t.ProtocolMessageWrite = "protocolMessageWrite"),
    (t.ProtocolWrite = "protocolWrite");
})(O0 || (O0 = {}));
var Gi;
(function (t) {
  (t.enableDiagnostics = !!globalThis.process?.env?.ENABLE_SOCKET_LOG), (t.records = []);
  const e = new WeakMap();
  let s = 0;
  function i(r, o) {
    if (!e.has(r)) {
      const a = String(++s);
      e.set(r, a);
    }
    return e.get(r);
  }
  function n(r, o, a, c) {
    if (!t.enableDiagnostics) return;
    const l = i(r, o);
    if (c instanceof L || c instanceof Uint8Array || c instanceof ArrayBuffer || ArrayBuffer.isView(c)) {
      const h = L.alloc(c.byteLength);
      h.set(c), t.records.push({ timestamp: Date.now(), id: l, label: o, type: a, buff: h });
    } else t.records.push({ timestamp: Date.now(), id: l, label: o, type: a, data: c });
  }
  t.traceSocketEvent = n;
})(Gi || (Gi = {}));
var L0;
(function (t) {
  (t[(t.NodeSocketCloseEvent = 0)] = "NodeSocketCloseEvent"), (t[(t.WebSocketCloseEvent = 1)] = "WebSocketCloseEvent");
})(L0 || (L0 = {}));
var Tu = null;
function di() {
  return Tu || (Tu = L.alloc(0)), Tu;
}
var h9 = class {
    get byteLength() {
      return this.b;
    }
    constructor() {
      (this.a = []), (this.b = 0);
    }
    acceptChunk(t) {
      this.a.push(t), (this.b += t.byteLength);
    }
    read(t) {
      return this.c(t, !0);
    }
    peek(t) {
      return this.c(t, !1);
    }
    c(t, e) {
      if (t === 0) return di();
      if (t > this.b) throw new Error("Cannot read so many bytes!");
      if (this.a[0].byteLength === t) {
        const r = this.a[0];
        return e && (this.a.shift(), (this.b -= t)), r;
      }
      if (this.a[0].byteLength > t) {
        const r = this.a[0].slice(0, t);
        return e && ((this.a[0] = this.a[0].slice(t)), (this.b -= t)), r;
      }
      const s = L.alloc(t);
      let i = 0,
        n = 0;
      for (; t > 0; ) {
        const r = this.a[n];
        if (r.byteLength > t) {
          const o = r.slice(0, t);
          s.set(o, i), (i += t), e && ((this.a[n] = r.slice(t)), (this.b -= t)), (t -= t);
        } else s.set(r, i), (i += r.byteLength), e ? (this.a.shift(), (this.b -= r.byteLength)) : n++, (t -= r.byteLength);
      }
      return s;
    }
  },
  N0;
(function (t) {
  (t[(t.None = 0)] = "None"),
    (t[(t.Regular = 1)] = "Regular"),
    (t[(t.Control = 2)] = "Control"),
    (t[(t.Ack = 3)] = "Ack"),
    (t[(t.Disconnect = 5)] = "Disconnect"),
    (t[(t.ReplayRequest = 6)] = "ReplayRequest"),
    (t[(t.Pause = 7)] = "Pause"),
    (t[(t.Resume = 8)] = "Resume"),
    (t[(t.KeepAlive = 9)] = "KeepAlive"),
    (t[(t.RemoteDisconnect = 192)] = "RemoteDisconnect");
})(N0 || (N0 = {}));
function T0(t) {
  switch (t) {
    case 0:
      return "None";
    case 1:
      return "Regular";
    case 2:
      return "Control";
    case 3:
      return "Ack";
    case 5:
      return "Disconnect";
    case 6:
      return "ReplayRequest";
    case 7:
      return "PauseWriting";
    case 8:
      return "ResumeWriting";
    case 9:
      return "KeepAlive";
    case 192:
      return "RemoteDisconnect";
  }
}
var j0;
(function (t) {
  (t[(t.HeaderLength = 13)] = "HeaderLength"),
    (t[(t.AcknowledgeTime = 2e3)] = "AcknowledgeTime"),
    (t[(t.TimeoutTime = 2e4)] = "TimeoutTime"),
    (t[(t.ReconnectionGraceTime = 2592e5)] = "ReconnectionGraceTime"),
    (t[(t.ReconnectionShortGraceTime = 3e5)] = "ReconnectionShortGraceTime"),
    (t[(t.KeepAliveSendTime = 5e3)] = "KeepAliveSendTime");
})(j0 || (j0 = {}));
var As = class {
    constructor(t, e, s, i) {
      (this.type = t), (this.id = e), (this.ack = s), (this.data = i), (this.writtenTime = 0);
    }
    get size() {
      return this.data.byteLength;
    }
  },
  F0 = class extends O {
    constructor(t) {
      super(),
        (this.f = this.B(new D())),
        (this.onMessage = this.f.event),
        (this.g = { readHead: !0, readLen: 13, messageType: 0, id: 0, ack: 0 }),
        (this.a = t),
        (this.b = !1),
        (this.c = new h9()),
        this.B(this.a.onData((e) => this.acceptChunk(e))),
        (this.lastReadTime = Date.now());
    }
    acceptChunk(t) {
      if (!(!t || t.byteLength === 0))
        for (this.lastReadTime = Date.now(), this.c.acceptChunk(t); this.c.byteLength >= this.g.readLen; ) {
          const e = this.c.read(this.g.readLen);
          if (this.g.readHead)
            (this.g.readHead = !1),
              (this.g.readLen = e.readUInt32BE(9)),
              (this.g.messageType = e.readUInt8(0)),
              (this.g.id = e.readUInt32BE(1)),
              (this.g.ack = e.readUInt32BE(5)),
              this.a.traceSocketEvent("protocolHeaderRead", { messageType: T0(this.g.messageType), id: this.g.id, ack: this.g.ack, messageSize: this.g.readLen });
          else {
            const s = this.g.messageType,
              i = this.g.id,
              n = this.g.ack;
            if (((this.g.readHead = !0), (this.g.readLen = 13), (this.g.messageType = 0), (this.g.id = 0), (this.g.ack = 0), this.a.traceSocketEvent("protocolMessageRead", e), this.f.fire(new As(s, i, n, e)), this.b)) break;
          }
        }
    }
    readEntireBuffer() {
      return this.c.read(this.c.byteLength);
    }
    dispose() {
      (this.b = !0), super.dispose();
    }
  },
  M0 = class {
    constructor(t) {
      (this.k = null), (this.a = !1), (this.b = !1), (this.c = t), (this.d = []), (this.f = 0), (this.lastWriteTime = 0);
    }
    dispose() {
      try {
        this.flush();
      } catch {}
      this.a = !0;
    }
    drain() {
      return this.flush(), this.c.drain();
    }
    flush() {
      this.m();
    }
    pause() {
      this.b = !0;
    }
    resume() {
      (this.b = !1), this.l();
    }
    write(t) {
      if (this.a) return;
      (t.writtenTime = Date.now()), (this.lastWriteTime = Date.now());
      const e = L.alloc(13);
      e.writeUInt8(t.type, 0),
        e.writeUInt32BE(t.id, 1),
        e.writeUInt32BE(t.ack, 5),
        e.writeUInt32BE(t.data.byteLength, 9),
        this.c.traceSocketEvent("protocolHeaderWrite", { messageType: T0(t.type), id: t.id, ack: t.ack, messageSize: t.data.byteLength }),
        this.c.traceSocketEvent("protocolMessageWrite", t.data),
        this.j(e, t.data);
    }
    g(t, e) {
      const s = this.f === 0;
      return this.d.push(t, e), (this.f += t.byteLength + e.byteLength), s;
    }
    h() {
      const t = L.concat(this.d, this.f);
      return (this.d.length = 0), (this.f = 0), t;
    }
    j(t, e) {
      this.g(t, e) && this.l();
    }
    l() {
      this.k ||
        (this.k = setTimeout(() => {
          (this.k = null), this.m();
        }));
    }
    m() {
      if (this.f === 0 || this.b) return;
      const t = this.h();
      this.c.traceSocketEvent("protocolWrite", { byteLength: t.byteLength }), this.c.write(t);
    }
  },
  Vr = class {
    constructor() {
      (this.b = !1),
        (this.c = !1),
        (this.d = []),
        (this.a = new D({
          onWillAddFirstListener: () => {
            (this.b = !0), queueMicrotask(() => this.f());
          },
          onDidRemoveLastListener: () => {
            this.b = !1;
          },
        })),
        (this.event = this.a.event);
    }
    f() {
      if (!this.c) {
        for (this.c = !0; this.b && this.d.length > 0; ) this.a.fire(this.d.shift());
        this.c = !1;
      }
    }
    fire(t) {
      this.b ? (this.d.length > 0 ? this.d.push(t) : this.a.fire(t)) : this.d.push(t);
    }
    flushBuffer() {
      this.d = [];
    }
  },
  u9 = class {
    constructor(t) {
      (this.data = t), (this.next = null);
    }
  },
  f9 = class {
    constructor() {
      (this.a = null), (this.b = null);
    }
    length() {
      let t = 0,
        e = this.a;
      for (; e; ) (e = e.next), t++;
      return t;
    }
    peek() {
      return this.a ? this.a.data : null;
    }
    toArray() {
      const t = [];
      let e = 0,
        s = this.a;
      for (; s; ) (t[e++] = s.data), (s = s.next);
      return t;
    }
    pop() {
      if (this.a) {
        if (this.a === this.b) {
          (this.a = null), (this.b = null);
          return;
        }
        this.a = this.a.next;
      }
    }
    push(t) {
      const e = new u9(t);
      if (!this.a) {
        (this.a = e), (this.b = e);
        return;
      }
      (this.b.next = e), (this.b = e);
    }
  },
  d9 = class Ls {
    static {
      this.a = 10;
    }
    static {
      this.b = null;
    }
    static getInstance() {
      return Ls.b || (Ls.b = new Ls()), Ls.b;
    }
    constructor() {
      this.c = [];
      const e = Date.now();
      for (let s = 0; s < Ls.a; s++) this.c[s] = e - 1e3 * s;
      setInterval(() => {
        for (let s = Ls.a; s >= 1; s--) this.c[s] = this.c[s - 1];
        this.c[0] = Date.now();
      }, 1e3);
    }
    d() {
      const e = Date.now(),
        s = (1 + Ls.a) * 1e3;
      let i = 0;
      for (let n = 0; n < Ls.a; n++) e - this.c[n] <= s && i++;
      return 1 - i / Ls.a;
    }
    hasHighLoad() {
      return this.d() >= 0.5;
    }
  },
  p9 = class {
    get unacknowledgedCount() {
      return this.d - this.f;
    }
    constructor(t) {
      (this.w = new Vr()),
        (this.onControlMessage = this.w.event),
        (this.x = new Vr()),
        (this.onMessage = this.x.event),
        (this.y = new Vr()),
        (this.onDidDispose = this.y.event),
        (this.z = new Vr()),
        (this.onSocketClose = this.z.event),
        (this.A = new Vr()),
        (this.onSocketTimeout = this.A.event),
        (this.u = t.loadEstimator ?? d9.getInstance()),
        (this.v = t.sendKeepAlive ?? !0),
        (this.a = !1),
        (this.c = new f9()),
        (this.d = 0),
        (this.f = 0),
        (this.g = null),
        (this.h = 0),
        (this.j = 0),
        (this.k = 0),
        (this.l = null),
        (this.n = 0),
        (this.o = Date.now()),
        (this.t = new ye()),
        (this.p = t.socket),
        (this.q = this.t.add(new M0(this.p))),
        (this.s = this.t.add(new F0(this.p))),
        this.t.add(this.s.onMessage((e) => this.B(e))),
        this.t.add(this.p.onClose((e) => this.z.fire(e))),
        t.initialChunk && this.s.acceptChunk(t.initialChunk),
        this.v
          ? (this.m = setInterval(() => {
              this.F();
            }, 5e3))
          : (this.m = null);
    }
    dispose() {
      this.g && (clearTimeout(this.g), (this.g = null)), this.l && (clearTimeout(this.l), (this.l = null)), this.m && (clearInterval(this.m), (this.m = null)), this.t.dispose();
    }
    drain() {
      return this.q.drain();
    }
    sendDisconnect() {
      if (!this.b) {
        this.b = !0;
        const t = new As(5, 0, 0, di());
        this.q.write(t), this.q.flush();
      }
    }
    sendPause() {
      const t = new As(7, 0, 0, di());
      this.q.write(t);
    }
    sendResume() {
      const t = new As(8, 0, 0, di());
      this.q.write(t);
    }
    pauseSocketWriting() {
      this.q.pause();
    }
    getSocket() {
      return this.p;
    }
    getMillisSinceLastIncomingData() {
      return Date.now() - this.s.lastReadTime;
    }
    beginAcceptReconnection(t, e) {
      (this.a = !0),
        this.t.dispose(),
        (this.t = new ye()),
        this.w.flushBuffer(),
        this.z.flushBuffer(),
        this.A.flushBuffer(),
        this.p.dispose(),
        (this.n = 0),
        (this.o = Date.now()),
        (this.p = t),
        (this.q = this.t.add(new M0(this.p))),
        (this.s = this.t.add(new F0(this.p))),
        this.t.add(this.s.onMessage((s) => this.B(s))),
        this.t.add(this.p.onClose((s) => this.z.fire(s))),
        this.s.acceptChunk(e);
    }
    endAcceptReconnection() {
      (this.a = !1), (this.j = this.h);
      const t = new As(3, 0, this.j, di());
      this.q.write(t);
      const e = this.c.toArray();
      for (let s = 0, i = e.length; s < i; s++) this.q.write(e[s]);
      this.D();
    }
    acceptDisconnect() {
      this.y.fire();
    }
    B(t) {
      if (t.ack > this.f) {
        this.f = t.ack;
        do {
          const e = this.c.peek();
          if (e && e.id <= t.ack) this.c.pop();
          else break;
        } while (!0);
      }
      switch (t.type) {
        case 0:
          break;
        case 1: {
          if (t.id > this.h)
            if (t.id !== this.h + 1) {
              const e = Date.now();
              e - this.n > 1e4 && ((this.n = e), this.q.write(new As(6, 0, 0, di())));
            } else (this.h = t.id), (this.k = Date.now()), this.C(), this.x.fire(t.data);
          break;
        }
        case 2: {
          this.w.fire(t.data);
          break;
        }
        case 3:
          break;
        case 5: {
          this.y.fire();
          break;
        }
        case 6: {
          const e = this.c.toArray();
          for (let s = 0, i = e.length; s < i; s++) this.q.write(e[s]);
          this.D();
          break;
        }
        case 7: {
          this.q.pause();
          break;
        }
        case 8: {
          this.q.resume();
          break;
        }
        case 9:
          break;
        case 192: {
          this.p.end();
          break;
        }
      }
    }
    readEntireBuffer() {
      return this.s.readEntireBuffer();
    }
    flush() {
      this.q.flush();
    }
    send(t) {
      const e = ++this.d;
      this.j = this.h;
      const s = new As(1, e, this.j, t);
      this.c.push(s), this.a || (this.q.write(s), this.D());
    }
    sendControl(t) {
      const e = new As(2, 0, 0, t);
      this.q.write(e);
    }
    C() {
      if (this.h <= this.j || this.l) return;
      const t = Date.now() - this.k;
      if (t >= 2e3) {
        this.E();
        return;
      }
      this.l = setTimeout(
        () => {
          (this.l = null), this.C();
        },
        2e3 - t + 5,
      );
    }
    D() {
      if (this.d <= this.f || this.g || this.a) return;
      const t = this.c.peek(),
        e = Date.now() - t.writtenTime,
        s = Date.now() - this.s.lastReadTime,
        i = Date.now() - this.o;
      if (e >= 2e4 && s >= 2e4 && i >= 2e4 && !this.u.hasHighLoad()) {
        (this.o = Date.now()), this.A.fire({ unacknowledgedMsgCount: this.c.length(), timeSinceOldestUnacknowledgedMsg: e, timeSinceLastReceivedSomeData: s });
        return;
      }
      const n = Math.max(2e4 - e, 2e4 - s, 2e4 - i, 500);
      this.g = setTimeout(() => {
        (this.g = null), this.D();
      }, n);
    }
    E() {
      if (this.h <= this.j) return;
      this.j = this.h;
      const t = new As(3, 0, this.j, di());
      this.q.write(t);
    }
    F() {
      this.j = this.h;
      const t = new As(9, 0, this.j, di());
      this.q.write(t);
    }
  };
(() => {
  if (!Gi.enableDiagnostics) return;
  if (typeof bc != "function") {
    console.log("Can only log socket diagnostics on native platforms.");
    return;
  }
  const t = process.argv.includes("--type=renderer") ? "renderer" : process.argv.includes("--type=extensionHost") ? "extensionHost" : process.argv.some((e) => e.includes("server-main")) ? "server" : "unknown";
  setInterval(() => {
    Gi.records.forEach((n) => {
      n.buff && ((n.data = Buffer.from(n.buff.buffer).toString("base64")), (n.buff = void 0));
    });
    const e = bc("fs"),
      i = bc("path").join(globalThis.process?.env?.SOCKET_LOG_DIR || "/cloudide/component/log", `${t}-${process.pid}_${new Date().toISOString().replaceAll(":", "-")}.json`);
    console.log(`dumping socket diagnostics at ${i}`), e.writeFile(i, JSON.stringify(Gi.records, null, 2), console.log), Gi.records.splice(0);
  }, 3e4);
})();
var g9 = 3e4,
  ju = class {
    traceSocketEvent(t, e) {
      Gi.traceSocketEvent(this.socket, this.debugLabel, t, e);
    }
    constructor(t, e = "") {
      (this.f = !0),
        (this.debugLabel = e),
        (this.socket = t),
        this.traceSocketEvent("created", { type: "NodeSocket" }),
        (this.a = (i) => {
          if ((this.traceSocketEvent("error", { code: i?.code, message: i?.message }), i)) {
            if (i.code === "EPIPE") return;
            rt(i);
          }
        }),
        this.socket.on("error", this.a);
      let s;
      (this.b = (i) => {
        this.traceSocketEvent("close", { hadError: i }), (this.f = !1), s && clearTimeout(s);
      }),
        this.socket.on("close", this.b),
        (this.d = () => {
          this.traceSocketEvent("nodeEndReceived"), (this.f = !1), (s = setTimeout(() => t.destroy(), g9));
        }),
        this.socket.on("end", this.d);
    }
    dispose() {
      this.socket.off("error", this.a), this.socket.off("close", this.b), this.socket.off("end", this.d), this.socket.destroy();
    }
    onData(t) {
      const e = (s) => {
        this.traceSocketEvent("read", s), t(L.wrap(s));
      };
      return this.socket.on("data", e), { dispose: () => this.socket.off("data", e) };
    }
    onClose(t) {
      const e = (s) => {
        t({ type: 0, hadError: s, error: void 0 });
      };
      return this.socket.on("close", e), { dispose: () => this.socket.off("close", e) };
    }
    onEnd(t) {
      const e = () => {
        t();
      };
      return this.socket.on("end", e), { dispose: () => this.socket.off("end", e) };
    }
    write(t) {
      if (!(this.socket.destroyed || !this.f))
        try {
          this.traceSocketEvent("write", t),
            this.socket.write(t.buffer, (e) => {
              if (e) {
                if (e.code === "EPIPE") return;
                rt(e);
              }
            });
        } catch (e) {
          if (e.code === "EPIPE") return;
          rt(e);
        }
    }
    end() {
      this.traceSocketEvent("nodeEndSent"), this.socket.end();
    }
    drain() {
      return (
        this.traceSocketEvent("nodeDrainBegin"),
        new Promise((t, e) => {
          if (this.socket.bufferSize === 0) {
            this.traceSocketEvent("nodeDrainEnd"), t();
            return;
          }
          const s = () => {
            this.socket.off("close", s), this.socket.off("end", s), this.socket.off("error", s), this.socket.off("timeout", s), this.socket.off("drain", s), this.traceSocketEvent("nodeDrainEnd"), t();
          };
          this.socket.on("close", s), this.socket.on("end", s), this.socket.on("error", s), this.socket.on("timeout", s), this.socket.on("drain", s);
        })
      );
    }
  },
  U0;
(function (t) {
  (t[(t.MinHeaderByteSize = 2)] = "MinHeaderByteSize"), (t[(t.MaxWebSocketMessageLength = 262144)] = "MaxWebSocketMessageLength");
})(U0 || (U0 = {}));
var _0;
(function (t) {
  (t[(t.PeekHeader = 1)] = "PeekHeader"), (t[(t.ReadHeader = 2)] = "ReadHeader"), (t[(t.ReadBody = 3)] = "ReadBody"), (t[(t.Fin = 4)] = "Fin");
})(_0 || (_0 = {}));
var GS = process.env.XDG_RUNTIME_DIR,
  Fu = "__ICUBE_LIGHT_RESOLVER_PERMANENT_CLOSE__",
  JS = z("remoteAuthorityResolverService"),
  B0;
(function (t) {
  (t[(t.WebSocket = 0)] = "WebSocket"), (t[(t.Managed = 1)] = "Managed");
})(B0 || (B0 = {}));
var KS = class {
    static {
      this.WEB_MANAGED_ID = Number.MAX_SAFE_INTEGER;
    }
    constructor(t) {
      (this.id = t), (this.type = 1);
    }
    toString() {
      return `Managed(${this.id})`;
    }
  },
  pi;
(function (t) {
  (t.Unknown = "Unknown"), (t.NotAvailable = "NotAvailable"), (t.TemporarilyNotAvailable = "TemporarilyNotAvailable"), (t.NoResolverFound = "NoResolverFound"), (t.InvalidAuthority = "InvalidAuthority");
})(pi || (pi = {}));
var gi = class en extends Si {
    static isNotAvailable(e) {
      return e instanceof en && e._code === pi.NotAvailable;
    }
    static isTemporarilyNotAvailable(e) {
      return e instanceof en && e._code === pi.TemporarilyNotAvailable;
    }
    static isNoResolverFound(e) {
      return e instanceof en && e._code === pi.NoResolverFound;
    }
    static isInvalidAuthority(e) {
      return e instanceof en && e._code === pi.InvalidAuthority;
    }
    static isHandled(e) {
      return e?.message?.includes(Fu) || (e instanceof en && e.isHandled);
    }
    constructor(e, s = pi.Unknown, i) {
      super(e), (this._message = e), (this._code = s), (this._detail = i), (this.isHandled = s === pi.NotAvailable && i === !0), Object.setPrototypeOf(this, en.prototype);
    }
  },
  z0 = {},
  q0 = 30 * 1e3,
  V0;
(function (t) {
  (t[(t.Management = 1)] = "Management"), (t[(t.ExtensionHost = 2)] = "ExtensionHost"), (t[(t.Tunnel = 3)] = "Tunnel"), (t[(t.Download = 128)] = "Download");
})(V0 || (V0 = {}));
function $t(t) {
  switch (t) {
    case 1:
      return "Management";
    case 2:
      return "ExtensionHost";
    case 3:
      return "Tunnel";
    case 128:
      return "Download";
  }
}
function Mu(t) {
  const e = new xs();
  return setTimeout(() => e.cancel(), t), e.token;
}
function m9(t, e) {
  if (t.isCancellationRequested || e.isCancellationRequested) return J.Cancelled;
  const s = new xs();
  return t.onCancellationRequested(() => s.cancel()), e.onCancellationRequested(() => s.cancel()), s.token;
}
var Uu = class {
  get didTimeout() {
    return this.c === "timedout";
  }
  constructor(t) {
    (this.c = "pending"), (this.d = new ye()), ({ promise: this.promise, resolve: this.f, reject: this.g } = fy()), t.isCancellationRequested ? this.h() : this.d.add(t.onCancellationRequested(() => this.h()));
  }
  registerDisposable(t) {
    this.c === "pending" ? this.d.add(t) : t.dispose();
  }
  h() {
    this.c === "pending" && (this.d.dispose(), (this.c = "timedout"), this.g(this.i()));
  }
  i() {
    const t = new Error("Time limit reached");
    return (t.code = "ETIMEDOUT"), (t.syscall = "connect"), t;
  }
  resolve(t) {
    this.c === "pending" && (this.d.dispose(), (this.c = "resolved"), this.f(t));
  }
  reject(t) {
    this.c === "pending" && (this.d.dispose(), (this.c = "rejected"), this.g(t));
  }
};
function w9(t, e) {
  const s = new Uu(e);
  return (
    s.registerDisposable(
      t.onControlMessage((i) => {
        const n = JSON.parse(i.toString()),
          r = $9(n);
        r ? s.reject(r) : s.resolve(n);
      }),
    ),
    s.promise
  );
}
function v9(t, e, s, i, n, r, o, a) {
  const c = new Uu(a),
    l = un.create(!1);
  return (
    t.info(`Creating a socket (${o})...`),
    _i(`code/willCreateSocket/${r}`),
    e.connect(s, i, n, o).then(
      (h) => {
        c.didTimeout
          ? (_i(`code/didCreateSocketError/${r}`),
            t.info(`Creating a socket (${o}) finished after ${l.elapsed()} ms, but this is too late and has timed out already.`),
            nt(`Creating a socket (${o}) finished after ${l.elapsed()} ms, but this is too late and has timed out already. will dispose socket`, r),
            h?.dispose())
          : (_i(`code/didCreateSocketOK/${r}`), t.info(`Creating a socket (${o}) was successful after ${l.elapsed()} ms.`), nt(`Creating a socket (${o}) was successful after ${l.elapsed()} ms.`, r), c.resolve(h));
      },
      (h) => {
        _i(`code/didCreateSocketError/${r}`), t.info(`Creating a socket (${o}) returned an error after ${l.elapsed()} ms.`), nt(`Creating a socket (${o}) returned an error after ${l.elapsed()} ms. Error: ${Xe(h)}`, r), c.reject(h);
      },
    ),
    c.promise
  );
}
function _u(t, e) {
  const s = new Uu(e);
  return (
    t.then(
      (i) => {
        s.didTimeout || s.resolve(i);
      },
      (i) => {
        s.didTimeout || s.reject(i);
      },
    ),
    s.promise
  );
}
function nt(t, e) {
  const s = z0.serviceCollection?.get(Se);
  !s || s instanceof de || s.publicLog2("remoteAgentConnectionState", { connectionType: typeof e == "string" ? e : $t(e), trace: t });
}
async function y9(t, e, s, i) {
  const n = Q0(t, e);
  t.logService.trace(`${n} 1/6. invoking socketFactory.connect().`), nt("invoking socketFactory.connect()", e);
  let r;
  try {
    const h = globalThis;
    (r =
      h.__vscodeCachedSocket ||
      (await v9(
        t.logService,
        t.remoteSocketFactoryService,
        t.connectTo,
        Md.getServerRootPath(),
        `reconnectionToken=${t.reconnectionToken}&reconnection=${t.reconnectionProtocol ? "true" : "false"}`,
        $t(e),
        `renderer-${$t(e)}-${t.reconnectionToken}`,
        i,
      ))),
      h.__vscodeCachedSocket && ((h.__vscodeCachedSocket.vscodeVars.VSBuffer = L), delete h.__vscodeCachedSocket);
  } catch (h) {
    throw (t.logService.error(`${n} socketFactory.connect() failed or timed out. Error:`), nt(`socketFactory.connect() failed or timed out. Error: ${Xe(h)}`, e), h);
  }
  t.logService.trace(`${n} 2/6. socketFactory.connect() was successful.`), nt("socketFactory.connect() was successful.", e);
  let o, a;
  t.reconnectionProtocol ? (t.reconnectionProtocol.beginAcceptReconnection(r, null), (o = t.reconnectionProtocol), (a = !1)) : ((o = new p9({ socket: r })), (a = !0)),
    t.logService.trace(`${n} 3/6. sending AuthRequest control message.`),
    nt("sending AuthRequest control message.", e);
  const c = await _u(t.signService.createNewMessage(Me()), i),
    l = { type: "auth", auth: t.connectionToken || "00000000000000000000", data: c.data };
  o.sendControl(L.fromString(JSON.stringify(l)));
  try {
    const h = await w9(o, m9(i, Mu(1e4)));
    if (h.type !== "sign" || typeof h.data != "string") {
      const p = new Error("Unexpected handshake message");
      throw ((p.code = "VSCODE_CONNECTION_ERROR"), p);
    }
    if (((z0.multiContainerOptions = h.payload), t.logService.trace(`${n} 4/6. received SignRequest control message.`), nt("received SignRequest control message.", e), !(await _u(t.signService.validate(c, h.signedData), i)))) {
      const p = new Error("Refused to connect to unsupported server");
      throw ((p.code = "VSCODE_CONNECTION_ERROR"), p);
    }
    const f = await _u(t.signService.sign(h.data), i),
      d = { type: "connectionType", commit: t.commit, signedData: f, desiredConnectionType: e };
    return (
      s && (d.args = s),
      e === 2 && (d.args = { ...s, product: { iCubeApp: Js.iCubeApp } }),
      t.logService.trace(`${n} 5/6. sending ConnectionTypeRequest control message.`),
      nt("sending ConnectionTypeRequest control message.", e),
      o.sendControl(L.fromString(JSON.stringify(d))),
      { protocol: o, ownsProtocol: a }
    );
  } catch (h) {
    throw (
      (h && h.code === "ETIMEDOUT" && (t.logService.error(`${n} the handshake timed out. Error:`), nt(`the handshake timed out. Error: ${Xe(h)}`, e)),
      h && h.code === "VSCODE_CONNECTION_ERROR" && (t.logService.error(`${n} received error control message when negotiating connection. Error:`), nt(`received error control message when negotiating connection. Error: ${Xe(h)}`, e)),
      a && zu(o, $t(e)),
      h)
    );
  }
}
async function b9(t, e, s) {
  const i = Date.now(),
    n = Q0(t, 3),
    { protocol: r } = await y9(t, 3, e, s);
  return t.logService.trace(`${n} 6/6. handshake finished, connection is up and running after ${Y0(i)}!`), nt(`handshake finished, connection is up and running after ${Y0(i)}!`, 3), r;
}
async function Bu(t, e, s) {
  const { connectTo: i, connectionToken: n } = await t.addressProvider.getAddress();
  return {
    commit: t.commit,
    quality: t.quality,
    connectTo: i,
    connectionToken: n,
    reconnectionToken: e,
    reconnectionProtocol: s,
    remoteSocketFactoryService: t.remoteSocketFactoryService,
    signService: t.signService,
    logService: t.logService,
  };
}
async function E9(t, e, s) {
  const i = await Bu(t, Me(), null);
  return await b9(i, { host: e, port: s }, J.None);
}
function W0(t) {
  return wt(
    (e) =>
      new Promise((s, i) => {
        const n = setTimeout(s, t * 1e3);
        e.onCancellationRequested(() => {
          clearTimeout(n), s();
        });
      }),
  );
}
var H0;
(function (t) {
  (t[(t.ConnectionLost = 0)] = "ConnectionLost"),
    (t[(t.ReconnectionWait = 1)] = "ReconnectionWait"),
    (t[(t.ReconnectionRunning = 2)] = "ReconnectionRunning"),
    (t[(t.ReconnectionPermanentFailure = 3)] = "ReconnectionPermanentFailure"),
    (t[(t.ConnectionGain = 4)] = "ConnectionGain");
})(H0 || (H0 = {}));
var G0 = class {
    constructor(t, e, s) {
      (this.reconnectionToken = t), (this.millisSinceLastIncomingData = e), (this.connectionType = s), (this.type = 0);
    }
  },
  J0 = class {
    constructor(t, e, s, i) {
      (this.reconnectionToken = t), (this.millisSinceLastIncomingData = e), (this.durationSeconds = s), (this.c = i), (this.type = 1);
    }
    skipWait() {
      this.c.cancel();
    }
  },
  K0 = class {
    constructor(t, e, s, i) {
      (this.reconnectionToken = t), (this.millisSinceLastIncomingData = e), (this.attempt = s), (this.connectionType = i), (this.type = 2);
    }
  },
  Qa = class {
    constructor(t, e, s, i, n) {
      (this.reconnectionToken = t), (this.millisSinceLastIncomingData = e), (this.millisSinceLastLost = s), (this.attempt = i), (this.connectionType = n), (this.type = 4);
    }
  },
  X0 = class {
    constructor(t, e, s, i, n) {
      (this.reconnectionToken = t), (this.millisSinceLastIncomingData = e), (this.attempt = s), (this.handled = i), (this.connectionType = n), (this.type = 3);
    }
  },
  S9 = class Ys extends O {
    static triggerPermanentFailure(e, s, i) {
      (this._permanentFailure = !0), (this.f = e), (this.g = s), (this.h = i), this.j.forEach((n) => n.F(this.f, this.g, this.h));
    }
    static debugTriggerReconnection() {
      this.j.forEach((e) => e.z());
    }
    static debugPauseSocketWriting() {
      this.j.forEach((e) => e.G());
    }
    static {
      this._permanentFailure = !1;
    }
    static {
      this.f = 0;
    }
    static {
      this.g = 0;
    }
    static {
      this.h = !1;
    }
    static {
      this.j = [];
    }
    get n() {
      return this.c || Ys._permanentFailure;
    }
    constructor(e, s, i, n, r) {
      super(),
        (this.u = e),
        (this.w = s),
        (this.reconnectionToken = i),
        (this.protocol = n),
        (this.y = r),
        (this.m = this.B(new D())),
        (this.onDidStateChange = this.m.event),
        (this.c = !1),
        (this.r = !1),
        (this.s = !1),
        (this.t = !1),
        this.m.fire(new Qa(this.reconnectionToken, 0, 0, 0, $t(this.u))),
        this.B(
          n.onSocketClose((o) => {
            const a = Ji(this.u, this.reconnectionToken, !0);
            if (!o) this.w.logService.info(`${a} received socket close event.`), nt("received socket close event.", this.u);
            else if (o.type === 0) {
              if ((this.w.logService.info(`${a} received socket close event (hadError: ${o.hadError}).`), nt(`received socket close event (hadError: ${o.hadError}).`, this.u), o.error?.message?.includes(Fu))) {
                this.t = !0;
                return;
              }
              o.error && nt(Xe(o.error), this.u);
            } else
              this.w.logService.info(`${a} received socket close event (wasClean: ${o.wasClean}, code: ${o.code}, reason: ${o.reason}).`),
                nt(`received socket close event (wasClean: ${o.wasClean}, code: ${o.code}, reason: ${o.reason}).`, this.u),
                o.event && nt(Xe(o.event), this.u);
            this.z();
          }),
        ),
        this.B(
          n.onSocketTimeout((o) => {
            if (this.t) return;
            const a = Ji(this.u, this.reconnectionToken, !0);
            this.w.logService.info(
              `${a} received socket timeout event (unacknowledgedMsgCount: ${o.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${o.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${o.timeSinceLastReceivedSomeData}).`,
            ),
              nt(
                `received socket timeout event (unacknowledgedMsgCount: ${o.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${o.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${o.timeSinceLastReceivedSomeData}).`,
                this.u,
              ),
              this.z();
          }),
        ),
        Ys.j.push(this),
        this.B(
          ue(() => {
            const o = Ys.j.indexOf(this);
            o >= 0 && Ys.j.splice(o, 1);
          }),
        ),
        this.n && this.F(Ys.f, Ys.g, Ys.h);
    }
    dispose() {
      super.dispose(), (this.s = !0);
    }
    async z() {
      if (!this.r)
        try {
          (this.r = !0), await this.C();
        } finally {
          this.r = !1;
        }
    }
    async C() {
      if (this.n || this.s) return;
      const e = Ji(this.u, this.reconnectionToken, !0);
      this.w.logService.info(`${e} starting reconnecting loop. You can get more information with the trace log level.`);
      const s = Date.now();
      this.m.fire(new G0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), $t(this.u)));
      const i = [0, 5, 5, 10, 10, 10, 10, 10, 30];
      let n = -1;
      do {
        n++;
        const r = n < i.length ? i[n] : i[i.length - 1];
        try {
          if (r > 0) {
            const a = W0(r);
            this.m.fire(new J0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r, a)), this.w.logService.info(`${e} waiting for ${r} seconds before reconnecting...`);
            try {
              await a;
            } catch {}
          }
          if (this.n) {
            this.w.logService.error(`${e} permanent failure occurred while running the reconnecting loop.`);
            break;
          }
          this.m.fire(new K0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), n + 1, $t(this.u))), this.w.logService.info(`${e} resolving connection...`);
          const o = await Bu(this.w, this.reconnectionToken, this.protocol);
          this.w.logService.info(`${e} connecting to ${o.connectTo}...`),
            await this.H(o, Mu(q0)),
            this.w.logService.info(`${e} reconnected!`),
            this.m.fire(new Qa(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), n + 1, Date.now() - s, $t(this.u)));
          break;
        } catch (o) {
          if (o.code === "VSCODE_CONNECTION_ERROR") {
            this.w.logService.error(`${e} A permanent error occurred in the reconnecting loop! Will give up now! Error:`), this.y && this.w.logService.error(o), this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, !1);
            break;
          }
          if (n > 360) {
            this.w.logService.error(`${e} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`),
              this.y && this.w.logService.error(o),
              this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, !1);
            break;
          }
          if (gi.isTemporarilyNotAvailable(o) || o?.error?.message?.includes("TemporarilyNotAvailable")) {
            this.w.logService.info(`${e} A temporarily not available error occurred while trying to reconnect, will try again...`), this.w.logService.trace(o);
            continue;
          }
          if ((o.code === "ETIMEDOUT" || o.code === "ENETUNREACH" || o.code === "ECONNREFUSED" || o.code === "ECONNRESET") && o.syscall === "connect") {
            this.w.logService.info(`${e} A network error occurred while trying to reconnect, will try again...`), this.w.logService.trace(o);
            continue;
          }
          if (Fs(o)) {
            this.w.logService.info(`${e} A promise cancelation error occurred while trying to reconnect, will try again...`), this.w.logService.trace(o);
            continue;
          }
          if (o instanceof gi) {
            this.w.logService.error(`${e} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`),
              this.y && this.w.logService.error(o),
              this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, gi.isHandled(o));
            break;
          }
          this.w.logService.error(`${e} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`),
            this.y && this.w.logService.error(o),
            this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, gi.isHandled(o));
          break;
        }
      } while (!this.n && !this.s);
    }
    D(e, s, i) {
      this.y ? Ys.triggerPermanentFailure(e, s, i) : this.F(e, s, i);
    }
    F(e, s, i) {
      this.m.fire(new X0(this.reconnectionToken, e, s, i, $t(this.u))), zu(this.protocol, $t(this.u));
    }
    G() {
      this.protocol.pauseSocketWriting();
    }
  },
  XS = class vi extends O {
    static triggerPermanentFailure(e, s, i) {
      (this._permanentFailure = !0), (this.f = e), (this.g = s), (this.h = i), this.j.forEach((n) => n.F(this.f, this.g, this.h));
    }
    static debugTriggerReconnection() {
      this.j.forEach((e) => e.z());
    }
    static debugPauseSocketWriting() {
      this.j.forEach((e) => e.G());
    }
    static {
      this._permanentFailure = !1;
    }
    static {
      this.f = 0;
    }
    static {
      this.g = 0;
    }
    static {
      this.h = !1;
    }
    static {
      this.j = [];
    }
    get n() {
      return this.c || vi._permanentFailure;
    }
    constructor(e, s, i, n, r) {
      super(),
        (this.u = e),
        (this.w = s),
        (this.reconnectionToken = i),
        (this.protocol = n),
        (this.y = r),
        (this.m = this.B(new D())),
        (this.onDidStateChange = this.m.event),
        (this.c = !1),
        (this.r = !1),
        (this.s = !1),
        (this.t = !1),
        this.m.fire(new Qa(this.reconnectionToken, 0, 0, 0, $t(this.u))),
        this.B(
          n.onSocketClose((o) => {
            const a = Ji(this.u, this.reconnectionToken, !0);
            if (!o) this.w.logService.info(`${a} received socket close event.`);
            else if (o.type === 0) {
              if ((this.w.logService.info(`${a} received socket close event (hadError: ${o.hadError}).`), o.error?.message?.includes(Fu))) {
                this.t = !0;
                return;
              }
            } else this.w.logService.info(`${a} received socket close event (wasClean: ${o.wasClean}, code: ${o.code}, reason: ${o.reason}).`);
            this.z();
          }),
        ),
        this.B(
          n.onSocketTimeout((o) => {
            if (this.t) return;
            const a = Ji(this.u, this.reconnectionToken, !0);
            this.w.logService.info(
              `${a} received socket timeout event (unacknowledgedMsgCount: ${o.unacknowledgedMsgCount}, timeSinceOldestUnacknowledgedMsg: ${o.timeSinceOldestUnacknowledgedMsg}, timeSinceLastReceivedSomeData: ${o.timeSinceLastReceivedSomeData}).`,
            ),
              this.z();
          }),
        ),
        vi.j.push(this),
        this.B(
          ue(() => {
            const o = vi.j.indexOf(this);
            o >= 0 && vi.j.splice(o, 1);
          }),
        ),
        this.n && this.F(vi.f, vi.g, vi.h);
    }
    dispose() {
      super.dispose(), (this.s = !0);
    }
    async z() {
      if (!this.r)
        try {
          (this.r = !0), await this.C();
        } finally {
          this.r = !1;
        }
    }
    async C() {
      if (this.n || this.s) return;
      const e = Ji(this.u, this.reconnectionToken, !0);
      this.w.logService.info(`${e} starting reconnecting loop. You can get more information with the trace log level.`);
      const s = Date.now();
      this.m.fire(new G0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), $t(this.u)));
      const i = [0, 5, 5, 10, 10, 10, 10, 10, 30];
      let n = -1;
      do {
        n++;
        const r = n < i.length ? i[n] : i[i.length - 1];
        try {
          if (r > 0) {
            const a = W0(r);
            this.m.fire(new J0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), r, a)), this.w.logService.info(`${e} waiting for ${r} seconds before reconnecting...`);
            try {
              await a;
            } catch {}
          }
          if (this.n) {
            this.w.logService.error(`${e} permanent failure occurred while running the reconnecting loop.`);
            break;
          }
          this.m.fire(new K0(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), n + 1, $t(this.u))), this.w.logService.info(`${e} resolving connection...`);
          const o = await Bu(this.w, this.reconnectionToken, this.protocol);
          this.w.logService.info(`${e} connecting to ${o.connectTo}...`),
            await this.H(o, Mu(q0)),
            this.w.logService.info(`${e} reconnected!`),
            this.m.fire(new Qa(this.reconnectionToken, this.protocol.getMillisSinceLastIncomingData(), Date.now() - s, n + 1, $t(this.u)));
          break;
        } catch (o) {
          if (o.code === "VSCODE_CONNECTION_ERROR") {
            this.w.logService.error(`${e} A permanent error occurred in the reconnecting loop! Will give up now! Error:`), this.y && this.w.logService.error(o), this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, !1);
            break;
          }
          if (n > 360) {
            this.w.logService.error(`${e} An error occurred while reconnecting, but it will be treated as a permanent error because the reconnection grace time has expired! Will give up now! Error:`),
              this.y && this.w.logService.error(o),
              this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, !1);
            break;
          }
          if (gi.isTemporarilyNotAvailable(o) || o?.error?.message?.includes("TemporarilyNotAvailable")) {
            this.w.logService.info(`${e} A temporarily not available error occurred while trying to reconnect, will try again...`), this.w.logService.trace(o);
            continue;
          }
          if ((o.code === "ETIMEDOUT" || o.code === "ENETUNREACH" || o.code === "ECONNREFUSED" || o.code === "ECONNRESET") && o.syscall === "connect") {
            this.w.logService.info(`${e} A network error occurred while trying to reconnect, will try again...`), this.w.logService.trace(o);
            continue;
          }
          if (Fs(o)) {
            this.w.logService.info(`${e} A promise cancelation error occurred while trying to reconnect, will try again...`), this.w.logService.trace(o);
            continue;
          }
          if (o instanceof gi) {
            this.w.logService.error(`${e} A RemoteAuthorityResolverError occurred while trying to reconnect. Will give up now! Error:`),
              this.y && this.w.logService.error(o),
              this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, gi.isHandled(o));
            break;
          }
          this.w.logService.error(`${e} An unknown error occurred while trying to reconnect, since this is an unknown case, it will be treated as a permanent error! Will give up now! Error:`),
            this.y && this.w.logService.error(o),
            this.D(this.protocol.getMillisSinceLastIncomingData(), n + 1, gi.isHandled(o));
          break;
        }
      } while (!this.n && !this.s);
    }
    D(e, s, i) {
      this.y ? S9.triggerPermanentFailure(e, s, i) : this.F(e, s, i);
    }
    F(e, s, i) {
      this.m.fire(new X0(this.reconnectionToken, e, s, i, $t(this.u))), zu(this.protocol, $t(this.u));
    }
    G() {
      this.protocol.pauseSocketWriting();
    }
  };
function zu(t, e) {
  try {
    t.acceptDisconnect();
    const s = t.getSocket();
    t.dispose(), s.dispose(), nt("safeDisposeProtocolAndSocket", e);
  } catch (s) {
    rt(s), nt(`got error when safeDisposeProtocolAndSocket, Error: ${Xe(s)}`, e);
  }
}
function $9(t) {
  if (t && t.type === "error") {
    const e = new Error(`Connection error: ${t.reason}`);
    return (e.code = "VSCODE_CONNECTION_ERROR"), e;
  }
  return null;
}
function x9(t, e) {
  for (; t.length < e; ) t += " ";
  return t;
}
function C9(t, e) {
  return `[remote-connection][${x9($t(t), 13)}][${e.substr(0, 5)}\u2026]`;
}
function Ji(t, e, s) {
  return `${C9(t, e)}[${s ? "reconnect" : "initial"}]`;
}
function Q0(t, e) {
  return `${Ji(e, t.reconnectionToken, !!t.reconnectionProtocol)}[${t.connectTo}]`;
}
function Y0(t) {
  return `${Date.now() - t} ms`;
}
var Ya = z("remoteSocketFactoryService"),
  k9 = class {
    constructor() {
      this.a = {};
    }
    register(t, e) {
      return (
        (this.a[t] ??= []),
        this.a[t].push(e),
        ue(() => {
          const s = this.a[t]?.indexOf(e);
          typeof s == "number" && s >= 0 && this.a[t]?.splice(s, 1);
        })
      );
    }
    b(t) {
      return (this.a[t.type] || []).find((s) => s.supports(t));
    }
    connect(t, e, s, i) {
      const n = this.b(t);
      if (!n) throw new Error(`No socket factory found for ${t}`);
      return n.connect(t, e, s, i);
    }
  };
async function D9(t, e, s, i, n) {
  let r;
  for (let o = 3; o && (r?.dispose(), (r = await new I9(t, e, s, i, n).waitForReady()), !((n && A0[n]) || !A0[r.tunnelLocalPort])); o--);
  return r;
}
var I9 = class extends O {
    constructor(t, e, s, i, n) {
      super(),
        (this.m = e),
        (this.n = n),
        (this.privacy = Xa.Private),
        (this.j = new Map()),
        (this.a = t),
        (this.b = o9.createServer()),
        (this.c = new Jc()),
        (this.f = () => this.c.open()),
        this.b.on("listening", this.f),
        (this.g = (r) => this.r(r)),
        this.b.on("connection", this.g),
        (this.h = () => {}),
        this.b.on("error", this.h),
        (this.tunnelRemotePort = i),
        (this.tunnelRemoteHost = s);
    }
    async dispose() {
      super.dispose(),
        this.b.removeListener("listening", this.f),
        this.b.removeListener("connection", this.g),
        this.b.removeListener("error", this.h),
        this.b.close(),
        Array.from(this.j.values()).forEach((e) => {
          e();
        });
    }
    async waitForReady() {
      const t = this.n ?? this.tunnelRemotePort,
        e = qr(this.m) ? "0.0.0.0" : "127.0.0.1";
      let s = await l9(t, 2, 1e3, e),
        i = null;
      return (
        this.b.listen(s, this.m),
        await this.c.wait(),
        (i = this.b.address()),
        i || ((s = 0), this.b.listen(s, this.m), await this.c.wait(), (i = this.b.address())),
        (this.tunnelLocalPort = i.port),
        (this.localAddress = `${this.tunnelRemoteHost === "127.0.0.1" ? "127.0.0.1" : "localhost"}:${i.port}`),
        this
      );
    }
    async r(t) {
      t.pause();
      const e = Ou(this.tunnelRemoteHost) || qr(this.tunnelRemoteHost) ? "localhost" : this.tunnelRemoteHost,
        s = await E9(this.a, e, this.tunnelRemotePort),
        i = s.getSocket(),
        n = s.readEntireBuffer();
      s.dispose(),
        n.byteLength > 0 && t.write(n.buffer),
        t.on("end", () => {
          t.localAddress && this.j.delete(t.localAddress), i.end();
        }),
        t.on("close", () => i.end()),
        t.on("error", () => {
          t.localAddress && this.j.delete(t.localAddress), i instanceof ju ? i.socket.destroy() : i.end();
        }),
        i instanceof ju ? this.t(t, i) : this.s(t, i),
        t.localAddress &&
          this.j.set(t.localAddress, () => {
            t.end(), i.end();
          });
    }
    s(t, e) {
      e.onClose(() => t.destroy()), e.onEnd(() => t.end()), e.onData((s) => t.write(s.buffer)), t.on("data", (s) => e.write(L.wrap(s))), t.resume();
    }
    t(t, e) {
      const s = e.socket;
      s.on("end", () => t.end()),
        s.on("close", () => t.end()),
        s.on("error", () => {
          t.destroy();
        }),
        s.pipe(t),
        t.pipe(s);
    }
  },
  qu = class extends Nu {
    constructor(e, s, i, n, r) {
      super(s, r), (this.H = e), (this.I = i), (this.J = n);
    }
    isPortPrivileged(e) {
      return r9(e, this.t, hn, a9.release());
    }
    F(e, s, i, n, r, o, a, c) {
      const l = this.D(s, i);
      if (l) return ++l.refcount, l.value;
      if (i9(e)) return this.G(e, s, i, r, o, a, c);
      {
        this.r.trace(`ForwardedPorts: (TunnelService) Creating tunnel without provider ${s}:${i} on local port ${r}.`);
        const h = { commit: this.J.commit, quality: this.J.quality, addressProvider: e, remoteSocketFactoryService: this.H, signService: this.I, logService: this.r, ipcLogger: null },
          u = D9(h, n, s, i, r);
        return this.r.trace("ForwardedPorts: (TunnelService) Tunnel created without provider."), this.z(s, i, u), u;
      }
    }
  };
qu = __decorate([__param(0, Ya), __param(1, ne), __param(2, Ka), __param(3, Ee), __param(4, Ce)], qu);
var Vu = class extends qu {
  constructor(e, s, i, n, r) {
    super(e, s, i, n, r);
  }
};
Vu = __decorate([__param(0, Ya), __param(1, ne), __param(2, Ka), __param(3, Ee), __param(4, Ce)], Vu);
var Wu = class extends O {
  constructor(e, s, i, n, r) {
    super(), (this.b = e), (this.c = s), (this.f = i), (this.g = n), (this.h = r), (this.a = new Map());
  }
  async openTunnel(e, s, i, n, r, o, a, c, l) {
    if ((this.c.trace(`ForwardedPorts: (SharedTunnelService) openTunnel request for ${i}:${n} on local port ${o}.`), !this.a.has(e))) {
      const h = new Vu(this.b, this.c, this.g, this.f, this.h);
      this.B(h),
        this.a.set(e, h),
        h.onTunnelClosed(async () => {
          (await h.tunnels).length === 0 && (h.dispose(), this.a.delete(e));
        });
    }
    return this.a.get(e).openTunnel(s, i, n, r, o, a, c, l);
  }
};
Wu = __decorate([__param(0, Ya), __param(1, ne), __param(2, Ee), __param(3, Ka), __param(4, Ce)], Wu);
var Z0 = z("sharedProcessTunnelService"),
  R9 = "sharedProcessTunnel",
  Hu,
  P9 = class extends O {
    constructor() {
      super(), (this.a = null), (this.b = null);
    }
    async getAddress() {
      return this.a ? this.a : (this.b || (this.b = new Ro()), this.b.p);
    }
    setAddress(t) {
      (this.a = t), this.b && (this.b.complete(t), (this.b = null));
    }
    setTunnel(t) {
      this.B(t);
    }
  },
  Gu = class extends O {
    static {
      Hu = this;
    }
    static {
      this.a = 0;
    }
    constructor(e, s) {
      super(), (this.f = e), (this.g = s), (this.b = new Map()), (this.c = new Set());
    }
    dispose() {
      super.dispose(), this.b.forEach((e) => e.dispose());
    }
    async createTunnel() {
      return { id: String(++Hu.a) };
    }
    async startTunnel(e, s, i, n, r, o, a) {
      const c = new P9(),
        l = await Promise.resolve(this.f.openTunnel(e, c, i, n, r, o, a));
      if (!l || typeof l == "string") throw (this.g.info(`[SharedProcessTunnelService] Could not create a tunnel to ${i}:${n} (remote).`), c.dispose(), new Error("Could not create tunnel"));
      if (this.c.has(s)) throw (this.c.delete(s), c.dispose(), await l.dispose(), uo());
      return c.setTunnel(l), this.b.set(s, c), this.g.info(`[SharedProcessTunnelService] Created tunnel ${s}: ${l.localAddress} (local) to ${i}:${n} (remote).`), { tunnelLocalPort: l.tunnelLocalPort, localAddress: l.localAddress };
    }
    async setAddress(e, s) {
      const i = this.b.get(e);
      i && i.setAddress(s);
    }
    async destroyTunnel(e) {
      const s = this.b.get(e);
      if (s) {
        this.g.info(`[SharedProcessTunnelService] Disposing tunnel ${e}.`), this.b.delete(e), await s.dispose();
        return;
      }
      this.c.add(e);
    }
  };
Gu = Hu = __decorate([__param(0, I0), __param(1, ne)], Gu);
var A9 = [],
  em;
(function (t) {
  (t[(t.Eager = 0)] = "Eager"), (t[(t.Delayed = 1)] = "Delayed");
})(em || (em = {}));
function O9(t, e, s) {
  e instanceof de || (e = new de(e, [], !!s)), A9.push([t, e]);
}
var tm,
  Ju = class {
    constructor(t, e, s) {
      (this.level = t), (this.key = e), (this.value = s), (this.forward = []);
    }
  },
  Wr = void 0,
  L9 = class Wn {
    constructor(e, s = 2 ** 16) {
      (this.comparator = e), (this[tm] = "SkipList"), (this.d = 0), (this.f = 0), (this.c = Math.max(1, Math.log2(s) | 0)), (this.e = new Ju(this.c, Wr, Wr));
    }
    get size() {
      return this.f;
    }
    clear() {
      (this.e = new Ju(this.c, Wr, Wr)), (this.f = 0);
    }
    has(e) {
      return !!Wn.g(this, e, this.comparator);
    }
    get(e) {
      return Wn.g(this, e, this.comparator)?.value;
    }
    set(e, s) {
      return Wn.h(this, e, s, this.comparator) && (this.f += 1), this;
    }
    delete(e) {
      const s = Wn.k(this, e, this.comparator);
      return s && (this.f -= 1), s;
    }
    forEach(e, s) {
      let i = this.e.forward[0];
      for (; i; ) e.call(s, i.value, i.key, this), (i = i.forward[0]);
    }
    [((tm = Symbol.toStringTag), Symbol.iterator)]() {
      return this.entries();
    }
    *entries() {
      let e = this.e.forward[0];
      for (; e; ) yield [e.key, e.value], (e = e.forward[0]);
    }
    *keys() {
      let e = this.e.forward[0];
      for (; e; ) yield e.key, (e = e.forward[0]);
    }
    *values() {
      let e = this.e.forward[0];
      for (; e; ) yield e.value, (e = e.forward[0]);
    }
    toString() {
      let e = "[SkipList]:",
        s = this.e.forward[0];
      for (; s; ) (e += `node(${s.key}, ${s.value}, lvl:${s.level})`), (s = s.forward[0]);
      return e;
    }
    static g(e, s, i) {
      let n = e.e;
      for (let r = e.d - 1; r >= 0; r--) for (; n.forward[r] && i(n.forward[r].key, s) < 0; ) n = n.forward[r];
      if (((n = n.forward[0]), n && i(n.key, s) === 0)) return n;
    }
    static h(e, s, i, n) {
      const r = [];
      let o = e.e;
      for (let a = e.d - 1; a >= 0; a--) {
        for (; o.forward[a] && n(o.forward[a].key, s) < 0; ) o = o.forward[a];
        r[a] = o;
      }
      if (((o = o.forward[0]), o && n(o.key, s) === 0)) return (o.value = i), !1;
      {
        const a = Wn.j(e);
        if (a > e.d) {
          for (let c = e.d; c < a; c++) r[c] = e.e;
          e.d = a;
        }
        o = new Ju(a, s, i);
        for (let c = 0; c < a; c++) (o.forward[c] = r[c].forward[c]), (r[c].forward[c] = o);
        return !0;
      }
    }
    static j(e, s = 0.5) {
      let i = 1;
      for (; Math.random() < s && i < e.c; ) i += 1;
      return i;
    }
    static k(e, s, i) {
      const n = [];
      let r = e.e;
      for (let o = e.d - 1; o >= 0; o--) {
        for (; r.forward[o] && i(r.forward[o].key, s) < 0; ) r = r.forward[o];
        n[o] = r;
      }
      if (((r = r.forward[0]), !r || i(r.key, s) !== 0)) return !1;
      for (let o = 0; o < e.d && n[o].forward[o] === r; o++) n[o].forward[o] = r.forward[o];
      for (; e.d > 0 && e.e.forward[e.d - 1] === Wr; ) e.d -= 1;
      return !0;
    }
  },
  sm = class Lf {
    static {
      this._clock = 0;
    }
    constructor(e) {
      (this.uri = e), (this.time = Lf._clock++);
    }
    touch() {
      return (this.time = Lf._clock++), this;
    }
  },
  Za = class {
    constructor(e) {
      (this.g = e), (this.c = new ye()), (this.f = 2 ** 16);
      const s = new Map(),
        i = (n) => {
          let r = s.get(n.scheme);
          return r === void 0 && ((r = e.hasProvider(n) && !this.g.hasCapability(n, 1024)), s.set(n.scheme, r)), r;
        };
      this.c.add(
        T.any(
          e.onDidChangeFileSystemProviderRegistrations,
          e.onDidChangeFileSystemProviderCapabilities,
        )((n) => {
          s.delete(n.scheme);
        }),
      ),
        (this.extUri = new Do(i)),
        (this.d = new L9((n, r) => this.extUri.compare(n, r, !0), this.f));
    }
    dispose() {
      this.c.dispose(), this.d.clear();
    }
    asCanonicalUri(e) {
      this.g.hasProvider(e) && (e = cy(e));
      const s = this.d.get(e);
      return s ? s.touch().uri.with({ fragment: e.fragment }) : (this.d.set(e, new sm(e)), this.h(), e);
    }
    h() {
      if (this.d.size < this.f) return;
      const e = [...this.d.entries()].sort((i, n) => (i[1].time < n[1].time ? 1 : i[1].time > n[1].time ? -1 : 0));
      (sm._clock = 0), this.d.clear();
      const s = this.f * 0.5;
      for (let i = 0; i < s; i++) this.d.set(e[i][0], e[i][1].touch());
    }
  };
(Za = __decorate([__param(0, ie)], Za)), O9(ke, Za, 1);
var N9 = class extends O {
    constructor(t, e, s, i, n, r) {
      super(),
        (this.f = t),
        (this.g = e),
        (this.h = s),
        (this.j = i),
        (this.m = n),
        (this.n = r),
        (this.capabilities = this.g.capabilities),
        (this.onDidChangeCapabilities = this.g.onDidChangeCapabilities),
        (this.a = this.B(new D())),
        (this.onDidChangeFile = this.a.event),
        (this.b = Cn.forUris(() => !(this.capabilities & 1024))),
        (this.c = new kc((o) => this.m.extUri.getComparisonKey(this.t(o)))),
        this.r(),
        this.B(i.onDidChangeProfiles(() => this.r())),
        this.B(this.g.onDidChangeFile((o) => this.s(o)));
    }
    r() {
      this.c.clear();
      for (const t of this.j.profiles) this.c.add(t.settingsResource), this.c.add(t.keybindingsResource), this.c.add(t.tasksResource), this.c.add(t.extensionsResource);
    }
    open(t, e) {
      return this.g.open(this.t(t), e);
    }
    close(t) {
      return this.g.close(t);
    }
    read(t, e, s, i, n) {
      return this.g.read(t, e, s, i, n);
    }
    write(t, e, s, i, n) {
      return this.g.write(t, e, s, i, n);
    }
    watch(t, e) {
      this.b.set(t, t);
      const s = this.g.watch(this.t(t), e);
      return ue(() => {
        this.b.delete(t), s.dispose();
      });
    }
    stat(t) {
      return this.g.stat(this.t(t));
    }
    mkdir(t) {
      return this.g.mkdir(this.t(t));
    }
    rename(t, e, s) {
      return this.g.rename(this.t(t), this.t(e), s);
    }
    readFile(t, e) {
      return this.g.readFile(this.t(t), e);
    }
    readFileStream(t, e, s) {
      return this.g.readFileStream(this.t(t), e, s);
    }
    readdir(t) {
      return this.g.readdir(this.t(t));
    }
    enforceAtomicReadFile(t) {
      return this.c.has(t);
    }
    writeFile(t, e, s) {
      return this.g.writeFile(this.t(t), e, s);
    }
    enforceAtomicWriteFile(t) {
      return this.c.has(t) ? { postfix: ".vsctmp" } : !1;
    }
    delete(t, e) {
      return this.g.delete(this.t(t), e);
    }
    copy(t, e, s) {
      if (xl(this.g)) return this.g.copy(this.t(t), this.t(e), s);
      throw new Error("copy not supported");
    }
    cloneFile(t, e) {
      if (X1(this.g)) return this.g.cloneFile(this.t(t), this.t(e));
      throw new Error("clone not supported");
    }
    s(t) {
      const e = [];
      for (const s of t) {
        if (s.resource.scheme !== this.f) continue;
        const i = this.u(s.resource);
        this.b.findSubstr(i) && e.push({ resource: i, type: s.type, cId: s.cId });
      }
      e.length && (this.n.debug("User data changed"), this.a.fire(e));
    }
    t(t) {
      return t.with({ scheme: this.f });
    }
    u(t) {
      return t.with({ scheme: this.h });
    }
  },
  T9 = "localFilesystem",
  j9 = class extends O {
    constructor(t, e) {
      super(),
        (this.a = t),
        (this.b = e),
        (this.onDidChangeCapabilities = T.None),
        (this.f = this.B(new D())),
        (this.onDidChangeFile = this.f.event),
        (this.g = this.B(new D())),
        (this.onDidWatchError = this.g.event),
        (this.h = Me()),
        this.j();
    }
    get capabilities() {
      return this.c || ((this.c = 253982), this.b.pathCaseSensitive && (this.c |= 1024), this.b.trash && (this.c |= 4096)), this.c;
    }
    stat(t) {
      return this.a.call("stat", [t]);
    }
    readdir(t) {
      return this.a.call("readdir", [t]);
    }
    async readFile(t, e) {
      const { buffer: s } = await this.a.call("readFile", [t, e]);
      return s;
    }
    readFileStream(t, e, s) {
      const i = or((r) => L.concat(r.map((o) => L.wrap(o))).buffer),
        n = new ye();
      return (
        n.add(
          this.a.listen("readFileStream", [t, e])((r) => {
            if (r instanceof L) i.write(r.buffer);
            else {
              if (r === "end") i.end();
              else {
                let o;
                if (r instanceof Error) o = r;
                else {
                  const a = r;
                  o = Ds(a.message ?? Xe(a), a.code ?? X.Unknown);
                }
                i.error(o), i.end();
              }
              n.dispose();
            }
          }),
        ),
        n.add(
          s.onCancellationRequested(() => {
            i.error(uo()), i.end(), n.dispose();
          }),
        ),
        i
      );
    }
    writeFile(t, e, s) {
      return this.a.call("writeFile", [t, L.wrap(e), s]);
    }
    open(t, e) {
      return this.a.call("open", [t, e, !!this.b.disableWriteLock]);
    }
    close(t) {
      return this.a.call("close", [t]);
    }
    async read(t, e, s, i, n) {
      const [r, o] = await this.a.call("read", [t, e, n]);
      return s.set(r.buffer.slice(0, o), i), o;
    }
    write(t, e, s, i, n) {
      return this.a.call("write", [t, e, L.wrap(s), i, n]);
    }
    mkdir(t) {
      return this.a.call("mkdir", [t]);
    }
    delete(t, e) {
      return this.a.call("delete", [t, e]);
    }
    rename(t, e, s) {
      return this.a.call("rename", [t, e, s]);
    }
    copy(t, e, s) {
      return this.a.call("copy", [t, e, s]);
    }
    cloneFile(t, e) {
      return this.a.call("cloneFile", [t, e]);
    }
    j() {
      this.B(
        this.a.listen("fileChange", [this.h])((t) => {
          if (Array.isArray(t)) {
            const e = t;
            this.f.fire(Oh(e));
          } else {
            const e = t;
            this.g.fire(e);
          }
        }),
      );
    }
    watch(t, e) {
      const s = Me();
      return this.a.call("watch", [this.h, s, t, e]), ue(() => this.a.call("unwatch", [this.h, s]));
    }
  },
  F9 = class {
    constructor() {
      this.a = new Map();
    }
    async startProfiling(t) {
      const s = await (await import("v8-inspect-profiler")).startProfiling({ host: t.host, port: t.port, checkForPaused: !0 }),
        i = Me();
      return this.a.set(i, s), i;
    }
    async stopProfiling(t) {
      const e = this.a.get(t);
      if (!e) throw new Error(`UNKNOWN session '${t}'`);
      const s = await e.stop();
      return this.a.delete(t), s.profile;
    }
  },
  im = z("IV8InspectProfilingService"),
  nm;
(function (t) {
  function e(i) {
    return !!(i.samples && i.timeDeltas);
  }
  t.isValidProfile = e;
  function s(i, n = "noAbsolutePaths") {
    for (const r of i.nodes) r.callFrame && r.callFrame.url && (xo(r.callFrame.url) || /^\w[\w\d+.-]*:\/\/\/?/.test(r.callFrame.url)) && (r.callFrame.url = V(n, Ot(r.callFrame.url)));
    return i;
  }
  t.rewriteAbsolutePaths = s;
})(nm || (nm = {}));
var Ku = class extends r2 {
  constructor(e, s, i, n, r, o, a, c) {
    super(C.file(r.builtinExtensionsPath), C.file(r.extensionsPath), r.userHome, e.defaultProfile, e, s, i, n, r, o, a, c);
  }
};
Ku = __decorate([__param(0, Te), __param(1, ci), __param(2, ie), __param(3, ne), __param(4, Zt), __param(5, Ee), __param(6, ke), __param(7, ds)], Ku);
var M9 = class extends Nb {
    constructor(t, e) {
      super(), (this.a = e);
      for (const s in t) {
        const { definition: i, value: n } = t[s];
        (this.f[s] = i), n !== void 0 && this.g.set(s, n);
      }
      this.a.listen("onDidChange")((s) => {
        for (const i in s) {
          const n = s[i];
          n === null ? this.g.delete(i) : this.g.set(i, n);
        }
        this.h.fire(Object.keys(s));
      });
    }
    async j(t) {
      const e = await this.a.call("updatePolicyDefinitions", t);
      for (const s in e) this.g.set(s, e[s]);
    }
  },
  U9 = class extends O {
    get defaultProfile() {
      return this.profiles[0];
    }
    get profiles() {
      return this.a;
    }
    constructor(t, e, s) {
      super(),
        (this.profilesHome = e),
        (this.c = s),
        (this.a = []),
        (this.b = this.B(new D())),
        (this.onDidChangeProfiles = this.b.event),
        (this.a = t.map((i) => es(i, this.profilesHome.scheme))),
        this.B(
          this.c.listen("onDidChangeProfiles")((i) => {
            const n = i.added.map((a) => es(a, this.profilesHome.scheme)),
              r = i.removed.map((a) => es(a, this.profilesHome.scheme)),
              o = i.updated.map((a) => es(a, this.profilesHome.scheme));
            (this.a = i.all.map((a) => es(a, this.profilesHome.scheme))), this.b.fire({ added: n, removed: r, updated: o, all: this.profiles });
          }),
        ),
        (this.onDidResetWorkspaces = this.c.listen("onDidResetWorkspaces"));
    }
    async createNamedProfile(t, e, s) {
      const i = await this.c.call("createNamedProfile", [t, e, s]);
      return es(i, this.profilesHome.scheme);
    }
    async createProfile(t, e, s, i) {
      const n = await this.c.call("createProfile", [t, e, s, i]);
      return es(n, this.profilesHome.scheme);
    }
    async createTransientProfile(t) {
      const e = await this.c.call("createTransientProfile", [t]);
      return es(e, this.profilesHome.scheme);
    }
    async setProfileForWorkspace(t, e) {
      await this.c.call("setProfileForWorkspace", [t, e]);
    }
    removeProfile(t) {
      return this.c.call("removeProfile", [t]);
    }
    async updateProfile(t, e) {
      const s = await this.c.call("updateProfile", [t, e]);
      return es(s, this.profilesHome.scheme);
    }
    resetWorkspaces() {
      return this.c.call("resetWorkspaces");
    }
    cleanUp() {
      return this.c.call("cleanUp");
    }
    cleanUpTransientProfiles() {
      return this.c.call("cleanUpTransientProfiles");
    }
  };
import * as _9 from "https";
var B9 = !1,
  z9 = class {
    constructor(t, e, s) {
      (this.id = t), (this.dependencies = e), (this.callback = s);
    }
  },
  Ki;
(function (t) {
  (t[(t.Uninitialized = 1)] = "Uninitialized"), (t[(t.InitializedInternal = 2)] = "InitializedInternal"), (t[(t.InitializedExternal = 3)] = "InitializedExternal");
})(Ki || (Ki = {}));
var q9 = class dw {
    static {
      this.INSTANCE = new dw();
    }
    constructor() {
      (this.a = typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope"), (this.b = typeof document == "object"), (this.c = []), (this.d = Ki.Uninitialized);
    }
    g() {
      if (this.d === Ki.Uninitialized) {
        if (globalThis.define) {
          this.d = Ki.InitializedExternal;
          return;
        }
      } else return;
      (this.d = Ki.InitializedInternal),
        (globalThis.define = (e, s, i) => {
          typeof e != "string" && ((i = s), (s = e), (e = null)), (typeof s != "object" || !Array.isArray(s)) && ((i = s), (s = null)), this.c.push(new z9(e, s, i));
        }),
        (globalThis.define.amd = !0),
        this.b
          ? (this.f =
              globalThis._VSCODE_WEB_PACKAGE_TTP ??
              window.trustedTypes?.createPolicy("amdLoader", {
                createScriptURL(e) {
                  if (e.startsWith(window.location.origin) || e.startsWith(`${oe.vscodeFileResource}://${Ud}`)) return e;
                  throw new Error(`[trusted_script_src] Invalid script url: ${e}`);
                },
              }))
          : this.a &&
            (this.f =
              globalThis._VSCODE_WEB_PACKAGE_TTP ??
              globalThis.trustedTypes?.createPolicy("amdLoader", {
                createScriptURL(e) {
                  return e;
                },
              }));
    }
    async load(e) {
      if ((this.g(), this.d === Ki.InitializedExternal))
        return new Promise((o) => {
          const a = Me();
          globalThis.define(a, [e], function (c) {
            o(c);
          });
        });
      const s = await (this.a ? this.i(e) : this.b ? this.h(e) : this.j(e));
      if (!s) {
        console.warn(`Did not receive a define call from script ${e}`);
        return;
      }
      const i = {},
        n = [],
        r = [];
      if (Array.isArray(s.dependencies)) for (const o of s.dependencies) o === "exports" ? n.push(i) : r.push(o);
      if (r.length > 0) throw new Error(`Cannot resolve dependencies for script ${e}. The dependencies are: ${r.join(", ")}`);
      return typeof s.callback == "function" ? (s.callback(...n) ?? i) : s.callback;
    }
    h(e) {
      return new Promise((s, i) => {
        const n = document.createElement("script");
        n.setAttribute("async", "async"), n.setAttribute("type", "text/javascript");
        const r = () => {
            n.removeEventListener("load", o), n.removeEventListener("error", a);
          },
          o = (c) => {
            r(), s(this.c.pop());
          },
          a = (c) => {
            r(), i(c);
          };
        n.addEventListener("load", o), n.addEventListener("error", a), this.f && (e = this.f.createScriptURL(e)), n.setAttribute("src", e), window.document.getElementsByTagName("head")[0].appendChild(n);
      });
    }
    async i(e) {
      return this.f && (e = this.f.createScriptURL(e)), await import(e), this.c.pop();
    }
    async j(e) {
      try {
        const s = (await import("fs")).default,
          i = (await import("vm")).default,
          n = (await import("module")).default,
          r = C.parse(e).fsPath,
          o = s.readFileSync(r).toString(),
          a = n.wrap(o.replace(/^#!.*/, ""));
        return new i.Script(a).runInThisContext().apply(), this.c.pop();
      } catch (s) {
        throw s;
      }
    }
  },
  Xu = new Map();
async function rm(t, e, s) {
  s === void 0 && (s = !!(globalThis._VSCODE_PRODUCT_JSON ?? globalThis.vscode?.context?.configuration()?.product)?.commit);
  const i = e ? `${t}/${e}` : t;
  if (Xu.has(i)) return Xu.get(i);
  let n;
  if (/^\w[\w\d+.-]*:\/\//.test(i)) n = i;
  else {
    const c = `${B9 && s && !Qe ? Yv : Qv}/${i}`;
    n = Cs.asBrowserUri(c).toString(!0);
  }
  const r = q9.INSTANCE.load(n);
  return Xu.set(i, r), r;
}
var om = "https://mobile.events.data.microsoft.com/OneCollector/1.0",
  V9 = "https://mobile.events.data.microsoft.com/ping";
async function W9(t, e, s) {
  const i = Qe ? await rm("@microsoft/1ds-core-js", "bundle/ms.core.min.js") : await import("@microsoft/1ds-core-js"),
    n = Qe ? await rm("@microsoft/1ds-post-js", "bundle/ms.post.min.js") : await import("@microsoft/1ds-post-js"),
    r = new i.AppInsightsCore(),
    o = new n.PostChannel(),
    a = { instrumentationKey: t, endpointUrl: om, loggingLevelTelemetry: 0, loggingLevelConsole: 0, disableCookiesUsage: !0, disableDbgExt: !0, disableInstrumentationKeyValidation: !0, channels: [[o]] };
  if (s) {
    a.extensionConfig = {};
    const c = { alwaysUseXhrOverride: !0, ignoreMc1Ms0CookieProcessing: !0, httpXHROverride: s };
    a.extensionConfig[o.identifier] = c;
  }
  return (
    r.initialize(a, []),
    r.addTelemetryInitializer((c) => {
      (c.ext = c.ext ?? {}), (c.ext.web = c.ext.web ?? {}), (c.ext.web.consentDetails = '{"GPC_DataSharingOptIn":false}'), e && ((c.ext.utc = c.ext.utc ?? {}), (c.ext.utc.flags = 8462029));
    }),
    r
  );
}
var H9 = class {
  constructor(t, e, s, i, n) {
    (this.e = t), (this.f = e), (this.g = s), (this.h = n), (this.c = om), (this.d = V9), this.g || (this.g = {}), typeof i == "function" ? (this.a = i()) : (this.a = i), (this.b = null);
  }
  i(t) {
    if (this.a) {
      if (typeof this.a != "string") {
        t(this.a);
        return;
      }
      this.b || (this.b = W9(this.a, this.e, this.h)),
        this.b.then(
          (e) => {
            t(e);
          },
          (e) => {
            rt(e), console.error(e);
          },
        );
    }
  }
  log(t, e) {
    if (!this.a) return;
    (e = br(e, this.g)), (e = Vp(e));
    const s = this.f + "/" + t;
    try {
      this.i((i) => {
        (i.pluginVersionString = e?.properties.version ?? "Unknown"), i.track({ name: s, baseData: { name: s, properties: e?.properties, measurements: e?.measurements } });
      });
    } catch {}
  }
  flush() {
    return this.a
      ? new Promise((t) => {
          this.i((e) => {
            e.unload(!0, () => {
              (this.a = void 0), t(void 0);
            });
          });
        })
      : Promise.resolve(void 0);
  }
};
async function G9(t, e) {
  const s = await e.request(t, J.None),
    i = (await Ai(s.stream)).toString(),
    n = s.res.statusCode ?? 200;
  return { headers: s.res.headers, statusCode: n, responseData: i };
}
async function J9(t) {
  const e = { method: t.type, headers: t.headers };
  return new Promise((i, n) => {
    const r = _9.request(t.url ?? "", e, (o) => {
      o.on("data", function (a) {
        i({ headers: o.headers, statusCode: o.statusCode ?? 200, responseData: a.toString() });
      }),
        o.on("error", function (a) {
          n(a);
        });
    });
    r.write(t.data, (o) => {
      o && n(o);
    }),
      r.end();
  });
}
async function K9(t, e, s) {
  const i = typeof e.data == "string" ? e.data : new TextDecoder().decode(e.data),
    n = { type: "POST", headers: { ...e.headers, "Content-Type": "application/json", "Content-Length": Buffer.byteLength(e.data).toString() }, url: e.urlString, data: i };
  try {
    const r = t ? await G9(n, t) : await J9(n);
    s(r.statusCode, r.headers, r.responseData);
  } catch {
    s(0, {});
  }
}
var X9 = class extends H9 {
    constructor(t, e, s, i, n) {
      const r = {
        sendPOST: (o, a) => {
          K9(t, o, a);
        },
      };
      super(e, s, i, n, r);
    }
  },
  Qu = class extends O {
    constructor(e) {
      super(),
        this.B(
          new ks(() => {
            e.cleanUp();
          }, 10 * 1e3),
        ).schedule();
    }
  };
Qu = __decorate([__param(0, Te)], Qu);
var am = z("IRemoteTunnelService"),
  ec = { active: !1 },
  Pt;
(function (t) {
  (t.disconnected = (e) => ({ type: "disconnected", onTokenFailed: e })),
    (t.connected = (e, s) => ({ type: "connected", info: e, serviceInstallFailed: s })),
    (t.connecting = (e) => ({ type: "connecting", progress: e })),
    (t.uninitialized = { type: "uninitialized" });
})(Pt || (Pt = {}));
var cm = "remote.tunnels.access",
  lm = cm + ".hostNameOverride",
  hm = cm + ".preventSleep",
  um = "remoteTunnelService",
  Q9 = w(2112, null),
  os,
  Yu = class {
    static {
      os = this;
    }
    static {
      this.a = "not-existing-resource";
    }
    static {
      this.b = "remote-backup";
    }
    static {
      this.c = "local-backup";
    }
    constructor(e, s, i, n, r, o, a, c, l, h) {
      (this.e = e), (this.f = s), (this.g = i), (this.h = r), (this.i = o), (this.j = a), (this.k = c), (this.l = l), (this.n = h), (this.d = n.extUri);
    }
    async getRemoteSyncedProfiles() {
      const e = await this.e.readResource("profiles", null, void 0);
      if (e.content) {
        const s = this.L(e.content, "profiles");
        return Hi(s);
      }
      return [];
    }
    async getLocalSyncedProfiles(e) {
      const s = await this.f.getAllResourceRefs("profiles", void 0, e);
      if (s.length) {
        const i = await this.f.resolveResourceContent("profiles", s[0].ref, void 0, e);
        if (i) {
          const n = this.L(i, "profiles");
          return Hi(n);
        }
      }
      return [];
    }
    async getLocalSyncedMachines(e) {
      const s = await this.f.getAllResourceRefs("machines", void 0, e);
      if (s.length) {
        const i = await this.f.resolveResourceContent("machines", s[0].ref, void 0, e);
        if (i) return JSON.parse(i).machines.map((r) => ({ ...r, isCurrent: !1 }));
      }
      return [];
    }
    async getRemoteSyncResourceHandles(e, s) {
      return (await this.e.getAllResourceRefs(e, s?.collection)).map(({ created: n, ref: r }) => ({
        created: n,
        uri: this.J({ remote: !0, syncResource: e, profile: s?.id ?? this.k.defaultProfile.id, location: void 0, collection: s?.collection, ref: r, node: void 0 }),
      }));
    }
    async getLocalSyncResourceHandles(e, s, i) {
      return (await this.f.getAllResourceRefs(e, s?.collection, i)).map(({ created: r, ref: o }) => ({
        created: r,
        uri: this.J({ remote: !1, syncResource: e, profile: s?.id ?? this.k.defaultProfile.id, collection: s?.collection, ref: o, node: void 0, location: i }),
      }));
    }
    resolveUserDataSyncResource({ uri: e }) {
      const s = this.K(e),
        i = s ? this.k.profiles.find((n) => n.id === s.profile) : void 0;
      return s && i ? { profile: i, syncResource: s?.syncResource } : void 0;
    }
    async getAssociatedResources({ uri: e }) {
      const s = this.K(e);
      if (!s) return [];
      const i = this.k.profiles.find((n) => n.id === s.profile);
      switch (s.syncResource) {
        case "settings":
          return this.s(e, i);
        case "keybindings":
          return this.u(e, i);
        case "tasks":
          return this.w(e, i);
        case "snippets":
          return this.y(e, i);
        case "globalState":
          return this.D(e, i);
        case "extensions":
          return this.A(e, i);
        case "profiles":
          return this.G(e, i);
        case "workspaceState":
          return [];
      }
    }
    async getMachineId({ uri: e }) {
      const s = this.K(e);
      if (s) {
        if (s.remote) {
          if (s.ref) {
            const { content: i } = await this.M(s.syncResource, s.ref, s.collection);
            if (i) return this.L(i, s.syncResource)?.machineId;
          }
          return;
        }
        if (s.location) {
          if (s.ref) {
            const i = await this.f.resolveResourceContent(s.syncResource, s.ref, s.collection, s.location);
            if (i) return this.L(i, s.syncResource)?.machineId;
          }
          return;
        }
        return On(this.h, this.j, this.i);
      }
    }
    async resolveContent(e) {
      const s = this.K(e);
      if (!s || s.node === os.a) return null;
      if (s.ref) {
        const i = await this.o(s.remote, s.syncResource, s.collection, s.ref, s.location);
        return s.node && i ? this.q(s.syncResource, i, s.node) : i;
      }
      return !s.remote && !s.node ? this.r(s.syncResource, s.profile) : null;
    }
    async o(e, s, i, n, r) {
      if (e) {
        const { content: o } = await this.M(s, n, i);
        return o;
      }
      return this.f.resolveResourceContent(s, n, i, r);
    }
    q(e, s, i) {
      const n = this.L(s, e);
      switch (e) {
        case "settings":
          return this.t(n, i);
        case "keybindings":
          return this.v(n, i);
        case "tasks":
          return this.x(n, i);
        case "snippets":
          return this.z(n, i);
        case "globalState":
          return this.E(n, i);
        case "extensions":
          return this.B(n, i);
        case "profiles":
          return this.H(n, i);
        case "workspaceState":
          return null;
      }
    }
    async r(e, s) {
      const i = this.k.profiles.find((n) => n.id === s);
      if (!i) return null;
      switch (e) {
        case "globalState":
          return this.F(i);
        case "extensions":
          return this.C(i);
        case "profiles":
          return this.I(i);
        case "settings":
          return null;
        case "keybindings":
          return null;
        case "tasks":
          return null;
        case "snippets":
          return null;
        case "workspaceState":
          return null;
      }
    }
    s(e, s) {
      const i = this.d.joinPath(e, "settings.json"),
        n = s ? s.settingsResource : this.d.joinPath(e, os.a);
      return [{ resource: i, comparableResource: n }];
    }
    t(e, s) {
      switch (s) {
        case "settings.json":
          return Su(e.content).settings;
      }
      return null;
    }
    u(e, s) {
      const i = this.d.joinPath(e, "keybindings.json"),
        n = s ? s.keybindingsResource : this.d.joinPath(e, os.a);
      return [{ resource: i, comparableResource: n }];
    }
    v(e, s) {
      switch (s) {
        case "keybindings.json":
          return Ba(e.content, !!this.l.getValue(qh), this.g);
      }
      return null;
    }
    w(e, s) {
      const i = this.d.joinPath(e, "tasks.json"),
        n = s ? s.tasksResource : this.d.joinPath(e, os.a);
      return [{ resource: i, comparableResource: n }];
    }
    x(e, s) {
      switch (s) {
        case "tasks.json":
          return Br(e.content, this.g);
      }
      return null;
    }
    async y(e, s) {
      const i = await this.resolveContent(e);
      if (i) {
        const n = this.L(i, "snippets");
        if (n) {
          const r = $u(n),
            o = [];
          for (const a of Object.keys(r)) {
            const c = this.d.joinPath(e, a),
              l = s ? this.d.joinPath(s.snippetsHome, a) : this.d.joinPath(e, os.a);
            o.push({ resource: c, comparableResource: l });
          }
          return o;
        }
      }
      return [];
    }
    z(e, s) {
      return $u(e)[s] || null;
    }
    A(e, s) {
      const i = this.d.joinPath(e, "extensions.json"),
        n = s ? this.J({ remote: !1, syncResource: "extensions", profile: s.id, location: void 0, collection: void 0, ref: void 0, node: void 0 }) : this.d.joinPath(e, os.a);
      return [{ resource: i, comparableResource: n }];
    }
    B(e, s) {
      switch (s) {
        case "extensions.json":
          return au(N7(e), !0);
      }
      return null;
    }
    async C(e) {
      const { localExtensions: s } = await this.n.createInstance(Ma).getLocalExtensions(e);
      return au(s, !0);
    }
    D(e, s) {
      const i = this.d.joinPath(e, "globalState.json"),
        n = s ? this.J({ remote: !1, syncResource: "globalState", profile: s.id, location: void 0, collection: void 0, ref: void 0, node: void 0 }) : this.d.joinPath(e, os.a);
      return [{ resource: i, comparableResource: n }];
    }
    E(e, s) {
      switch (s) {
        case "globalState.json":
          return Wi(JSON.parse(e.content), !0);
      }
      return null;
    }
    async F(e) {
      const s = await this.n.createInstance(_a).getLocalGlobalState(e);
      return Wi(s, !0);
    }
    G(e, s) {
      const i = this.d.joinPath(e, "profiles.json"),
        n = this.J({ remote: !1, syncResource: "profiles", profile: this.k.defaultProfile.id, location: void 0, collection: void 0, ref: void 0, node: void 0 });
      return [{ resource: i, comparableResource: n }];
    }
    H(e, s) {
      switch (s) {
        case "profiles.json":
          return yr(JSON.parse(e.content), {});
      }
      return null;
    }
    async I(e) {
      return Du(
        this.k.profiles.filter((s) => !s.isDefault && !s.isTransient),
        !0,
      );
    }
    J(e) {
      const s = e.remote ? os.b : os.c,
        i = [];
      return (
        e.location && (i.push(`scheme:${e.location.scheme}`), i.push(`authority:${e.location.authority}`), i.push(Cv(e.location.path, "/"))),
        i.push(`syncResource:${e.syncResource}`),
        i.push(`profile:${e.profile}`),
        e.collection && i.push(`collection:${e.collection}`),
        e.ref && i.push(`ref:${e.ref}`),
        e.node && i.push(e.node),
        this.d.joinPath(C.from({ scheme: _, authority: s, path: "/", query: e.location?.query, fragment: e.location?.fragment }), ...i)
      );
    }
    K(e) {
      if (e.scheme !== _) return;
      const s = [];
      for (; e.path !== "/"; ) s.unshift(this.d.basename(e)), (e = this.d.dirname(e));
      if (s.length < 2) return;
      const i = e.authority === os.b;
      let n, r;
      const o = [];
      let a, c, l, h, u;
      for (; s.length; ) {
        const f = s.shift();
        f.startsWith("scheme:")
          ? (n = f.substring(7))
          : f.startsWith("authority:")
            ? (r = f.substring(10))
            : f.startsWith("syncResource:")
              ? (a = f.substring(13))
              : f.startsWith("profile:")
                ? (c = f.substring(8))
                : f.startsWith("collection:")
                  ? (l = f.substring(11))
                  : f.startsWith("ref:")
                    ? (h = f.substring(4))
                    : a
                      ? (u = f)
                      : o.push(f);
      }
      return { remote: i, syncResource: a, profile: c, collection: l, ref: h, node: u, location: n && r !== void 0 ? this.d.joinPath(C.from({ scheme: n, authority: r, query: e.query, fragment: e.fragment, path: "/" }), ...o) : void 0 };
    }
    L(e, s) {
      try {
        const i = JSON.parse(e);
        if (jr(i)) return i;
      } catch (i) {
        this.g.error(i);
      }
      throw new De(w(2766, null), "IncompatibleRemoteContent", s);
    }
    async M(e, s, i) {
      const n = await this.e.resolveResourceContent(e, s, i);
      return { ref: s, content: n };
    }
  };
Yu = os = __decorate([__param(0, St), __param(1, ts), __param(2, Pe), __param(3, ke), __param(4, fe), __param(5, ae), __param(6, ie), __param(7, Te), __param(8, Ce), __param(9, ds)], Yu);
async function Y9(t, e, s, i, n) {
  try {
    const r = await t.getExtensionsControlManifest();
    if (!r.deprecated) return;
    const o = await t.getInstalled(1);
    for (const [a, c] of Object.entries(r.deprecated)) {
      if (!c?.extension) continue;
      const { id: l, autoMigrate: h, preRelease: u } = c.extension;
      if (!h) continue;
      const f = o.find((p) => G(p.identifier, { id: a }));
      if (!f) continue;
      const d = (await e.getExtensions([{ id: l, preRelease: u }], { targetPlatform: await t.getTargetPlatform(), compatible: !0 }, J.None))[0];
      if (!d) {
        n.info(`Skipping migrating '${f.identifier.id}' extension because, the comaptible target '${l}' extension is not found`);
        continue;
      }
      try {
        n.info(`Migrating '${f.identifier.id}' extension to '${l}' extension...`);
        const p = !i.getDisabledExtensions().some((m) => G(m, f.identifier));
        await t.uninstall(f), n.info(`Uninstalled the unsupported extension '${f.identifier.id}'`);
        let g = o.find((m) => G(m.identifier, { id: l }));
        (!g || (!g.isPreReleaseVersion && p)) &&
          ((g = await t.installFromGallery(d, { installPreReleaseVersion: !0, isMachineScoped: f.isMachineScoped, operation: 4 })),
          n.info(`Installed the pre-release extension '${g.identifier.id}'`),
          p || (await i.disableExtension(g.identifier), n.info(`Disabled the pre-release extension '${g.identifier.id}' because the unsupported extension '${f.identifier.id}' is disabled`)),
          h.storage && (s.addToMigrationList(ea(f.manifest.publisher, f.manifest.name), ea(g.manifest.publisher, g.manifest.name)), n.info("Added pre-release extension to the storage migration list"))),
          n.info(`Migrated '${f.identifier.id}' extension to '${l}' extension.`);
      } catch (p) {
        n.error(p);
      }
    }
  } catch (r) {
    n.error(r);
  }
}
var Zu = class extends O {
  constructor(e, s, i, n, r, o) {
    super(), e.cleanUp(), Y9(e, s, i, n, o), Tr.removeOutdatedExtensionVersions(e, r);
  }
};
Zu = __decorate([__param(0, Cg), __param(1, ps), __param(2, _h), __param(3, j1), __param(4, ae), __param(5, ne)], Zu);
var Z9 = class extends O {
    constructor(t, e = []) {
      super(), (this.a = new _4([t, ...e])), this.B(t.onDidChangeLogLevel((s) => this.setLevel(s)));
    }
    get onDidChangeLogLevel() {
      return this.a.onDidChangeLogLevel;
    }
    setLevel(t) {
      this.a.setLevel(t);
    }
    getLevel() {
      return this.a.getLevel();
    }
    trace(t, ...e) {
      this.a.trace(t, ...e);
    }
    debug(t, ...e) {
      this.a.debug(t, ...e);
    }
    info(t, ...e) {
      this.a.info(t, ...e);
    }
    warn(t, ...e) {
      this.a.warn(t, ...e);
    }
    error(t, ...e) {
      this.a.error(t, ...e);
    }
    flush() {
      this.a.flush();
    }
  },
  fm = z("sharedProcessLifecycleService"),
  ef = class extends O {
    constructor(e) {
      super(), (this.b = e), (this.a = this.B(new D())), (this.onWillShutdown = this.a.event);
    }
    fireOnWillShutdown() {
      this.b.trace("Lifecycle#onWillShutdown.fire()"), this.a.fire();
    }
  };
ef = __decorate([__param(0, ne)], ef);
import { spawn as dm } from "child_process";
import { hostname as e8, homedir as t8 } from "os";
import { Transform as s8 } from "stream";
var pm = class extends s8 {
    constructor(t) {
      if ((super(), typeof t == "number")) (this.b = t), (this.c = 1);
      else {
        const e = Buffer.isBuffer(t) ? t : Buffer.from(t);
        (this.b = e.length === 1 ? e[0] : e), (this.c = e.length);
      }
    }
    _transform(t, e, s) {
      this.a ? (this.a = Buffer.concat([this.a, t])) : (this.a = t);
      let i = 0;
      for (; i < this.a.length; ) {
        const n = typeof this.b == "number" ? this.a.indexOf(this.b, i) : s1(this.a, this.b, i);
        if (n === -1) break;
        this.push(this.a.slice(i, n + this.c)), (i = n + this.c);
      }
      (this.a = i === this.a.length ? void 0 : this.a.slice(i)), s();
    }
    _flush(t) {
      this.a && this.push(this.a), t();
    }
  },
  i8 = [lm, hm],
  tf = "remoteTunnelSession",
  sf = "remoteTunnelIsService",
  nf = class extends O {
    constructor(e, s, i, n, r, o, a) {
      super(),
        (this.y = e),
        (this.z = s),
        (this.C = i),
        (this.D = o),
        (this.F = a),
        (this.f = new D()),
        (this.onDidTokenFailed = this.f.event),
        (this.g = new D()),
        (this.onDidChangeTunnelStatus = this.g.event),
        (this.h = new D()),
        (this.onDidChangeMode = this.h.event),
        (this.n = ec),
        (this.w = !1),
        (this.I = (c, l) => {
          l ? this.j.error(c) : this.j.info(c);
        }),
        (this.j = this.B(n.createLogger(M(i.logsHome, `${um}.log`), { id: um, name: Q9 }))),
        (this.t = new Gc(100)),
        this.B(this.j.onDidChangeLogLevel((c) => this.j.info("Log level changed to " + Fo(c)))),
        this.B(
          r.onWillShutdown(() => {
            this.r?.cancel(), (this.r = void 0), this.dispose();
          }),
        ),
        this.B(
          o.onDidChangeConfiguration((c) => {
            i8.some((l) => c.affectsConfiguration(l)) && this.t.trigger(() => this.L());
          }),
        ),
        (this.n = this.R()),
        (this.s = Pt.uninitialized);
    }
    async getTunnelStatus() {
      return this.s;
    }
    G(e) {
      (this.s = e), this.g.fire(e);
    }
    H(e) {
      gm(this.n, e) ||
        ((this.n = e),
        this.S(e),
        this.h.fire(this.n),
        e.active
          ? (this.j.info(`Session updated: ${e.session.accountLabel} (${e.session.providerId}) (service=${e.asService})`), e.session.token && this.j.info(`Session token updated: ${e.session.accountLabel} (${e.session.providerId})`))
          : this.j.info("Session reset"));
    }
    getMode() {
      return Promise.resolve(this.n);
    }
    async initialize(e) {
      if (this.w) return this.s;
      (this.w = !0), this.H(e);
      try {
        await this.t.trigger(() => this.L());
      } catch (s) {
        this.j.error(s);
      }
      return this.s;
    }
    J() {
      if (!this.u) {
        let e;
        Ss ? (e = this.C.appRoot) : (e = Yt(Yt(this.C.appRoot))), (this.u = V(e, "bin", `${this.z.tunnelApplicationName}${Be ? ".exe" : ""}`));
      }
      return this.u;
    }
    async startTunnel(e) {
      if (gm(this.n, e) && this.s.type !== "disconnected") return this.s;
      this.H(e);
      try {
        await this.t.trigger(() => this.L());
      } catch (s) {
        this.j.error(s);
      }
      return this.s;
    }
    async stopTunnel() {
      if ((this.r && (this.r.cancel(), (this.r = void 0)), this.n.active)) {
        const e = this.n.asService;
        this.H(ec);
        try {
          e && this.O("uninstallService", ["service", "uninstall"]);
        } catch (s) {
          this.j.error(s);
        }
      }
      try {
        await this.O("stop", ["kill"]);
      } catch (e) {
        this.j.error(e);
      }
      this.G(Pt.disconnected());
    }
    async L() {
      this.y.publicLog2("remoteTunnel.enablement", { enabled: this.n.active, service: this.n.active && this.n.asService }), this.r && (this.r.cancel(), (this.r = void 0));
      let e = "",
        s = !1;
      const i = (l, h) => {
          h ? this.j.error(l) : (e += l), !this.C.isBuilt && l.startsWith("   Compiling") && this.G(Pt.connecting(w(2113, null)));
        },
        n = this.O("status", ["status"], i);
      this.r = n;
      try {
        if ((await n, this.r !== n)) return;
        let l;
        try {
          l = JSON.parse(
            e
              .trim()
              .split(
                `
`,
              )
              .find((h) => h.startsWith("{")),
          );
        } catch {
          this.j.error(`Could not parse status output: ${JSON.stringify(e.trim())}`), this.G(Pt.disconnected());
          return;
        }
        if (((s = l.service_installed), this.j.info(l.tunnel ? "Other tunnel running, attaching..." : "No other tunnel running"), !l.tunnel && !this.n.active)) {
          this.G(Pt.disconnected());
          return;
        }
      } catch (l) {
        this.j.error(l), this.G(Pt.disconnected());
        return;
      } finally {
        this.r === n && (this.r = void 0);
      }
      const r = this.n.active ? this.n.session : void 0;
      if (r && r.token) {
        const l = r.token;
        this.G(Pt.connecting(w(2114, null, r.accountLabel, r.providerId)));
        const h = (f, d) => {
            (f = f.replaceAll(l, "*".repeat(4))), i(f, d);
          },
          u = this.O("login", ["user", "login", "--provider", r.providerId, "--log", Fo(this.j.getLevel())], h, { VSCODE_CLI_ACCESS_TOKEN: l });
        this.r = u;
        try {
          if ((await u, this.r !== u)) return;
        } catch (f) {
          this.j.error(f), (this.r = void 0), this.f.fire(r), this.G(Pt.disconnected(r));
          return;
        }
      }
      const o = this.Q();
      o ? this.G(Pt.connecting(w(2115, null, o))) : this.G(Pt.connecting(w(2116, null)));
      const a = ["--accept-server-license-terms", "--log", Fo(this.j.getLevel())];
      o ? a.push("--name", o) : a.push("--random-name");
      let c = !1;
      return this.n.active && this.n.asService && !s && (c = (await this.M(a)) === !1), this.N(r, a, c);
    }
    async M(e) {
      let s;
      try {
        s = await this.O("serviceInstall", ["service", "install", ...e]);
      } catch (i) {
        this.j.error(i), (s = 1);
      }
      if (s !== 0) {
        const i = w(2117, null);
        return this.j.warn(i), this.G(Pt.connecting(i)), !1;
      }
      return !0;
    }
    async N(e, s, i) {
      s.push("--parent-process-id", String(process.pid)), this.P() && s.push("--no-sleep");
      let n = !1;
      const r = this.O("tunnel", s, (o, a) => {
        a ? this.j.error(o) : this.j.info(o), o.includes("Connected to an existing tunnel process") && (n = !0);
        const c = o.match(/Open this link in your browser (https:\/\/([^\/\s]+)\/([^\/\s]+)\/([^\/\s]+))/);
        if (c) {
          const l = { link: c[1], domain: c[2], tunnelName: c[4], isAttached: n };
          this.G(Pt.connected(l, i));
        } else o.match(/error refreshing token/) && (r.cancel(), this.f.fire(e), this.G(Pt.disconnected(e)));
      });
      (this.r = r),
        r.finally(() => {
          r === this.r && (this.j.info("tunnel process terminated"), (this.r = void 0), (this.n = ec), this.G(Pt.disconnected()));
        });
    }
    O(e, s, i = this.I, n) {
      return wt(
        (r) =>
          new Promise((o, a) => {
            r.isCancellationRequested && o(-1);
            let c;
            const l = ["ignore", "pipe", "pipe"];
            if (
              (r.onCancellationRequested(() => {
                c && (this.j.info(`${e} terminating(${c.pid})`), c.kill());
              }),
              !this.C.isBuilt)
            )
              i(
                `Building tunnel CLI from sources and run
`,
                !1,
              ),
                i(
                  `${e} Spawning: cargo run -- tunnel ${s.join(" ")}
`,
                  !1,
                ),
                (c = dm("cargo", ["run", "--", "tunnel", ...s], { cwd: V(this.C.appRoot, "cli"), stdio: l, env: { ...process.env, RUST_BACKTRACE: "1", ...n } }));
            else {
              i(
                `Running tunnel CLI
`,
                !1,
              );
              const h = this.J();
              i(
                `${e} Spawning: ${h} tunnel ${s.join(" ")}
`,
                !1,
              ),
                (c = dm(h, ["tunnel", ...s], { cwd: t8(), stdio: l, env: { ...process.env, ...n } }));
            }
            c.stdout
              .pipe(
                new pm(`
`),
              )
              .on("data", (h) => {
                if (c) {
                  const u = h.toString();
                  i(u, !1);
                }
              }),
              c.stderr
                .pipe(
                  new pm(`
`),
                )
                .on("data", (h) => {
                  if (c) {
                    const u = h.toString();
                    i(u, !0);
                  }
                }),
              c.on("exit", (h) => {
                c && (i(`${e} exit(${c.pid}): + ${h} `, !1), (c = void 0), o(h || 0));
              }),
              c.on("error", (h) => {
                c && (i(`${e} error(${c.pid}): + ${h} `, !0), (c = void 0), a());
              });
          }),
      );
    }
    async getTunnelName() {
      return this.Q();
    }
    P() {
      return !!this.D.getValue(hm);
    }
    Q() {
      let e = this.D.getValue(lm) || e8();
      return (
        (e = e
          .replace(/^-+/g, "")
          .replace(/[^\w-]/g, "")
          .substring(0, 20)),
        e || void 0
      );
    }
    R() {
      try {
        const e = this.F.get(tf, -1),
          s = this.F.getBoolean(sf, -1, !1);
        if (e) {
          const i = JSON.parse(e);
          if (i && _e(i.accountLabel) && _e(i.sessionId) && _e(i.providerId)) return { active: !0, session: i, asService: s };
          this.j.error("Problems restoring session from storage, invalid format", i);
        }
      } catch (e) {
        this.j.error("Problems restoring session from storage", e);
      }
      return ec;
    }
    S(e) {
      if (e.active) {
        const s = { providerId: e.session.providerId, sessionId: e.session.sessionId, accountLabel: e.session.accountLabel };
        this.F.store(tf, JSON.stringify(s), -1, 1), this.F.store(sf, e.asService, -1, 1);
      } else this.F.remove(tf, -1), this.F.remove(sf, -1);
    }
  };
nf = __decorate([__param(0, Se), __param(1, Ee), __param(2, Zt), __param(3, $n), __param(4, fm), __param(5, Ce), __param(6, ae)], nf);
function n8(t, e) {
  return t && e ? t.sessionId === e.sessionId && t.providerId === e.providerId && t.token === e.token : t === e;
}
var gm = (t, e) => (t.active !== e.active ? !1 : t.active && e.active ? t.asService === e.asService && n8(t.session, e.session) : !0),
  rf = class extends gh {
    constructor(e, s, i, n, r, o) {
      super(C.file(e.extensionsPath), s, i, n, r, o);
    }
  };
rf = __decorate([__param(0, Zt), __param(1, ie), __param(2, Te), __param(3, ke), __param(4, Se), __param(5, ne)], rf);
var r8 = class {
    constructor(t) {
      this.a = t;
    }
    get ignoredRecommendations() {
      throw new Error("not supported");
    }
    promptImportantExtensionsInstallNotification(t) {
      return this.a.call("promptImportantExtensionsInstallNotification", [t]);
    }
    promptWorkspaceRecommendations(t) {
      throw new Error("not supported");
    }
    hasToIgnoreRecommendationNotifications() {
      throw new Error("not supported");
    }
  },
  of = class {
    constructor(e, s) {
      return (
        (this.windowId = e),
        It.toService(s.getChannel("nativeHost"), {
          context: e,
          properties: (() => {
            const i = new Map();
            return i.set("windowId", e), i;
          })(),
        })
      );
    }
  };
of = __decorate([__param(1, gr)], of);
var af = "sync.disableMachineEventually",
  cf = "sync.sessionId",
  lf = "sync.storeUrl",
  hf = "sync.productQuality",
  uf = class extends O {
    get n() {
      const e = this.H.get(lf, -1);
      return e ? C.parse(e) : void 0;
    }
    set n(e) {
      e ? this.H.store(lf, e.toString(), -1, 1) : this.H.remove(lf, -1);
    }
    get s() {
      return this.H.get(hf, -1);
    }
    set s(e) {
      e ? this.H.store(hf, e, -1, 1) : this.H.remove(hf, -1);
    }
    constructor(e, s, i, n, r, o, a, c, l, h) {
      super(),
        (this.u = s),
        (this.w = i),
        (this.y = n),
        (this.z = r),
        (this.C = o),
        (this.D = a),
        (this.F = c),
        (this.G = l),
        (this.H = h),
        (this.a = this.B(new Es())),
        (this.b = 0),
        (this.c = void 0),
        (this.g = !1),
        (this.h = this.B(new D())),
        (this.onError = this.h.event),
        (this.S = []),
        (this.f = this.B(new Ri(this.U()))),
        (this.j = this.n),
        (this.n = s.userDataSyncStore?.url),
        (this.r = this.s),
        (this.s = e.quality),
        this.n &&
          (this.C.info("Using settings sync service", this.n.toString()),
          this.B(
            s.onDidChangeUserDataSyncStore(() => {
              zs(this.n, s.userDataSyncStore?.url) || ((this.j = this.n), (this.n = s.userDataSyncStore?.url), this.n && this.C.info("Using settings sync service", this.n.toString()));
            }),
          ),
          this.y.isEnabled() ? this.C.info("Auto Sync is enabled.") : this.C.info("Auto Sync is disabled."),
          this.I(),
          this.Q() && this.P(),
          this.B(a.onDidChangeAccount(() => this.I())),
          this.B(i.onDidChangeDonotMakeRequestsUntil(() => this.I())),
          this.B(r.onDidChangeLocal((u) => this.triggerSync([u], !1, !1))),
          this.B(T.filter(this.y.onDidChangeResourceEnablement, ([, u]) => u)(() => this.triggerSync(["resourceEnablement"], !1, !1))),
          this.B(this.u.onDidChangeUserDataSyncStore(() => this.triggerSync(["userDataSyncStoreChanged"], !1, !1))));
    }
    I() {
      const { enabled: e, message: s } = this.L();
      e
        ? this.a.value === void 0 &&
          ((this.a.value = new o8(this.j, 1e3 * 60 * 5, this.u, this.w, this.z, this.G, this.C, this.F, this.H)),
          this.a.value.register(this.a.value.onDidStartSync(() => (this.c = new Date().getTime()))),
          this.a.value.register(this.a.value.onDidFinishSync((i) => this.O(i))),
          this.J() && this.a.value.start())
        : (this.f.cancel(), this.a.value !== void 0 ? (s && this.C.info(s), this.a.clear()) : s && this.y.isEnabled() && this.C.info(s));
    }
    J() {
      return !0;
    }
    L() {
      return this.y.isEnabled()
        ? this.D.account
          ? this.w.donotMakeRequestsUntil
            ? { enabled: !1, message: `Auto Sync: Suspended until ${Da(this.w.donotMakeRequestsUntil)} because server is not accepting requests until then.` }
            : this.g
              ? { enabled: !1, message: "Auto Sync: Suspended until restart." }
              : { enabled: !0 }
          : { enabled: !1, message: "Auto Sync: Suspended until auth token is available." }
        : { enabled: !1, message: "Auto Sync: Disabled." };
    }
    async turnOn() {
      this.R(), (this.j = this.n), this.M(!0);
    }
    async turnOff(e, s, i) {
      try {
        this.D.account && !i && (await this.G.removeCurrentMachine()), this.M(!1), this.H.remove(cf, -1), e ? (this.F.publicLog2("sync/turnOffEveryWhere"), await this.z.reset()) : await this.z.resetLocal();
      } catch (n) {
        if ((this.C.error(n), s)) this.M(!1);
        else throw n;
      }
    }
    M(e) {
      this.y.isEnabled() !== e && (this.y.setEnablement(e), this.I());
    }
    N() {
      return !!this.r && !!this.s && this.r !== this.s;
    }
    async O(e) {
      if (!e) {
        this.b = 0;
        return;
      }
      const s = De.toUserDataSyncError(e);
      s instanceof Xs && this.F.publicLog2("autosync/error", { code: s.code, service: this.u.userDataSyncStore.url.toString() }),
        s.code === "SessionExpired"
          ? (await this.turnOff(!1, !0), this.C.info("Auto Sync: Turned off sync because current session is expired"))
          : s.code === "TurnedOff"
            ? (await this.turnOff(!1, !0), this.C.info("Auto Sync: Turned off sync because sync is turned off in the cloud"))
            : s.code === "LocalTooManyRequests"
              ? ((this.g = !0), this.C.info("Auto Sync: Suspended sync because of making too many requests to server"), this.I())
              : s.code === "RemoteTooManyRequests"
                ? (await this.turnOff(!1, !0, !0), this.P(), this.C.info("Auto Sync: Turned off sync because of making too many requests to server"))
                : s.code === "MethodNotFound"
                  ? (await this.turnOff(!1, !0), this.C.info("Auto Sync: Turned off sync because current client is making requests to server that are not supported"))
                  : s.code === "UpgradeRequired" || s.code === "Gone"
                    ? (await this.turnOff(!1, !0, !0), this.P(), this.C.info("Auto Sync: Turned off sync because current client is not compatible with server. Requires client upgrade."))
                    : s.code === "IncompatibleLocalContent"
                      ? (await this.turnOff(!1, !0), this.C.info(`Auto Sync: Turned off sync because server has ${s.resource} content with newer version than of client. Requires client upgrade.`))
                      : s.code === "IncompatibleRemoteContent"
                        ? (await this.turnOff(!1, !0), this.C.info(`Auto Sync: Turned off sync because server has ${s.resource} content with older version than of client. Requires server reset.`))
                        : s.code === "ServiceChanged" || s.code === "DefaultServiceChanged"
                          ? Qe && s.code === "DefaultServiceChanged" && !this.N()
                            ? (await this.turnOff(!1, !0), this.C.info("Auto Sync: Turned off sync because default sync service is changed."))
                            : (await this.turnOff(!1, !0, !0), await this.turnOn(), this.C.info("Auto Sync: Sync Service changed. Turned off auto sync, reset local state and turned on auto sync."))
                          : (this.C.error(s), this.b++),
        this.h.fire(s);
    }
    async P() {
      this.H.store(af, !0, -1, 1), await Pi(1e3 * 60 * 10), this.Q() && (this.R(), !this.y.isEnabled() && this.D.account && (await this.G.removeCurrentMachine()));
    }
    Q() {
      return this.H.getBoolean(af, -1, !1);
    }
    R() {
      this.H.remove(af, -1);
    }
    async triggerSync(e, s, i) {
      if (this.a.value === void 0) return this.f.cancel();
      if (s && this.c && Math.round((new Date().getTime() - this.c) / 1e3) < 10) {
        this.C.debug("Auto Sync: Skipped. Limited to once per 10 seconds.");
        return;
      }
      return (
        this.S.push(...e),
        this.f.trigger(
          async () => {
            this.C.trace("activity sources", ...this.S);
            const n = this.D.account?.authenticationProviderId || "";
            this.F.publicLog2("sync/triggered", { sources: this.S, providerId: n }), (this.S = []), this.a.value && (await this.a.value.sync("Activity", i));
          },
          this.b ? this.U() * 1 * Math.min(Math.pow(2, this.b), 60) : this.U(),
        )
      );
    }
    U() {
      return 2e3;
    }
  };
uf = __decorate([__param(0, Ee), __param(1, hi), __param(2, St), __param(3, jt), __param(4, xa), __param(5, Pe), __param(6, ka), __param(7, Se), __param(8, Pa), __param(9, ae)], uf);
var o8 = class Nf extends O {
    static {
      this.a = "Interval";
    }
    constructor(e, s, i, n, r, o, a, c, l) {
      super(),
        (this.m = e),
        (this.n = s),
        (this.r = i),
        (this.s = n),
        (this.u = r),
        (this.w = o),
        (this.y = a),
        (this.z = c),
        (this.C = l),
        (this.b = this.B(new Es())),
        (this.c = this.B(new D())),
        (this.onDidStartSync = this.c.event),
        (this.f = this.B(new D())),
        (this.onDidFinishSync = this.f.event),
        (this.g = null);
    }
    start() {
      this.B(this.onDidFinishSync(() => this.D())),
        this.B(
          ue(() => {
            this.j && (this.j.cancel(), this.y.info("Auto sync: Cancelled sync that is in progress"), (this.j = void 0)), this.h?.stop(), this.y.info("Auto Sync: Stopped");
          }),
        ),
        this.sync(Nf.a, !1);
    }
    D() {
      this.b.value = gn(() => {
        this.sync(Nf.a, !1), (this.b.value = void 0);
      }, this.n);
    }
    sync(e, s) {
      const i = wt(async (n) => {
        if (this.j)
          try {
            this.y.debug("Auto Sync: Waiting until sync is finished."), await this.j;
          } catch (r) {
            if (Fs(r)) return;
          }
        return this.H(e, s, n);
      });
      return (this.j = i), this.j.finally(() => (this.j = void 0)), this.j;
    }
    F() {
      return this.m !== void 0 && !zs(this.m, this.r.userDataSyncStore?.url);
    }
    async G() {
      const e = await this.r.getPreviousUserDataSyncStore(),
        s = this.r.userDataSyncStore;
      return !!s && !!e && (!zs(s.defaultUrl, e.defaultUrl) || !zs(s.insidersUrl, e.insidersUrl) || !zs(s.stableUrl, e.stableUrl));
    }
    async H(e, s, i) {
      this.y.info(`Auto Sync: Triggered by ${e}`), this.c.fire();
      let n;
      try {
        await this.I(s, i);
      } catch (r) {
        if ((this.y.error(r), (n = r), De.toUserDataSyncError(r).code === "MethodNotFound"))
          try {
            this.y.info("Auto Sync: Client is making invalid requests. Cleaning up data..."), await this.u.cleanUpRemoteData(), this.y.info("Auto Sync: Retrying sync..."), await this.I(s, i), (n = void 0);
          } catch (o) {
            this.y.error(o), (n = o);
          }
      }
      this.f.fire(n);
    }
    async I(e, s) {
      if (((this.h = await this.u.createSyncTask(this.g, e)), s.isCancellationRequested)) return;
      if (((this.g = this.h.manifest), this.g === null && (await this.u.hasPreviouslySynced())))
        throw this.F() ? ((await this.G()) ? new Xs(w(2752, null), "DefaultServiceChanged") : new Xs(w(2753, null), "ServiceChanged")) : new Xs(w(2754, null), "TurnedOff");
      const i = this.C.get(cf, -1);
      if (i && this.g && i !== this.g.session) throw this.F() ? ((await this.G()) ? new Xs(w(2755, null), "DefaultServiceChanged") : new Xs(w(2756, null), "ServiceChanged")) : new Xs(w(2757, null), "SessionExpired");
      const n = await this.w.getMachines(this.g || void 0);
      if (s.isCancellationRequested) return;
      const r = n.find((a) => a.isCurrent);
      if (r?.disabled) throw new Xs(w(2758, null), "TurnedOff");
      const o = new Date().getTime();
      if ((await this.h.run(), this.z.publicLog2("settingsSync:sync", { duration: new Date().getTime() - o }), this.g === null))
        try {
          this.g = await this.s.manifest(null);
        } catch (a) {
          throw new Xs(Xe(a), a instanceof De ? a.code : "Unknown");
        }
      this.g && this.g.session !== i && this.C.store(cf, this.g.session, -1, 1), !s.isCancellationRequested && (r || (await this.w.addCurrentMachine(this.g || void 0)));
    }
    register(e) {
      return super.B(e);
    }
  },
  ff = class extends uf {
    constructor(e, s, i, n, r, o, a, c, l, h, u) {
      super(e, s, i, n, r, a, c, l, h, u),
        this.B(
          T.debounce(
            T.any(
              T.map(o.onDidFocusMainWindow, () => "windowFocus"),
              T.map(o.onDidOpenMainWindow, () => "windowOpen"),
            ),
            (f, d) => (f ? [...f, d] : [d]),
            1e3,
          )((f) => this.triggerSync(f, !0, !1)),
        );
    }
  };
ff = __decorate([__param(0, Ee), __param(1, hi), __param(2, St), __param(3, jt), __param(4, xa), __param(5, _o), __param(6, Pe), __param(7, ka), __param(8, Se), __param(9, Pa), __param(10, ae)], ff);
var df = class extends O {
  constructor(e, s) {
    super(), (this.b = e), (this.c = s), (this.a = new Map()), this.c.configBasedExtensionTips && Object.entries(this.c.configBasedExtensionTips).forEach(([, i]) => this.a.set(i.configPath, i));
  }
  getConfigBasedTips(e) {
    return this.f(e);
  }
  async getImportantExecutableBasedTips() {
    return [];
  }
  async getOtherExecutableBasedTips() {
    return [];
  }
  async f(e) {
    const s = [];
    for (const [i, n] of this.a)
      if (!(n.configScheme && n.configScheme !== e.scheme))
        try {
          const r = (await this.b.readFile(M(e, i))).value.toString();
          for (const [o, a] of Object.entries(n.recommendations))
            (!a.contentPattern || new RegExp(a.contentPattern, "mig").test(r)) &&
              s.push({ extensionId: o, extensionName: a.name, configName: n.configName, important: !!a.important, isExtensionPack: !!a.isExtensionPack, whenNotInstalled: a.whenNotInstalled });
        } catch {}
    return s;
  }
};
df = __decorate([__param(0, ie), __param(1, Ee)], df);
var mm = "extensionTips/promptedExecutableTips",
  wm = "extensionTips/lastPromptedMediumImpExeTime",
  a8 = class extends df {
    constructor(t, e, s, i, n, r, o, a) {
      super(o, a),
        (this.r = t),
        (this.s = e),
        (this.t = s),
        (this.u = i),
        (this.w = n),
        (this.z = r),
        (this.g = new Map()),
        (this.h = new Map()),
        (this.j = new Map()),
        (this.m = new Map()),
        (this.n = new Map()),
        a.exeBasedExtensionTips &&
          Object.entries(a.exeBasedExtensionTips).forEach(([c, l]) => {
            const h = [],
              u = [],
              f = [];
            Object.entries(l.recommendations).forEach(([d, p]) => {
              p.important
                ? l.important
                  ? h.push({ extensionId: d, extensionName: p.name, isExtensionPack: !!p.isExtensionPack })
                  : u.push({ extensionId: d, extensionName: p.name, isExtensionPack: !!p.isExtensionPack })
                : f.push({ extensionId: d, extensionName: p.name, isExtensionPack: !!p.isExtensionPack });
            }),
              h.length && this.g.set(c, { exeFriendlyName: l.friendlyName, windowsPath: l.windowsPath, recommendations: h }),
              u.length && this.h.set(c, { exeFriendlyName: l.friendlyName, windowsPath: l.windowsPath, recommendations: u }),
              f.length && this.j.set(c, { exeFriendlyName: l.friendlyName, windowsPath: l.windowsPath, recommendations: f });
          }),
        gn(
          async () => {
            await this.C(), this.F(), this.G();
          },
          3e3,
          this.q,
        );
    }
    async getImportantExecutableBasedTips() {
      const t = await this.O(this.g),
        e = await this.O(this.h);
      return [...t, ...e];
    }
    getOtherExecutableBasedTips() {
      return this.O(this.j);
    }
    async C() {
      const t = await this.O(this.g),
        e = await this.O(this.h),
        s = await this.u.getInstalled();
      (this.m = this.D(t, s)), (this.n = this.D(e, s));
    }
    D(t, e) {
      const s = new Map();
      t.forEach((a) => s.set(a.extensionId.toLowerCase(), a));
      const { installed: i, uninstalled: n } = this.N([...s.keys()], e);
      for (const a of i) {
        const c = s.get(a);
        c && this.t.publicLog2("exeExtensionRecommendations:alreadyInstalled", { extensionId: a, exeName: c.exeName });
      }
      for (const a of n) {
        const c = s.get(a);
        c && this.t.publicLog2("exeExtensionRecommendations:notInstalled", { extensionId: a, exeName: c.exeName });
      }
      const r = this.L(),
        o = new Map();
      for (const a of n) {
        const c = s.get(a);
        if (c && (!r[c.exeName] || !r[c.exeName].includes(c.extensionId))) {
          let l = o.get(c.exeName);
          l || ((l = []), o.set(c.exeName, l)), l.push(c);
        }
      }
      return o;
    }
    F() {
      if (this.m.size === 0) return;
      const [t, e] = [...this.m.entries()][0];
      this.H(e).then((s) => {
        switch (s) {
          case "reacted":
            this.M(e[0].exeName, e);
            break;
          case "ignored":
            this.m.delete(t);
            break;
          case "incompatibleWindow": {
            const i = T.once(T.latch(T.any(this.s.onDidOpenMainWindow, this.s.onDidFocusMainWindow)));
            this.B(i(() => this.F()));
            break;
          }
          case "toomany": {
            const i = this.B(new Es());
            i.value = gn(
              () => {
                i.dispose(), this.F();
              },
              60 * 60 * 1e3,
            );
            break;
          }
        }
      });
    }
    G() {
      if (this.n.size === 0) return;
      const t = this.I(),
        e = Date.now() - t,
        s = 7 * 24 * 60 * 60 * 1e3;
      if (e < s) {
        const r = this.B(new Es());
        r.value = gn(() => {
          r.dispose(), this.G();
        }, s - e);
        return;
      }
      const [i, n] = [...this.n.entries()][0];
      this.H(n).then((r) => {
        switch (r) {
          case "reacted": {
            this.J(Date.now()), this.n.delete(i), this.M(n[0].exeName, n);
            const o = this.B(new Es());
            o.value = gn(() => {
              o.dispose(), this.G();
            }, s);
            break;
          }
          case "ignored":
            this.n.delete(i), this.G();
            break;
          case "incompatibleWindow": {
            const o = T.once(T.latch(T.any(this.s.onDidOpenMainWindow, this.s.onDidFocusMainWindow)));
            this.B(o(() => this.G()));
            break;
          }
          case "toomany": {
            const o = this.B(new Es());
            o.value = gn(
              () => {
                o.dispose(), this.G();
              },
              60 * 60 * 1e3,
            );
            break;
          }
        }
      });
    }
    async H(t) {
      const e = await this.u.getInstalled(1),
        s = t.filter((i) => !i.whenNotInstalled || i.whenNotInstalled.every((n) => e.every((r) => !G(r.identifier, { id: n })))).map(({ extensionId: i }) => i.toLowerCase());
      return this.z.promptImportantExtensionsInstallNotification({ extensions: s, source: 3, name: t[0].exeFriendlyName, searchValue: `@exe:"${t[0].exeName}"` });
    }
    I() {
      let t = this.w.getNumber(wm, -1);
      return t || ((t = Date.now()), this.J(t)), t;
    }
    J(t) {
      this.w.store(wm, t, -1, 1);
    }
    L() {
      return JSON.parse(this.w.get(mm, -1, "{}"));
    }
    M(t, e) {
      const s = this.L();
      (s[t] = e.map(({ extensionId: i }) => i.toLowerCase())), this.w.store(mm, JSON.stringify(s), -1, 0);
    }
    N(t, e) {
      const s = [],
        i = [],
        n = e.reduce((r, o) => (r.add(o.identifier.id.toLowerCase()), r), new Set());
      return (
        t.forEach((r) => {
          n.has(r.toLowerCase()) ? s.push(r) : i.push(r);
        }),
        { installed: s, uninstalled: i }
      );
    }
    async O(t) {
      const e = [],
        s = new Map();
      for (const i of t.keys()) {
        const n = t.get(i);
        if (!n || !Xn(n.recommendations)) continue;
        const r = [];
        Be
          ? n.windowsPath &&
            r.push(
              n.windowsPath
                .replace("%USERPROFILE%", () => Y.USERPROFILE)
                .replace("%ProgramFiles(x86)%", () => Y["ProgramFiles(x86)"])
                .replace("%ProgramFiles%", () => Y.ProgramFiles)
                .replace("%APPDATA%", () => Y.APPDATA)
                .replace("%WINDIR%", () => Y.WINDIR),
            )
          : (r.push(V("/usr/local/bin", i)), r.push(V("/usr/bin", i)), r.push(V(this.r.fsPath, i)));
        for (const o of r) {
          let a = s.get(o);
          if ((a === void 0 && ((a = await this.b.exists(C.file(o))), s.set(o, a)), a))
            for (const { extensionId: c, extensionName: l, isExtensionPack: h, whenNotInstalled: u } of n.recommendations)
              e.push({ extensionId: c, extensionName: l, isExtensionPack: h, exeName: i, exeFriendlyName: n.exeFriendlyName, windowsPath: n.windowsPath, whenNotInstalled: u });
        }
      }
      return e;
    }
  },
  pf = class extends a8 {
    constructor(e, s, i, n, r, o, a, c) {
      super(e.userHome, r, s, i, n, o, a, c);
    }
  };
pf = __decorate([__param(0, Zt), __param(1, Se), __param(2, Vs), __param(3, ae), __param(4, _o), __param(5, Rg), __param(6, ie), __param(7, Ee)], pf);
var c8 = class extends eg {
  constructor(t, e, s, i) {
    super(),
      (this.db = t),
      (this.eb = e),
      (this.fb = s),
      (this.gb = i),
      (this.s = this.eb.defaultProfile),
      (this.X = this.hb()),
      (this.Y = this.eb.currentProfile),
      (this.Z = this.B(new ye())),
      (this.$ = this.ib(this.Y)),
      (this.ab = this.db?.id),
      (this.bb = this.B(new ye())),
      (this.cb = this.jb(this.db));
  }
  hb() {
    const t = this.B(new _1(this.fb.getChannel("storage"))),
      e = this.B(new ta(t));
    return this.B(e.onDidChangeStorage((s) => this.u(-1, s))), e;
  }
  ib(t) {
    this.Z.clear(), (this.Y = t);
    let e;
    if (na(t)) e = this.X;
    else {
      const s = this.Z.add(new B1(this.fb.getChannel("storage"), t));
      e = this.Z.add(new ta(s));
    }
    return this.Z.add(e.onDidChangeStorage((s) => this.u(0, s))), e;
  }
  jb(t) {
    this.bb.clear(), (this.ab = t?.id);
    let e;
    if (t) {
      const s = this.bb.add(new Y4(this.fb.getChannel("storage"), t));
      (e = this.bb.add(new ta(s))), this.bb.add(e.onDidChangeStorage((i) => this.u(1, i)));
    }
    return e;
  }
  async Q() {
    await Ze.settled([this.X.init(), this.$.init(), this.cb?.init() ?? Promise.resolve()]);
  }
  R(t) {
    switch (t) {
      case -1:
        return this.X;
      case 0:
        return this.$;
      case 2:
        return this.$;
      default:
        return this.cb;
    }
  }
  S(t) {
    switch (t) {
      case -1:
        return this.s.globalStorageHome.with({ scheme: oe.file }).fsPath;
      case 0:
        return this.Y?.globalStorageHome.with({ scheme: oe.file }).fsPath;
      default:
        return this.ab ? `${M(this.gb.workspaceStorageHome, this.ab, "state.vscdb").with({ scheme: oe.file }).fsPath}` : void 0;
    }
  }
  async close() {
    this.t(), this.w(Bi.SHUTDOWN), await Ze.settled([this.X.close(), this.$.close(), this.cb?.close() ?? Promise.resolve()]);
  }
  async U(t) {
    if (!this.O(this.Y, t)) return;
    const e = this.$,
      s = e.items;
    e !== this.X && (await e.close()), (this.$ = this.ib(t)), await this.$.init(), this.P(s, this.$, 0);
  }
  async W(t, e) {
    const s = this.cb,
      i = s?.items ?? new Map();
    await s?.close(), (this.cb = this.jb(t)), await this.cb.init(), this.P(i, this.cb, 1);
  }
  hasScope(t) {
    return Xp(t) ? this.Y.id === t.id : this.ab === t.id;
  }
};
import * as l8 from "net";
var h8 = (t, e, s) => {
    const i = new Uint8Array(16);
    for (let o = 0; o < 16; o++) i[o] = Math.round(Math.random() * 256);
    const n = By(L.wrap(i));
    return (
      [`GET ws://localhost${t}?${e}&skipWebSocketFrames=true HTTP/1.1`, "Connection: Upgrade", "Upgrade: websocket", `Sec-WebSocket-Key: ${n}`].join(`\r
`) +
      `\r
\r
`
    );
  },
  w$ = L.fromString(`\r
\r
`),
  u8 = new (class {
    supports(t) {
      return !0;
    }
    connect({ host: t, port: e }, s, i, n) {
      return new Promise((r, o) => {
        const a = l8.createConnection({ host: t, port: e }, () => {
          a.removeListener("error", o), a.write(h8(s, i, n));
          const c = (l) => {
            l.toString().indexOf(`\r
\r
`) >= 0 && (a.off("data", c), r(new ju(a, n)));
          };
          a.on("data", c);
        });
        a.setNoDelay(!0), a.once("error", o);
      });
    }
  })();
import { homedir as f8, tmpdir as d8 } from "os";
var vm = /^([^.]+\..+)[:=](.+)$/,
  we = class {
    get enableMultiContainer() {
      return Y.ICUBE_MULTI_CONTAINER?.toLowerCase() === "true";
    }
    get enableExtMultiContainer() {
      return Y.ICUBE_EXT_MULTI_CONTAINER?.toLowerCase() !== "false";
    }
    get safeExtensionIds() {
      const t = this.c.safeExtensionIds ?? [],
        e = Y.ICUBE_SAFE_EXTENSIONS?.split(",") ?? [];
      return [...new Set([...t, ...e])];
    }
    get appRoot() {
      return Yt(Cs.asFileUri("").fsPath);
    }
    get userHome() {
      return C.file(this.b.homeDir);
    }
    get userDataPath() {
      return this.b.userDataDir;
    }
    get appSettingsHome() {
      return C.file(V(this.userDataPath, "User"));
    }
    get tmpDir() {
      return C.file(this.b.tmpDir);
    }
    get cacheHome() {
      return C.file(this.userDataPath);
    }
    get stateResource() {
      return M(this.appSettingsHome, "globalStorage", "storage.json");
    }
    get userRoamingDataHome() {
      return this.appSettingsHome.with({ scheme: oe.vscodeUserData });
    }
    get userDataSyncHome() {
      return M(this.appSettingsHome, "sync");
    }
    get logsHome() {
      if (!this.args.logsPath) {
        const t = Da(new Date()).replace(/-|:|\.\d+Z$/g, "");
        this.args.logsPath = V(this.userDataPath, "logs", t);
      }
      return C.file(this.args.logsPath);
    }
    get extensionHostLogsHome() {
      if (!this.args.extHostLogsPath) {
        const t = Y.ICUBE_CUSTOM_EXTENSION_HOST_LOGS_HOME;
        if (t) {
          const e = Da(new Date()).replace(/-|:|\.\d+Z$/g, "");
          this.args.extHostLogsPath = V(t, "logs", e);
        }
      }
      return this.args.extHostLogsPath ? C.file(this.args.extHostLogsPath) : void 0;
    }
    get sync() {
      return this.args.sync;
    }
    get machineSettingsResource() {
      return M(C.file(V(this.userDataPath, "Machine")), "settings.json");
    }
    get workspaceStorageHome() {
      return M(this.appSettingsHome, "workspaceStorage");
    }
    get localHistoryHome() {
      return M(this.appSettingsHome, "History");
    }
    get keyboardLayoutResource() {
      return M(this.userRoamingDataHome, "keyboardLayout.json");
    }
    get argvResource() {
      const t = Y.VSCODE_PORTABLE;
      return t ? C.file(V(t, "argv.json")) : M(this.userHome, this.c.dataFolderName, "argv.json");
    }
    get isExtensionDevelopment() {
      return !!this.args.extensionDevelopmentPath;
    }
    get untitledWorkspacesHome() {
      return C.file(V(this.userDataPath, "Workspaces"));
    }
    get builtinExtensionsPath() {
      const t = this.args["builtin-extensions-dir"];
      return t ? Ii(t) : Di(V(Cs.asFileUri("").fsPath, "..", "extensions"));
    }
    get extensionsDownloadLocation() {
      const t = this.args["extensions-download-dir"];
      return t ? C.file(Ii(t)) : C.file(V(this.userDataPath, "CachedExtensionVSIXs"));
    }
    get extensionsPath() {
      const t = this.args["extensions-dir"];
      if (t) return Ii(t);
      const e = Y.VSCODE_EXTENSIONS;
      if (e) return e;
      const s = Y.VSCODE_PORTABLE;
      return s ? V(s, "extensions") : M(this.userHome, this.c.dataFolderName, "extensions").fsPath;
    }
    get extensionDevelopmentLocationURI() {
      const t = this.args.extensionDevelopmentPath;
      if (Array.isArray(t)) return t.map((e) => (/^[^:/?#]+?:\/\//.test(e) ? C.parse(e) : C.file(Di(e))));
    }
    get extensionDevelopmentKind() {
      return this.args.extensionDevelopmentKind?.map((t) => (t === "ui" || t === "workspace" || t === "web" ? t : "workspace"));
    }
    get extensionTestsLocationURI() {
      const t = this.args.extensionTestsPath;
      if (t) return /^[^:/?#]+?:\/\//.test(t) ? C.parse(t) : C.file(Di(t));
    }
    get disableExtensions() {
      if (this.args["disable-extensions"]) return !0;
      const t = this.args["disable-extension"];
      if (t) {
        if (typeof t == "string") return [t];
        if (Array.isArray(t) && t.length > 0) return t;
      }
      return !1;
    }
    get debugExtensionHost() {
      return p8(this.args, this.isBuilt);
    }
    get debugRenderer() {
      return !!this.args.debugRenderer;
    }
    get isBuilt() {
      return !Y.VSCODE_DEV;
    }
    get verbose() {
      return !!this.args.verbose;
    }
    get logLevel() {
      return this.args.log?.find((t) => !vm.test(t));
    }
    get extensionLogLevel() {
      const t = [];
      for (const e of this.args.log || []) {
        const s = vm.exec(e);
        s && s[1] && s[2] && t.push([s[1], s[2]]);
      }
      return t.length ? t : void 0;
    }
    get serviceMachineIdResource() {
      return M(C.file(this.userDataPath), "machineid");
    }
    get crashReporterId() {
      return this.args["crash-reporter-id"];
    }
    get crashReporterDirectory() {
      return this.args["crash-reporter-directory"];
    }
    get disableTelemetry() {
      return !!this.args["disable-telemetry"];
    }
    get disableWorkspaceTrust() {
      return !!this.args["disable-workspace-trust"];
    }
    get useInMemorySecretStorage() {
      return !!this.args["use-inmemory-secretstorage"];
    }
    get policyFile() {
      if (this.args["__enable-file-policy"]) {
        const t = Y.VSCODE_PORTABLE;
        return t ? C.file(V(t, "policy.json")) : M(this.userHome, this.c.dataFolderName, "policy.json");
      }
    }
    get continueOn() {
      return this.args.continueOn;
    }
    set continueOn(t) {
      this.args.continueOn = t;
    }
    get args() {
      return this.a;
    }
    constructor(t, e, s) {
      (this.a = t), (this.b = e), (this.c = s), (this.editSessionId = this.args.editSessionId);
    }
  };
__decorate([me], we.prototype, "enableMultiContainer", null),
  __decorate([me], we.prototype, "enableExtMultiContainer", null),
  __decorate([me], we.prototype, "safeExtensionIds", null),
  __decorate([me], we.prototype, "appRoot", null),
  __decorate([me], we.prototype, "userHome", null),
  __decorate([me], we.prototype, "userDataPath", null),
  __decorate([me], we.prototype, "appSettingsHome", null),
  __decorate([me], we.prototype, "tmpDir", null),
  __decorate([me], we.prototype, "cacheHome", null),
  __decorate([me], we.prototype, "stateResource", null),
  __decorate([me], we.prototype, "userRoamingDataHome", null),
  __decorate([me], we.prototype, "userDataSyncHome", null),
  __decorate([me], we.prototype, "sync", null),
  __decorate([me], we.prototype, "machineSettingsResource", null),
  __decorate([me], we.prototype, "workspaceStorageHome", null),
  __decorate([me], we.prototype, "localHistoryHome", null),
  __decorate([me], we.prototype, "keyboardLayoutResource", null),
  __decorate([me], we.prototype, "argvResource", null),
  __decorate([me], we.prototype, "isExtensionDevelopment", null),
  __decorate([me], we.prototype, "untitledWorkspacesHome", null),
  __decorate([me], we.prototype, "builtinExtensionsPath", null),
  __decorate([me], we.prototype, "extensionsPath", null),
  __decorate([me], we.prototype, "extensionDevelopmentLocationURI", null),
  __decorate([me], we.prototype, "extensionDevelopmentKind", null),
  __decorate([me], we.prototype, "extensionTestsLocationURI", null),
  __decorate([me], we.prototype, "debugExtensionHost", null),
  __decorate([me], we.prototype, "logLevel", null),
  __decorate([me], we.prototype, "extensionLogLevel", null),
  __decorate([me], we.prototype, "serviceMachineIdResource", null),
  __decorate([me], we.prototype, "disableTelemetry", null),
  __decorate([me], we.prototype, "disableWorkspaceTrust", null),
  __decorate([me], we.prototype, "useInMemorySecretStorage", null),
  __decorate([me], we.prototype, "policyFile", null);
function p8(t, e) {
  return g8(t["inspect-extensions"], t["inspect-brk-extensions"], 5870, e, t.debugId, t.extensionEnvironment);
}
function g8(t, e, s, i, n, r) {
  const a = Number(e || t) || (i ? null : s),
    c = a ? !!e : !1;
  let l;
  if (r)
    try {
      l = JSON.parse(r);
    } catch {}
  return { port: a, break: c, debugId: n, env: l };
}
import * as ym from "os";
import * as mi from "path";
var m8 = process.env.VSCODE_CWD || process.cwd();
function w8(t, e) {
  const s = v8(t, e),
    i = [s];
  return mi.isAbsolute(s) || i.unshift(m8), mi.resolve(...i);
}
function v8(t, e) {
  const s = process.env.VSCODE_PORTABLE;
  if (s) return mi.join(s, "user-data");
  let i = process.env.VSCODE_APPDATA;
  if (i) return mi.join(i, e);
  const n = t["user-data-dir"];
  if (n) return n;
  switch (process.platform) {
    case "win32":
      if (((i = process.env.APPDATA), !i)) {
        const r = process.env.USERPROFILE;
        if (typeof r != "string") throw new Error("Windows: Unexpected undefined %USERPROFILE% environment variable");
        i = mi.join(r, "AppData", "Roaming");
      }
      break;
    case "darwin":
      i = mi.join(ym.homedir(), "Library", "Application Support");
      break;
    case "linux":
      i = process.env.XDG_CONFIG_HOME || mi.join(ym.homedir(), ".config");
      break;
    default:
      throw new Error("Platform not supported");
  }
  return mi.join(i, e);
}
var y8 = class extends we {
    constructor(t, e) {
      super(t, { homeDir: f8(), tmpDir: d8(), userDataDir: w8(t, e.nameShort) }, e);
    }
  },
  gf = { exit: "vscode:electron-main->shared-process=exit", ipcReady: "vscode:shared-process->electron-main=ipc-ready", initDone: "vscode:shared-process->electron-main=init-done" },
  b8 = { request: "vscode:createSharedProcessRawConnection", response: "vscode:createSharedProcessRawConnectionResult" };
import { constants as E8, promises as S8 } from "fs";
import { createInterface as $8 } from "readline";
async function x8(t) {
  if (Ss || Be) return;
  let e;
  for (const s of ["/etc/os-release", "/usr/lib/os-release", "/etc/lsb-release"])
    try {
      e = await S8.open(s, E8.R_OK);
      break;
    } catch {}
  if (!e) {
    t("Unable to retrieve release information from known identifier paths.");
    return;
  }
  try {
    const s = new Set(["ID", "DISTRIB_ID", "ID_LIKE", "VERSION_ID", "DISTRIB_RELEASE"]),
      i = { id: "unknown" };
    for await (const n of $8({ input: e.createReadStream(), crlfDelay: 1 / 0 })) {
      if (!n.includes("=")) continue;
      const r = n.split("=")[0].toUpperCase().trim();
      if (s.has(r)) {
        const o = n.split("=")[1].replace(/"/g, "").toLowerCase().trim();
        r === "ID" || r === "DISTRIB_ID" ? (i.id = o) : r === "ID_LIKE" ? (i.id_like = o) : (r === "VERSION_ID" || r === "DISTRIB_RELEASE") && (i.version_id = o);
      }
    }
    return i;
  } catch (s) {
    t(s);
  }
}
var je;
(function (t) {
  (t.UNKNOWN = "UNKNOWN"),
    (t.CINNAMON = "CINNAMON"),
    (t.DEEPIN = "DEEPIN"),
    (t.GNOME = "GNOME"),
    (t.KDE3 = "KDE3"),
    (t.KDE4 = "KDE4"),
    (t.KDE5 = "KDE5"),
    (t.KDE6 = "KDE6"),
    (t.PANTHEON = "PANTHEON"),
    (t.UNITY = "UNITY"),
    (t.XFCE = "XFCE"),
    (t.UKUI = "UKUI"),
    (t.LXQT = "LXQT");
})(je || (je = {}));
var C8 = "XDG_CURRENT_DESKTOP",
  mf = "KDE_SESSION_VERSION";
function k8() {
  const t = Y[C8];
  if (t) {
    const s = t
      .split(":")
      .map((i) => i.trim())
      .filter((i) => i.length > 0);
    for (const i of s)
      switch (i) {
        case "Unity": {
          const n = Y.DESKTOP_SESSION;
          return n && n.includes("gnome-fallback") ? je.GNOME : je.UNITY;
        }
        case "Deepin":
          return je.DEEPIN;
        case "GNOME":
          return je.GNOME;
        case "X-Cinnamon":
          return je.CINNAMON;
        case "KDE": {
          const n = Y[mf];
          return n === "5" ? je.KDE5 : n === "6" ? je.KDE6 : je.KDE4;
        }
        case "Pantheon":
          return je.PANTHEON;
        case "XFCE":
          return je.XFCE;
        case "UKUI":
          return je.UKUI;
        case "LXQt":
          return je.LXQT;
      }
  }
  const e = Y.DESKTOP_SESSION;
  if (e)
    switch (e) {
      case "deepin":
        return je.DEEPIN;
      case "gnome":
      case "mate":
        return je.GNOME;
      case "kde4":
      case "kde-plasma":
        return je.KDE4;
      case "kde":
        return mf in Y ? je.KDE4 : je.KDE3;
      case "xfce":
      case "xubuntu":
        return je.XFCE;
      case "ukui":
        return je.UKUI;
    }
  return "GNOME_DESKTOP_SESSION_ID" in Y ? je.GNOME : "KDE_FULL_SESSION" in Y ? (mf in Y ? je.KDE4 : je.KDE3) : je.UNKNOWN;
}
import { constants as D8, promises as I8 } from "fs";
var R8 = "XDG_SESSION_TYPE",
  P8 = "WAYLAND_DISPLAY",
  A8 = "XDG_RUNTIME_DIR",
  bm;
(function (t) {
  (t.Wayland = "wayland"), (t.XWayland = "xwayland"), (t.X11 = "x11"), (t.Unknown = "unknown");
})(bm || (bm = {}));
async function O8(t) {
  const e = Y[R8];
  if (e) return e === "wayland" || e === "x11" ? e : "unknown";
  if (Y[P8]) {
    const i = Y[A8];
    if (i) {
      const n = V(i, "wayland-0");
      try {
        return await I8.access(n, D8.R_OK), "wayland";
      } catch (r) {
        return t(r), "unknown";
      }
    } else return "unknown";
  } else return "x11";
}
function L8(t, e) {
  if (e)
    switch (e) {
      case "auto":
        return t;
      case "x11":
        return t === "wayland" ? "xwayland" : "x11";
      case "wayland":
        return "wayland";
      default:
        return "unknown";
    }
  else return t === "wayland" ? "xwayland" : "x11";
}
import { net as N8 } from "electron";
import { parse as Em } from "url";
import { spawn as T8 } from "child_process";
import { userInfo as j8 } from "os";
import * as F8 from "os";
var Sm = /^\d+$/,
  M8 = /^Microsoft.PowerShell_.*/,
  U8 = /^Microsoft.PowerShellPreview_.*/,
  $m;
(function (t) {
  (t[(t.x64 = 0)] = "x64"), (t[(t.x86 = 1)] = "x86"), (t[(t.ARM = 2)] = "ARM");
})($m || ($m = {}));
var Hr;
switch (process.arch) {
  case "ia32":
    Hr = 1;
    break;
  case "arm":
  case "arm64":
    Hr = 2;
    break;
  default:
    Hr = 0;
    break;
}
var Bn;
process.env.PROCESSOR_ARCHITEW6432 ? (Bn = process.env.PROCESSOR_ARCHITEW6432 === "ARM64" ? 2 : 0) : process.env.PROCESSOR_ARCHITECTURE === "ARM64" ? (Bn = 2) : process.env.PROCESSOR_ARCHITECTURE === "X86" ? (Bn = 1) : (Bn = 0);
var tc = class {
  constructor(t, e, s) {
    (this.exePath = t), (this.displayName = e), (this.a = s);
  }
  async exists() {
    return this.a === void 0 && (this.a = await Wt.existsFile(this.exePath)), this.a;
  }
};
function _8({ useAlternateBitness: t = !1 } = {}) {
  return t ? (Hr === 0 ? process.env["ProgramFiles(x86)"] || null : (Bn === 0 && process.env.ProgramW6432) || null) : process.env.ProgramFiles || null;
}
async function sc({ useAlternateBitness: t = !1, findPreview: e = !1 } = {}) {
  const s = _8({ useAlternateBitness: t });
  if (!s) return null;
  const i = V(s, "PowerShell");
  if (!(await Wt.existsDirectory(i))) return null;
  let n = -1,
    r = null;
  for (const c of await he.readdir(i)) {
    let l = -1;
    if (e) {
      const u = c.indexOf("-");
      if (u < 0) continue;
      const f = c.substring(0, u);
      if (!Sm.test(f) || c.substring(u + 1) !== "preview") continue;
      l = parseInt(f, 10);
    } else {
      if (!Sm.test(c)) continue;
      l = parseInt(c, 10);
    }
    if (l <= n) continue;
    const h = V(i, c, "pwsh.exe");
    (await Wt.existsFile(h)) && ((r = h), (n = l));
  }
  if (!r) return null;
  const o = s.includes("x86") ? " (x86)" : "",
    a = e ? " Preview" : "";
  return new tc(r, `PowerShell${a}${o}`, !0);
}
async function xm({ findPreview: t } = {}) {
  if (!process.env.LOCALAPPDATA) return null;
  const e = V(process.env.LOCALAPPDATA, "Microsoft", "WindowsApps");
  if (!(await Wt.existsDirectory(e))) return null;
  const { pwshMsixDirRegex: s, pwshMsixName: i } = t ? { pwshMsixDirRegex: U8, pwshMsixName: "PowerShell Preview (Store)" } : { pwshMsixDirRegex: M8, pwshMsixName: "PowerShell (Store)" };
  for (const n of await he.readdir(e))
    if (s.test(n)) {
      const r = V(e, n, "pwsh.exe");
      return new tc(r, i);
    }
  return null;
}
function B8() {
  const t = V(F8.homedir(), ".dotnet", "tools", "pwsh.exe");
  return new tc(t, ".NET Core PowerShell Global Tool");
}
function z8() {
  const t = V(process.env.windir, Hr === 1 && Bn !== 1 ? "SysNative" : "System32", "WindowsPowerShell", "v1.0", "powershell.exe");
  return new tc(t, "Windows PowerShell", !0);
}
async function* q8() {
  let t = await sc();
  t && (yield t),
    (t = await sc({ useAlternateBitness: !0 })),
    t && (yield t),
    (t = await xm()),
    t && (yield t),
    (t = B8()),
    t && (yield t),
    (t = await sc({ findPreview: !0 })),
    t && (yield t),
    (t = await xm({ findPreview: !0 })),
    t && (yield t),
    (t = await sc({ useAlternateBitness: !0, findPreview: !0 })),
    t && (yield t),
    (t = z8()),
    t && (yield t);
}
async function* V8() {
  for await (const t of q8()) (await t.exists()) && (yield t);
}
async function W8() {
  for await (const t of V8()) return t;
  return null;
}
async function H8(t, e) {
  return t === 1 ? (Be ? J8() : V2(e)) : G8(t, e);
}
var wf = null;
function G8(t, e) {
  if ((ht && t === 2) || (Ss && t === 3)) return "/bin/bash";
  if (!wf) {
    let s;
    if (Be) s = "/bin/bash";
    else {
      if (((s = e.SHELL), !s))
        try {
          s = j8().shell;
        } catch {}
      s || (s = "sh"), s === "/bin/false" && (s = "/bin/bash");
    }
    wf = s;
  }
  return wf;
}
var vf = null;
async function J8() {
  return vf || (vf = (await W8()).exePath), vf;
}
import "assert";
var I$ = xw(Cw(), 1),
  R$ = { o: w(1749, null), e: w(1750, null), t: w(1751, null) },
  P$ = {
    tunnel: {
      type: "subcommand",
      description: "Make the current machine accessible from vscode.dev or other machines through a secure tunnel",
      options: {
        "cli-data-dir": { type: "string", args: "dir", description: w(1752, null) },
        "disable-telemetry": { type: "boolean" },
        "telemetry-level": { type: "string" },
        user: { type: "subcommand", options: { login: { type: "subcommand", options: { provider: { type: "string" }, "access-token": { type: "string" } } } } },
      },
    },
    "serve-web": {
      type: "subcommand",
      description: "Run a server that displays the editor UI in browsers.",
      options: { "cli-data-dir": { type: "string", args: "dir", description: w(1753, null) }, "disable-telemetry": { type: "boolean" }, "telemetry-level": { type: "string" } },
    },
    diff: { type: "boolean", cat: "o", alias: "d", args: ["file", "file"], description: w(1754, null) },
    merge: { type: "boolean", cat: "o", alias: "m", args: ["path1", "path2", "base", "result"], description: w(1755, null) },
    add: { type: "boolean", cat: "o", alias: "a", args: "folder", description: w(1756, null) },
    goto: { type: "boolean", cat: "o", alias: "g", args: "file:line[:character]", description: w(1757, null) },
    "new-window": { type: "boolean", cat: "o", alias: "n", description: w(1758, null) },
    "reuse-window": { type: "boolean", cat: "o", alias: "r", description: w(1759, null) },
    wait: { type: "boolean", cat: "o", alias: "w", description: w(1760, null) },
    waitMarkerFilePath: { type: "string" },
    locale: { type: "string", cat: "o", args: "locale", description: w(1761, null) },
    "user-data-dir": { type: "string", cat: "o", args: "dir", description: w(1762, null) },
    profile: { type: "string", cat: "o", args: "profileName", description: w(1763, null) },
    help: { type: "boolean", cat: "o", alias: "h", description: w(1764, null) },
    "extensions-dir": { type: "string", deprecates: ["extensionHomePath"], cat: "e", args: "dir", description: w(1765, null) },
    "extensions-download-dir": { type: "string" },
    "builtin-extensions-dir": { type: "string" },
    "list-extensions": { type: "boolean", cat: "e", description: w(1766, null) },
    "show-versions": { type: "boolean", cat: "e", description: w(1767, null) },
    category: { type: "string", allowEmptyValue: !0, cat: "e", description: w(1768, null), args: "category" },
    "install-extension": { type: "string[]", cat: "e", args: "ext-id | path", description: w(1769, null) },
    "pre-release": { type: "boolean", cat: "e", description: w(1770, null) },
    "uninstall-extension": { type: "string[]", cat: "e", args: "ext-id", description: w(1771, null) },
    "update-extensions": { type: "boolean", cat: "e", description: w(1772, null) },
    "enable-proposed-api": { type: "string[]", allowEmptyValue: !0, cat: "e", args: "ext-id", description: w(1773, null) },
    version: { type: "boolean", cat: "t", alias: "v", description: w(1774, null) },
    verbose: { type: "boolean", cat: "t", global: !0, description: w(1775, null) },
    log: { type: "string[]", cat: "t", args: "level", global: !0, description: w(1776, null) },
    status: { type: "boolean", alias: "s", cat: "t", description: w(1777, null) },
    "prof-startup": { type: "boolean", cat: "t", description: w(1778, null) },
    "prof-append-timers": { type: "string" },
    "prof-duration-markers": { type: "string[]" },
    "prof-duration-markers-file": { type: "string" },
    "no-cached-data": { type: "boolean" },
    "prof-startup-prefix": { type: "string" },
    "prof-v8-extensions": { type: "boolean" },
    "disable-extensions": { type: "boolean", deprecates: ["disableExtensions"], cat: "t", description: w(1779, null) },
    "disable-extension": { type: "string[]", cat: "t", args: "ext-id", description: w(1780, null) },
    sync: { type: "string", cat: "t", description: w(1781, null), args: ["on | off"] },
    "inspect-extensions": { type: "string", allowEmptyValue: !0, deprecates: ["debugPluginHost"], args: "port", cat: "t", description: w(1782, null) },
    "inspect-brk-extensions": { type: "string", allowEmptyValue: !0, deprecates: ["debugBrkPluginHost"], args: "port", cat: "t", description: w(1783, null) },
    "disable-lcd-text": { type: "boolean", cat: "t", description: w(1784, null) },
    "disable-gpu": { type: "boolean", cat: "t", description: w(1785, null) },
    "disable-chromium-sandbox": { type: "boolean", cat: "t", description: w(1786, null) },
    sandbox: { type: "boolean" },
    telemetry: { type: "boolean", cat: "t", description: w(1787, null) },
    remote: { type: "string", allowEmptyValue: !0 },
    "folder-uri": { type: "string[]", cat: "o", args: "uri" },
    "file-uri": { type: "string[]", cat: "o", args: "uri" },
    "locate-extension": { type: "string[]" },
    extensionDevelopmentPath: { type: "string[]" },
    extensionDevelopmentKind: { type: "string[]" },
    extensionTestsPath: { type: "string" },
    extensionEnvironment: { type: "string" },
    debugId: { type: "string" },
    debugRenderer: { type: "boolean" },
    "inspect-ptyhost": { type: "string", allowEmptyValue: !0 },
    "inspect-brk-ptyhost": { type: "string", allowEmptyValue: !0 },
    "inspect-search": { type: "string", deprecates: ["debugSearch"], allowEmptyValue: !0 },
    "inspect-brk-search": { type: "string", deprecates: ["debugBrkSearch"], allowEmptyValue: !0 },
    "inspect-sharedprocess": { type: "string", allowEmptyValue: !0 },
    "inspect-brk-sharedprocess": { type: "string", allowEmptyValue: !0 },
    "export-default-configuration": { type: "string" },
    "install-source": { type: "string" },
    "enable-smoke-test-driver": { type: "boolean" },
    logExtensionHostCommunication: { type: "boolean" },
    "skip-release-notes": { type: "boolean" },
    "skip-welcome": { type: "boolean" },
    "disable-telemetry": { type: "boolean" },
    "disable-updates": { type: "boolean" },
    "use-inmemory-secretstorage": { type: "boolean", deprecates: ["disable-keytar"] },
    "password-store": { type: "string" },
    "disable-workspace-trust": { type: "boolean" },
    "disable-crash-reporter": { type: "boolean" },
    "crash-reporter-directory": { type: "string" },
    "crash-reporter-id": { type: "string" },
    "skip-add-to-recently-opened": { type: "boolean" },
    "open-url": { type: "boolean" },
    "file-write": { type: "boolean" },
    "file-chmod": { type: "boolean" },
    "install-builtin-extension": { type: "string[]" },
    force: { type: "boolean" },
    "do-not-sync": { type: "boolean" },
    trace: { type: "boolean" },
    "trace-category-filter": { type: "string" },
    "trace-options": { type: "string" },
    "preserve-env": { type: "boolean" },
    "force-user-env": { type: "boolean" },
    "force-disable-user-env": { type: "boolean" },
    "open-devtools": { type: "boolean" },
    "disable-gpu-sandbox": { type: "boolean" },
    logsPath: { type: "string" },
    extHostLogsPath: { type: "string" },
    "__enable-file-policy": { type: "boolean" },
    editSessionId: { type: "string" },
    continueOn: { type: "string" },
    "locate-shell-integration-path": { type: "string", args: ["bash", "pwsh", "zsh", "fish"] },
    "enable-coi": { type: "boolean" },
    "no-proxy-server": { type: "boolean" },
    "no-sandbox": { type: "boolean", alias: "sandbox" },
    "proxy-server": { type: "string" },
    "proxy-bypass-list": { type: "string" },
    "proxy-pac-url": { type: "string" },
    "js-flags": { type: "string" },
    inspect: { type: "string", allowEmptyValue: !0 },
    "inspect-brk": { type: "string", allowEmptyValue: !0 },
    nolazy: { type: "boolean" },
    "force-device-scale-factor": { type: "string" },
    "force-renderer-accessibility": { type: "boolean" },
    "ignore-certificate-errors": { type: "boolean" },
    "allow-insecure-localhost": { type: "boolean" },
    "log-net-log": { type: "string" },
    vmodule: { type: "string" },
    _urls: { type: "string[]" },
    "disable-dev-shm-usage": { type: "boolean" },
    "profile-temp": { type: "boolean" },
    "ozone-platform": { type: "string" },
    "enable-tracing": { type: "string" },
    "trace-startup-format": { type: "string" },
    "trace-startup-file": { type: "string" },
    "trace-startup-duration": { type: "string" },
    _: { type: "string[]" },
  };
function Cm(t) {
  return t.VSCODE_CLI === "1";
}
function K8(t, e, s) {
  return Math.min(Math.max(t, e), s);
}
var yf = void 0;
async function X8(t, e, s, i) {
  return s["force-disable-user-env"]
    ? (e.trace("resolveShellEnv(): skipped (--force-disable-user-env)"), {})
    : Be
      ? (e.trace("resolveShellEnv(): skipped (Windows)"), {})
      : Cm(i) && !s["force-user-env"]
        ? (e.trace("resolveShellEnv(): skipped (VSCODE_CLI is set)"), {})
        : (Cm(i) ? e.trace("resolveShellEnv(): running (--force-user-env)") : e.trace("resolveShellEnv(): running (macOS/Linux)"),
          yf ||
            (yf = Ze.withAsyncBody(async (n, r) => {
              const o = new xs();
              let a = 3e4;
              const c = t.getValue("application.shellEnvironmentResolutionTimeout");
              typeof c == "number" && (a = K8(c, 1, 120) * 1e3);
              const l = setTimeout(() => {
                o.dispose(!0), r(new Error(w(2155, null)));
              }, a);
              try {
                n(await Q8(e, o.token));
              } catch (h) {
                !Fs(h) && !o.token.isCancellationRequested ? r(new Error(w(2156, null, Xe(h)))) : n({});
              } finally {
                clearTimeout(l), o.dispose();
              }
            })),
          yf);
}
async function Q8(t, e) {
  const s = process.env.ELECTRON_RUN_AS_NODE;
  t.trace("getUnixShellEnvironment#runAsNode", s);
  const i = process.env.ELECTRON_NO_ATTACH_CONSOLE;
  t.trace("getUnixShellEnvironment#noAttach", i);
  const n = Me().replace(/-/g, "").substr(0, 12),
    r = new RegExp(n + "({.*})" + n),
    o = { ...process.env, ELECTRON_RUN_AS_NODE: "1", ELECTRON_NO_ATTACH_CONSOLE: "1", VSCODE_RESOLVING_ENVIRONMENT: "1" };
  t.trace("getUnixShellEnvironment#env", o);
  const a = await H8(hn, o);
  return (
    t.trace("getUnixShellEnvironment#shell", a),
    new Promise((c, l) => {
      if (e.isCancellationRequested) return l(new ot());
      const h = Ot(a);
      let u, f;
      const d = "";
      /^pwsh(-preview)?$/.test(h)
        ? ((u = `& '${process.execPath}' ${d} -p '''${n}'' + JSON.stringify(process.env) + ''${n}'''`), (f = ["-Login", "-Command"]))
        : h === "nu"
          ? ((u = `^'${process.execPath}' ${d} -p '"${n}" + JSON.stringify(process.env) + "${n}"'`), (f = ["-i", "-l", "-c"]))
          : h === "xonsh"
            ? ((u = `import os, json; print("${n}", json.dumps(dict(os.environ)), "${n}")`), (f = ["-i", "-l", "-c"]))
            : ((u = `'${process.execPath}' ${d} -p '"${n}" + JSON.stringify(process.env) + "${n}"'`), h === "tcsh" || h === "csh" ? (f = ["-ic"]) : (f = ["-i", "-l", "-c"])),
        t.trace("getUnixShellEnvironment#spawn", JSON.stringify(f), u);
      const p = T8(a, [...f, u], { detached: !0, stdio: ["ignore", "pipe", "pipe"], env: o });
      e.onCancellationRequested(() => (p.kill(), l(new ot()))),
        p.on("error", (v) => {
          t.error("getUnixShellEnvironment#errorChildProcess", Xe(v)), l(v);
        });
      const g = [];
      p.stdout.on("data", (v) => g.push(v));
      const m = [];
      p.stderr.on("data", (v) => m.push(v)),
        p.on("close", (v, b) => {
          const E = Buffer.concat(g).toString("utf8");
          t.trace("getUnixShellEnvironment#raw", E);
          const $ = Buffer.concat(m).toString("utf8");
          if (($.trim() && t.trace("getUnixShellEnvironment#stderr", $), v || b)) return l(new Error(w(2157, null, v, b)));
          const P = r.exec(E),
            U = P ? P[1] : "{}";
          try {
            const Q = JSON.parse(U);
            s ? (Q.ELECTRON_RUN_AS_NODE = s) : delete Q.ELECTRON_RUN_AS_NODE,
              i ? (Q.ELECTRON_NO_ATTACH_CONSOLE = i) : delete Q.ELECTRON_NO_ATTACH_CONSOLE,
              delete Q.VSCODE_RESOLVING_ENVIRONMENT,
              delete Q.XDG_RUNTIME_DIR,
              t.trace("getUnixShellEnvironment#result", Q),
              c(Q);
          } catch (Q) {
            t.error("getUnixShellEnvironment#errorCaught", Xe(Q)), l(Q);
          }
        });
    })
  );
}
import { parse as km } from "url";
function Y8(t, e) {
  return t.protocol === "http:" ? e.HTTP_PROXY || e.http_proxy || null : (t.protocol === "https:" && (e.HTTPS_PROXY || e.https_proxy || e.HTTP_PROXY || e.http_proxy)) || null;
}
async function Z8(t, e, s = {}) {
  const i = km(t),
    n = s.proxyUrl || Y8(i, e);
  if (!n) return null;
  const r = km(n);
  if (!/^https?:$/.test(r.protocol || "")) return null;
  const o = { host: r.hostname || "", port: (r.port ? +r.port : 0) || (r.protocol === "https" ? 443 : 80), auth: r.auth, rejectUnauthorized: Ms(s.strictSSL) ? s.strictSSL : !0 };
  if (i.protocol === "http:") {
    const { default: a } = await import("http-proxy-agent");
    return new a.HttpProxyAgent(n, o);
  } else {
    const { default: a } = await import("https-proxy-agent");
    return new a.HttpsProxyAgent(n, o);
  }
}
import { createGunzip as e6 } from "zlib";
var bf = class extends Gb {
  constructor(e, s, i) {
    super(i),
      (this.m = e),
      (this.n = s),
      this.r(),
      this.B(
        e.onDidChangeConfiguration((n) => {
          n.affectsConfiguration("http") && this.r();
        }),
      );
  }
  r() {
    const e = this.m.getValue("http");
    (this.f = e?.proxy), (this.g = !!e?.proxyStrictSSL), (this.h = e?.proxyAuthorization);
  }
  async request(e, s) {
    const { f: i, g: n } = this;
    let r;
    try {
      r = await X8(this.m, this.b, this.n.args, process.env);
    } catch (c) {
      this.j || ((this.j = !0), this.b.error("resolving shell environment failed", ve(c)));
    }
    const o = { ...process.env, ...r },
      a = e.agent ? e.agent : await Z8(e.url || "", o, { proxyUrl: i, strictSSL: n });
    return (e.agent = a), (e.strictSSL = n), this.h && (e.headers = { ...(e.headers || {}), "Proxy-Authorization": this.h }), this.c(e, () => Dm(e, s));
  }
  async resolveProxy(e) {}
  async lookupAuthorization(e) {}
  async lookupKerberosAuthorization(e) {
    try {
      const s = await import("kerberos"),
        i = new URL(e),
        n = this.m.getValue("http.proxyKerberosServicePrincipal") || (process.platform === "win32" ? `HTTP/${i.hostname}` : `HTTP@${i.hostname}`);
      return this.b.debug("RequestService#lookupKerberosAuthorization Kerberos authentication lookup", `proxyURL:${i}`, `spn:${n}`), "Negotiate " + (await (await s.initializeClient(n)).step(""));
    } catch (s) {
      this.b.debug("RequestService#lookupKerberosAuthorization Kerberos authentication failed", s);
      return;
    }
  }
  async loadCertificates() {
    return (await import("@vscode/proxy-agent")).loadSystemCertificates({ log: this.b });
  }
};
bf = __decorate([__param(0, Ce), __param(1, Zt), __param(2, ne)], bf);
async function t6(t) {
  return (Em(t.url).protocol === "https:" ? await import("https") : await import("http")).request;
}
async function Dm(t, e) {
  return Ze.withAsyncBody(async (s, i) => {
    const n = Em(t.url),
      r = t.getRawRequest ? t.getRawRequest(t) : await t6(t),
      o = {
        hostname: n.hostname,
        port: n.port ? parseInt(n.port) : n.protocol === "https:" ? 443 : 80,
        protocol: n.protocol,
        path: n.path,
        method: t.type || "GET",
        headers: t.headers,
        agent: t.agent,
        rejectUnauthorized: Ms(t.strictSSL) ? t.strictSSL : !0,
      };
    t.user && t.password && (o.auth = t.user + ":" + t.password);
    const a = r(o, (c) => {
      const l = Sc(t.followRedirects) ? t.followRedirects : 3;
      if (c.statusCode && c.statusCode >= 300 && c.statusCode < 400 && l > 0 && c.headers.location) Dm({ ...t, url: c.headers.location, followRedirects: l - 1 }, e).then(s, i);
      else {
        let h = c;
        !t.isChromiumNetwork && c.headers["content-encoding"] === "gzip" && (h = c.pipe(e6())), s({ res: c, stream: Fy(h) });
      }
    });
    a.on("error", i),
      t.timeout && a.setTimeout(t.timeout),
      t.isChromiumNetwork && a.removeHeader("Content-Length"),
      t.data && typeof t.data == "string" && a.write(t.data),
      a.end(),
      e.onCancellationRequested(() => {
        a.abort(), i(new ot());
      });
  });
}
function s6(t) {
  return N8.request;
}
var i6 = class extends bf {
    request(t, e) {
      return super.request({ ...(t || {}), getRawRequest: s6, isChromiumNetwork: !0 }, e);
    }
  },
  N$ = z("IICubeTrackerService"),
  T$ = z("IICubeSlardarService"),
  Gr = z("IICubeEventReportService"),
  n6 = class {
    constructor() {
      (this.commonParams = {}), (this.a = new D()), (this.onDidCommonParamsChange = this.a.event);
    }
    async getTeaClient() {
      return null;
    }
    async getSlardarClient() {
      return null;
    }
    getEventVerify() {
      return { isEventVerifyEnabled: !1, eventVerifyHost: "" };
    }
    getCommonParams() {
      return this.commonParams;
    }
  },
  j$ = new n6(),
  Im;
(function (t) {
  (t.LOGIN = "1"), (t.NOT_LOGIN = "0");
})(Im || (Im = {}));
var ic;
(function (t) {
  (t.Focus = "focus"), (t.NotFocus = "not_focus");
})(ic || (ic = {}));
import { exec as nc } from "child_process";
function r6(t) {
  return new Promise((e, s) => {
    let i;
    const n = new Map();
    function r(c, l, h, u, f) {
      const d = n.get(l);
      if (c === t || d) {
        const p = { name: o(h), cmd: h, pid: c, ppid: l, load: u, mem: f };
        n.set(c, p), c === t && (i = p), d && (d.children || (d.children = []), d.children.push(p), d.children.length > 1 && (d.children = d.children.sort((g, m) => g.pid - m.pid)));
      }
    }
    function o(c) {
      const l = /--utility-sub-type=network/i,
        h = /--ms-enable-electron-run-as-node/i,
        u = /--crashes-directory/i,
        f = /\\pipe\\winpty-control/i,
        d = /conhost\.exe.+--headless/i,
        p = /--type=([a-zA-Z-]+)/,
        g = /bin\/manager/i,
        m = /ckg_server_(darwin|linux|windows)_(arm64|x64)/i,
        v = /aiserver/i;
      if (u.exec(c)) return "electron-crash-reporter";
      if (f.exec(c)) return "winpty-agent";
      if (d.exec(c)) return "conpty-agent";
      if (g.test(c)) return "icube-manager";
      if (m.test(c)) return m.exec(c)?.[0] || c;
      if (v.test(c)) return "ai-server";
      let b = p.exec(c);
      if (b && b.length === 2) return b[1] === "renderer" ? "window" : b[1] === "utility" ? (l.exec(c) ? "utility-network-service" : "utility-process") : b[1] === "extensionHost" ? "extension-host" : b[1];
      const E = /[a-zA-Z-]+\.js/g;
      let $ = "";
      do (b = E.exec(c)), b && ($ += b + " ");
      while (b);
      return $ && c.indexOf("node ") < 0 && c.indexOf("node.exe") < 0 ? `electron-nodejs (${$})` : h.exec(c) ? `electron-nodejs (${c})` : c;
    }
    if (process.platform === "win32") {
      const c = (l) => (l.indexOf("\\\\?\\") === 0 || l.indexOf("\\??\\") === 0 ? l.substring(4) : l.indexOf('"\\\\?\\') === 0 || l.indexOf('"\\??\\') === 0 ? '"' + l.substring(5) : l);
      import("@vscode/windows-process-tree").then((l) => {
        l.getProcessList(
          t,
          (h) => {
            if (!h) {
              s(new Error(`Root process ${t} not found`));
              return;
            }
            l.getProcessCpuUsage(h, (u) => {
              const f = new Map();
              u.forEach((d) => {
                const p = c(d.commandLine || "");
                f.set(d.pid, { name: o(p), cmd: p, pid: d.pid, ppid: d.ppid, load: d.cpu || 0, mem: d.memory || 0 });
              }),
                (i = f.get(t)),
                i
                  ? (f.forEach((d) => {
                      const p = f.get(d.ppid);
                      p && (p.children || (p.children = []), p.children.push(d));
                    }),
                    f.forEach((d) => {
                      d.children && (d.children = d.children.sort((p, g) => p.pid - g.pid));
                    }),
                    e(i))
                  : s(new Error(`Root process ${t} not found`));
            });
          },
          l.ProcessDataFlag.CommandLine | l.ProcessDataFlag.Memory,
        );
      });
    } else {
      let c = function () {
        let l = [i];
        const h = [];
        for (; l.length; ) {
          const f = l.shift();
          f && (h.push(f.pid), f.children && (l = l.concat(f.children)));
        }
        let u = JSON.stringify(Cs.asFileUri("vs/base/node/cpuUsage.sh").fsPath);
        (u += " " + h.join(" ")),
          nc(u, {}, (f, d, p) => {
            if (f || p) s(f || new Error(p.toString()));
            else {
              const g = d.toString().split(`
`);
              for (let m = 0; m < h.length; m++) {
                const v = n.get(h[m]);
                v.load = parseFloat(g[m]);
              }
              if (!i) {
                s(new Error(`Root process ${t} not found`));
                return;
              }
              e(i);
            }
          });
      };
      var a = c;
      nc("which ps", {}, (l, h, u) => {
        if (l || u)
          if (process.platform !== "linux") s(l || new Error(u.toString()));
          else {
            const f = JSON.stringify(Cs.asFileUri("vs/base/node/ps.sh").fsPath);
            nc(f, {}, (d, p, g) => {
              d || g ? s(d || new Error(g.toString())) : (Rm(p, r), c());
            });
          }
        else {
          const f = h.toString().trim();
          nc(`${f} -ax -o pid=,ppid=,pcpu=,pmem=,command=`, { maxBuffer: 1e3 * 1024, env: { LC_NUMERIC: "en_US.UTF-8" } }, (p, g, m) => {
            p || (m && !m.includes("screen size is bogus")) ? s(p || new Error(m.toString())) : (Rm(g, r), process.platform === "linux" ? c() : i ? e(i) : s(new Error(`Root process ${t} not found`)));
          });
        }
      });
    }
  });
}
function Rm(t, e) {
  const s = /^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+\.[0-9]+)\s+([0-9]+\.[0-9]+)\s+(.+)$/,
    i = t.toString().split(`
`);
  for (const n of i) {
    const r = s.exec(n.trim());
    r && r.length === 6 && e(parseInt(r[1]), parseInt(r[2]), r[5], parseFloat(r[3]), parseFloat(r[4]));
  }
}
import * as Ef from "os";
var Sf,
  $f = class extends O {
    static {
      Sf = this;
    }
    static {
      this.MONITOR_INTERVAL = Y.VSCODE_ENV ? 1e3 * 60 : 1e3 * 60 * 5;
    }
    constructor(e, s) {
      super(), (this.a = e), (this.b = s), this.f();
    }
    dispose() {
      super.dispose(), this.c && clearInterval(this.c);
    }
    async f() {
      this.c = setInterval(() => {
        this.g();
      }, Sf.MONITOR_INTERVAL);
    }
    async g() {
      const e = await this.b.getSlardarClient(),
        s = await this.a.call("getPidToNameMap"),
        i = Number(process.env.VSCODE_PID),
        n = await r6(i),
        { cpuUsage: r, memoryUsage: o, totalMemory: a, freeMemory: c } = await this.n();
      let l = 0,
        h = 0;
      const u = (f, d) => {
        const { name: p, pid: g, mem: m, load: v, children: b } = f,
          E = g === i ? "main-process" : s[g] || p,
          $ = a * (m / 100);
        (l += $), (h += v);
        const P = [d, E].filter(Boolean).join(" ");
        e?.sendEvent?.({
          name: "native_ide_process_performance",
          metrics: { processCpuUsage: v, processMemory: $, systemCpuUsage: r, systemMemoryUsage: o, totalSystemMemory: a, totalSystemFreeMemory: c },
          categories: { processName: P, processPid: String(g) },
        }),
          E === "ptyHost" && (d = "[pty-subprocess]"),
          E.startsWith("extensionHost") && (d = "[exthost-subprocess]"),
          b &&
            b.length > 0 &&
            b.forEach((U) => {
              u(U, d);
            });
      };
      u(n), e?.sendEvent?.({ name: "native_ide_process_performance_total", metrics: { totalProcessMemoryUsage: l, totalProcessCpuUsage: h, systemCpuUsage: r, systemMemoryUsage: o, totalSystemMemory: a, totalSystemFreeMemory: c } });
    }
    async h() {
      return new Promise((e) => {
        const s = this.j();
        setTimeout(() => {
          const i = this.j(),
            n = i.idle - s.idle,
            r = i.total - s.total,
            o = 100 - Math.floor((100 * n) / r);
          e(o);
        }, 100);
      });
    }
    j() {
      const e = Ef.cpus();
      let s = 0,
        i = 0;
      for (const n of e) {
        for (const r in n.times) i += n.times[r];
        s += n.times.idle;
      }
      return { idle: s / e.length, total: i / e.length };
    }
    m() {
      const e = Ef.totalmem(),
        s = Ef.freemem(),
        i = e - s,
        n = Math.floor((i / e) * 100);
      return { total: Math.floor(e / (1024 * 1024)), free: Math.floor(s / (1024 * 1024)), usage: n };
    }
    async n() {
      const e = await this.h(),
        s = this.m();
      return { cpuUsage: e, memoryUsage: s.usage, totalMemory: s.total, freeMemory: s.free };
    }
  };
$f = Sf = __decorate([__param(1, Gr)], $f);
import * as Pm from "fs/promises";
import * as rc from "path";
var Am;
(function (t) {
  (t.USEast = "US-East"), (t.SG = "Singapore-Central"), (t.BOEI18N = "US-BOE"), (t.BOE = "China-BOE"), (t.CN = "China-North");
})(Am || (Am = {}));
var Xi;
(function (t) {
  (t.BYTEDANCE = "bytedance"), (t.MARSCODE = "marscode");
})(Xi || (Xi = {}));
var Om;
(function (t) {
  (t.BYTEDANCE = "bytedance"), (t.DCAR = "dcar"), (t.MARSCODE_CN = "marscode_cn"), (t.MARSCODE_COM = "marscode_com"), (t.UNKNOWN = "unknown");
})(Om || (Om = {}));
var Lm;
(function (t) {
  (t.CN = "cn"), (t.I18N = "i18n");
})(Lm || (Lm = {}));
var ws;
(function (t) {
  (t.CN = "CN"), (t.SG = "SG"), (t.US = "US"), (t.BOE = "BOE"), (t.BOEI18N = "BOEI18N");
})(ws || (ws = {}));
var Jr;
(function (t) {
  (t.cn = "cn"), (t.sg = "sg"), (t.us = "us");
})(Jr || (Jr = {}));
var U$ = { [Jr.cn]: ws.CN, [Jr.sg]: ws.SG, [Jr.us]: ws.US },
  _$ = new Map([
    [ws.SG, { url: "api.trae.ai", region: "sg", clientId: "ono9krqynydwx5", path: "trae" }],
    [ws.US, { url: "api.trae.ai", region: "us", clientId: "ono9krqynydwx5", path: "trae" }],
    [ws.CN, { url: "api.marscode.cn", region: "cn", clientId: "jn91924vxlq380", path: "public" }],
  ]),
  B$ = new Map([
    [xi.SPRING, { domain: "www.trae.ai", authFrom: "trae" }],
    [xi.YINLI, { domain: "www.marscode.cn", authFrom: "marscode" }],
  ]);
import * as Nm from "fs/promises";
var o6 = 500 * 1024 * 1024,
  a6 = class extends O {
    constructor(t) {
      super(), (this.a = t);
    }
    async getLogFileDiff(t, e) {
      const s = e[t] || 0;
      try {
        const i = await Nm.stat(t);
        return i.size > o6
          ? (this.a.warn(`LogDiffManager: Skip reading large file ${t} (${i.size} bytes)`), [])
          : (await Nm.readFile(t, "utf-8"))
              .split(
                `
`,
              )
              .splice(s)
              .map((c) => ({ log: { file: { path: t } }, message: c }));
      } catch (i) {
        return this.a.error(`LogDiffManager#sync log file ${t} diff failed: ${i}`), [];
      }
    }
  };
import * as zn from "fs/promises";
import * as Kr from "path";
var c6 = class extends O {
    constructor(t, e) {
      super(), (this.b = t), (this.c = e), (this.a = Kr.join(this.b.userDataPath, "logs", "shared_local_state"));
    }
    async getItem(t) {
      try {
        const e = Kr.join(this.a, `${t}.json`),
          s = await zn.readFile(e, "utf-8");
        return JSON.parse(s);
      } catch {
        return {};
      }
    }
    async setItem(t, e) {
      const s = Kr.join(this.a, `${t}.json`);
      await zn.mkdir(this.a, { recursive: !0 }), await zn.writeFile(s, JSON.stringify(e, null, 2), "utf-8");
    }
    async removeItem(t) {
      const e = Kr.join(this.a, `${t}.json`);
      try {
        await zn.unlink(e);
      } catch (s) {
        this.c?.error(`LocalStateService#Failed to remove item from local state: ${s}`);
      }
    }
    async clear() {
      const t = await zn.readdir(this.a);
      for (const e of t) {
        const s = Kr.join(this.a, e);
        try {
          await zn.unlink(s);
        } catch (i) {
          this.c?.error(`LocalStateService#Failed to clear local state: ${i}`);
        }
      }
    }
  },
  xf = { MarsCodeInternal: "https://airpod.bytedance.net", MarscodeExternal: "https://cloudide.zijieapi.com", Trae: "https://icube-log-us-east.trae.ai" },
  l6 = class Hn extends O {
    static {
      this.s = 1e3 * 60 * 5;
    }
    static {
      this.t = "log_uploader.log";
    }
    static {
      this.u = "native_stable_0106";
    }
    static {
      this.w = 7;
    }
    static {
      this.y = ["log_uploader", "Dev0"].map((e) => new RegExp(`^${e}\\d*\\.log$`));
    }
    constructor(e, s, i, n, r) {
      super(), (this.z = e), (this.C = s), (this.D = i), (this.F = n), (this.G = r), (this.b = ""), (this.c = {}), (this.j = null), (this.m = ""), (this.n = Xi.MARSCODE);
      const o = this.z.logsHome.fsPath.split("/");
      o.pop(),
        (this.f = o.join("/")),
        (this.g = M(e.logsHome, Hn.t)),
        (this.h = this.B(this.F.createLogger(this.g, { id: "logUploader", name: "Log Uploader" }))),
        (this.r = this.B(new c6(this.z, this.h))),
        (this.a = this.B(new a6(this.h))),
        this.H();
    }
    async H() {
      (this.m = (await this.G.call("getAuthUserInfo"))?.userId || this.D),
        (this.n = (await this.G.call("getAuthUserInfo"))?.account?.scope || Xi.MARSCODE),
        await this.I(),
        await this.J(this.f, !1),
        (this.j = setInterval(() => {
          this.J(this.f, !1);
        }, Hn.s));
      const e = this.G.listen("onDidChangeUserInfo");
      this.B(
        e((s) => {
          (this.m = s?.userId || this.D), (this.n = s?.account?.scope || Xi.MARSCODE), this.I();
        }),
      );
    }
    async I() {
      const s = Math.floor(new Date().getTime() / (1e3 * 60 * 60 * 24 * 7)),
        i = `logsMap_${this.m}_${s}`;
      (this.b = i), (this.c = (await this.r.getItem(i)) || {});
    }
    async J(e, s = !0) {
      if (s && this.M(e)) return;
      this.h.info(`logUploader#Start uploading home logs diff: ${e}`);
      const i = await Pm.readdir(e);
      try {
        for (const n of i) {
          const r = rc.join(e, n),
            o = await Pm.stat(r);
          if (o.isDirectory()) await this.J(r);
          else if (o.isFile()) {
            const a = await this.a.getLogFileDiff(r, this.c),
              c = await this.O(r, a);
            this.c[r] ? (this.c[r] += c) : (this.c[r] = c);
          }
        }
      } catch (n) {
        this.h.error(`logUploader#Failed to upload home logs diff: ${n}`);
      }
      this.r.setItem(this.b, this.c), this.h.info(`logUploader#Finished uploading home logs diff: ${e}`);
    }
    L(e) {
      const s = rc.join(this.z.userDataPath.split("/").pop() || "", "logs");
      return e
        .map((i) => ({ ...i, log: { file: { path: `${this.D}/${s}${i.log.file.path.replace(this.f, "")}` } } }))
        .filter((i) => i.message)
        .filter((i) => !this.M(i.log.file.path));
    }
    M(e) {
      const s = /(\d{8})T\d{6}/,
        n = e.split(rc.sep).find((h) => s.test(h));
      if (!n) return !1;
      const r = s.exec(n);
      if (!r || !r[1]) return !1;
      const o = r[1],
        a = new Date(parseInt(o.substring(0, 4)), parseInt(o.substring(4, 6)) - 1, parseInt(o.substring(6, 8)));
      if ((new Date().getTime() - a.getTime()) / (1e3 * 60 * 60 * 24) > Hn.w) return !0;
      {
        const h = rc.basename(e);
        return Hn.y.some((u) => u.test(h));
      }
    }
    N() {
      return this.C.provider === "Spring" ? { host: xf.Trae, region: "us" } : this.n === Xi.BYTEDANCE ? { host: xf.MarscodeExternal, region: "cn" } : { host: xf.MarsCodeInternal, region: "cn" };
    }
    async O(e, s) {
      const i = this.L(s),
        { host: n, region: r } = this.N(),
        o = `${Hn.u}_${r}`,
        a = this.m,
        c = {
          "Airpod-Source": "filebeat",
          "Airpod-Tenantid": o,
          "Airpod-Workspaceid": a,
          "Airpod-extra": JSON.stringify({ quality: this.C.quality, buildVersion: this.C.version }),
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.C.airpodAuthToken}`,
        };
      this.h.info(`logUploader#Upload host: ${n}, region: ${r}, tid: ${o}, wsid: ${a}, fullPath: ${e}`);
      const l = 100,
        h = [];
      for (let d = 0; d < i.length; d += l) {
        const p = i.slice(d, d + l);
        h.push(p);
      }
      let u = 0,
        f = !1;
      for (const d of h) {
        if (f) break;
        try {
          const p = await fetch(`${n}/log-proxy/api/v2/log-push`, { method: "POST", headers: c, body: JSON.stringify(d) });
          p.ok
            ? (this.h.info(`logUploader#Successfully uploaded ${d.length} logs, fullPath: ${e}`), (u += d.length))
            : (this.h.error(`logUploader#Failed to upload log: Network response was not ok, fullPath: ${e}, response: ${JSON.stringify(p)}`), (f = !0));
        } catch (p) {
          this.h.error(`logUploader#Failed to upload log: ${p}`), (f = !0);
        }
      }
      return this.h.info(`logUploader#Final Successfully uploaded ${u} log items, fullPath: ${e}`), u;
    }
    dispose() {
      this.j && clearInterval(this.j), super.dispose();
    }
  };
import * as Qi from "os";
function h6() {
  const t = { release: Qi.release(), hostname: Qi.hostname(), memory: Qi.totalmem(), cpu: Qi.cpus().map((u) => u.model) },
    e = Qi.totalmem(),
    s = Qi.freemem(),
    n = `${((e - s) / e) * 100}%`,
    r = Qi.cpus(),
    o = r.reduce((u, f) => u + f.times.idle, 0),
    a = r.reduce((u, f) => u + Object.values(f.times).reduce((d, p) => d + p, 0), 0),
    c = o / r.length,
    l = a / r.length,
    h = `${(1 - c / l) * 100}%`;
  return { ...t, memoryUsagePercentage: n, usage: h };
}
import { Tenant as Tm } from "@byted-icube/env";
import { createDefaultTeaClient as u6 } from "@byted-icube/tea/dist/index.node.js";
import { createDefaultSlardarClient as f6 } from "@byted-icube/slardar/dist/index.node.js";
var d6 = "https://mcs.bytedance.net",
  p6 = "https://mcs.byteoversea.net",
  g6 = class extends O {
    constructor() {
      super(), (this.commonParams = {}), (this.b = null), (this.c = null), (this.f = !1), (this.g = !1), (this.h = ""), (this.j = this.B(new D())), (this.onDidCommonParamsChange = this.j.event);
    }
    m() {
      return this.a.provider === xi.YINLI ? ws.CN : ws.US;
    }
    n(t, e, s) {
      if (
        (Y.VSCODE_DEV ? (Y.EVENT_REPORT_IN_LOCAL ? (this.f = !1) : (this.f = !t.getValue("icube.debug.enableReportOnDev"))) : (this.f = !1),
        e === "stable" ? (this.g = !1) : Y.EVENT_VERIFY_ENABLED ? (this.g = !0) : (this.g = t.getValue("icube.debug.enableEventVerify") ?? !1),
        this.g)
      ) {
        const i = s === ws.CN ? d6 : p6;
        this.h = Y.EVENT_VERIFY_HOST ?? t.getValue("icube.debug.eventVerifyHost") ?? i;
      }
    }
    r(t, e, s, i, n, r, o, a, c) {
      const l = s?.userId || t;
      this.commonParams = {
        icube_uid: l,
        user_id: l,
        biz_user_id: l,
        user_is_login: !!s?.userId,
        device_id: t,
        user_unique_id: t,
        machine_id: e,
        arch: Bc,
        system: So,
        scope: s?.account?.scope || "unknown",
        build_version: this.a.tronBuildVersion,
        vscode_version: this.a.version,
        tenant: i?.appTenant,
        region: n,
        aiRegion: r,
        quality: this.a.quality,
        build_time: this.a.date,
        icube_main_uid: o,
        window_id: a,
        workspace_id: c,
      };
    }
    s(t) {
      Object.keys(t).some((s) => this.commonParams[s] !== t[s]) && ((this.commonParams = { ...this.commonParams, ...t }), this.C(), this.D()), this.j.fire(this.commonParams);
    }
    t(t) {
      this.s({ user_unique_id: t, device_id: t }), this.commonParams.icube_uid === "0" && this.u(void 0);
    }
    u(t) {
      const e = t?.userId || this.commonParams.device_id;
      this.s({ icube_uid: e, user_id: e, biz_user_id: e, user_is_login: !!t?.userId, scope: t?.account?.scope || "unknown" });
    }
    w(t) {
      this.s({ tenant: t?.appTenant });
    }
    y(t) {
      this.s({ region: t });
    }
    z(t) {
      this.s({ aiRegion: t });
    }
    F(t) {
      this.b = t;
    }
    G(t) {
      this.c = t;
    }
    async getTeaClient() {
      return this.f ? null : this.b ? this.b : (await this.C(), this.b);
    }
    async getSlardarClient() {
      return this.f ? null : this.c ? this.c : (await this.D(), this.c);
    }
    getEventVerify() {
      return { isEventVerifyEnabled: this.g, eventVerifyHost: this.h };
    }
    getCommonParams() {
      return this.commonParams;
    }
  },
  Cf = class extends g6 {
    constructor(e, s, i, n, r, o) {
      super(), (this.H = e), (this.a = s), (this.J = i), (this.L = n), (this.M = r), (this.N = o), this.O();
    }
    async O() {
      const e = await this.L.call("getAuthUserInfo"),
        s = await this.L.call("getNativeAppMetadata"),
        i = await this.M.call("getRegion"),
        n = await this.N.call("getDeviceId");
      this.r(n || "0", this.H.machineId, e, s, i, void 0, void 0, void 0, void 0), this.n(this.J, this.a.quality, i), await this.C(), await this.D();
      const r = this.L.listen("onDidChangeUserInfo");
      this.B(r((l) => this.u(l)));
      const o = this.L.listen("onDidChangeAppMetadata");
      this.B(o((l) => this.w(l)));
      const a = this.M.listen("onDidChangeRegion");
      this.B(a((l) => this.y(l)));
      const c = this.N.listen("onDidChangeDeviceId");
      this.B(c((l) => this.t(l)));
    }
    async C() {
      const { device_id: e, user_id: s, user_is_login: i, tenant: n, region: r = this.m() } = this.commonParams,
        o = u6({ region: r, tenant: n === Xi.BYTEDANCE ? Tm.BYTEDANCE : Tm.PUBLIC, event_verify_url: this.g ? `${this.h}/v1/list_test` : void 0 });
      o.config({ user: { user_unique_id: e || "0", user_id: s || "0", device_id: e || "0", user_is_login: i }, custom: this.commonParams }), this.F(o);
    }
    async D() {
      const { region: e = this.m(), device_id: s } = this.commonParams,
        i = f6({ userId: s || "0" }, this.commonParams, e);
      this.G(i);
    }
  };
Cf = __decorate([__param(0, Se), __param(1, Ee), __param(2, Ce)], Cf);
import * as m6 from "https";
import * as w6 from "http";
import * as jm from "os";
var v6 = "icube-telemetry-0.0.2",
  y6 = class extends O {
    constructor(t, e, s, i, n, r) {
      super(),
        (this.c = t),
        (this.f = e),
        (this.g = s),
        (this.h = i),
        (this.j = n),
        (this.m = r),
        (this.pluginVersionString = v6),
        this.g &&
          this.h &&
          (this.h.call("getAuthUserInfo").then((o) => {
            this.a = o?.userId;
          }),
          this.B(
            this.h.listen("onDidChangeUserInfo")((o) => {
              this.a = o?.userId;
            }),
          )),
        this.g &&
          this.j &&
          (this.j.call("getDeviceId").then((o) => {
            this.b = o;
          }),
          this.B(
            this.j.listen("onDidChangeDeviceId")((o) => {
              this.b = o;
            }),
          ));
    }
    track(t) {
      if (this.g && process.env.VSCODE_DEV) return;
      const e = t.baseData || {};
      e.properties || (e.properties = {}), e.measurements || (e.measurements = {});
      try {
        (e.measurements.memoryFree = jm.freemem()), (e.measurements.memoryTotal = jm.totalmem());
      } catch {}
      this.g
        ? ((e.properties["common.deviceId"] = this.b || "0"), (e.properties["icube.userid"] = this.a || this.m))
        : this.f && ((e.properties["icube.workspaceId"] = this.f.id), (e.properties["icube.userid"] = this.f.owner), (e.properties["icube.deploymentType"] = this.f.deploymentType));
      try {
        const s = (/^http:/.test(this.c) ? w6 : m6).request(this.c, { method: "POST", headers: { "Content-Type": "application/json" } });
        s.on("error", () => {}), s.write(JSON.stringify(e)), s.end();
      } catch (s) {
        console.log("singal telemetry error----", s);
      }
    }
    unload(t, e) {}
  },
  kf = class extends O {
    constructor(e) {
      super(), (this.a = e);
    }
    async behave(e, s) {
      this.b(e, s || {});
    }
    async report(e, s) {
      this.b(e, s || {});
    }
    async b(e, s) {
      const i = await this.a.getTeaClient();
      i && i.collect(e, s);
    }
  };
kf = __decorate([__param(0, Gr)], kf);
var b6 = class extends kf {},
  E6 = z("commandService"),
  Fm = new (class {
    constructor() {
      (this.a = new Map()), (this.b = new Map()), (this.c = new D()), (this.onDidRegisterCommand = this.c.event);
    }
    registerCommand(t, e) {
      if (!t) throw new Error("invalid command");
      const s = new ye(),
        i = (a, c) => (this.b.set(a, c), ue(() => this.b.delete(a)));
      if (typeof t == "string") {
        if (!e) throw new Error("invalid command");
        return s.add(this.registerCommand({ id: t, handler: e })), s.add(i(t, s)), s;
      }
      if (t.metadata && Array.isArray(t.metadata.args)) {
        const a = [];
        for (const l of t.metadata.args) a.push(l.constraint);
        const c = t.handler;
        t.handler = function (l, ...h) {
          return Mw(h, a), c(l, ...h);
        };
      }
      const { id: n } = t;
      let r = this.a.get(n);
      r || ((r = new Nc()), this.a.set(n, r));
      const o = r.unshift(t);
      return (
        s.add(
          ue(() => {
            o(), this.a.get(n)?.isEmpty() && this.a.delete(n);
          }),
        ),
        this.c.fire(n),
        s.add(i(n, s)),
        s
      );
    }
    registerCommandAlias(t, e) {
      return Fm.registerCommand(t, (s, ...i) => s.get(E6).executeCommand(e, ...i));
    }
    unregisterCommand(t) {
      const e = typeof t == "string" ? t : t.id,
        s = this.b.get(e);
      s && s.dispose();
    }
    getCommand(t) {
      const e = this.a.get(t);
      if (!(!e || e.isEmpty())) return $i.first(e);
    }
    getCommands() {
      const t = new Map();
      for (const e of this.a.keys()) {
        const s = this.getCommand(e);
        s && t.set(e, s);
      }
      return t;
    }
  })();
Fm.registerCommand("noop", () => {});
var S6 = z("iCubeTeaService"),
  Df = class {
    constructor(e) {
      this.a = e;
    }
    async event(e) {
      const s = await this.a.getSlardarClient();
      s && s.sendEvent && s.sendEvent({ ...e, categories: { ...e?.categories, isFocus: document.hasFocus() ? ic.Focus : ic.NotFocus, isVisible: document.visibilityState } });
    }
    async error(e, s) {
      const i = await this.a.getSlardarClient();
      i && i.sendEvent && i.report({ name: "js_error", payload: { message: e?.message, stack: e?.stack, name: e?.name }, extra: s });
    }
  };
Df = __decorate([__param(0, Gr)], Df);
var $6 = class extends Df {},
  x6 = z("IICubeSlardarService");
import oc from "fs";
import Mm from "path";
import { TosClient as C6 } from "@volcengine/tos-sdk";
import { S3Client as k6, PutObjectCommand as D6 } from "@aws-sdk/client-s3";
import I6 from "axios";
import vs from "fs";
import qn from "path";
import { create as R6 } from "tar";
async function P6(t, { logsHome: e, startTime: s, endTime: i, ignoreFiles: n = [], maxSize: r }) {
  const o = qn.join(e, `alog_${t}`),
    a = qn.join(o, `logs_${s}_${i}.tar.gz`),
    c = qn.join(e, `alog_${t}_large_files_${s}_${i}.log`);
  await L6(o);
  const l = vs.createWriteStream(c, { flags: "a" });
  try {
    const h = await O6(e, s, i),
      u = await A6(h, e, n, r, l);
    if ((l.end(), u.length === 0)) throw new Error("No logs to upload");
    return (
      u.push(c),
      await R6(
        { gzip: !0, file: a, cwd: e },
        u.map((f) => qn.relative(e, f)),
      ),
      await vs.promises.unlink(c),
      a
    );
  } catch (h) {
    throw (await N6(a, c, l), h);
  }
}
async function A6(t, e, s, i, n) {
  const r = [];
  for (const o of t) {
    const a = qn.join(e, o),
      c = await vs.promises.readdir(a);
    for (const l of c) {
      if (s.includes(l)) continue;
      const h = qn.join(a, l);
      if ((await vs.promises.stat(h)).size > i) {
        n.write(`${h}
`);
        continue;
      }
      r.push(h);
    }
  }
  return r;
}
async function O6(t, e, s) {
  const i = await vs.promises.readdir(t),
    n = /^\d{8}T\d{6}$/;
  return i.filter((r) => {
    if (!n.test(r)) return !1;
    const [o, a, c, l, h, u] = [r.slice(0, 4), r.slice(4, 6), r.slice(6, 8), r.slice(9, 11), r.slice(11, 13), r.slice(13, 15)],
      f = new Date(`${o}-${a}-${c}T${l}:${h}:${u}`).getTime();
    return f >= e && f <= s;
  });
}
async function L6(t) {
  vs.existsSync(t) && (await vs.promises.rm(t, { recursive: !0 })), await vs.promises.mkdir(t, { recursive: !0 });
}
async function N6(t, e, s) {
  vs.existsSync(t) && (await vs.promises.unlink(t)), s.end(), await vs.promises.unlink(e);
}
var T6 = class io extends O {
    static {
      this.n = "alog.log";
    }
    static {
      this.r = 10 * 60 * 1e3;
    }
    static {
      this.s = [".DS_Store", "log_uploader.log"];
    }
    static {
      this.t = 100 * 1024 * 1024;
    }
    constructor(e, s, i, n, r, o, a, c) {
      super(), (this.u = e), (this.w = s), (this.y = i), (this.z = n), (this.C = r), (this.D = o), (this.F = a), (this.G = c), (this.j = void 0), (this.m = new Set()), (this.h = this.y.iCubeApp?.nativeAppConfig?.aLog?.endpoint || "");
      const l = this.z.logsHome.fsPath;
      (this.c = Mm.dirname(l)),
        (this.f = M(this.z.logsHome, io.n)),
        (this.g = this.B(this.D.createLogger(this.f, { id: "aLog", name: "ALog" }))),
        this.X("[initialize]", { machineId: e, logsHome: this.c, endpoint: this.h }),
        this.h && this.H();
    }
    async H() {
      const e = this.F.listen("onDidChangeUserInfo");
      this.B(e((r) => this.U(r)));
      const s = await this.F.call("getAuthUserInfo");
      this.U(s);
      const i = this.G.listen("onDidChangeDeviceId");
      this.B(i((r) => this.W(r)));
      const n = await this.G.call("getDeviceId");
      this.W(n),
        (this.j = setInterval(() => {
          this.I();
        }, io.r));
    }
    async I() {
      if (!this.a) {
        this.X("[pullTask] user not logged in");
        return;
      }
      const e = await this.J();
      if (!e?.success) {
        this.X("[pullTask:error]", e?.message);
        return;
      }
      if (!e?.data) {
        this.X("[pullTask] no task need to handle");
        return;
      }
      if (e.data.action !== "log") {
        this.X("[pullTask:actionError]", e.data.action);
        return;
      }
      const s = e.data.id;
      if (this.m.has(s)) {
        this.X("[pullTask:taskPoolError] duplicate task id: ", s);
        return;
      }
      this.m.add(s);
      try {
        await this.M(e.data), await this.L(s, !0), this.X("[handleLogTask:success] id:", s), this.C.publicLog2("ALog:handleLogTask", { success: !0, taskId: s }), this.m.delete(s);
      } catch (i) {
        this.X("[handleLogTask:error]", i), this.C.publicLog2("ALog:handleLogTask", { success: !1, taskId: s, error: i.message }), this.m.delete(s), await this.L(s, !1, i.message);
      }
    }
    async J() {
      try {
        const e = await this.w
          .request(
            {
              type: "POST",
              url: `${this.h}/icube/api/v1/device/log/check`,
              data: JSON.stringify({ machineId: this.u, deviceId: this.b, userId: this.a?.userId, organization: this.a?.account?.organization, platform: gd, arch: process.arch, packageType: `${this.y.quality}_${this.y.providerCode}` }),
              headers: { "Content-Type": "application/json", "x-icube-token": this.a?.token },
            },
            J.None,
          )
          .then(Ui);
        return this.X("[fetchLogTask]", e), this.C.publicLog2("ALog:fetchLogTask", { success: !0, taskId: e?.data?.id }), e;
      } catch (e) {
        return this.X("[fetchLogTask:error]", e), this.C.publicLog2("ALog:fetchLogTask", { success: !1, error: e.message }), null;
      }
    }
    async L(e, s, i = "") {
      try {
        const n = await this.w
          .request(
            {
              type: "POST",
              url: `${this.h}/icube/api/v1/device/log/callback`,
              data: JSON.stringify({ id: e, status: s, message: i, platform: gd, arch: process.arch, buildVersion: this.y.tronBuildVersion }),
              headers: { "Content-Type": "application/json", "x-icube-token": this.a?.token },
            },
            J.None,
          )
          .then(Ui);
        this.X("[callbackLogTask]", n), this.C.publicLog2("ALog:callbackLogTask", { success: !0, taskId: e });
      } catch (n) {
        this.X("[callbackLogTask:error]", n), this.C.publicLog2("ALog:callbackLogTask", { success: !1, taskId: e, error: n.message });
      }
    }
    async M(e) {
      const { startTime: s, endTime: i, id: n, extra: r } = e,
        o = r?.maxSize || io.t,
        a = await P6(n, { startTime: s, endTime: i, maxSize: o, ignoreFiles: io.s, logsHome: this.c });
      this.X("[handleLogTask]", a);
      const c = Mm.dirname(a);
      try {
        await this.N(a, e), this.C.publicLog2("ALog:uploadLogs", { success: !0, taskId: n });
      } catch (l) {
        throw (this.X("[handleLogTask: uploadLogs error]", l), this.C.publicLog2("ALog:uploadLogs", { success: !1, taskId: n, error: l.message }), l);
      }
      await oc.promises.rm(c, { recursive: !0 });
    }
    async N(e, s) {
      const { extra: i } = s;
      if (!i) throw new Error("extra is required");
      try {
        this.y.provider === xi.YINLI ? await this.O(e, i) : this.y.provider === xi.SPRING && (await this.Q(e, i));
      } catch (n) {
        throw (this.X("[uploadLogs:error]", n), n);
      }
    }
    async O(e, s) {
      const { uploadUrl: i } = s;
      i ? await this.S(e, i) : await this.P(e, s);
    }
    async P(e, s) {
      const { sts: i, objectKey: n, bucket: r } = s;
      if (!i || !n || !r) throw new Error("bucket\u3001objectKey and extra.sts are required");
      const { accessKeyId: o, secretAccessKey: a, region: c, sessionToken: l } = i;
      await new C6({ accessKeyId: o, accessKeySecret: a, region: c, stsToken: l }).putObject({ bucket: r, key: n, body: oc.readFileSync(e) });
    }
    async Q(e, s) {
      const { uploadUrl: i } = s;
      i ? await this.S(e, i) : await this.R(e, s);
    }
    async R(e, s) {
      const { sts: i, objectKey: n, bucket: r } = s;
      if (!i || !n || !r) throw new Error("bucket\u3001objectKey and extra.sts are required");
      const { accessKeyId: o, secretAccessKey: a, region: c, sessionToken: l } = i,
        h = new k6({ credentials: { accessKeyId: o, secretAccessKey: a, sessionToken: l }, region: c }),
        u = new D6({ Bucket: r, Key: n, Body: oc.readFileSync(e) });
      await h.send(u);
    }
    async S(e, s) {
      const i = oc.readFileSync(e);
      await I6.put(s, i, {
        headers: { "content-type": "application/gzip" },
        onUploadProgress: (n) => {
          if (n.total) {
            const r = Math.round((n.loaded * 100) / n.total);
            this.X("[uploadByUrl:uploadProgress] ", r + "%");
          }
        },
      });
    }
    U(e) {
      this.X("[updateUserInfo]", { userId: e?.userId, region: e?.region, organization: e?.account?.organization }), (this.a = e);
    }
    W(e) {
      this.X("[updateDeviceId]", e), (this.b = e);
    }
    X(e, ...s) {
      this.y.quality !== "stable" ? this.g.info(e, ...s) : this.g.trace(e, ...s);
    }
    dispose() {
      super.dispose(), this.j && clearInterval(this.j), this.m.clear();
    }
  },
  j6 = class extends O {
    constructor(t) {
      super(), (this.f = t), (this.a = this.B(new Yy(this))), (this.b = void 0), (this.c = this.B(new D())), this.g();
    }
    g() {
      let t = !1;
      const e = () => {
        t || ((t = !0), this.b?.fireOnWillShutdown(), this.dispose());
      };
      process.once("exit", e), Zy(process.parentPort, gf.exit, e);
    }
    async init() {
      const t = await this.h();
      g7(),
        t.invokeFunction((e) => {
          const s = e.get(ne),
            i = e.get(Se),
            n = e.get(Te),
            r = e.get(Zt),
            o = e.get($n),
            a = e.get(gr),
            c = e.get(Ee),
            l = e.get(ps),
            h = e.get(oi),
            u = a.getChannel("userInfo");
          u.listen("onDidChangeUserInfo")((d) => {
            l.updateUserInfo(d || null);
          });
          const f = e.get(Gr);
          s.trace("sharedProcess configuration", JSON.stringify(this.f)),
            this.j(e),
            this.m(s),
            this.n(i, n),
            this.B(n.onDidChangeProfiles(() => this.n(i, n))),
            this.r(i, s),
            this.B(new $f(a.getChannel("processDiagnosis"), f)),
            this.B(new l6(r, c, this.f.machineId, o, a.getChannel("userInfo"))),
            this.B(new T6(this.f.machineId, h, c, r, i, o, u, a.getChannel("deviceRegister")));
        }),
        this.B(Rc(t.createInstance(pl, this.f.codeCachePath), t.createInstance(gl), t.createInstance($l), t.createInstance(Sl), t.createInstance(El), t.createInstance(Zu), t.createInstance(Qu)));
    }
    async h() {
      const t = new Nh(),
        e = { _serviceBrand: void 0, ...Js };
      t.set(Ee, e);
      const s = new c1((Z) => Z === "main"),
        i = new ab(this.a, s);
      t.set(gr, i);
      const n = this.f.policiesData ? new M9(this.f.policiesData, i.getChannel("policy")) : new xp();
      t.set($p, n);
      const r = new y8(this.f.args, e);
      t.set(Zt, r);
      const o = new c7(
        void 0,
        this.f.logLevel,
        r.logsHome,
        this.f.loggers.map((Z) => ({ ...Z, resource: C.revive(Z.resource) })),
        i.getChannel("logger"),
      );
      t.set($n, o);
      const a = this.B(o.createLogger("sharedprocess", { name: w(176, null) })),
        c = this.B(new M4(a.getLevel())),
        l = this.B(new Z9(a, [c]));
      t.set(ne, l), (this.b = this.B(new ef(l))), t.set(fm, this.b);
      const h = this.B(new Rh(l));
      t.set(ie, h);
      const u = this.B(new t7(l));
      h.registerProvider(oe.file, u);
      const f = new Za(h);
      t.set(ke, f);
      const d = this.B(new U9(this.f.profiles.all, C.revive(this.f.profiles.home).with({ scheme: r.userRoamingDataHome.scheme }), i.getChannel("userDataProfiles")));
      t.set(Te, d);
      const p = this.B(new N9(oe.file, this.B(new j9(i.getChannel(T9), { pathCaseSensitive: ht })), oe.vscodeUserData, d, f, l));
      h.registerProvider(oe.vscodeUserData, p);
      const g = this.B(new Fb(d.defaultProfile.settingsResource, h, n, l));
      t.set(Ce, g);
      const m = new c8(void 0, { defaultProfile: d.defaultProfile, currentProfile: d.defaultProfile }, i, r);
      t.set(ae, m), this.B(ue(() => m.flush())), await Promise.all([g.initialize(), m.initialize()]);
      const v = new i6(g, r, l);
      t.set(oi, v), t.set(G1, new de(Al, void 0, !1)), t.set(im, new de(F9, void 0, !1));
      const b = new of(-1, i);
      t.set(_o, b), t.set(jp, new de(Xl, void 0, !0));
      const E = this.B(new Z7(b)),
        $ = new c1((Z) => E.getActiveClientId().then((A) => Z === A));
      t.set(Rg, new r8(this.a.getChannel("extensionRecommendationNotification", $)));
      let P;
      const U = [],
        Q = o5(e, g);
      if (eh(e, r)) {
        const Z = new ya(l, o, r, e);
        if ((U.push(Z), !zp(e, r))) {
          const W = i.getChannel("userInfo"),
            se = i.getChannel("deviceRegister"),
            pe = new X9(v, Q, "monacoworkbench", null, () => new y6(e.iCubeApp?.telemetryEndpoint || "", void 0, !0, W, se, this.f.machineId));
          this.B(ue(() => pe.flush())), U.push(pe);
        }
        const { memory: A, cpu: R, memoryUsagePercentage: F, usage: N } = h6();
        P = new ba(
          {
            appenders: U,
            commonProperties: t5(Dw(), kw(), process.arch, e.commit, e.version, this.f.machineId, this.f.sqmId, this.f.devDeviceId, Q, void 0, e.tronBuildVersion, JSON.stringify(A), JSON.stringify(R), F, N, e.quality),
            sendErrorTelemetry: !0,
            piiPaths: a5(r),
          },
          g,
          e,
        );
      } else {
        P = n5;
        const Z = r5;
        U.push(Z);
      }
      this.a.registerChannel("telemetryAppender", new h7(U)), t.set(Se, P);
      const k = new Uh(g, P, l, o, r, e);
      t.set(Pp, k),
        t.set(ci, new de(rf, void 0, !0)),
        t.set(pa, new de(Ku, void 0, !0)),
        e.quality === "stable" ? t.set(uh, new de(fh, void 0, !0)) : t.set(uh, It.toService(i.getChannel("signatureVerificationService"))),
        t.set(Cg, new de(xh, void 0, !0)),
        t.set(ps, new de(hh, void 0, !0)),
        t.set(F1, new de(pf, void 0, !1)),
        t.set(yl, new de(jh, void 0, !1)),
        t.set(Cp, new de(Gl, void 0, !1)),
        t.set(ka, new de(Wh, void 0, !0)),
        t.set(Pe, new de(tu, void 0, !0)),
        t.set(Ca, It.toService(this.a.getChannel("userDataSyncUtil", (Z) => Z.ctx !== "main"))),
        t.set(j1, new de(ra, void 0, !1)),
        t.set(Ea, new de(Bh, void 0, !0)),
        t.set(_h, new de(Tr)),
        t.set(hi, new de(Yh, void 0, !0)),
        t.set(St, new de(eu, void 0, !0)),
        t.set(Pa, new de(su, void 0, !0)),
        t.set(ts, new de(Gh, void 0, !1)),
        t.set(jt, new de(iu, void 0, !0)),
        t.set(xa, new de(Ru, void 0, !1)),
        t.set(Mr, new de(Pu, void 0, !0)),
        t.set(Vh, new de(Yu, void 0, !0)),
        t.set(Ka, new de(s9, void 0, !1));
      const I = new k9();
      t.set(Ya, I), I.register(0, u8), t.set(I0, new de(Wu)), t.set(Z0, new de(Gu)), t.set(am, new de(nf));
      const H = new Cf(P, e, g, i.getChannel("userInfo"), i.getChannel("region"), i.getChannel("deviceRegister"));
      t.set(Gr, H);
      const B = new b6(H);
      t.set(S6, B);
      const j = new $6(H);
      return t.set(x6, j), new n7(t);
    }
    j(t) {
      const e = new H5(t.get(Vs), () => null);
      this.a.registerChannel("extensions", e);
      const s = It.fromService(t.get(yl), this.q);
      this.a.registerChannel("languagePacks", s);
      const i = It.fromService(t.get(Cp), this.q);
      this.a.registerChannel("diagnostics", i);
      const n = new G5(t.get(F1));
      this.a.registerChannel("extensionTipsService", n);
      const r = It.fromService(t.get(G1), this.q);
      this.a.registerChannel("checksum", r);
      const o = It.fromService(t.get(im), this.q);
      this.a.registerChannel("v8InspectProfiling", o);
      const a = It.fromService(t.get(Pa), this.q);
      this.a.registerChannel("userDataSyncMachines", a);
      const c = It.fromService(t.get(Pp), this.q);
      this.a.registerChannel("customEndpointTelemetry", c);
      const l = new S7(t.get(ka));
      this.a.registerChannel("userDataSyncAccount", l);
      const h = new $7(t.get(hi));
      this.a.registerChannel("userDataSyncStoreManagement", h);
      const u = new Q7(t.get(xa), t.get(Te), t.get(ne));
      this.a.registerChannel("userDataSync", u);
      const f = this.B(t.get(ds).createInstance(ff));
      this.a.registerChannel("userDataAutoSync", It.fromService(f, this.q)), this.a.registerChannel("IUserDataSyncResourceProviderService", It.fromService(t.get(Vh), this.q));
      const d = It.fromService(t.get(Z0), this.q);
      this.a.registerChannel(R9, d);
      const p = It.fromService(t.get(am), this.q);
      this.a.registerChannel("remoteTunnel", p);
    }
    m(t) {
      process.on("uncaughtException", (e) => rt(e)),
        process.on("unhandledRejection", (e) => rt(e)),
        Pw((e) => {
          const s = Xe(e, !0);
          s && t.error(`[uncaught exception in sharedProcess]: ${s}`);
        });
    }
    n(t, e) {
      t.publicLog2("profilesInfo", { count: e.profiles.length });
    }
    async r(t, e) {
      if (ht) {
        const [s, i] = await Promise.all([x8(e.error.bind(e)), O8(e.error.bind(e))]),
          n = k8(),
          r = L8(i, this.f.args["ozone-platform"]);
        s && t.publicLog2("clientPlatformInfo", { platformId: s.id, platformVersionId: s.version_id, platformIdLike: s.id_like, desktopEnvironment: n, displayProtocol: i, codeDisplayProtocol: r });
      }
    }
    handledClientConnection(t) {
      if (t.data !== b8.response) return !1;
      const e = t.ports.at(0);
      return e ? (this.c.fire(e), !0) : !1;
    }
  };
async function Um(t) {
  try {
    const e = new j6(t);
    process.parentPort.postMessage(gf.ipcReady), await e.init(), process.parentPort.postMessage(gf.initDone);
  } catch (e) {
    process.parentPort.postMessage({ error: e.toString() });
  }
}
var F6 = setTimeout(() => {
  process.parentPort.postMessage({ warning: "[SharedProcess] did not receive configuration within 30s..." });
}, 3e4);
process.parentPort.once("message", (t) => {
  clearTimeout(F6), Um(t.data);
});
export { Um as main };
