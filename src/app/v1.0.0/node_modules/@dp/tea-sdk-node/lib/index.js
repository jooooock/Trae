var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeaSDK = void 0;
const assert_1 = __importDefault(require("assert"));
const config_manager_1 = __importDefault(require("./config-manager"));
const node_utils_1 = require("@logsdk/node-utils");
const package_json_1 = require("../package.json");
class TeaSDK {
    constructor(opt) {
        this.plugins = [];
        this.instanceID = Math.random().toString(32).slice(2);
        /**
         * @description change configuration will affect the subsequent events
         */
        this.config = (options) => {
            this.plugins.map(plugin => {
                var _a;
                (_a = plugin.beforeConfig) === null || _a === void 0 ? void 0 : _a.call(plugin, options);
            });
            this.configManager.configure(options);
            this.plugins.map(plugin => {
                var _a;
                (_a = plugin.afterConfig) === null || _a === void 0 ? void 0 : _a.call(plugin, options);
            });
        };
        this.logger = new node_utils_1.Logger('Logsdk');
        this.logger.setLevel(opt.logLevel || 'silent');
        if (opt.isolated) {
            this.logger.warn('Global isolation is enabled');
        }
        (0, assert_1.default)(typeof (opt === null || opt === void 0 ? void 0 : opt.app_id) === 'number');
        this.configManager = new config_manager_1.default(Object.assign(Object.assign({}, opt), { logger: this.logger }));
        this.logger.trace('initialized success with options %o', opt);
    }
    get meta() {
        return {
            caller: this.configManager.caller,
            user: this.configManager.userFields,
            header: this.configManager.headerFields,
            appId: this.configManager.appId,
            version: package_json_1.version,
            instanceID: this.instanceID,
            installedPlugins: [],
        };
    }
    composeHookContext(plugin) {
        const self = this;
        return {
            get metaInfo() {
                return self.meta;
            },
            logger: this.logger.propagate(plugin.name),
            collect: (events, overridden) => {
                this.trigger(Object.assign({ events: events.map(e => (Object.assign(Object.assign({}, e.extra), { event: e.name, params: JSON.stringify(e.params), time: Math.ceil(Date.now() / 1000) }))) }, overridden), { originatedBy: plugin.name });
            },
        };
    }
    trigger(...args) {
        const [event, context] = args;
        const composedEvents = this.configManager.compose(event, context);
        this.logger.trace('Composed event %o', composedEvents);
        this.plugins.map(plugin => {
            var _a, _b;
            (_a = plugin.beforeSendEvent) === null || _a === void 0 ? void 0 : _a.call(plugin, composedEvents);
            (_b = plugin.onSendEvent) === null || _b === void 0 ? void 0 : _b.call(plugin, composedEvents);
        });
    }
    use(...plugins) {
        this.plugins.push(...plugins);
        plugins.map(plugin => {
            var _a;
            (_a = plugin.install) === null || _a === void 0 ? void 0 : _a.call(plugin, this.composeHookContext(plugin));
            this.logger.trace('Plugin %s installed', plugin.name);
        });
    }
    collectEvents(user, header, events, caller) {
        this.trigger({
            events,
            user,
            header,
            caller: caller || this.configManager.caller,
        });
    }
    collect(nameOrInfo, paramsOrOverridden, overridden) {
        const events = Array.isArray(nameOrInfo)
            ? nameOrInfo.map(({ name, params }) => ({
                event: name,
                params: JSON.stringify(params),
            }))
            : [{ event: nameOrInfo, params: JSON.stringify(paramsOrOverridden) }];
        const useOverridden = (Array.isArray(nameOrInfo) ? paramsOrOverridden : overridden) || {};
        const { custom } = useOverridden, useOptions = __rest(useOverridden, ["custom"]);
        if (!this.plugins.length) {
            this.logger.warn('Dry run since no plugin applied');
        }
        this.trigger(Object.assign({ events: events.map(e => (Object.assign(Object.assign({}, e), { time: Math.ceil(Date.now() / 1000) }))), customOfHeader: custom }, useOptions));
    }
}
exports.TeaSDK = TeaSDK;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@dp/tea-sdk-node/lib/index.js.map