"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initUserConfig = exports.AuthClient = void 0;
const vscode = __importStar(require("vscode"));
const jwt_decode_1 = require("jwt-decode");
const index_extension_1 = require("@byted-icube/authentication/dist/lib/index.extension");
class AuthClient {
    // private region: Region;
    logger;
    iCubeAuthClient;
    readyMap = {
        [index_extension_1.AuthPlatformTypes.Github]: false,
        [index_extension_1.AuthPlatformTypes.Deploy]: false,
        [index_extension_1.AuthPlatformTypes.Ide]: false,
    };
    deployTokenReady = Promise.resolve();
    constructor(_region, options) {
        // this.region = region;
        this.logger = options?.logger;
        const headers = process.env.CLOUDIDE_FEATURE_ENV
            ? {
                'x-tt-env': process.env.CLOUDIDE_FEATURE_ENV,
            }
            : {};
        if ((process.env.CLOUDIDE_FEATURE_ENV || '').startsWith('ppe')) {
            headers['x-use-ppe'] = '1';
        }
        this.iCubeAuthClient = new index_extension_1.ICubeAuthVSExtensionClient({ baseUrl: process.env.CLOUDIDE_APISERVER_BASE_URL || 'https://api-sg-central.marscode.com' }, {
            headers,
        });
        if (!options?.disableInvokeDeployTokenInConstructor || !process.env.VSCODE_RUN_IN_ELECTRON) {
            this.deployTokenReady = this.getDeployToken({
                needLogin: false,
            }).then(res => {
                this.readyMap[index_extension_1.AuthPlatformTypes.Deploy] = true;
                return res;
            });
        }
        this.iCubeAuthClient
            .getAuthToken(index_extension_1.AuthPlatformTypes.Ide, {
            needLogin: false,
        })
            .then(() => {
            this.readyMap[index_extension_1.AuthPlatformTypes.Ide] = true;
        });
        this.logger?.info('[Auth Client Init]');
    }
    async getUserInfo() {
        const userInfo = await this.iCubeAuthClient.getUserInfo();
        return {
            ...userInfo,
        };
    }
    getDefaultIDEToken() {
        const token = (vscode.icube.initInfo?.tokens || []).find((d) => d.type === 'IDE');
        if (!token) {
            return null;
        }
        const decoded = (0, jwt_decode_1.jwtDecode)(token?.token);
        if (!token || (decoded?.exp && decoded?.exp * 1000 < Date.now())) {
            return null;
        }
        return token;
    }
    async getIDEToken(options) {
        if (!this.readyMap[index_extension_1.AuthPlatformTypes.Ide]) {
            let token = this.getDefaultIDEToken();
            return token ? token : this.iCubeAuthClient.getAuthToken(index_extension_1.AuthPlatformTypes.Ide, options);
        }
        else {
            return this.iCubeAuthClient.getAuthToken(index_extension_1.AuthPlatformTypes.Ide, options);
        }
    }
    async getDeployToken(options) {
        const start = Date.now();
        if (process.env.VSCODE_RUN_IN_ELECTRON) {
            return null;
        }
        if (!this.readyMap[index_extension_1.AuthPlatformTypes.Deploy]) {
            // this.logger && this.logger.info('[Request IDE Token]', +new Date() - start);
            // const ideToken = await this.getIDEToken();
            let ideToken = this.getDefaultIDEToken();
            this.logger && this.logger.info('[Default IDE Token]', ideToken);
            if (!ideToken) {
                ideToken = await this.getIDEToken();
            }
            if (ideToken && ideToken.token) {
                return this.iCubeAuthClient.requestDeployToken(ideToken.token).then(res => {
                    this.logger && this.logger.info('[Request Deploy Token By IDE Token]', res, Number(new Date()) - start);
                    return res;
                });
            }
            else {
                return this.iCubeAuthClient.getAuthToken(index_extension_1.AuthPlatformTypes.Deploy, options);
            }
        }
        else {
            return this.iCubeAuthClient.getAuthToken(index_extension_1.AuthPlatformTypes.Deploy, options);
        }
    }
    async getAuthToken(app, options) {
        if (app === index_extension_1.AuthPlatformTypes.Ide) {
            return this.getIDEToken();
        }
        else if (app === index_extension_1.AuthPlatformTypes.Deploy) {
            await this.deployTokenReady;
            return this.iCubeAuthClient.getAuthToken(index_extension_1.AuthPlatformTypes.Deploy, options);
        }
        return this.iCubeAuthClient.getAuthToken(app, options);
    }
}
exports.AuthClient = AuthClient;
async function initUserConfig(options) {
    const { slardar, tea, logger, auth, getUserInfo } = options;
    try {
        if (process.env.VSCODE_RUN_IN_ELECTRON) {
            return;
        }
        const userInfo = getUserInfo ? await getUserInfo() : await auth.getUserInfo();
        logger.info(`UserInfo: ${JSON.stringify(userInfo)}`);
        if (userInfo && userInfo.userId) {
            return;
        }
        tea.config({ user: { user_unique_id: userInfo.userId } });
        slardar.config({ userId: userInfo.userId });
        const extra = {
            user_name: userInfo.name,
            tenant_id: userInfo.tenantId,
            user_id: userInfo.userId,
        };
        for (const [key, value] of Object.entries(extra)) {
            slardar.context?.set(key, value);
            tea.config({ custom: { [key]: value } });
        }
    }
    catch (error) {
        logger.error(`Get user info error: ${error.stack || error.message}`);
    }
}
exports.initUserConfig = initUserConfig;
