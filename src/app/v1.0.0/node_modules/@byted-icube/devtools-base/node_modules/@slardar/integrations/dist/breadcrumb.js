'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function id(v) {
    return v;
}

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isString(o) {
    return typeof o === 'string';
}

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}

var now = function () { return Date.now(); };

function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}

/**
 * from sentry https://github.com/getsentry/sentry-javascript/blob/5.30.0/packages/utils/src/browser.ts
 */
var UNKNOWN_PATH = '<unknown>';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 256; // be matched with the filtering rules of data reporting
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return UNKNOWN_PATH;
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el) {
    var _a, _b;
    var elem = el;
    var out = [];
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        return "#" + elem.id;
    }
    var className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
        }
    }
    var attrlist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrlist.length; i++) {
        key = attrlist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    // Check for siblings with the same selector
    var sibling = elem;
    var siblingIndex = 1;
    var isUnique = true;
    while ((sibling = sibling.previousElementSibling)) {
        if (((_a = sibling.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = elem.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            if (sibling.className === elem.className &&
                attrlist.every(function (attr) { return elem.getAttribute(attr) === (sibling === null || sibling === void 0 ? void 0 : sibling.getAttribute(attr)); })) {
                isUnique = false;
            }
            siblingIndex++;
        }
    }
    if (siblingIndex > 1 && !isUnique) {
        out.push(":nth-of-type(" + siblingIndex + ")");
    }
    return out.join('');
}

var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
var getConfig = function (c, defaultConfig) {
    if (isObject(c)) {
        return __assign(__assign({}, defaultConfig), c);
    }
    else {
        return c ? defaultConfig : false;
    }
};

var JS_ERROR_EV_TYPE = 'js_error';
var HTTP_EV_TYPE = 'http';

var CLICK_EVENT_NAME = 'click';
var CLICK_SUBJECT_NAME = CLICK_EVENT_NAME + "_0";
var DOM_EVENT_TYPE = 'dom';
var observeClick = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var removeListener = addListenerToDocument(document, CLICK_EVENT_NAME, next, true);
    tearDown(function () {
        removeListener();
    });
};
var clickSubject = [CLICK_SUBJECT_NAME, observeClick];
var KEYPRESS_EVENT_NAME = 'keypress';
var KEYPRESS_SUBJECT_NAME = KEYPRESS_EVENT_NAME + "_0";
var observeKeypress = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var removeListener = addListenerToDocument(document, KEYPRESS_EVENT_NAME, next, true);
    tearDown(function () {
        removeListener();
    });
};
var keypressSubject = [KEYPRESS_SUBJECT_NAME, observeKeypress];

/**
 * Creates breadcrumbs from DOM API calls
 */
var domBreadcrumb = function (addBreadcrumb) { return function (handlerData) {
    var target;
    // Accessing event.target can throw (see getsentry/raven-js#838, #768)
    try {
        target = handlerData.event.target
            ? htmlTreeAsString(handlerData.event.target)
            : htmlTreeAsString(handlerData.event);
    }
    catch (e) {
        target = UNKNOWN_PATH;
    }
    if (target.length === 0) {
        return;
    }
    addBreadcrumb({
        type: 'dom',
        category: "ui." + handlerData.name,
        message: target,
    });
}; };
var triggerHandlers = function (addBreadcrumb, type) {
    return function (data) {
        if (!type) {
            return;
        }
        try {
            addBreadcrumb(data);
        }
        catch (e) {
            // ignore
        }
    };
};
var applyDomAndKeyPress = function (debounceDuration) {
    var keypressTimeout;
    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param name the event name (e.g. "click")
     * @param handler function that will be triggered
     * @param debounce decides whether it should wait till another event loop
     * @returns wrapped breadcrumb events handler
     * @hidden
     */
    var domEventHandler = function (name, handler) {
        var lastCapturedEvent;
        return function (event) {
            // reset keypress timeout; e.g. triggering a 'click' after
            // a 'keypress' will reset the keypress debounce so that a new
            // set of keypress can be recorded
            keypressTimeout = undefined;
            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors). Ignore if we've
            // already captured the event.
            if (!event || lastCapturedEvent === event) {
                return;
            }
            lastCapturedEvent = event;
            handler({ event: event, name: name });
        };
    };
    /**
     * Wraps addEventListener to capture keypress UI events
     * @param handler function that will be triggered
     * @returns wrapped keypress events handler
     * @hidden
     */
    var keypressEventHandler = function (handler) {
        // debounce timeout is triggered, we will only capture
        // a single breadcrumb from the FIRST target (acceptable?)
        return function (event) {
            var target;
            try {
                target = event.target;
            }
            catch (e) {
                // just accessing event properties can throw an exception in some rare circumstances
                // see: https://github.com/getsentry/raven-js/issues/838
                return;
            }
            var tagName = target && target.tagName;
            // only consider keypress events on actual input elements
            // this will disregard keypress targeting body (e.g. tabbing
            // through elements, hotkeys, etc)
            if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)) {
                return;
            }
            // record first keypress in a series, but ignore subsequent
            // keypress until debounce clears
            !keypressTimeout && domEventHandler('input', handler)(event);
            clearTimeout(keypressTimeout);
            keypressTimeout = window.setTimeout(function () {
                keypressTimeout = undefined;
            }, debounceDuration);
        };
    };
    return [domEventHandler, keypressEventHandler];
};
var applyBreadcrumb = function (maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs) {
    if (maxBreadcrumbs === void 0) { maxBreadcrumbs = 20; }
    if (onAddBreadcrumb === void 0) { onAddBreadcrumb = id; }
    if (onMaxBreadcrumbs === void 0) { onMaxBreadcrumbs = function (bs, max) { return bs.slice(-max); }; }
    var breadcrumbs = [];
    var addBreadcrumb = function (breadcrumb) {
        var processed = onAddBreadcrumb(breadcrumb);
        if (processed) {
            var mergedBreadcrumb = __assign(__assign({}, processed), { timestamp: breadcrumb.timestamp || now() });
            breadcrumbs =
                maxBreadcrumbs >= 0 && breadcrumbs.length + 1 > maxBreadcrumbs
                    ? onMaxBreadcrumbs(__spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false), maxBreadcrumbs)
                    : __spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false);
        }
    };
    return [function () { return breadcrumbs; }, addBreadcrumb];
};

var breadcrumbGetterWithDomObserver = function (tearDownGroup, _a, config) {
    var _b = __read(_a, 2), clickObserver = _b[0], keypressObserver = _b[1];
    var maxBreadcrumbs = config.maxBreadcrumbs, onAddBreadcrumb = config.onAddBreadcrumb, onMaxBreadcrumbs = config.onMaxBreadcrumbs, dom = config.dom;
    var _c = __read(applyDomAndKeyPress(100), 2), domEventHandler = _c[0], keypressHandler = _c[1];
    var _d = __read(applyBreadcrumb(maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs), 2), getBreadcrumbs = _d[0], addBreadcrumb = _d[1];
    if (dom) {
        var createDomBreadcrumb = domBreadcrumb(addBreadcrumb);
        tearDownGroup.push(clickObserver[0](domEventHandler(CLICK_EVENT_NAME, triggerHandlers(createDomBreadcrumb, DOM_EVENT_TYPE))));
        tearDownGroup.push(keypressObserver[0](keypressHandler(triggerHandlers(createDomBreadcrumb, DOM_EVENT_TYPE))));
    }
    return [getBreadcrumbs, addBreadcrumb];
};

var BREADCRUMB_MONITOR_PLUGIN_NAME = 'breadcrumb';
var defaultConfig = {
    maxBreadcrumbs: 20,
    dom: true,
};
function BreadcrumbMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var _a = __read(breadcrumbGetterWithDomObserver(tearDownGroup, [initSubjectInGlobal(client, clickSubject), initSubjectInGlobal(client, keypressSubject)], config), 2), getBreadcrumbs = _a[0], addBreadcrumb = _a[1];
    var listenOtherReport = function (ev) {
        if (ev.ev_type === HTTP_EV_TYPE) {
            addBreadcrumb({
                type: HTTP_EV_TYPE,
                category: ev.payload.api,
                message: '',
                data: {
                    method: ev.payload.request.method,
                    url: ev.payload.request.url,
                    status_code: String(ev.payload.response.status),
                },
                timestamp: ev.payload.request.timestamp,
            });
        }
        return ev;
    };
    client.on('report', listenOtherReport);
    tearDownGroup.push(function () {
        client.off('report', listenOtherReport);
    });
    registerTearDownGroup(client, BREADCRUMB_MONITOR_PLUGIN_NAME, JS_ERROR_EV_TYPE, tearDownGroup);
    client.provide('getBreadcrumbs', getBreadcrumbs);
    client.provide('addBreadcrumb', addBreadcrumb);
}

var BREADCRUMB_INTEGRATION_NAME = BREADCRUMB_MONITOR_PLUGIN_NAME;
var breadcrumbPlugin = function (config) {
    if (config === void 0) { config = {}; }
    return ({
        name: BREADCRUMB_INTEGRATION_NAME,
        setup: function (client) {
            BreadcrumbMonitorBasePlugin(client, config);
        },
    });
};

exports.BREADCRUMB_INTEGRATION_NAME = BREADCRUMB_INTEGRATION_NAME;
exports.breadcrumbPlugin = breadcrumbPlugin;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/breadcrumb.js.map
