'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
var objProto = Object.prototype;
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}

var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultHistory() {
    // eslint-disable-next-line compat/compat
    return getDefaultBrowser() && window.history;
}

function parseUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url) {
        return {
            url: url,
            protocol: '',
            domain: '',
            query: '',
            path: '',
            hash: '',
        };
    }
    var a = document.createElement('a');
    a.href = url;
    var path = a.pathname || '/';
    /* istanbul ignore next */
    if (path[0] !== '/') {
        path = '/' + path;
    }
    return {
        url: a.href,
        protocol: a.protocol.slice(0, -1),
        domain: a.hostname,
        query: a.search.substring(1),
        path: path,
        hash: a.hash,
    };
}
function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var FIRST_PV_SUBJECT_NAME = 'f_view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyFirstPV = function (client) {
    return function (_, tearDown) {
        var firstOverrides = getOverrides(client);
        tearDown(noop, function (subscriber) {
            firstOverrides && subscriber(firstOverrides);
        });
    };
};

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};
var getConfig = function (c, defaultConfig) {
    if (isObject(c)) {
        return __assign(__assign({}, defaultConfig), c);
    }
    else {
        return c ? defaultConfig : false;
    }
};

var PAGEVIEW_EV_TYPE = 'pageview';
var SESSION_EV_TYPE = 'session';
var JS_ERROR_EV_TYPE = 'js_error';
var HTTP_EV_TYPE = 'http';
var RESOURCE_ERROR_EV_TYPE = 'resource_error';
var RESOURCE_EV_TYPE = 'resource';
var PERFORMANCE_METRIC_EV_TYPE = 'performance';
var LONG_TASK_EV_TYPE = 'performance_longtask';
var BLANK_SCREEN_EV_TYPE = 'blank_screen';
var ACTION_EV_TYPE = 'action';

var HIDDEN_SUBJECT_NAME = 'hidden_3';
var visibilityStateIsHidden = function (d) { return d.visibilityState === 'hidden'; };
var observeHidden = function (next, tearDown) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    // some browsers have buggy implementations of visibilitychange,
    // so we use pagehide in addition, just to be safe.
    var onVisibilityChangeOrPageHide = function (event) {
        next(event.type === 'pagehide' || visibilityStateIsHidden(document));
    };
    var removeVisibilityListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChangeOrPageHide, true);
    var removePageHideListener = addListenerToWindow(window, 'pagehide', onVisibilityChangeOrPageHide, true);
    tearDown(function () {
        removeVisibilityListener();
        removePageHideListener();
    }, function (subscriber) {
        subscriber(visibilityStateIsHidden(document));
    });
};
/**
 * When subscribing to hiddenSubject, it's important to note that it may immediately and synchronously trigger.
 */
var hiddenSubject = [HIDDEN_SUBJECT_NAME, observeHidden];
var readyStateIsComplete = function (d) { return d.readyState === 'complete'; };
var UNLOAD_SUBJECT_NAME = 'unload_0';
var observeUnload = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    var _a = __read(invokeCallbackOnce(next), 1), invokeCbOnce = _a[0];
    var unloadEventList = ['unload', 'beforeunload', 'pagehide'];
    var handler = function () {
        invokeCbOnce();
    };
    var tearDowns = [];
    unloadEventList.forEach(function (ev) {
        tearDowns.push(addListenerToWindow(window, ev, handler, false));
    });
    tearDown(function () {
        tearDowns.forEach(function (e) { return e(); });
    });
};
var unloadSubject = [UNLOAD_SUBJECT_NAME, observeUnload];

var HISTORY_SUBJECT_NAME = 'history_0';
var HASH_SUBJECT_NAME = 'hash_0';
var observeHistory = function (next, tearDown) {
    var history = getDefaultHistory();
    var window = getDefaultBrowser();
    if (!history || !window)
        return;
    var restoreFns = [];
    var historyChangeListener = function () { return next(location.href); };
    var hookStateChange = function (origin) {
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            try {
                origin.apply(history, params);
            }
            finally {
                historyChangeListener();
            }
        };
    };
    restoreFns.push(hookObjectProperty(history, 'pushState', hookStateChange)(), hookObjectProperty(history, 'replaceState', hookStateChange)());
    restoreFns.push(addListenerToWindow(window, 'popstate', historyChangeListener, true));
    tearDown(function () {
        restoreFns.forEach(function (fn) { return fn(); });
    });
};
var observeHash = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var hashChangeListener = function () { return next(location.href); };
    var removeListener = addListenerToWindow(window, 'hashchange', hashChangeListener, true);
    tearDown(function () {
        removeListener();
    });
};
var hashSubject = [HASH_SUBJECT_NAME, observeHash];
var historySubject = [HISTORY_SUBJECT_NAME, observeHistory];

var getDefaultExtractor = function (routeMode) { return function (url) {
    var _a;
    if (routeMode === 'hash') {
        return ((_a = parseUrl(url).hash) === null || _a === void 0 ? void 0 : _a.replace(/^#/, '')) || '/';
    }
    else {
        return parseUrl(url).path;
    }
}; };
var getViewId = function (pid) { return joinWithSeparator(pid, now()); };
var joinWithSeparator = function (a, b) { return a + "_" + b; };
var applyOnPidChange = function (cb, initPid, firstOriginPid, onPidUpdate) {
    // store originalPid from url
    var originalPid = firstOriginPid;
    // store finalPid send to server
    var finalPid = initPid;
    // set init pid in config
    onPidUpdate && onPidUpdate(initPid);
    var onPidChange = function (source, newPid, customPid) {
        // newPid is extractPid from url, should send pageview if changed, no matter customPid changed
        if (source !== "user_set" /* user_set */ && newPid !== originalPid) {
            originalPid = newPid;
            finalPid = customPid !== null && customPid !== void 0 ? customPid : originalPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
            // newPid is by user set, should send pageview if not equal to finalPid
        }
        else if (source === "user_set" /* user_set */ && newPid !== finalPid) {
            finalPid = newPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
        }
    };
    var sendInit = function () {
        initPid && cb("init" /* init */, initPid);
    };
    return [onPidChange, sendInit];
};
var applyOnUrlChange = function (cb, initUrl) {
    var url = initUrl;
    var onUrlChange = function (source, newUrl) {
        if (newUrl !== url) {
            url = newUrl;
            cb(source, url);
        }
    };
    return [onUrlChange];
};
var wrapPageview = function (source, pid) { return ({
    ev_type: PAGEVIEW_EV_TYPE,
    payload: {
        pid: pid,
        source: source,
    },
}); };
var applyReportPageview = function (report) {
    return function (source, pid) {
        report(wrapPageview(source, pid));
    };
};
var isManualMode = function (routeMode) { return routeMode === 'manual'; };
var ERROR_WEIGHT = 'error_weight';
var DURATION_APDEX = 'duration_apdex';
var PREF_APDEX = 'perf_apdex';
var ACTION_KEY = 'action';
var getDefaultApdexDetail = function () {
    var _a;
    return _a = {
            error_count: [0, 0, 0, 0],
            duration_count: [0, 0, 0]
        },
        _a[PREF_APDEX] = {},
        _a;
};
var getRank = function (apdex, setting) {
    var total = apdex[0 /* satisfying */] + apdex[1 /* tolerable */] + apdex[2 /* frustrating */];
    var s_percent = apdex[0 /* satisfying */] / total;
    var f_percent = apdex[2 /* frustrating */] / total;
    return f_percent > setting.frustrating_threshold
        ? 2 /* frustrating */
        : s_percent > setting.satisfying_threshold || total === 0
            ? 0 /* satisfying */
            : 1 /* tolerable */;
};
var calculateSpentTime = function () {
    // record spent time
    var spentTime = 0;
    var lastShowTimeStamp = undefined;
    var handleHidden = function (isHidden) {
        if (isHidden) {
            if (!lastShowTimeStamp)
                return;
            // set spentTime and reset last show timestamp
            spentTime += now() - lastShowTimeStamp;
            lastShowTimeStamp = undefined;
        }
        else {
            lastShowTimeStamp = now();
        }
    };
    var getSpentTime = function () {
        // correct the value of the last spent
        lastShowTimeStamp && (spentTime += now() - lastShowTimeStamp);
        var time = spentTime;
        // reset status
        spentTime = 0;
        lastShowTimeStamp = now();
        return time;
    };
    return [handleHidden, getSpentTime];
};
var applyCalculateWight = function (calculateDuration, calculateError) {
    return function (ev, apdexSetting) {
        var payload = ev.payload;
        switch (ev.ev_type) {
            case PERFORMANCE_METRIC_EV_TYPE:
                var name_1 = payload.name;
                if (payload.isSupport) {
                    calculateDuration(apdexSetting[PREF_APDEX], name_1, payload.value);
                }
                break;
            case ACTION_EV_TYPE:
                calculateDuration(apdexSetting[PREF_APDEX], ACTION_KEY, payload.duration || 0);
                break;
            case JS_ERROR_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 0);
                break;
            case HTTP_EV_TYPE:
                if (payload.response.is_custom_error || payload.response.status >= 400) {
                    calculateError(apdexSetting[ERROR_WEIGHT], 1);
                }
                else {
                    var timing = payload.response.timing;
                    timing && calculateDuration(apdexSetting[DURATION_APDEX], 0, timing.duration);
                }
                break;
            case RESOURCE_ERROR_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 2);
                break;
            case BLANK_SCREEN_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 3);
                break;
            case RESOURCE_EV_TYPE:
                calculateDuration(apdexSetting[DURATION_APDEX], 1, payload.duration);
                break;
            case LONG_TASK_EV_TYPE:
                payload.longtasks.forEach(function (l) {
                    calculateDuration(apdexSetting[DURATION_APDEX], 2, l.duration);
                });
                break;
        }
    };
};
var calculateApdex = function () {
    var apdexWeight;
    var apdexDetail;
    var initApdex = function () {
        apdexWeight = [0, 0, 0];
        apdexDetail = getDefaultApdexDetail();
    };
    // init apdex first
    initApdex();
    var calculateDurationWeight = function (weight, nameOrIndex, value) {
        var rules = weight && weight[nameOrIndex];
        // make sure all value is valuable
        if (!rules || value <= 0)
            return;
        var level = value < (rules[0 /* satisfying */].threshold || 0)
            ? 0 /* satisfying */
            : value > (rules[1 /* tolerable */].threshold || 0)
                ? 2 /* frustrating */
                : 1 /* tolerable */;
        apdexWeight[level] += rules[level].weight;
        if (typeof nameOrIndex === 'string') {
            var name_2 = joinWithSeparator(nameOrIndex, level);
            var value_1 = apdexDetail[PREF_APDEX][name_2];
            apdexDetail[PREF_APDEX][name_2] = (value_1 || 0) + 1;
        }
        else {
            level === 2 /* frustrating */ && (apdexDetail.duration_count[nameOrIndex] += 1);
        }
    };
    var calculateErrorWeight = function (weight, index) {
        if (!weight)
            return;
        apdexWeight[2 /* frustrating */] += weight[index];
        apdexDetail.error_count[index] += 1;
    };
    var getApdex = function () {
        return [apdexWeight, apdexDetail];
    };
    return [calculateDurationWeight, calculateErrorWeight, getApdex, initApdex];
};
var calculateSession = function () {
    var sessionPayload = {
        // use the current initialized time as start is more appropriate than navigationStart
        start: now(),
        end: 0,
        time_spent: 0,
        is_bounced: false,
        entry: '',
        exit: '',
        p_count: 0,
        a_count: 0,
    };
    var handleUnload = function (sessionApdexInfo, lastPage) {
        var _a = __read(sessionApdexInfo, 3), rank = _a[0], apdex = _a[1], apdex_detail = _a[2];
        sessionPayload.end = now();
        sessionPayload.time_spent += (lastPage && lastPage.time_spent) || 0;
        sessionPayload.last_page = lastPage;
        sessionPayload.p_count += 1;
        sessionPayload.rank = rank;
        sessionPayload.apdex = apdex;
        sessionPayload.apdex_detail = apdex_detail;
        var d = getDefaultDocument();
        d && (sessionPayload.is_bounced = !readyStateIsComplete(d));
    };
    var handlePageview = function (lastPage, newPid) {
        sessionPayload.time_spent += lastPage.time_spent;
        sessionPayload.p_count += 1;
        sessionPayload.exit = newPid;
    };
    var handleAction = function () {
        sessionPayload.a_count += 1;
    };
    var setEntry = function (entry) {
        sessionPayload.entry = entry;
        sessionPayload.exit = entry;
    };
    var getSessionPayload = function () { return sessionPayload; };
    return [handleUnload, handlePageview, handleAction, setEntry, getSessionPayload];
};

var pvGetterWithRouteObserver = function (report, tearDownGroup, routeObservers, config) {
    var sendInitFlag = config.sendInit, initPid = config.initPid, routeMode = config.routeMode, extractPid = config.extractPid, onPidUpdate = config.onPidUpdate;
    var extractPidFromUrl = isManualMode(routeMode) ? function () { return ''; } : getDefaultExtractor(routeMode);
    var customPidFromUrl = extractPid || (function () { return undefined; });
    var getFinalPid = function (url) { var _a; return (_a = customPidFromUrl(url)) !== null && _a !== void 0 ? _a : extractPidFromUrl(url); };
    var _a = __read(applyOnPidChange(applyReportPageview(report), initPid || getFinalPid(location.href), extractPidFromUrl(location.href), onPidUpdate), 2), onPidChange = _a[0], sendInit = _a[1];
    if (!isManualMode(routeMode)) {
        var _b = __read(applyOnUrlChange(function (sources, url) { return onPidChange(sources, extractPidFromUrl(url), customPidFromUrl(url)); }, ''), 1), onUrlChange_1 = _b[0];
        routeObservers.length &&
            routeObservers.forEach(function (routeObserver) {
                return tearDownGroup.push(routeObserver[0](function (value) { return onUrlChange_1(routeMode, value); }));
            });
    }
    if (sendInitFlag) {
        sendInit();
    }
    return [onPidChange.bind(null, "user_set" /* user_set */)];
};

var apdexGetterWithHiddenObserver = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), hiddenObserver = _b[0], unloadObserver = _b[1];
    var onlyPageApdex = config.apdex === 2;
    // record last page detail and current page info
    var currentPageInfo = undefined;
    var lastPidPayload = undefined;
    // apdex setting get from server, and not report any thing if not setting
    var apdexSetting = undefined;
    var apdexStarted = false;
    var _c = __read(calculateApdex(), 4), calculateDurationWeight = _c[0], calculateErrorWeight = _c[1], getApdex = _c[2], resetApdex = _c[3];
    var _d = __read(calculateApdex(), 4), calculateSessionDurationWeight = _d[0], calculateSessionErrorWeight = _d[1], getSessionApdex = _d[2], resetSessionApdex = _d[3];
    var _e = __read(calculateSession(), 5), handleUnload = _e[0], handlePageview = _e[1], handleAction = _e[2], setEntry = _e[3], getSessionPayload = _e[4];
    // record spent time
    var _f = __read(calculateSpentTime(), 2), handleHidden = _f[0], getSpentTime = _f[1];
    tearDownGroup.push(hiddenObserver[0](handleHidden));
    // send session event if need
    !onlyPageApdex &&
        tearDownGroup.push(unloadObserver[0](function () {
            if (!apdexStarted)
                return;
            var _a = __read(getSessionApdex(), 2), apdex = _a[0], detail = _a[1];
            var sessionRank = getRank(apdex, apdexSetting);
            handleUnload([sessionRank, apdex, detail], getPagePayload());
            report({
                ev_type: SESSION_EV_TYPE,
                payload: getSessionPayload(),
            });
            resetSessionApdex();
        }));
    var handlePageviewWeight = applyCalculateWight(calculateDurationWeight, calculateErrorWeight);
    var handleSessionWeight = applyCalculateWight(calculateSessionDurationWeight, calculateSessionErrorWeight);
    var handleSend = function (ev) {
        // make sure already have apdex setting and currentPid
        if (!apdexStarted)
            return;
        // always handle session weight if session flag is open
        if (!onlyPageApdex) {
            handleSessionWeight(ev, apdexSetting);
            ev.ev_type === ACTION_EV_TYPE && handleAction();
        }
        // discard asynchronous data to avoid affecting the apdex of the current pid.
        if (ev.common.pid !== currentPageInfo[1])
            return;
        handlePageviewWeight(ev, apdexSetting);
    };
    var getPagePayload = function () {
        var _a = __read(getApdex(), 2), apdex = _a[0], detail = _a[1];
        return {
            start: currentPageInfo[0],
            pid: currentPageInfo[1],
            view_id: currentPageInfo[2],
            end: now(),
            time_spent: getSpentTime(),
            apdex: apdex,
            rank: getRank(apdex, apdexSetting),
            detail: detail,
        };
    };
    var handlePageviewChange = function (newPid, newViewId) {
        // if no current page info, init current page, else settle current page and reset status
        if (!currentPageInfo) {
            currentPageInfo = [now(), newPid, newViewId];
            // set entry to session
            setEntry(newPid);
            // set started status
            apdexStarted = !!(apdexSetting && currentPageInfo);
            return;
        }
        if (apdexStarted) {
            // set last pid payload
            lastPidPayload = getPagePayload();
            // send last pid payload to session
            handlePageview(lastPidPayload, newPid);
        }
        // reset status
        currentPageInfo = [now(), newPid, newViewId];
        resetApdex();
    };
    var reportPageviewWithApdex = function (ev) {
        apdexStarted && (ev.payload.last = lastPidPayload);
        report(ev);
    };
    var setApdexSetting = function (apdex) {
        if (!apdex) {
            // teardown all effect
            tearDownGroup.forEach(function (e) { return e(); });
            tearDownGroup.length = 0;
            return;
        }
        apdexSetting = apdex;
        apdexStarted = !!(apdexSetting && currentPageInfo);
    };
    tearDownGroup.push(function () {
        apdexStarted = false;
    });
    return [handlePageviewChange, handleSend, reportPageviewWithApdex, setApdexSetting];
};

var PAGEVIEW_MONITOR_PLUGIN_NAME = 'pageview';
var defaultConfig = {
    sendInit: true,
    routeMode: 'history',
    apdex: 2,
};
function PageviewMonitorBasePlugin(client, c) {
    var _a;
    var config = getConfig(c, defaultConfig);
    if (!config || !getDefaultLocation()) {
        return;
    }
    var routeMode = config.routeMode, apdex = config.apdex;
    var report = client.report.bind(client);
    var handlePageviewChange = noop;
    // apdex start
    if (apdex) {
        var apdexTearDownGroup = [];
        var _b = __read(apdexGetterWithHiddenObserver(client.report.bind(client), apdexTearDownGroup, [initSubjectInGlobal(client, hiddenSubject), initSubjectInGlobal(client, unloadSubject)], config), 4), handlePageview = _b[0], handleSend_1 = _b[1], reportWithApdex = _b[2], setApdexSetting_1 = _b[3];
        report = reportWithApdex;
        handlePageviewChange = handlePageview;
        client.on('send', handleSend_1);
        apdexTearDownGroup.push(function () { return client.off('send', handleSend_1); });
        client.on('start', function () {
            setApdexSetting_1(client.config().apdex);
        });
        registerTearDownGroup(client, PAGEVIEW_MONITOR_PLUGIN_NAME, SESSION_EV_TYPE, apdexTearDownGroup);
    }
    // apdex end
    var tearDownGroup = [];
    var _c = __read(pvGetterWithRouteObserver(report, tearDownGroup, isManualMode(routeMode) ? [] : [client.initSubject(hashSubject), client.initSubject(historySubject)], __assign(__assign({}, config), { initPid: (_a = client.config()) === null || _a === void 0 ? void 0 : _a.pid, onPidUpdate: function (pid) {
            var viewId = getViewId(pid);
            // the apdex score must be settled when reporting, needs to know the change before reporting
            handlePageviewChange(pid, viewId);
            client.set({ pid: pid, viewId: viewId, actionId: undefined });
        } })), 1), sendPageview = _c[0];
    initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
    var onConfig = function () {
        sendPageview(client.config().pid);
    };
    client.on('config', onConfig);
    tearDownGroup.push(function () { return client.off('config', onConfig); });
    registerTearDownGroup(client, PAGEVIEW_MONITOR_PLUGIN_NAME, PAGEVIEW_EV_TYPE, tearDownGroup);
    client.provide('sendPageview', sendPageview);
}

var PAGEVIEW_INTEGRATION_NAME = PAGEVIEW_MONITOR_PLUGIN_NAME;
var pageviewPlugin = function (config) {
    if (config === void 0) { config = {}; }
    return ({
        name: PAGEVIEW_INTEGRATION_NAME,
        setup: function (client) {
            PageviewMonitorBasePlugin(client, config);
        },
    });
};

exports.PAGEVIEW_INTEGRATION_NAME = PAGEVIEW_INTEGRATION_NAME;
exports.pageviewPlugin = pageviewPlugin;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/pageview.js.map
