/* eslint-disable @typescript-eslint/no-implied-eval */
import { initPrivateSubject, isNumber } from '@slardar/sdk-template';
import { HEATMAP_EV_TYPE, applyPV, PV_SUBJECT_NAME, addListenerToWindow, onPageLoad, now } from '@slardar/sdk-web';
var HEATMAP_INTEGRATION_NAME = 'heatmap';
var DRAW_MARK = 'slardar_heatmap_draw';
var urlMatch = function (url) {
    var _a;
    var re = new RegExp(url, 'i');
    if ((_a = re.test) === null || _a === void 0 ? void 0 : _a.call(re, location.href)) {
        return true;
    }
    return false;
};
var getMatchList = function (openList) {
    return openList.filter(function (item) {
        return urlMatch(item.monitor_url);
    });
};
// throttle interval is recommended to be within 250 ms
var throttle = function (callback, interval) {
    if (interval === void 0) { interval = 200; }
    var time;
    return function (event) {
        var nowTime = now();
        if (!time || nowTime - time > interval) {
            callback(event);
            time = nowTime;
        }
    };
};
// debounce interval is recommended to set within the range of 500 to 1000 ms
var debounce = function (callback, interval) {
    if (interval === void 0) { interval = 800; }
    var timers;
    return function (event) {
        // 清除之前的定时器
        if (timers !== undefined) {
            clearTimeout(timers);
        }
        // 设置新的定时器
        timers = setTimeout(function () {
            callback(event);
        }, interval);
    };
};
export var getLocationSearch = function (location) {
    if (location === void 0) { location = window.location; }
    var search = location.search, hash = location.hash;
    // support hash router like: '/path/#hash?draw=1', which location is: { search: '', hash: '#hash?draw=1'}
    var searchIndexInHash = hash.indexOf('?');
    if (!search.length && searchIndexInHash > 0) {
        return hash.slice(searchIndexInHash);
    }
    return search;
};
var getXPath = function (elem) {
    var nodeElem = elem;
    if (nodeElem.id) {
        return "//*[@id=\"" + nodeElem.id + "\"]";
    }
    var parts = [];
    while (nodeElem && nodeElem.nodeType === Node.ELEMENT_NODE) {
        var nbOfPreviousSiblings = 0;
        var hasNextSiblings = false;
        var sibling = nodeElem.previousSibling;
        while (sibling) {
            if (sibling.nodeType !== Node.DOCUMENT_TYPE_NODE && sibling.nodeName === nodeElem.nodeName) {
                nbOfPreviousSiblings++;
            }
            sibling = sibling.previousSibling;
        }
        sibling = nodeElem.nextSibling;
        while (sibling) {
            if (sibling.nodeName === nodeElem.nodeName) {
                hasNextSiblings = true;
                break;
            }
            sibling = sibling.nextSibling;
        }
        var prefix = nodeElem.prefix ? nodeElem.prefix + ':' : '';
        var nth = nbOfPreviousSiblings || hasNextSiblings ? "[" + (nbOfPreviousSiblings + 1) + "]" : '';
        parts.unshift(prefix + nodeElem.localName + nth);
        nodeElem = nodeElem.parentNode;
    }
    return parts.length ? '/' + parts.join('/') : '';
};
var handleScrollData = function (event, _b) {
    var _c, _d;
    var trackRootScroll = _b.trackRootScroll;
    var xpath;
    var target = event.target;
    try {
        xpath = target ? getXPath(target) : getXPath(event);
        // handle the document element with special consideration during scroll event
        if (target && trackRootScroll && target.nodeType === Node.DOCUMENT_NODE) {
            xpath = '/html';
            target = document.documentElement;
        }
    }
    catch (e) {
        xpath = '<unknown>';
    }
    if (xpath.length === 0) {
        return;
    }
    var startY = (_c = target === null || target === void 0 ? void 0 : target.scrollTop) !== null && _c !== void 0 ? _c : 0;
    var scrollX = (_d = target === null || target === void 0 ? void 0 : target.scrollLeft) !== null && _d !== void 0 ? _d : 0;
    // when startY === 0 &  scrollX > 0, it is considered horizontal scrolling and needs to be discarded.
    if (startY === 0 && scrollX > 0) {
        return;
    }
    return {
        xpath: xpath,
        start_y: startY,
        end_y: target ? (target.clientHeight || 0) + startY : 0,
    };
};
var handleMouseData = function (event) {
    var _b, _c;
    var xpath;
    try {
        xpath = event.target ? getXPath(event.target) : getXPath(event);
    }
    catch (e) {
        xpath = '<unknown>';
    }
    if (xpath.length === 0) {
        return;
    }
    var _d = event.target.getBoundingClientRect(), left = _d.left, top = _d.top;
    if (isNumber(event.pageX) && isNumber(event.pageY)) {
        return {
            xpath: xpath,
            offset_x: (_b = Math.round(event.pageX - document.documentElement.scrollLeft - left)) !== null && _b !== void 0 ? _b : 0,
            offset_y: (_c = Math.round(event.pageY - document.documentElement.scrollTop - top)) !== null && _c !== void 0 ? _c : 0,
        };
    }
    else {
        return undefined;
    }
};
var heatmapMonitor = function (report, flags) {
    var monitorList = [];
    var tearDown = [];
    var handleEvent = function (eventData, evtType) {
        if (eventData && eventData.xpath) {
            monitorList.forEach(function (_b) {
                var _c;
                var heat_map_id = _b.heat_map_id;
                report({
                    // @ts-expect-error
                    ev_type: 'heat_map',
                    payload: (_c = {
                            type: 'post',
                            name: 'HeatmapMonitor',
                            heat_map_id: heat_map_id
                        },
                        _c[evtType] = eventData,
                        _c),
                });
            });
        }
    };
    var collectMouseEvent = function () {
        // click and mousemove events prefer to use throttle to collect continuous data
        var throttleEventList = ['click', 'mousemove'];
        throttleEventList.forEach(function (evtType) {
            var handler = function (event) {
                var eventData = handleMouseData(event);
                handleEvent(eventData, evtType);
            };
            tearDown.push(addListenerToWindow(window, evtType, throttle(handler), false));
        });
        // mouseover events prefer to use debounce to reflect the user's focus on page elements
        var handleMouseOver = function (event) {
            var eventData = handleMouseData(event);
            handleEvent(eventData, 'mouseover');
        };
        tearDown.push(addListenerToWindow(window, 'mouseover', debounce(handleMouseOver), false));
    };
    var collectScrollEvent = function () {
        var evtType = 'scroll';
        var handler = function (event) {
            var eventData = handleScrollData(event, flags);
            handleEvent(eventData, evtType);
        };
        tearDown.push(addListenerToWindow(window, evtType, throttle(handler), true));
    };
    var collectEvent = function (list) {
        monitorList = list;
        onPageLoad(function () {
            collectMouseEvent();
            collectScrollEvent();
        });
    };
    var stopCollect = function () {
        tearDown.forEach(function (fn) { return fn(); });
        tearDown = [];
        monitorList = [];
    };
    return { collectEvent: collectEvent, stopCollect: stopCollect };
};
var setupHeatmapDraw = function (config, getPVObserver, drawUrl) {
    var _b;
    if (!window || !document) {
        return;
    }
    var scriptOnload = function () {
        window.setTimeout(function () {
            if (!window.drawHeatmap)
                return;
            window.drawHeatmap(config, getPVObserver);
        }, 0);
    };
    if (window.drawHeatmap) {
        scriptOnload();
    }
    var script = document.createElement('script');
    script.src = drawUrl;
    // eslint-disable-next-line compat/compat
    (_b = document.head) === null || _b === void 0 ? void 0 : _b.appendChild(script);
    script.onload = scriptOnload;
};
var setupHeatmap = function (flags, config, report, getPVObserver, tearDown) {
    var open_list = config.open_list;
    var _b = heatmapMonitor(report, flags), collectEvent = _b.collectEvent, stopCollect = _b.stopCollect;
    // setup heatmap
    var originList = getMatchList(open_list);
    originList.length > 0 && collectEvent(originList);
    // re-setup heatmap if needed when pid change
    var onPidChange = function () {
        stopCollect();
        // wait 100ms to make sure location.href have changed
        setTimeout(function () {
            var monitorList = getMatchList(open_list);
            monitorList.length > 0 && collectEvent(monitorList);
        }, 100);
    };
    var pvObserver = getPVObserver();
    tearDown.push(pvObserver[0](function () {
        onPidChange();
    }));
    tearDown.push(function () {
        stopCollect();
    });
};
export var heatmap = function (flags) {
    if (flags === void 0) { flags = { trackRootScroll: false }; }
    return {
        name: HEATMAP_INTEGRATION_NAME,
        setup: function (client) {
            // on start lifecycle to make sure can get server config
            client.on('start', function () {
                var _b;
                var heatmapConfig = (_b = client.config()) === null || _b === void 0 ? void 0 : _b.plugins[HEATMAP_INTEGRATION_NAME];
                if (!heatmapConfig) {
                    return;
                }
                // identify DrawMode or MonitorMode
                var isDrawMode = getLocationSearch().indexOf(DRAW_MARK) !== -1;
                if (isDrawMode) {
                    var drawUrl = client.config().pluginPathPrefix + "/heatmap-draw.js";
                    setupHeatmapDraw(heatmapConfig, function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); }, drawUrl);
                    return;
                }
                // open_list.length === 0 means there are no ongoing heatmap experiments, so don't need to setup heatmap monitor
                var _c = heatmapConfig.open_list, open_list = _c === void 0 ? [] : _c;
                if (!open_list.length) {
                    return;
                }
                // startup heatmap monitor
                var tearDown = [];
                setupHeatmap(flags, { open_list: open_list }, function (args) { return client.report(args); }, function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); }, tearDown);
                client.destroyAgent.set(HEATMAP_INTEGRATION_NAME, HEATMAP_EV_TYPE, tearDown);
            });
        },
    };
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/esm/heatmap.js.map