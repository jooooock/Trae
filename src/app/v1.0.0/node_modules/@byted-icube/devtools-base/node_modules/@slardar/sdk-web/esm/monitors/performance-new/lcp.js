import { __read } from "tslib";
import { observePerfWithBuffer } from '../../collector';
import { visibilityStateIsHidden } from '../../collector/page';
import { getDefaultPerformanceObserver, htmlTreeAsString, addListenerToDocument, getDefaultDocument } from '../../utils';
import { initMetric } from '../performance/util';
import { applySendOnceAndTearDown, wrapPerformanceMetric, getActivationStart } from './util';
export var LCP_ENTRY_NAME = 'largest-contentful-paint';
export var LCP_METRIC_NAME = "lcp" /* lcp */;
var LCPListenerEventTypes = ['keydown', 'click'];
var getLCP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), activatedObserver = _b[0], getHiddenObserver = _b[1], getUnloadObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var document = getDefaultDocument();
    var metric = initMetric(LCP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!PerformanceObserver || !document) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var handleActivated = function () {
        // if the page is initially hidden or still hidden after prerendering
        // that means the tab was activated in a background state, so it is marked as unsupported
        if (visibilityStateIsHidden(document)) {
            metric.isSupport = false;
            sendOnceAndTearDown(metric);
            return;
        }
        tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, 
        // @ts-expect-error
        function (_a) {
            var startTime = _a.startTime, element = _a.element;
            // should be relative to page activation rather than navigation start if the page was pre-rendered.
            // but in cases where `activationStart` occurs after the LCP, this time should be clamped at 0.
            var activatedTimeStamp = getActivationStart();
            metric.value = startTime < activatedTimeStamp ? 0 : startTime - activatedTimeStamp;
            if (element) {
                try {
                    metric.extra = {
                        element: htmlTreeAsString(element),
                    };
                }
                catch (_b) {
                    // do nothing
                }
            }
        }, LCP_ENTRY_NAME));
        var inputEventHandler = function () {
            // wrap in a setTimeout so the callback is run in a separate task
            // to avoid extending the keyboard/click handler to reduce INP impact
            setTimeout(function () {
                sendOnceAndTearDown(metric);
            }, 0);
        };
        LCPListenerEventTypes.forEach(function (type) {
            tearDownGroup.push(addListenerToDocument(document, type, inputEventHandler, true));
        });
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            metric.isBounced = true;
            sendOnceAndTearDown(metric);
        }));
        var hiddenCallback = function (isHidden) {
            if (isHidden) {
                // if initially not hidden but suddenly becomes hidden, then the metric can be settle.
                sendOnceAndTearDown(metric);
            }
        };
        // hiddenObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        var hiddenObserver = getHiddenObserver();
        tearDownGroup.push(function () { return hiddenObserver[1](hiddenCallback); });
        hiddenObserver[0](hiddenCallback);
    };
    // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return activatedObserver[1](handleActivated); });
    activatedObserver[0](handleActivated);
};
export var LCP = [LCP_METRIC_NAME, getLCP];//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/sdk-web/esm/monitors/performance-new/lcp.js.map