'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function promisifyRequest(request) {
    return new Promise((resolve, reject) => {
        // @ts-ignore - file size hacks
        request.oncomplete = request.onsuccess = () => resolve(request.result);
        // @ts-ignore - file size hacks
        request.onabort = request.onerror = () => reject(request.error);
    });
}
function createStore(dbName, storeName) {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    const dbp = promisifyRequest(request);
    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
    if (!defaultGetStoreFunc) {
        defaultGetStoreFunc = createStore('keyval-store', 'keyval');
    }
    return defaultGetStoreFunc;
}
/**
 * Update a value. This lets you see the old value and update it as an atomic operation.
 *
 * @param key
 * @param updater A callback that takes the old value and returns a new value.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function update(key, updater, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => 
    // Need to create the promise manually.
    // If I try to chain promises, the transaction closes in browsers
    // that use a promise polyfill (IE10/11).
    new Promise((resolve, reject) => {
        store.get(key).onsuccess = function () {
            try {
                store.put(updater(this.result), key);
                resolve(promisifyRequest(store.transaction));
            }
            catch (err) {
                reject(err);
            }
        };
    }));
}

var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}

var applyRequestIdleCallback = function (win) {
    return (win.requestIdleCallback ||
        function (cb) {
            return win.setTimeout(cb, 1);
        });
};

var OFFLINE_INTEGRATION_NAME = 'offline';
var IndexedDB_Name = "__" + OFFLINE_INTEGRATION_NAME + "__db__";
var IndexedDB_Store_Name = "__" + OFFLINE_INTEGRATION_NAME + "__store__";
var MaxSendSize = 60;
var MaxStoreEvents = 60;
var SendIntervalTime = 2000;
var CONTEXT_FLAG = "_is_" + OFFLINE_INTEGRATION_NAME + "_";
var offlineIntegration = function (props) {
    var tearDownGroup = [];
    return {
        name: OFFLINE_INTEGRATION_NAME,
        setup: function (client) {
            var win = getDefaultBrowser();
            if (!win || !indexedDB)
                return;
            var maxStoreEvents = (props && props.maxStoreEvents) || MaxStoreEvents;
            var maxSendSize = (props && props.maxSendSize) || MaxSendSize;
            var isPostDataFailed = false;
            var _a = client.config(), transport = _a.transport, bid = _a.bid;
            var storeKey = bid;
            var sender = client.getSender();
            var isOffline = getOffline();
            var requestIdleCallback = applyRequestIdleCallback(win);
            /**
             * report the data where cached on indexedDB
             * @param data
             * @param fail
             */
            var postData = function (data, success, fail) {
                transport.post({
                    url: sender.getEndpoint(),
                    data: data,
                    success: success,
                    fail: function (err) {
                        fail(err, data);
                    },
                });
            };
            var initialization = function () {
                var offlineStore = createStore(IndexedDB_Name, IndexedDB_Store_Name);
                var handleFailCallback = function (_err, batchStringData) {
                    var data;
                    try {
                        var batchData = JSON.parse(batchStringData);
                        data = batchData.list;
                    }
                    catch (_a) {
                        // do nothing
                    }
                    isPostDataFailed = true;
                    if (data) {
                        data.forEach(function (event) { return (event.common.context[CONTEXT_FLAG] = '1'); });
                        void insertData(offlineStore, storeKey, data, maxStoreEvents);
                    }
                };
                var sendEvents = function () { return __awaiter(void 0, void 0, void 0, function () {
                    var events;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, spliceStore(offlineStore, storeKey, maxSendSize)];
                            case 1:
                                events = _a.sent();
                                if (events.length && !isPostDataFailed) {
                                    postData(stringifyBatch(events), function () { return setTimeout(function () { return void sendEvents(); }, SendIntervalTime); }, handleFailCallback);
                                }
                                return [2 /*return*/];
                        }
                    });
                }); };
                sender.fail && sender.fail(handleFailCallback);
                tearDownGroup.push(onlineListener(sendEvents));
                // send events immediately as soon as initialization completes
                if (!isOffline())
                    void sendEvents();
            };
            var onStart = function () {
                return requestIdleCallback(function () {
                    void initialization();
                });
            };
            client.on('start', onStart);
            tearDownGroup.push(function () { return client.off('start', onStart); });
        },
        tearDown: function () { return tearDownGroup.forEach(function (fn) { return fn(); }); },
    };
};
function insertData(store, storeKey, events, maxStoreEvents) {
    if (maxStoreEvents === void 0) { maxStoreEvents = MaxStoreEvents; }
    return __awaiter(this, void 0, void 0, function () {
        var error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, update(storeKey, function (oldData) {
                            if (!Array.isArray(oldData))
                                return events;
                            var mergedData = oldData.concat(events);
                            return mergedData.length > maxStoreEvents
                                ? mergedData.slice(mergedData.length - maxStoreEvents, mergedData.length)
                                : mergedData;
                        }, store)];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    // may be throw error like an object can't be cloned
                    console.info('indexedDB update error', error_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function spliceStore(store, storeKey, deleteCount) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = [];
                    return [4 /*yield*/, update(storeKey, function (val) {
                            if (val) {
                                result = val.splice(0, deleteCount);
                                return val;
                            }
                            return [];
                        }, store)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
/**
 * return false if window or navigator.onLine is undefined
 * @returns
 */
function getOffline() {
    var window = getDefaultBrowser();
    if (!(window && 'navigator' in window && 'onLine' in window.navigator))
        return function () { return false; };
    return function () { return !window.navigator.onLine; };
}
function onlineListener(callback) {
    var window = getDefaultBrowser();
    if (window && 'addEventListener' in window) {
        window.addEventListener('online', callback);
        return function () { return window.removeEventListener('online', callback); };
    }
    return function () { };
}

exports.CONTEXT_FLAG = CONTEXT_FLAG;
exports.IndexedDB_Name = IndexedDB_Name;
exports.IndexedDB_Store_Name = IndexedDB_Store_Name;
exports.OFFLINE_INTEGRATION_NAME = OFFLINE_INTEGRATION_NAME;
exports.SendIntervalTime = SendIntervalTime;
exports.getOffline = getOffline;
exports.insertData = insertData;
exports.offlineIntegration = offlineIntegration;
exports.onlineListener = onlineListener;
exports.spliceStore = spliceStore;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/offline.js.map
