'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isUndefined(o) {
    return o === undefined;
}
var objProto = Object.prototype;
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}

// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var applyRecord = function () {
    var record = {};
    var set = function (key, val) { return (record[key] = val); };
    var del = function (key) { return delete record[key]; };
    return [record, set, del];
};

function getRegexp(ignore) {
    if (!isArray(ignore)) {
        return null;
    }
    return ignore.length ? joinRegExp(ignore) : null;
}
function joinRegExp(patterns) {
    var sources = [];
    var len = patterns.length;
    for (var i = 0; i < len; i++) {
        var pattern = patterns[i];
        if (isString(pattern)) {
            sources.push(pattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'));
        }
        else if (pattern && pattern.source) {
            sources.push(pattern.source);
        }
    }
    return new RegExp(sources.join('|'), 'i');
}
var checkIfHit = function (rules, url) {
    var Rgx = getRegexp(rules || []);
    return !!Rgx && Rgx.test(url);
};

/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}

function getFullUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url)
        return '';
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}
function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var reportWithCurrentContext = function (client, timeRequiresAdjustment) {
    if (timeRequiresAdjustment === void 0) { timeRequiresAdjustment = false; }
    var overrides = getOverrides(client);
    timeRequiresAdjustment && (overrides.timestamp = now());
    return function (ev) {
        client.report(__assign(__assign({}, ev), { overrides: overrides }));
    };
};

var applyMutationObserver = function (MutationObserver, callback) {
    // eslint-disable-next-line compat/compat
    var observer = MutationObserver && new MutationObserver(callback);
    var observe = function (target, options) {
        observer && target && observer.observe(target, options);
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
var applyPerformance = function (performance) {
    // eslint-disable-next-line compat/compat
    var timing = (performance && performance.timing) || undefined;
    var now = function () {
        if (performance && performance.now)
            return performance.now();
        var time = Date.now ? Date.now() : +new Date();
        var start = (timing && timing.navigationStart) || 0;
        return time - start;
    };
    var getEntriesByType = function (type) {
        var getEntriesByType = (performance || {}).getEntriesByType;
        return (isFunction(getEntriesByType) && getEntriesByType.call(performance, type)) || [];
    };
    var getEntriesByName = function (name) {
        var getEntriesByName = (performance || {}).getEntriesByName;
        return (isFunction(getEntriesByName) && getEntriesByName.call(performance, name)) || [];
    };
    var clearResourceTiming = function () {
        var clearResourceTimings = (performance || {}).clearResourceTimings;
        isFunction(clearResourceTimings) && clearResourceTimings.call(performance);
    };
    return [timing, now, getEntriesByType, clearResourceTiming, getEntriesByName];
};

/**
 * from sentry https://github.com/getsentry/sentry-javascript/blob/5.30.0/packages/utils/src/browser.ts
 */
var UNKNOWN_PATH = '<unknown>';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 256; // be matched with the filtering rules of data reporting
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return UNKNOWN_PATH;
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el) {
    var _a, _b;
    var elem = el;
    var out = [];
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        return "#" + elem.id;
    }
    var className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
        }
    }
    var attrlist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrlist.length; i++) {
        key = attrlist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    // Check for siblings with the same selector
    var sibling = elem;
    var siblingIndex = 1;
    var isUnique = true;
    while ((sibling = sibling.previousElementSibling)) {
        if (((_a = sibling.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = elem.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            if (sibling.className === elem.className &&
                attrlist.every(function (attr) { return elem.getAttribute(attr) === (sibling === null || sibling === void 0 ? void 0 : sibling.getAttribute(attr)); })) {
                isUnique = false;
            }
            siblingIndex++;
        }
    }
    if (siblingIndex > 1 && !isUnique) {
        out.push(":nth-of-type(" + siblingIndex + ")");
    }
    return out.join('');
}

var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};

var XHR_SUBJECT_NAME = 'xhr_0';
var getReportPathRegExp = function () {
    var SELF_REPORT_PATH_REGEXP = new RegExp('\\/monitor_web\\/collect|\\/monitor_browser\\/collect\\/batch', 'i');
    return function (url) { return SELF_REPORT_PATH_REGEXP.test(url); };
};
var hookOpen = function (open) {
    return function () {
        var _a;
        var openOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            openOptions[_i] = arguments[_i];
        }
        _a = __read(openOptions, 2), this._method = _a[0], this._url = _a[1];
        return open.apply(this, openOptions);
    };
};
var hookSetHeader = function (setRequestHeader) {
    return function () {
        var setOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            setOptions[_i] = arguments[_i];
        }
        this._reqHeaders = this._reqHeaders || {};
        var _a = __read(setOptions, 2), name = _a[0], value = _a[1];
        this._reqHeaders[name] = value;
        return setRequestHeader && setRequestHeader.apply(this, setOptions);
    };
};
var hookOnreadystatechange = function (xhr, endNext) {
    return hookMethodDangerously(xhr, 'onreadystatechange', function (origin) {
        return function () {
            var ev = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ev[_i] = arguments[_i];
            }
            // @ts-expect-error
            this.readyState === 4 && endNext(xhr);
            return origin && origin.apply(this, ev);
        };
    });
};
var hookSend = function (send, next) {
    var hitReportPath = getReportPathRegExp();
    return function () {
        var sendOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sendOptions[_i] = arguments[_i];
        }
        this._start = now();
        this._data = sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions[0];
        // not trigger the xhr subject if hit the report path
        if (!hitReportPath(this._url)) {
            var endNext = next([this._method, this._url, this._start, this]);
            hookOnreadystatechange(this, endNext)();
        }
        return send.apply(this, sendOptions);
    };
};
var applyXHR = function (xhr) {
    return function (next, tearDown) {
        if (!xhr)
            return;
        var tearDownGroup = [];
        tearDownGroup.push(hookMethodDangerously(xhr, 'open', hookOpen)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'setRequestHeader', hookSetHeader)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'send', hookSend)(next));
        tearDown(function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    };
};
var FETCH_SUBJECT_NAME = 'fetch_0';
var hookFetch = function (_fetch, next) {
    return function (req, options) {
        if (options === void 0) { options = {}; }
        var endNext = next([req, options]);
        var fetchPromise = _fetch(req, options);
        fetchPromise.then(function (res) {
            // @ts-expect-error
            endNext(res);
        }, function () {
            // @ts-expect-error
            endNext(undefined);
        });
        return fetchPromise;
    };
};
var observeFetch = function (next, tearDown) {
    var global = getDefaultBrowser();
    if (!global || !fetch)
        return;
    var tearDownGroup = [];
    tearDownGroup.push(hookMethodDangerously(global, 'fetch', hookFetch)(next));
    tearDown(function () {
        tearDownGroup.forEach(function (e) { return e(); });
    });
};
var fetchSubject = [FETCH_SUBJECT_NAME, observeFetch];

var RESOURCE_TYPE = ['resource']; // used by resourceMonitor / resourceErrorMonitor / HttpMonitor
var LONGTASK_TYPE = ['longtask']; // used by ttiMonitor / longtaskMonitor / actionMonitor / mpfidMonitor
var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type, durationThreshold) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            var options = { type: type, buffered: true };
            !isUndefined(durationThreshold) && (options.durationThreshold = durationThreshold);
            observer.observe(options);
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerf = function (Ob, pipe, types) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), observe = _a[0], disconnect = _a[2];
    observe(types);
    return disconnect;
};
var LONGTASK_SUBJECT_NAME = 'longtask_0';
var observeLongtask = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, LONGTASK_TYPE));
};
var longtaskSubject = [LONGTASK_SUBJECT_NAME, observeLongtask];
var RESOURCE_SUBJECT_NAME = 'resource_0';
var observeResource = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    var hitReportPath = getReportPathRegExp();
    tearDown(observePerf(PerformanceObserver, function (entry) {
        !hitReportPath(entry.name) && next(entry);
    }, RESOURCE_TYPE));
};
var resourceSubject = [RESOURCE_SUBJECT_NAME, observeResource];

var PAGEVIEW_EV_TYPE = 'pageview';
var JS_ERROR_EV_TYPE = 'js_error';
var HTTP_EV_TYPE = 'http';
var RESOURCE_ERROR_EV_TYPE = 'resource_error';
var RESOURCE_EV_TYPE = 'resource';
var LONG_TASK_EV_TYPE = 'performance_longtask';
var ACTION_EV_TYPE = 'action';

var PAGE_ACTIVITY_DELAY = 100;
var ROOT_TAGS = ['BODY', 'HTML', 'HEAD'];
var SVG_TAG = 'SVG';
var DEFAULT_ATTR_NAME = 'data-apm-action';
/**
 * 控制等待策略和强制结算
 * 结算策略: 没有进行中的请求, 没有dom变更, 没有resource or longTask
 */
var waitActionComplete = function (win, cb, forceClear, maxTimeOut) {
    var idleTimer;
    var maxIdleTimer;
    var started = false;
    var notify = function () {
        win.clearTimeout(idleTimer);
        started &&
            (idleTimer = win.setTimeout(function () {
                cb();
            }, PAGE_ACTIVITY_DELAY));
    };
    var start = function () {
        started = true;
        win.clearTimeout(maxIdleTimer);
        maxIdleTimer = win.setTimeout(function () {
            cb(true);
            forceClear();
        }, maxTimeOut);
        notify();
    };
    var complete = function () {
        started = false;
        win.clearTimeout(idleTimer);
        win.clearTimeout(maxIdleTimer);
    };
    return [start, notify, complete];
};
var isSupportsElementClosest = (function () {
    var supportsElementClosest;
    return function () {
        return supportsElementClosest === undefined
            ? (supportsElementClosest = 'closest' in HTMLElement.prototype)
            : supportsElementClosest;
    };
})();
var findElementWithAttributeByParents = function (target, attribute, maxParentLoops) {
    if (maxParentLoops === void 0) { maxParentLoops = 10; }
    var element = target;
    for (var i = 0; i < maxParentLoops && element; i++) {
        if (~ROOT_TAGS.indexOf(element.nodeName))
            return;
        if (element.hasAttribute(attribute)) {
            return element;
        }
        element = element.parentElement;
    }
};
var getActionNameByAttribute = function (target, attribute) {
    var elementWithAttribute;
    if (isSupportsElementClosest()) {
        elementWithAttribute = target.closest("[" + attribute + "]");
    }
    else {
        elementWithAttribute = findElementWithAttributeByParents(target, attribute);
    }
    if (!elementWithAttribute)
        return;
    var name = elementWithAttribute.getAttribute(attribute);
    // Possibly length of name is too long to be stored on backend.Let it go for now.Add truncation if someone oncalled
    return name.trim();
};
var getActionName = function (target, attribute) {
    return getActionNameByAttribute(target, attribute) || target.innerText;
};
var isSVGTarget = function (element) {
    var current = element;
    var flag = false;
    while (current) {
        if (current.tagName.toUpperCase() === SVG_TAG) {
            current = null;
            flag = true;
        }
        else {
            current = current.parentElement;
        }
    }
    return flag;
};
var isElementWithinTwoLevels = function (element) {
    var childElement = element.children;
    return childElement.length ? ![].slice.call(childElement).some(function (c) { return c.children.length > 0; }) : true;
};
var isValidTarget = function (element) {
    // if not element node or is root element or is svg
    var tagName = element.tagName.toUpperCase();
    if (element.nodeType !== 1 || ROOT_TAGS.includes(tagName) || isSVGTarget(element)) {
        return false;
    }
    // if element display none
    if (element.style && element.style.display === 'none') {
        return false;
    }
    // if is allowed TagName or has special attribute
    if (['A', 'BUTTON', 'INPUT', 'TEXTAREA'].includes(tagName) || getActionNameByAttribute(element, DEFAULT_ATTR_NAME)) {
        return true;
    }
    // if element not within two levels
    if (!isElementWithinTwoLevels(element)) {
        return false;
    }
    return true;
};
var shouldIgnoreUrl = function (ignoreUrls, url) {
    return !!(ignoreUrls && ignoreUrls.length && url && checkIfHit(ignoreUrls, getFullUrl(url)));
};
var shouldIgnoreEvent = function (ignoreUrls, ev) {
    var url;
    if (ev.ev_type === HTTP_EV_TYPE) {
        url = ev.payload.request.url;
    }
    else if (ev.ev_type === RESOURCE_EV_TYPE && 'name' in ev.payload) {
        url = ev.payload.name;
    }
    else if (ev.ev_type === RESOURCE_ERROR_EV_TYPE) {
        url = ev.payload.url;
    }
    return shouldIgnoreUrl(ignoreUrls, url);
};

var SUPPORT_TYPES = ["click" /* CLICK */];
var EVENT_LISTENER_OPTIONS = { capture: true };
var MIN_LONG_TASK = 50;
var MAX_ACTIVITY_DELAY = 10000;
/**
 * Hook XHR & fetch to monitor the number of incomplete requests on the current page.
 */
var applyIncompleteReq = function (tearDownGroup, _a, notify, ignoreUrls) {
    var _b = __read(_a, 2), xhrObserver = _b[0], fetchObserver = _b[1];
    var _c = __read(applyRecord(), 3), incompleteReq = _c[0], before = _c[1], after = _c[2];
    var uniqId = 0;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 2); _b[0]; var _url = _b[1];
        if (shouldIgnoreUrl(ignoreUrls, _url)) {
            return noop;
        }
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    tearDownGroup.push(fetchObserver[0](function (_a) {
        var _b = __read(_a, 1), req = _b[0];
        var url = typeof req === 'string' ? req : req.url;
        if (shouldIgnoreUrl(ignoreUrls, url)) {
            return noop;
        }
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    return incompleteReq;
};
var actionGetterWithFetchObserver = function (setCurrentContext, tearDownGroup, _a, config) {
    var _b = __read(_a, 4), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3];
    var types = config.types, pure = config.pure, ignoreUrls = config.ignoreUrls;
    var currentPayload = null;
    var lastPayload = null;
    var reportWithContext = undefined;
    var requestStartAndEnd = [];
    var longtaskDuration = 0;
    var _c = __read(applyPerformance(performance), 2), now = _c[1];
    var reportActionIfAllowed = function (force) {
        // no action metrics || no payload || not force but there are still pending requests
        if (!currentPayload ||
            (!pure && !Object.keys(currentPayload.metrics).length) ||
            (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        // set long task duration
        currentPayload.metrics[LONG_TASK_EV_TYPE] &&
            (currentPayload.metrics[LONG_TASK_EV_TYPE].duration = longtaskDuration);
        // set request duration
        var requestDuration = requestStartAndEnd.length > 0 ? Math.max.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) - Math.min.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) : 0;
        currentPayload.metrics[HTTP_EV_TYPE] && (currentPayload.metrics[HTTP_EV_TYPE].duration = requestDuration);
        // end time
        var actionDuration = now() - currentPayload.start_time;
        reportWithContext &&
            reportWithContext({
                ev_type: ACTION_EV_TYPE,
                payload: __assign(__assign({}, currentPayload), { duration: actionDuration, frontend_time: actionDuration - requestDuration }),
            });
        // reset action after report current action
        resetAction();
    };
    var resetAction = function () {
        complete();
        // refresh lastPayload so that delay-type events can be correctly attach action id
        currentPayload &&
            (lastPayload = {
                start_time: currentPayload.start_time,
                id: currentPayload.id,
            });
        currentPayload = null;
        requestStartAndEnd = [];
        longtaskDuration = 0;
    };
    var calculateMetric = function (ev_type) {
        var _a, _b;
        currentPayload &&
            (currentPayload.metrics[ev_type] = {
                count: ((_b = (_a = currentPayload.metrics[ev_type]) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0) + 1,
            });
    };
    var _d = __read(waitActionComplete(window, reportActionIfAllowed, resetAction, MAX_ACTIVITY_DELAY), 3), start = _d[0], notify = _d[1], complete = _d[2];
    // notify if meet xhr and fetch
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify, ignoreUrls);
    // notify if meet mutation change
    var _e = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _e[0], disconnect = _e[1];
    observe();
    tearDownGroup.push(disconnect);
    tearDownGroup.push(complete);
    // notify if meet longtask
    tearDownGroup.push(longtaskObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration;
        notify();
        // calculate longtask
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (currentPayload && currentPayload.start_time <= startTime + MIN_LONG_TASK) {
            longtaskDuration = longtaskDuration + duration;
            calculateMetric(LONG_TASK_EV_TYPE);
        }
    }));
    // notify if meet resource
    tearDownGroup.push(resourceObserver[0](function (_a) {
        var name = _a.name, startTime = _a.startTime, duration = _a.duration, initiatorType = _a.initiatorType;
        if (shouldIgnoreUrl(ignoreUrls, name)) {
            return;
        }
        notify();
        if (currentPayload && currentPayload.start_time < startTime) {
            // calculate http
            if (['xmlhttprequest', 'fetch'].includes(initiatorType)) {
                // the reason for calculating HTTP duration here is that incompleteReq cannot get the correct start and end times
                requestStartAndEnd.push(startTime, startTime + duration);
                calculateMetric(HTTP_EV_TYPE);
            }
            // calculate resource
            if (!['xmlhttprequest', 'fetch', 'beacon'].includes(initiatorType)) {
                calculateMetric(RESOURCE_EV_TYPE);
            }
        }
    }));
    // attach action id to other data
    var applyOtherReport = function (ev) {
        if (shouldIgnoreEvent(ignoreUrls, ev)) {
            return;
        }
        // if there is a new Page View, forcefully settle the current action
        if (ev.ev_type === PAGEVIEW_EV_TYPE) {
            reportActionIfAllowed(true);
            resetAction();
            return;
        }
        // because http needs to wait timing so http event belongs to the delay-type events, need special correction.
        if (ev.ev_type === HTTP_EV_TYPE) {
            var startTime = ev.payload.response.timing && ev.payload.response.timing.startTime;
            if (!startTime)
                return;
            if (currentPayload && startTime > currentPayload.start_time)
                return currentPayload.id;
            if (lastPayload && startTime > lastPayload.start_time)
                return lastPayload.id;
            return;
        }
        // due to the event loop, the starting time of long task will be earlier than the time of interactive trigger.
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (ev.ev_type === LONG_TASK_EV_TYPE) {
            var startTime = ev.payload.longtasks.length && ev.payload.longtasks[0].startTime + MIN_LONG_TASK;
            if (currentPayload && startTime && startTime > currentPayload.start_time)
                return currentPayload.id;
            return;
        }
        if (!currentPayload) {
            return;
        }
        // calculate js error and resource error
        // because JS error and resource error are synchronous events, they can be attached here.
        if (ev.ev_type === JS_ERROR_EV_TYPE || ev.ev_type === RESOURCE_ERROR_EV_TYPE) {
            calculateMetric(ev.ev_type);
        }
        return currentPayload.id;
    };
    var initAction = function (target, type) {
        // refresh action id in common
        var actionId = uuid();
        var _a = __read(applyPerformance(performance), 2), now = _a[1];
        // init payload
        currentPayload = {
            start_time: now(),
            id: actionId,
            type: type,
            target: target,
            metrics: {},
        };
        reportWithContext = setCurrentContext();
        start();
    };
    var handleEvent = function (e) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        if (!(e.target instanceof HTMLElement) || !isValidTarget(e.target)) {
            return;
        }
        var name = getActionName(e.target, DEFAULT_ATTR_NAME);
        if (!name) {
            return;
        }
        initAction({ name: name, path: htmlTreeAsString(e.target) }, e.type);
    };
    types &&
        types.forEach(function (t) {
            if (arrayIncludes(SUPPORT_TYPES, t)) {
                tearDownGroup.push(addListenerToDocument(document, t, handleEvent, EVENT_LISTENER_OPTIONS));
            }
        });
    var startAction = function (name, type) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        initAction({ name: name }, type);
    };
    return [applyOtherReport, startAction];
};

var ACTION_MONITOR_PLUGIN_NAME = 'action';
var defaultConfig = {
    types: ["click" /* CLICK */],
    pure: true,
};
function ActionMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig; }
    var tearDownGroup = [];
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var _a = __read(actionGetterWithFetchObserver(function () { return reportWithCurrentContext(client, true); }, tearDownGroup, [
        initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
        initSubjectInGlobal(client, fetchSubject),
        initSubjectInGlobal(client, longtaskSubject),
        initSubjectInGlobal(client, resourceSubject),
    ], config), 2), applyOtherReport = _a[0], startAction = _a[1];
    var listenOtherReport = function (ev) {
        var actionId = applyOtherReport(ev);
        actionId && ev.extra && (ev.extra.action_id = actionId);
        return ev;
    };
    client.on('report', listenOtherReport);
    tearDownGroup.push(function () {
        client.off('report', listenOtherReport);
    });
    client.provide('startAction', startAction);
    registerTearDownGroup(client, ACTION_MONITOR_PLUGIN_NAME, ACTION_EV_TYPE, tearDownGroup);
}

var ACTION_INTEGRATION_NAME = ACTION_MONITOR_PLUGIN_NAME;
var actionPlugin = function (config) { return ({
    name: ACTION_INTEGRATION_NAME,
    setup: function (client) {
        ActionMonitorBasePlugin(client, config);
    },
}); };

exports.ACTION_INTEGRATION_NAME = ACTION_INTEGRATION_NAME;
exports.actionPlugin = actionPlugin;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/action.js.map
