'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isUndefined(o) {
    return o === undefined;
}
var objProto = Object.prototype;
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}

var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultPerformance() {
    if (getDefaultBrowser() && isObject(window.performance))
        return window.performance;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}
function getDefaultPerformanceEventTiming() {
    if (getDefaultBrowser() && isFunction(window.PerformanceEventTiming))
        return window.PerformanceEventTiming;
}

function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client);
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = __assign(__assign({}, getOverrides(client)), getViewOverrides(newConfig));
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};

/**
 * from sentry https://github.com/getsentry/sentry-javascript/blob/5.30.0/packages/utils/src/browser.ts
 */
var UNKNOWN_PATH = '<unknown>';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 256; // be matched with the filtering rules of data reporting
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return UNKNOWN_PATH;
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el) {
    var _a, _b;
    var elem = el;
    var out = [];
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        return "#" + elem.id;
    }
    var className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
        }
    }
    var attrlist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrlist.length; i++) {
        key = attrlist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    // Check for siblings with the same selector
    var sibling = elem;
    var siblingIndex = 1;
    var isUnique = true;
    while ((sibling = sibling.previousElementSibling)) {
        if (((_a = sibling.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = elem.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            if (sibling.className === elem.className &&
                attrlist.every(function (attr) { return elem.getAttribute(attr) === (sibling === null || sibling === void 0 ? void 0 : sibling.getAttribute(attr)); })) {
                isUnique = false;
            }
            siblingIndex++;
        }
    }
    if (siblingIndex > 1 && !isUnique) {
        out.push(":nth-of-type(" + siblingIndex + ")");
    }
    return out.join('');
}

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};

var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type, durationThreshold) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            var options = { type: type, buffered: true };
            !isUndefined(durationThreshold) && (options.durationThreshold = durationThreshold);
            observer.observe(options);
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerfWithBuffer = function (Ob, pipe, type, durationThreshold) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), bufferedObserver = _a[1], disconnect = _a[2];
    bufferedObserver(type, durationThreshold);
    return disconnect;
};

var PERFORMANCE_METRIC_EV_TYPE = 'performance';

var HIDDEN_SUBJECT_NAME = 'hidden_3';
var visibilityStateIsHidden = function (d) { return d.visibilityState === 'hidden'; };
var observeHidden = function (next, tearDown) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    // some browsers have buggy implementations of visibilitychange,
    // so we use pagehide in addition, just to be safe.
    var onVisibilityChangeOrPageHide = function (event) {
        next(event.type === 'pagehide' || visibilityStateIsHidden(document));
    };
    var removeVisibilityListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChangeOrPageHide, true);
    var removePageHideListener = addListenerToWindow(window, 'pagehide', onVisibilityChangeOrPageHide, true);
    tearDown(function () {
        removeVisibilityListener();
        removePageHideListener();
    }, function (subscriber) {
        subscriber(visibilityStateIsHidden(document));
    });
};
/**
 * When subscribing to hiddenSubject, it's important to note that it may immediately and synchronously trigger.
 */
var hiddenSubject = [HIDDEN_SUBJECT_NAME, observeHidden];
var UNLOAD_SUBJECT_NAME = 'unload_0';
var observeUnload = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    var _a = __read(invokeCallbackOnce(next), 1), invokeCbOnce = _a[0];
    var unloadEventList = ['unload', 'beforeunload', 'pagehide'];
    var handler = function () {
        invokeCbOnce();
    };
    var tearDowns = [];
    unloadEventList.forEach(function (ev) {
        tearDowns.push(addListenerToWindow(window, ev, handler, false));
    });
    tearDown(function () {
        tearDowns.forEach(function (e) { return e(); });
    });
};
var unloadSubject = [UNLOAD_SUBJECT_NAME, observeUnload];
var ACTIVATED_SUBJECT_NAME = 'activated_0';
var observeActivated = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onActivated = function () {
        next();
        onceTriggered = true;
    };
    // @ts-expect-error
    if (document && document.prerendering) {
        removeListener = addListenerToDocument(document, 'prerenderingchange', onActivated, true);
    }
    else {
        onActivated();
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to activatedSubject, it's important to note that it may immediately and synchronously trigger.
 */
var activatedSubject = [ACTIVATED_SUBJECT_NAME, observeActivated];

var defaultMetricContext = {
    isSupport: true,
    isPolyfill: false,
    isBounced: false,
    isCustom: false,
    type: 'perf',
};
var initMetric = function (name, value) {
    return __assign({ name: name, value: value }, defaultMetricContext);
};

var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: PERFORMANCE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
var applyReportMetric = function (report) {
    return function (metric, overrides) {
        report(wrapPerformanceMetric(metric, overrides));
    };
};

var FI_ENTRY_NAME = 'first-input';

var EVENT_TIMING_TYPE = 'event';
var INP_METRIC_NAME = "inp" /* inp */;
var MAX_INTERACTIONS_TO_CONSIDER = 10;
var initInteractionCountPolyfill = function (po, tearDownGroup) {
    var interactionCountEstimate = 0;
    var minKnownInteractionId = Infinity;
    var maxKnownInteractionId = 0;
    var updateEstimate = function (e) {
        if (e.interactionId) {
            minKnownInteractionId = Math.min(minKnownInteractionId, e.interactionId);
            maxKnownInteractionId = Math.max(maxKnownInteractionId, e.interactionId);
            interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0;
        }
    };
    tearDownGroup.push(observePerfWithBuffer(po, updateEstimate, EVENT_TIMING_TYPE, 0));
    return [
        function () {
            return interactionCountEstimate;
        },
    ];
};
var getINP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 4), activatedObserver = _b[0], getUnloadObserver = _b[2], getPVObserver = _b[3];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var PerformanceEventTiming = getDefaultPerformanceEventTiming();
    var performance = getDefaultPerformance();
    var metric = initMetric(INP_METRIC_NAME, 0);
    var reportMetric = applyReportMetric(report);
    if (!PerformanceObserver || !PerformanceEventTiming || !performance) {
        metric.isSupport = false;
        reportMetric(metric);
        return;
    }
    var prevInteractionCount = 0;
    // top 10 longest interactionList and the first one is the longest
    var longestInteractionList = [];
    // a mapping of longest interactions by their interaction ID.
    var longestInteractionMap = {};
    var resetStatus = function () {
        prevInteractionCount = getInteractionCount();
        longestInteractionList = [];
        longestInteractionMap = {};
    };
    var processEntry = function (entry) {
        var minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];
        var existingInteraction = longestInteractionMap[entry.interactionId];
        // update longestInteractionList info if necessary: if the interaction already exists, update it, otherwise create one.
        if (existingInteraction ||
            longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||
            entry.duration > minLongestInteraction.latency) {
            if (existingInteraction) {
                existingInteraction.entries.push(entry);
                existingInteraction.latency = Math.max(existingInteraction.latency, entry.duration);
            }
            else {
                var interaction = {
                    id: entry.interactionId,
                    latency: entry.duration,
                    entries: [entry],
                };
                longestInteractionMap[interaction.id] = interaction;
                longestInteractionList.push(interaction);
            }
            // sort the longestInteractionList again.
            longestInteractionList.sort(function (a, b) { return b.latency - a.latency; });
            longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(function (i) {
                delete longestInteractionMap[i.id];
            });
        }
    };
    var _c = __read(initInteractionCountPolyfill(PerformanceObserver, tearDownGroup), 1), getInteractionCount = _c[0];
    var getInteractionCountForNavigation = function () {
        return getInteractionCount() - prevInteractionCount;
    };
    var estimateP98LongestInteraction = function () {
        var candidateInteractionIndex = Math.min(longestInteractionList.length - 1, Math.floor(getInteractionCountForNavigation() / 50));
        return longestInteractionList[candidateInteractionIndex];
    };
    var updateMetric = function () {
        var inp = estimateP98LongestInteraction();
        if (inp) {
            metric.value = inp.latency;
            // add element if have
            var target = inp.entries[0].target;
            target && (metric.extra = { element: htmlTreeAsString(target) });
        }
    };
    var handleEntry = function (entry) {
        if (entry.interactionId) {
            processEntry(entry);
        }
        if (entry.entryType === 'first-input') {
            var noMatchingEntry = !longestInteractionList.some(function (interaction) {
                return interaction.entries.some(function (prevEntry) {
                    return entry.duration === prevEntry.duration && entry.startTime === prevEntry.startTime;
                });
            });
            // only consider if no matching entry
            if (noMatchingEntry) {
                processEntry(entry);
            }
        }
    };
    tearDownGroup.push(activatedObserver[0](function () {
        // observe event
        tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, handleEntry, EVENT_TIMING_TYPE, 40));
        // observe FI if support interactionId
        if ('interactionId' in PerformanceEventTiming.prototype) {
            tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, handleEntry, FI_ENTRY_NAME));
        }
        var pvObserver = getPVObserver();
        tearDownGroup.push(pvObserver[0](function (overrides) {
            updateMetric();
            reportMetric(metric, overrides);
            resetStatus();
            // set new metric
            metric = initMetric(INP_METRIC_NAME, 0);
        }));
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            updateMetric();
            reportMetric(metric);
        }));
        tearDownGroup.push(resetStatus);
    }));
};
var INP = [INP_METRIC_NAME, getINP];

var INP_MONITOR_PLUGIN_NAME = INP[0];
function INPMonitorPlugin(client) {
    client.on('init', function () {
        var activatedObserver = initSubjectInGlobal(client, activatedSubject);
        var getHiddenObserver = function () { return initSubjectInGlobal(client, hiddenSubject); };
        var getUnloadObserver = function () { return initSubjectInGlobal(client, unloadSubject); };
        var getPVObserver = function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); };
        var tearDown = [];
        INP[1](client.report.bind(client), tearDown, [
            activatedObserver,
            getHiddenObserver,
            getUnloadObserver,
            getPVObserver,
        ]);
        registerTearDownGroup(client, INP_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDown);
    });
}

var INP_INTEGRATION_NAME = INP_MONITOR_PLUGIN_NAME;
var INPPlugin = function () { return ({
    name: INP_INTEGRATION_NAME,
    setup: function (client) {
        INPMonitorPlugin(client);
    },
}); };

exports.INPPlugin = INPPlugin;
exports.INP_INTEGRATION_NAME = INP_INTEGRATION_NAME;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/inp.js.map
