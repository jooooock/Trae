'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isUndefined(o) {
    return o === undefined;
}
var objProto = Object.prototype;
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}

var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultPerformance() {
    if (getDefaultBrowser() && isObject(window.performance))
        return window.performance;
}
function getDefaultMutationObserver() {
    if (getDefaultBrowser() && isFunction(window.MutationObserver))
        return window.MutationObserver;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}
function getDefaultRaf() {
    if (getDefaultBrowser() && 'requestAnimationFrame' in window) {
        return window.requestAnimationFrame;
    }
}
function getDefaultCaf() {
    if (getDefaultBrowser() && 'cancelAnimationFrame' in window) {
        return window.cancelAnimationFrame;
    }
}

function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var reportWithCurrentContext = function (client, timeRequiresAdjustment) {
    if (timeRequiresAdjustment === void 0) { timeRequiresAdjustment = false; }
    var overrides = getOverrides(client);
    timeRequiresAdjustment && (overrides.timestamp = now());
    return function (ev) {
        client.report(__assign(__assign({}, ev), { overrides: overrides }));
    };
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client);
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = __assign(__assign({}, getOverrides(client)), getViewOverrides(newConfig));
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};

var applyMutationObserver = function (MutationObserver, callback) {
    // eslint-disable-next-line compat/compat
    var observer = MutationObserver && new MutationObserver(callback);
    var observe = function (target, options) {
        observer && target && observer.observe(target, options);
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
var applyAnimationFrame = function (document, originRAF, originCAF, force) {
    var requestAnimationFrame = 
    // eslint-disable-next-line compat/compat
    !isFunction(originRAF) || (force && document && document.hidden)
        ? function (cb) {
            cb(0);
            return 0;
        }
        : originRAF;
    var cancelAnimationFrame = isFunction(originCAF) ? originCAF : noop;
    /**
     * 以 animationFrame 调用函数，如果一帧内多次调用，则会取消前面的调用
     */
    var af;
    var scheduleAnimationFrame = function (cb) {
        af && cancelAnimationFrame(af);
        af = requestAnimationFrame(cb);
    };
    return [scheduleAnimationFrame, requestAnimationFrame, cancelAnimationFrame];
};
var applyPerformance = function (performance) {
    // eslint-disable-next-line compat/compat
    var timing = (performance && performance.timing) || undefined;
    var now = function () {
        if (performance && performance.now)
            return performance.now();
        var time = Date.now ? Date.now() : +new Date();
        var start = (timing && timing.navigationStart) || 0;
        return time - start;
    };
    var getEntriesByType = function (type) {
        var getEntriesByType = (performance || {}).getEntriesByType;
        return (isFunction(getEntriesByType) && getEntriesByType.call(performance, type)) || [];
    };
    var getEntriesByName = function (name) {
        var getEntriesByName = (performance || {}).getEntriesByName;
        return (isFunction(getEntriesByName) && getEntriesByName.call(performance, name)) || [];
    };
    var clearResourceTiming = function () {
        var clearResourceTimings = (performance || {}).clearResourceTimings;
        isFunction(clearResourceTimings) && clearResourceTimings.call(performance);
    };
    return [timing, now, getEntriesByType, clearResourceTiming, getEntriesByName];
};

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
function clearTimerWithTearDowns(timer, tearDowns) {
    timer && tearDowns.push(function () { return clearTimeout(timer); });
}
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};

var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type, durationThreshold) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            var options = { type: type, buffered: true };
            !isUndefined(durationThreshold) && (options.durationThreshold = durationThreshold);
            observer.observe(options);
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerf = function (Ob, pipe, types) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), observe = _a[0], disconnect = _a[2];
    observe(types);
    return disconnect;
};

var PERFORMANCE_METRIC_EV_TYPE = 'performance';

var HIDDEN_SUBJECT_NAME = 'hidden_3';
var visibilityStateIsHidden = function (d) { return d.visibilityState === 'hidden'; };
var observeHidden = function (next, tearDown) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    // some browsers have buggy implementations of visibilitychange,
    // so we use pagehide in addition, just to be safe.
    var onVisibilityChangeOrPageHide = function (event) {
        next(event.type === 'pagehide' || visibilityStateIsHidden(document));
    };
    var removeVisibilityListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChangeOrPageHide, true);
    var removePageHideListener = addListenerToWindow(window, 'pagehide', onVisibilityChangeOrPageHide, true);
    tearDown(function () {
        removeVisibilityListener();
        removePageHideListener();
    }, function (subscriber) {
        subscriber(visibilityStateIsHidden(document));
    });
};
/**
 * When subscribing to hiddenSubject, it's important to note that it may immediately and synchronously trigger.
 */
var hiddenSubject = [HIDDEN_SUBJECT_NAME, observeHidden];
var LOAD_SUBJECT_NAME = 'load_1';
var readyStateIsComplete = function (d) { return d.readyState === 'complete'; };
var observeLoad = function (next, tearDown) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onLoad = function () {
        // queue a task so the callback runs after `loadEventEnd`
        setTimeout(function () {
            next();
            onceTriggered = true;
        }, 0);
    };
    if (readyStateIsComplete(document)) {
        onLoad();
    }
    else {
        removeListener = addListenerToWindow(window, 'load', onLoad, false);
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to loadSubject, it's important to note that it may immediately and synchronously trigger.
 */
var loadSubject = [LOAD_SUBJECT_NAME, observeLoad];
var UNLOAD_SUBJECT_NAME = 'unload_0';
var observeUnload = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    var _a = __read(invokeCallbackOnce(next), 1), invokeCbOnce = _a[0];
    var unloadEventList = ['unload', 'beforeunload', 'pagehide'];
    var handler = function () {
        invokeCbOnce();
    };
    var tearDowns = [];
    unloadEventList.forEach(function (ev) {
        tearDowns.push(addListenerToWindow(window, ev, handler, false));
    });
    tearDown(function () {
        tearDowns.forEach(function (e) { return e(); });
    });
};
var unloadSubject = [UNLOAD_SUBJECT_NAME, observeUnload];
var ACTIVATED_SUBJECT_NAME = 'activated_0';
var observeActivated = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onActivated = function () {
        next();
        onceTriggered = true;
    };
    // @ts-expect-error
    if (document && document.prerendering) {
        removeListener = addListenerToDocument(document, 'prerenderingchange', onActivated, true);
    }
    else {
        onActivated();
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to activatedSubject, it's important to note that it may immediately and synchronously trigger.
 */
var activatedSubject = [ACTIVATED_SUBJECT_NAME, observeActivated];

var defaultMetricContext = {
    isSupport: true,
    isPolyfill: false,
    isBounced: false,
    isCustom: false,
    type: 'perf',
};
var initMetric = function (name, value) {
    return __assign({ name: name, value: value }, defaultMetricContext);
};

var applySendOnceAndTearDown = function (wrapPerformanceMetric, report, tearDownGroup) {
    var hasInvoked = false;
    return function (metric) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                v();
            });
        tearDownGroup.length = 0;
        if (hasInvoked)
            return;
        hasInvoked = true;
        report && report(wrapPerformanceMetric(metric));
    };
};
var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: PERFORMANCE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
var getNavigationEntry = function () {
    var performance = getDefaultPerformance();
    var _a = __read(applyPerformance(performance), 3), getEntriesByType = _a[2];
    return getEntriesByType('navigation')[0];
};
var getActivationStart = function () {
    var navEntry = getNavigationEntry();
    // @ts-expect-error
    return (navEntry && navEntry.activationStart) || 0;
};

var FP_ENTRY_NAME = 'first-paint';
var Paint_Type = 'paint';
var getPaint = function (entryName, metricName, report, tearDownGroup, _a) {
    var _b = __read(_a, 3), activatedObserver = _b[0], getHiddenObserver = _b[1], getUnloadObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var document = getDefaultDocument();
    var metric = initMetric(metricName, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!performance || !PerformanceObserver || !document) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var handleActivated = function () {
        // if the page is initially hidden or still hidden after prerendering
        // that means the tab was activated in a background state, so it is marked as unsupported
        if (visibilityStateIsHidden(document)) {
            metric.isSupport = false;
            sendOnceAndTearDown(metric);
            return;
        }
        var invokePaint = function (_a) {
            var startTime = _a.startTime;
            // should be relative to page activation rather than navigation start if the page was pre-rendered.
            // but in cases where `activationStart` occurs after the FP or FCP, this time should be clamped at 0.
            var activatedTimeStamp = getActivationStart();
            metric.value = startTime < activatedTimeStamp ? 0 : startTime - activatedTimeStamp;
            sendOnceAndTearDown(metric);
        };
        var _a = __read(applyPerformance(performance), 5), getEntriesByName = _a[4];
        var paint = getEntriesByName(entryName)[0];
        if (paint) {
            invokePaint(paint);
            return;
        }
        tearDownGroup.push(observePerf(PerformanceObserver, function (entry) {
            entry.name === entryName && invokePaint(entry);
        }, [Paint_Type]));
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            metric.isBounced = true;
            sendOnceAndTearDown(metric);
        }));
        var hiddenCallback = function (isHidden) {
            if (isHidden) {
                // if initially not hidden but suddenly becomes hidden, then the metric can be settle.
                sendOnceAndTearDown(metric);
            }
        };
        // hiddenObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        var hiddenObserver = getHiddenObserver();
        tearDownGroup.push(function () { return hiddenObserver[1](hiddenCallback); });
        hiddenObserver[0](hiddenCallback);
    };
    // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return activatedObserver[1](handleActivated); });
    activatedObserver[0](handleActivated);
};

var FMP_METRIC_NAME = 'fmp';
var DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var getScore = function (element, depth, exist, ignoreTags) {
    if (!element || ignoreTags.indexOf(element.tagName) > -1) {
        return 0;
    }
    var _a = element.children, children = _a === void 0 ? [] : _a;
    var score = [].slice
        .call(children)
        .reduceRight(function (sum, child) { return sum + getScore(child, depth + 1, sum > 0, ignoreTags); }, 0);
    if (score <= 0 && !exist) {
        if (!isFunction(element.getBoundingClientRect)) {
            return 0;
        }
        var _b = element.getBoundingClientRect() || {}, top_1 = _b.top, height = _b.height;
        if (top_1 > window.innerHeight || height <= 0) {
            return 0;
        }
    }
    return score + 1 + 0.5 * depth;
};
var getFMPInternal = function (_a) {
    var _b = _a === void 0 ? [] : _a, _c = __read(_b), first = _c[0], rest = _c.slice(1);
    return ((rest &&
        rest.reduce(function (_a, cur) {
            var _b = __read(_a, 2), prev = _b[0], target = _b[1];
            var diff = cur.score - prev.score;
            return [cur, cur.time >= prev.time && target.rate < diff ? { time: cur.time, rate: diff } : target];
        }, [first, { time: first === null || first === void 0 ? void 0 : first.time, rate: 0 }])[1].time) ||
        0);
};
var getFMP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), loadObserver = _b[0], pvObserver = _b[1];
    var document = getDefaultDocument();
    var MutationObserver = getDefaultMutationObserver();
    var performance = getDefaultPerformance();
    var navigationStart = (performance && performance.timing && performance.timing.navigationStart) || undefined;
    var metric = initMetric(FMP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!document || !MutationObserver || !navigationStart) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var startTime = now();
    var list = [];
    var record = function () {
        return list.push({
            time: now() - startTime,
            // eslint-disable-next-line compat/compat
            score: getScore(document && document.body, 1, false, DEFAULT_IGNORE_TAGS),
        });
    };
    var raf = getDefaultRaf();
    var caf = getDefaultCaf();
    var _c = __read(applyAnimationFrame(document, raf, caf, true), 1), scheduleAF = _c[0];
    // 持续监听 dom 变化，记录下时间和得分
    // scheduleAF 可以避免强制回流，同时真正的变更是在animationFrame 中
    var _d = __read(applyMutationObserver(MutationObserver, function () { return scheduleAF(record); }), 2), observe = _d[0], disconnect = _d[1];
    var triggerFMP = function (timeGap) {
        if (timeGap === void 0) { timeGap = 0; }
        var fmp = getFMPInternal(list);
        metric.value = fmp ? fmp + timeGap : 0;
        sendOnceAndTearDown(metric);
        list.length = 0;
    };
    var timeGap = startTime - (navigationStart || 0);
    observe(document, { subtree: true, childList: true });
    tearDownGroup.push(disconnect);
    tearDownGroup.push(pvObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
    tearDownGroup.push(loadObserver[0](function () {
        clearTimerWithTearDowns(window.setTimeout(function () {
            triggerFMP(timeGap);
        }, 200), tearDownGroup);
    }));
};

var FMP_MONITOR_PLUGIN_NAME = 'fmp';
var defaultConfig = {
    renderType: 'CSR',
};
function FMPMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig; }
    var tearDownGroup = [];
    if (config.renderType === 'SSR') {
        // @ts-expect-error
        getPaint(FP_ENTRY_NAME, FMP_MONITOR_PLUGIN_NAME, reportWithCurrentContext(client), tearDownGroup, [
            initSubjectInGlobal(client, activatedSubject),
            function () { return initSubjectInGlobal(client, hiddenSubject); },
            function () { return initSubjectInGlobal(client, unloadSubject); },
        ]);
    }
    else {
        getFMP(reportWithCurrentContext(client), tearDownGroup, [
            initSubjectInGlobal(client, loadSubject),
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
        ]);
    }
    registerTearDownGroup(client, FMP_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDownGroup);
}

var FMP_INTEGRATION_NAME = FMP_MONITOR_PLUGIN_NAME;
var FMPPlugin = function (config) { return ({
    name: FMP_INTEGRATION_NAME,
    setup: function (client) {
        FMPMonitorBasePlugin(client, config);
    },
}); };

exports.FMPPlugin = FMPPlugin;
exports.FMP_INTEGRATION_NAME = FMP_INTEGRATION_NAME;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/fmp.js.map
