"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IDE = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../common/utils");
const object_factory_1 = require("../impl-registry/object-factory");
const fetch_1 = require("./fetch");
const config_1 = require("../common/config");
const path_browserify_1 = tslib_1.__importDefault(require("path-browserify"));
let IDE = class IDE {
    async getFileRangeLine(params) {
        return this._fetch.ide('getFileRangeLine', params);
    }
    // public async getConfiguration<T>(params: ConfigurationParams<T>): Promise<T> {
    //   return this._fetch.ide('getConfiguration', params) as T;
    // }
    async getDefinitions(params) {
        return this._fetch.ide('get_definitions', params);
    }
    async readFileLine(params) {
        return this._fetch.ide('read_file_line', params);
    }
    getWorkspaceDirs() {
        return this._configHelper.getWorkspaceDirs();
    }
    async toWorkspaceRelativePath(fullPath) {
        const paths = await this.batchToWorkspaceRelativePath([fullPath]);
        if (paths.length < 1) {
            throw this.throwENOENT(fullPath);
        }
        return paths[0];
    }
    async batchToWorkspaceRelativePath(fullPath) {
        const dirs = await this.getWorkspaceDirs();
        const relativePaths = [];
        for (const p of fullPath) {
            const fp = dirs.find((d) => p.startsWith(d));
            utils_1.Utils.assert(fp, `${p} is not in workspace`);
            relativePaths.push(this.getRelativePath(fp, p));
        }
        return relativePaths;
    }
    getRelativePath(from, to) {
        const fromParts = from.split('/').filter(Boolean);
        const toParts = to.split('/').filter(Boolean);
        // Find the common base between the two paths
        let commonLength = 0;
        for (let i = 0; i < Math.min(fromParts.length, toParts.length); i++) {
            if (fromParts[i] === toParts[i]) {
                commonLength++;
            }
            else {
                break;
            }
        }
        // Number of directories to go up
        const up = fromParts.length - commonLength;
        const down = toParts.slice(commonLength).join('/');
        return '../'.repeat(up) + down;
    }
    async createWorkspaceReadStream(filePath) {
        const fullPath = await this.getWorkspacePath(filePath);
        return this._fetch.ide('read_file', { file_path: fullPath });
    }
    async readWorkspaceDir(dirPath) {
        const fullPath = await this.getWorkspacePath(dirPath);
        return this._fetch.ide('get_dir_list', { dir_path: fullPath });
    }
    async statWorkspacePath(filePath) {
        const fullPath = await this.getWorkspacePath(filePath);
        return this._fetch.ide('stat', { dir_path: fullPath });
    }
    async getWorkspacePath(filePath) {
        for (const folder of this.getWorkspaceDirs()) {
            const fullPath = path_browserify_1.default.resolve(folder, filePath);
            try {
                const res = await this._fetch.ide('stat', { dir_path: fullPath });
                if (res.error) {
                    throw Error(res.error);
                }
                return fullPath;
            }
            catch (err) {
                if (err.code !== "ENOENT") {
                    throw err;
                }
            }
        }
        throw this.throwENOENT(filePath);
    }
    async readWorkspaceFile(filePath) {
        const fullPath = await this.getWorkspacePath(filePath);
        return await this._fetch.ide('read_file', { file_path: fullPath });
    }
    async isWorkspacePathExist(filePath) {
        try {
            await this.getWorkspacePath(filePath);
            return true;
        }
        catch (err) {
            if (err.code !== "ENOENT") {
                throw err;
            }
        }
        return false;
    }
    throwENOENT(filePath) {
        const err = new Error(`can not find ${filePath} in all workspace folders`);
        err.code = "ENOENT";
        return err;
    }
};
exports.IDE = IDE;
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", fetch_1.FetchClient)
], IDE.prototype, "_fetch", void 0);
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", config_1.AutoDebugConfigHelper)
], IDE.prototype, "_configHelper", void 0);
exports.IDE = IDE = tslib_1.__decorate([
    object_factory_1.SingletonInjectable
], IDE);
