"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const tslib_1 = require("tslib");
// import { AUTO_DEBUG_REQ_TIMEOUT } from "../common/constant";
const logger_1 = require("../common/logger");
const axios_1 = tslib_1.__importDefault(require("axios"));
const utils_1 = require("../common/utils");
const enum_1 = require("../typing/enum");
const object_factory_1 = require("../impl-registry/object-factory");
const ss_handler_1 = require("../common/ss-handler");
const fetch_1 = require("./fetch");
let Server = class Server {
    async pathFileDiff(body) {
        const method = "patch_file_diff";
        return await this.sendRequest(method, body);
    }
    async sendRequest(method, body) {
        body = utils_1.Utils.parseOutgoingProtocol(body);
        this._logger.info("send request body", method, JSON.stringify(body));
        const data = await this._fetch.agent(method, body);
        this._logger.info(`get response body`, JSON.stringify(data));
        return utils_1.Utils.parseIncomingProtocol(data);
    }
    async runAutoDebug(request) {
        // const url = await this._configHelper.getServerUrl(`api/ide/v1/agents/runs`);
        const method = 'agents_runs';
        return this.sendSSERequest(method, request);
    }
    async reportToolCallOutput(request) {
        // const path = "api/ide/v1/agents/runs/:id/tool_call_outputs";
        // const urlPattern = await this._configHelper.getServerUrl(path);
        // const url = urlPattern.replace(":id", request.run_id);
        const method = 'get_tool_outputs';
        return this.sendSSERequest(method, request);
    }
    sendSSERequest(url, body) {
        const canceler = axios_1.default.CancelToken.source();
        const handler = object_factory_1.ObjectFactory.getObject(ss_handler_1.SSEHandler, canceler);
        this.doSendSSERequest(url, body, handler, canceler);
        return handler;
    }
    async doSendSSERequest(url, body, handler, _cancelSource) {
        const result = {
            error: undefined,
            status: enum_1.SSEStatus.DONE,
            events: [],
        };
        try {
            body = utils_1.Utils.parseOutgoingProtocol(body);
            this._logger.info("send sse request body", url, JSON.stringify(body));
            const response = await this._fetch.agentSSE(url, body, this.handleSEEMessage.bind(this, result, handler));
            this._logger.info("get sse response, headers", JSON.stringify(response));
        }
        catch (err) {
            if (handler.isFinalized) {
                this._logger.info(`sse handler finalized, ignore error`, err.message);
            }
            else {
                this._logger.info("failed sse response", err.response?.headers, err.message, err.stack);
                result.status = enum_1.SSEStatus.ERROR;
                result.error = err;
                result.error.code = enum_1.AutoDebugErrorCode.CLIENT_REQUEST_ABORT;
            }
        }
        finally {
            if (!handler.isFinalized) {
                handler.done(result);
            }
        }
    }
    handleSEEMessage(result, handler, message) {
        let event;
        try {
            event = {
                name: message.event,
                data: utils_1.Utils.parseIncomingProtocol(JSON.parse(message.data)),
            };
        }
        catch (err) {
            this._logger.error("parse sse event failed", JSON.stringify(message), err);
            return;
        }
        // 忽略 done 事件
        if (event.name === enum_1.AutoDebugSSEEventType.DONE) {
            return;
        }
        try {
            result.events.push(event);
            handler.event(event);
        }
        catch (err) {
            this._logger.error("handle sse event error", err);
        }
    }
};
exports.Server = Server;
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], Server.prototype, "_logger", void 0);
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", fetch_1.FetchClient)
], Server.prototype, "_fetch", void 0);
exports.Server = Server = tslib_1.__decorate([
    object_factory_1.SingletonInjectable
], Server);
