"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReviewDefinitionTool = void 0;
const tslib_1 = require("tslib");
const i_tool_1 = require("../../common/base/i-tool");
const constant_1 = require("../../common/constant");
const utils_1 = require("../../common/utils");
const enum_1 = require("../../typing/enum");
let ReviewDefinitionTool = class ReviewDefinitionTool extends i_tool_1.ITool {
    async run() {
        this._logger.info("review definition...", JSON.stringify(this._input));
        const { identifier } = this._input;
        // 模型 line 从 1 开始
        const line = this._input.line - 1;
        const filePath = await this._ide.getWorkspacePath(this._input.filePath);
        const lineContent = await this._ide.readFileLine({ filePath, line });
        const character = new RegExp(`\\b${identifier}\\b`).exec(lineContent)?.index;
        utils_1.Utils.assert(character, `Could not find word ${identifier} in ${lineContent}`);
        this._logger.info(`find ${identifier} in ${lineContent} at ${character}`);
        const def = await this._ide.getDefinitions({
            filePath,
            line,
            character,
        });
        const lineRanges = this.getReadLineRanges(def);
        this._logger.info(`find ${def.length} definitions, range list`, JSON.stringify(lineRanges));
        const output = {
            definitions: [],
        };
        await utils_1.Utils.promiseControl(lineRanges, async (l) => {
            const content = await this._ide.getFileRangeLine(l);
            const raws = content
                .split("\n")
                .map((c, i) => `【${l.startLine + i + 1}】${c}\n`)
                .join("");
            output.definitions.push({
                symbol: identifier,
                filePath: l.filePath,
                line: l.startLine + 1,
                content: raws,
            });
        });
        return output;
    }
    getReadLineRanges(locations) {
        const ret = [];
        for (let i = 0; i < locations.length; ++i) {
            const range = {
                filePath: locations[i].uri.fsPath,
                startLine: locations[i].range.start.line,
                /**
                 * 这里期望读到整个函数的定义，但不同 lsp 的 range 有差异
                 * go、python 的 range 只有函数名，ts 会包含整个函数体
                 * 所以这里固定读后面 x 行，由模型自己去处理 @caoyunxiang
                 */
                endLine: locations[i].range.start.line +
                    constant_1.AUTO_DEBUG_REVIEW_DEFINITION_AFTER_LINE_COUNT,
            };
            if (i < locations.length - 1) {
                const nextLocation = locations[i + 1];
                // 不要有重复的区间
                if (range.endLine >= nextLocation.range.start.line) {
                    range.endLine = nextLocation.range.start.line - 1;
                }
            }
            ret.push(range);
        }
        return ret;
    }
};
exports.ReviewDefinitionTool = ReviewDefinitionTool;
exports.ReviewDefinitionTool = ReviewDefinitionTool = tslib_1.__decorate([
    (0, i_tool_1.ToolImpl)(enum_1.ToolType.REVIEW_DEFINITION)
], ReviewDefinitionTool);
