"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoDebugAgent = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("../common/logger");
const utils_1 = require("../common/utils");
const run_1 = require("../core/run");
const object_factory_1 = require("../impl-registry/object-factory");
const auto_debug_1 = require("../typing/auto-debug");
const enum_1 = require("../typing/enum");
let AutoDebugAgent = class AutoDebugAgent {
    constructor() {
        this._runs = [];
    }
    // 终止最后一个
    stop() {
        this._logger.info(`Stopping last run`);
        const run = this._runs[this._runs.length - 1];
        utils_1.Utils.assert(run, "No run to stop");
        utils_1.Utils.assert(!run.isFinalized, "Run is finalized");
        run.stop();
    }
    async run(config) {
        this._logger.info(`Starting run with params`, JSON.stringify(config));
        if (!config.projectInfo.variables.projectPath) {
            throw new auto_debug_1.AutoDebugRunError(enum_1.AutoDebugErrorCode.NO_WORKSPACE, "No workspace open");
        }
        if (!config.projectInfo.variables.language) {
            config.projectInfo.variables.language = "";
        }
        const run = object_factory_1.ObjectFactory.getObject(run_1.AutoDebugRun);
        this._runs.push(run);
        await run.go(config);
    }
};
exports.AutoDebugAgent = AutoDebugAgent;
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], AutoDebugAgent.prototype, "_logger", void 0);
exports.AutoDebugAgent = AutoDebugAgent = tslib_1.__decorate([
    object_factory_1.SingletonInjectable
], AutoDebugAgent);
