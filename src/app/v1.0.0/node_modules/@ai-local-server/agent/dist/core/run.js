"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoDebugRun = exports.runMethodImplRegistry = exports.RunEventImpl = void 0;
const tslib_1 = require("tslib");
const server_1 = require("../adaptor/server");
const step_1 = require("../core/step");
const utils_1 = require("../common/utils");
const message_1 = require("../core/message");
const method_1 = require("../impl-registry/method");
const enum_1 = require("../typing/enum");
const i_sse_event_handler_1 = require("../common/base/i-sse-event-handler");
const auto_debug_1 = require("../typing/auto-debug");
const i_life_cycle_1 = require("../common/base/i-life-cycle");
const object_factory_1 = require("../impl-registry/object-factory");
const ss_handler_1 = require("../common/ss-handler");
const i_tool_1 = require("../common/base/i-tool");
_a = tslib_1.__read((0, method_1.createMethodImplRegistry)(), 2), exports.RunEventImpl = _a[0], exports.runMethodImplRegistry = _a[1];
let AutoDebugRun = class AutoDebugRun extends i_sse_event_handler_1.AutoDebugSSEEventHandler {
    constructor() {
        super(...arguments);
        // 一次 auto debug 可能由多个 sse 请求组成，出现 tool_call 时当前请求会结束
        // tool call 结果上报后再续上
        this._turns = [];
        this._steps = [];
        /* step event end */
    }
    stop() {
        this._sseCanceller?.();
        this.setFinalized();
        const err = new auto_debug_1.AutoDebugRunError(enum_1.AutoDebugErrorCode.CLIENT_STOP, "run stopped");
        this._executor.reject(err);
    }
    get id() {
        return this._data?.id;
    }
    async go(config) {
        const { userInput, chatHistory, variables, terminalInfo, projectInfo, listener, } = config;
        const handler = await this._server.runAutoDebug({
            agentId: 'multi_agent_autofix', // write die
            userInput,
            variables: JSON.stringify(utils_1.Utils.parseOutgoingProtocol({
                ...variables,
                summarizeConclusion: true,
            })),
            chatHistory,
            contextResolvers: [
                {
                    resolverId: projectInfo.resolverId,
                    variables: JSON.stringify(utils_1.Utils.parseOutgoingProtocol(projectInfo.variables)),
                },
                {
                    resolverId: terminalInfo.resolverId,
                    variables: JSON.stringify(utils_1.Utils.parseOutgoingProtocol(terminalInfo.variables)),
                },
            ],
            availableTools: (await this.getAvailableToolTypes()).map(t => ({
                id: t,
            })),
        });
        const runPromise = new Promise((r, j) => {
            this._executor = {
                resolve: () => {
                    this._logger.info("run Complete", this.id);
                    r();
                },
                reject: (err) => {
                    this._logger.error("run Error", err);
                    j(err);
                },
            };
        });
        this._progressListener = listener;
        this.updateSSEHandler(handler);
        await runPromise;
    }
    async getAvailableToolTypes() {
        const ret = [];
        await utils_1.Utils.promiseControl(Object.values(enum_1.ToolType), async (t) => {
            const tool = i_tool_1.toolRegistry.get(t);
            let isEnable = false;
            try {
                isEnable = await tool.isEnable();
            }
            catch (err) {
                this._logger.info(`tool ${t} is enable failed`, err);
            }
            if (isEnable) {
                ret.push(t);
            }
        });
        return ret;
    }
    updateSSEHandler(handler) {
        handler.setListener({
            onEvent: this.onSSEEvent.bind(this),
            onDone: this.onSSEDone.bind(this),
        });
        this._sseCanceller = handler.cancel.bind(handler);
    }
    get methodImplRegistry() {
        return exports.runMethodImplRegistry;
    }
    async onSSEDone(result) {
        this._logger.info(`run sse done: ${this.id}, isFinalized`, this.isFinalized);
        if (this.isFinalized) {
            return;
        }
        if (result.error) {
            this._executor?.reject(result.error);
            return;
        }
        utils_1.Utils.assert(this._data, `run data not found`);
        this._turns.push(result);
        const step = this._steps.at(this._steps.length - 1);
        utils_1.Utils.assert(step, `last step not found`);
        const toolCallOutputs = await step.runToolCalls();
        const handler = await this._server.reportToolCallOutput({
            run_id: this._data.id,
            toolCallOutputs,
        });
        this.updateSSEHandler(handler);
    }
    /* handle sse end */
    /* run event begin */
    async onCreate(event) {
        this._data = event.data;
        this._logger.info(`run created`, JSON.stringify(this._data));
        this._progressListener.onEvent({
            agentRun: {
                runId: event.data.id,
            },
        });
    }
    async onBypass(event) {
        this._logger.info(`bypass event, ignore`, JSON.stringify(event));
    }
    async onComplete(_) {
        this.setFinalized();
        this._executor?.resolve();
    }
    async onError(event) {
        this._logger.info("on error", JSON.stringify(event));
        this.setFinalized();
        const { code, message } = event.data;
        this._executor?.reject(new auto_debug_1.AutoDebugRunError(code, message));
    }
    /* run event end */
    /* message event begin */
    async onMessageEvent(event) {
        utils_1.Utils.assert(this._message, `message not found`);
        this._message.onSSEEvent(event);
    }
    async onMessageCreated(event) {
        this._message = object_factory_1.ObjectFactory.getObject(message_1.AutoDebugMessage, this.id, this._progressListener);
        await this._message.onSSEEvent(event);
    }
    /* message event end */
    /* step event begin */
    async onStepCreated(event) {
        const step = object_factory_1.ObjectFactory.getObject(step_1.AutoDebugStep, this.id, this._progressListener);
        this._steps.push(step);
        step.onSSEEvent(event);
    }
    async onStepProcess(event) {
        let step = this._steps.find((s) => s.id === event.data.id);
        utils_1.Utils.assert(step, `step not found: ${event.data.id}`);
        await step.onSSEEvent(event);
    }
};
exports.AutoDebugRun = AutoDebugRun;
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", server_1.Server)
], AutoDebugRun.prototype, "_server", void 0);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], AutoDebugRun.prototype, "stop", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "go", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [ss_handler_1.SSEHandler]),
    tslib_1.__metadata("design:returntype", void 0)
], AutoDebugRun.prototype, "updateSSEHandler", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.RUN_CREATED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onCreate", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.RUN_IN_PROGRESS, enum_1.AutoDebugSSEEventType.RUN_REQUIRES_ACTION, enum_1.AutoDebugSSEEventType.RUN_FAILED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onBypass", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.RUN_COMPLETE),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onComplete", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.ERROR),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onError", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.MESSAGE_COMPLETED, enum_1.AutoDebugSSEEventType.MESSAGE_CREATED, enum_1.AutoDebugSSEEventType.MESSAGE_DELTA),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onMessageEvent", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.MESSAGE_CREATED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onMessageCreated", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.STEP_CREATED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onStepCreated", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.RunEventImpl)(enum_1.AutoDebugSSEEventType.STEP_COMPLETED, enum_1.AutoDebugSSEEventType.STEP_DELTA, enum_1.AutoDebugSSEEventType.STEP_FAILED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugRun.prototype, "onStepProcess", null);
exports.AutoDebugRun = AutoDebugRun = tslib_1.__decorate([
    object_factory_1.ExecutionInjectable
], AutoDebugRun);
