import _ from 'lodash';
export class Utils {
    static assert(exp, message) {
        if (!exp) {
            throw new Error(message);
        }
    }
    static parseOutgoingProtocol(obj) {
        if (typeof obj === 'undefined') {
            return obj;
        }
        if (Array.isArray(obj)) {
            return obj.map(Utils.parseOutgoingProtocol);
        }
        else if (obj !== null && obj.constructor === Object) {
            return Object.keys(obj).reduce((acc, key) => {
                const snakeKey = _.snakeCase(key);
                acc[snakeKey] = Utils.parseOutgoingProtocol(obj[key]);
                return acc;
            }, {});
        }
        return obj;
    }
    static parseIncomingProtocol(obj) {
        if (Array.isArray(obj)) {
            return obj.map(Utils.parseIncomingProtocol);
        }
        else if (obj !== null && obj.constructor === Object) {
            return Object.keys(obj).reduce((acc, key) => {
                const camelKey = _.camelCase(key);
                acc[camelKey] = Utils.parseIncomingProtocol(obj[key]);
                return acc;
            }, {});
        }
        return obj;
    }
    static async promiseControl(data, promiseFactories, concurrency = 5) {
        const results = [];
        const runningPromises = [];
        for (let i = 0; i < data.length; i++) {
            const promiseFactory = promiseFactories(data[i], i);
            // 等待当前运行的 promise 数量小于并发数数限制
            while (runningPromises.length >= concurrency) {
                await Promise.race(runningPromises);
            }
            // 执行 promise 并加入到运行中的 promise 数组
            const promise = promiseFactory
                .then(result => {
                results[i] = result;
                // 当 promise 完成后，从运行中的 promise 数组中移除
                const index = runningPromises.indexOf(promise);
                runningPromises.splice(index, 1);
            })
                .catch(error => {
                // 当回调函数抛出异常时，停止并抛出异常
                throw error;
            });
            runningPromises.push(promise);
        }
        // 等待所有 promise 执行完毕
        await Promise.all(runningPromises);
        return results;
    }
}
