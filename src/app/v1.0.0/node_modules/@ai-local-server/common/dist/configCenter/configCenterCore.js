import { __decorate, __metadata } from "tslib";
import { Language, Namespace } from '../typings';
import { LocalConfig } from '../configStorage/localConfig';
import { MemoryConfig } from '../configStorage/memoryConfig';
import { RemoteConfig } from '../configStorage/remoteConfig';
import { initI18n } from '@byted-icube/devtools-i18n';
import { STARLING_ZONE_HOST_MAP } from '../common/constant';
// TODO json 的数据，rollup 打包的时候，不识别别名，所以暂时先用相对路径
import enTranslation from '../local/locales/en.json';
import zhTranslation from '../local/locales/zh.json';
import { AICommonOptionsHelper } from '../options/aiCommonOptions';
import { Inject } from '@artus/injection';
import { SingletonInjectable } from '../common/injection';
import { Logger } from '../common/logger';
import { Utils } from '../common/utils';
let ConfigCenterCore = class ConfigCenterCore {
    /**
     * Get config value from config center
     * @param key key of config
     * @param defaultValue default value if config not exist
     * @returns value of config
     */
    get(key, defaultValue) {
        try {
            const memoryConfig = this._memoryConfig.get(key);
            if (typeof memoryConfig !== 'undefined') {
                return memoryConfig;
            }
        }
        catch (error) {
            this._logger.error(`[ConfigCenter] get config from memory failed: ${error.stack}`);
        }
        Utils.assert(typeof defaultValue !== 'undefined', `[ConfigCenter] get config failed: ${key} not exist`);
        return defaultValue;
    }
    /**
     * Get i18n translator
     * @param lang language
     * @returns i18n translator
     */
    getTranslator(lang) {
        switch (lang) {
            case Language.ZH:
                return this._zhI18n;
            case Language.EN:
                return this._enI18n;
        }
    }
    /**
     * Translate text
     * @param lang language
     * @param key language key for translation in starling
     * @param params parameters of i18n
     * @param defaultValue default value if i18n not exist
     * @returns translation of i18n
     */
    translate(lang, key, params, defaultValue) {
        const i18n = this.getTranslator(lang);
        return i18n.t(key, params, defaultValue);
    }
    async setup() {
        this._remoteConfig.setup();
        await this.initConfig();
        await this.initI18n();
    }
    async initConfig() {
        const localConfig = await this._localConfig.readRawConfig();
        // 默认使用远程数据
        try {
            // 远程数据合并本地数据
            const remoteConfig = await this._remoteConfig.readRawConfig();
            this._memoryConfig.updateRawConfig(Object.assign({}, localConfig, remoteConfig));
            // 更新配置
            this._remoteConfig.onRawConfigChange(rawConfig => {
                this._memoryConfig.updateRawConfig(Object.assign({}, localConfig, rawConfig));
            });
            return;
        }
        catch (error) {
            this._logger.error(`[ConfigCenter] sync remote config failed: ${error.stack}`);
        }
        // 兜底使用本地数据
        try {
            // const localConfig = await this._localConfig.readRawConfig();
            this._memoryConfig.updateRawConfig(localConfig);
        }
        catch (error) {
            this._logger.error(`[ConfigCenter] sync local config failed: ${error.stack}`);
        }
    }
    async initI18n() {
        const { region, namespace = Namespace.AI, i18nResource } = this._optionsHelper;
        const [enI18n, zhI18n] = await Promise.all([
            this.initI18nWithLanguage({ region, namespace, lang: Language.EN, i18nResource }),
            this.initI18nWithLanguage({ region, namespace, lang: Language.ZH, i18nResource }),
        ]);
        this._enI18n = enI18n;
        this._zhI18n = zhI18n;
    }
    async initI18nWithLanguage(params) {
        const { region, namespace, lang, i18nResource } = params;
        return await initI18n({
            lang,
            logger: this._logger,
            namespace,
            region,
            starlingZoneHost: STARLING_ZONE_HOST_MAP[region],
            resources: {
                en: { translation: Object.assign({}, enTranslation, i18nResource?.enTranslation) },
                zh: { translation: Object.assign({}, zhTranslation, i18nResource?.zhTranslation) },
            },
        });
    }
};
__decorate([
    Inject(),
    __metadata("design:type", Logger)
], ConfigCenterCore.prototype, "_logger", void 0);
__decorate([
    Inject(),
    __metadata("design:type", MemoryConfig)
], ConfigCenterCore.prototype, "_memoryConfig", void 0);
__decorate([
    Inject(),
    __metadata("design:type", LocalConfig)
], ConfigCenterCore.prototype, "_localConfig", void 0);
__decorate([
    Inject(),
    __metadata("design:type", RemoteConfig)
], ConfigCenterCore.prototype, "_remoteConfig", void 0);
__decorate([
    Inject(),
    __metadata("design:type", AICommonOptionsHelper)
], ConfigCenterCore.prototype, "_optionsHelper", void 0);
ConfigCenterCore = __decorate([
    SingletonInjectable
], ConfigCenterCore);
export { ConfigCenterCore };
