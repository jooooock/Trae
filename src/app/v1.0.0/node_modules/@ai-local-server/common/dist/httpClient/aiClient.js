import { __decorate, __metadata } from "tslib";
import { Logger } from '../common/logger';
import { Utils } from '../common/utils';
import { REQUEST_AUTH_HEADER_MAP, AI_REQUEST_HOST_MAP, RequestPathType, AI_SEVER_REGION_MAP, AI_SERVER_APP_ID, DEV_AI_REQUEST_HOST_MAP, } from '../common/constant';
import { SlardarEventName, SlardarEventStatus } from '../typings/slardar';
import { SingletonInjectable } from '../common/injection';
import { AICommonOptionsHelper } from '../options/aiCommonOptions';
import { Inject } from '@artus/injection';
import axios from 'axios';
import { AISlardarClient } from '../slardar';
import { ERRCODE } from '../typings/http';
let AIRequestClient = class AIRequestClient {
    constructor() {
        this._httpClient = this.createHttpClient();
    }
    async request({ path, body, params, options, method, }) {
        const { signal, enableParser, headers: customHeaders, ...axiosOptions } = options || {};
        const url = await this.getUrl(path);
        const targetBody = enableParser ? Utils.parseOutgoingProtocol(body) : body;
        const targetParams = enableParser ? Utils.parseOutgoingProtocol(params) : params;
        const headers = {
            ...(await this.getRequestHeaders()),
            'content-type': 'application/json',
            ...customHeaders,
        };
        this._logger.info('send request data', url, JSON.stringify(headers), JSON.stringify(targetBody || targetParams));
        const source = axios.CancelToken.source();
        if (signal) {
            signal.addEventListener('abort', () => {
                source.cancel('Request Canceled');
            });
        }
        const globalChatRequestPayload = {
            name: SlardarEventName.GlobalChatRequest,
            status: SlardarEventStatus.Success,
            costTime: Date.now(),
            path,
            body: JSON.stringify(targetBody),
            options: JSON.stringify(options),
            httpCode: '200',
            extra: JSON.stringify({
                product: this._optionsHelper.product,
            })
        };
        try {
            const response = await this._httpClient.request({
                url,
                proxy: false,
                data: targetBody,
                params: targetParams,
                headers,
                cancelToken: source.token,
                method,
                ...axiosOptions,
            });
            this._logger.info('send request:', response.config.method, response.config.url, response.status, response.statusText, JSON.stringify(response.config.headers));
            if (options?.responseType === 'stream') {
                this._logger.info('get stream response', response.config.url, response.headers['x-tt-logid']);
                globalChatRequestPayload.logId = response.headers?.['x-tt-logid'];
                return response.data;
            }
            else {
                globalChatRequestPayload.logId = response.headers?.['x-tt-logid'];
                this._logger.info('get response', response.config.url, JSON.stringify(response.headers['x-tt-logid']), JSON.stringify(response.data));
                const data = enableParser ? Utils.parseIncomingProtocol(response.data) : response.data;
                return data;
            }
        }
        catch (err) {
            if (options?.responseType !== 'stream') {
                globalChatRequestPayload.bizCode = String(err.response?.data.code);
            }
            // slardar 类型接收 string - string
            globalChatRequestPayload.httpCode = String(err.status);
            globalChatRequestPayload.errCode = String(err.code);
            globalChatRequestPayload.errorMsg = err.message;
            globalChatRequestPayload.status = SlardarEventStatus.Failed;
            globalChatRequestPayload.logId = err.response?.headers?.['x-tt-logid'];
            this._logger.info('send request failed', err.code, err.response?.config?.url, JSON.stringify(err.response?.headers), JSON.stringify(err.response?.data), err.stack);
            // axios 的 error 包含 request/response 对象，用 util.inspect 可能导致 crash，这里重新生成个 error 对象
            const e = new Error(err.message);
            e.stack = err.stack;
            // 有 reponse 且 body 返回了错误码，比如 1001（鉴权问题）
            if (err.response?.data?.code) {
                e.code = err.response?.data?.code;
            }
            else {
                e.code = ERRCODE[err.code] || ERRCODE.DEFAULT;
            }
            throw e;
        }
        finally {
            globalChatRequestPayload.costTime = Date.now() - globalChatRequestPayload.costTime;
            this._slardarClient.event(globalChatRequestPayload);
        }
    }
    async post(path, body, options) {
        return await this.request({ path, body, options, method: 'POST' });
    }
    async get(path, params, options) {
        return await this.request({ path, params, options, method: 'GET' });
    }
    get defaultHost() {
        const host = AI_REQUEST_HOST_MAP[this._optionsHelper.productAndRegion];
        Utils.assert(host, `host map not contains region ${this._optionsHelper.productAndRegion}`);
        return host;
    }
    async getHost(path) {
        const developmentMode = this._optionsHelper.developmentMode;
        const developmentHost = DEV_AI_REQUEST_HOST_MAP[this._optionsHelper.productAndRegion];
        if (developmentMode && developmentHost) {
            return developmentHost;
        }
        await this.updateHostConfig();
        if (!this._hostConfig) {
            return this.defaultHost;
        }
        // 没有路径映射的 path 用默认的 hostKey
        let hostKey = 'default';
        if (path && this._hostConfig.pathOverrides?.[path]) {
            hostKey = this._hostConfig.pathOverrides[path];
        }
        const host = this._hostConfig.domains?.[hostKey]?.[0];
        if (!host) {
            this._logger.info(`host for path is not exist ${path}`);
            return this.defaultHost;
        }
        return host;
    }
    async getUrl(path) {
        const host = await this.getHost(path);
        return `${host}/${path}`;
    }
    get hostConfig() {
        return this._hostConfig;
    }
    async updateHostConfig() {
        if (this._updateHostConfigPromise) {
            await this._updateHostConfigPromise;
            return;
        }
        this._updateHostConfigPromise = new Promise(async (resolve) => {
            try {
                const url = `${this.defaultHost}/${RequestPathType.DOMAIN_CONFIG}`;
                const region = AI_SEVER_REGION_MAP[this._optionsHelper.region];
                Utils.assert(region, `${this._optionsHelper.region} server region not exist`);
                this._logger.info('update host config request', url, this._optionsHelper.region);
                const response = await this._httpClient.get(url, {
                    proxy: false,
                    timeout: 5000,
                    headers: await this.getRequestHeaders(),
                    params: {
                        region,
                    },
                });
                this._logger.info('update host config reponse', response.config.url, JSON.stringify(response.headers['x-tt-logid']), JSON.stringify(response.data));
                this._hostConfig = {
                    domains: { ...response.data.domains },
                    pathOverrides: { ...response.data.path_overrides },
                };
            }
            catch (err) {
                this._updateHostConfigPromise = undefined;
                this._logger.info('update host config failed', err.code, err.response?.headers['x-tt-logid']);
            }
            finally {
                resolve();
            }
        });
        await this._updateHostConfigPromise;
    }
    async getRequestHeaders() {
        const headers = {};
        // ppe 小流量
        const requestPPEEnv = this._optionsHelper.getRequestPPEEnv();
        if (requestPPEEnv) {
            headers['x-use-ppe'] = '1';
            headers['x-tt-env'] = requestPPEEnv;
        }
        const requestAppVersion = this._optionsHelper.getRequestAppVersion();
        if (requestAppVersion) {
            headers['x-app-version'] = requestAppVersion;
        }
        // token
        const appId = this.getAppID();
        headers['x-app-id'] = appId;
        const token = await this._optionsHelper.getRequestToken();
        const authHeader = REQUEST_AUTH_HEADER_MAP[this._optionsHelper.product];
        const [authKey, authValue] = authHeader.split(': ');
        headers[authKey] = authValue.replace('$token', token);
        this._logger.info(`request headers`, JSON.stringify(headers));
        return headers;
    }
    getAppID() {
        const appId = AI_SERVER_APP_ID[this._optionsHelper.product];
        Utils.assert(appId, 'no appId config');
        return appId;
    }
    resetHostConfig() {
        this._updateHostConfigPromise = undefined;
    }
    getClient() {
        return this._httpClient;
    }
    createHttpClient() {
        const instance = axios.create({});
        return instance;
    }
    setInterceptors({ requestInterceptors, responseInterceptors, }) {
        requestInterceptors.forEach(interceptor => {
            this._httpClient.interceptors.request.use(async (request) => {
                await interceptor.call(this, request);
                return request;
            });
        });
        responseInterceptors.forEach(interceptor => {
            this._httpClient.interceptors.response.use(async (response) => {
                await interceptor.onFulfilled.call(this, response);
                return response;
            }, async (err) => {
                await interceptor.onReject.call(this, err);
            });
        });
    }
};
__decorate([
    Inject(),
    __metadata("design:type", Logger)
], AIRequestClient.prototype, "_logger", void 0);
__decorate([
    Inject(),
    __metadata("design:type", AICommonOptionsHelper)
], AIRequestClient.prototype, "_optionsHelper", void 0);
__decorate([
    Inject(),
    __metadata("design:type", AISlardarClient)
], AIRequestClient.prototype, "_slardarClient", void 0);
AIRequestClient = __decorate([
    SingletonInjectable
], AIRequestClient);
export { AIRequestClient };
