import anyTest from 'ava';
import sinon from 'sinon';
import { DEFAULT_STORAGE_EXPIRES, formatStorageExpires, getStorageWithDecoding, setStorageWithEncoding, } from '../storage';
var test = anyTest;
test.before(function () {
    proxyLocalStorage();
});
test.beforeEach(function (t) {
    t.context.clock = sinon.useFakeTimers();
});
export var proxyLocalStorage = function () {
    var localStorageMock = (function () {
        var store = {};
        return {
            getItem: function (key) {
                return store[key];
            },
            setItem: function (key, value) {
                store[key] = value.toString();
            },
            clear: function () {
                store = {};
            },
            removeItem: function (key) {
                delete store[key];
            },
        };
    })();
    Object.defineProperty(global, 'localStorage', { value: localStorageMock });
};
test.serial('setStorageWithEncoding should not store when expires <= 0', function (t) {
    var key_1 = 'key_1';
    var value = { a: 1 };
    var expires_1 = -1;
    setStorageWithEncoding(key_1, value, expires_1);
    t.is(getStorageWithDecoding(key_1), undefined);
    var expires_2 = 0;
    setStorageWithEncoding(key_1, value, expires_2);
    t.is(getStorageWithDecoding(key_1), undefined);
});
test.serial('getStorageWithDecoding and setStorageWithEncoding should work together', function (t) {
    var key_1 = 'key_1';
    var value_1 = { a: 1 };
    var expires = 1000;
    setStorageWithEncoding(key_1, value_1, expires);
    t.deepEqual(getStorageWithDecoding(key_1), value_1);
    t.context.clock.tick(500);
    t.deepEqual(getStorageWithDecoding(key_1), value_1);
    t.context.clock.tick(1100);
    // data expired
    t.is(getStorageWithDecoding(key_1), undefined);
    var value_2 = {
        a: 2,
    };
    var expires_2 = 2000;
    setStorageWithEncoding(key_1, value_2, expires_2);
    t.deepEqual(getStorageWithDecoding(key_1), value_2);
    t.context.clock.tick(1000);
    t.deepEqual(getStorageWithDecoding(key_1), value_2);
    t.context.clock.tick(2100);
    // data expired
    t.is(getStorageWithDecoding(key_1), undefined);
});
test.serial('formatStorageExpires should work ', function (t) {
    t.is(formatStorageExpires(0), 0);
    t.is(formatStorageExpires(1), 1);
    t.is(formatStorageExpires(-1), -1);
    t.is(formatStorageExpires(false), 0);
    t.is(formatStorageExpires(undefined), DEFAULT_STORAGE_EXPIRES);
    t.is(formatStorageExpires(true), DEFAULT_STORAGE_EXPIRES);
});//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/base/node_modules/@slardar/sdk-web/esm/utils/__test__/storage.spec.js.map