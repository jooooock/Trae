import { __assign, __read, __spreadArray } from "tslib";
/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
import { id } from '@slardar/sdk-template';
import { htmlTreeAsString, now, UNKNOWN_PATH } from '../../utils';
/**
 * Creates breadcrumbs from DOM API calls
 */
export var domBreadcrumb = function (addBreadcrumb) { return function (handlerData) {
    var target;
    // Accessing event.target can throw (see getsentry/raven-js#838, #768)
    try {
        target = handlerData.event.target
            ? htmlTreeAsString(handlerData.event.target)
            : htmlTreeAsString(handlerData.event);
    }
    catch (e) {
        target = UNKNOWN_PATH;
    }
    if (target.length === 0) {
        return;
    }
    addBreadcrumb({
        type: 'dom',
        category: "ui." + handlerData.name,
        message: target,
    });
}; };
export var triggerHandlers = function (addBreadcrumb, type) {
    return function (data) {
        if (!type) {
            return;
        }
        try {
            addBreadcrumb(data);
        }
        catch (e) {
            // ignore
        }
    };
};
export var applyDomAndKeyPress = function (debounceDuration) {
    var keypressTimeout;
    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param name the event name (e.g. "click")
     * @param handler function that will be triggered
     * @param debounce decides whether it should wait till another event loop
     * @returns wrapped breadcrumb events handler
     * @hidden
     */
    var domEventHandler = function (name, handler) {
        var lastCapturedEvent;
        return function (event) {
            // reset keypress timeout; e.g. triggering a 'click' after
            // a 'keypress' will reset the keypress debounce so that a new
            // set of keypress can be recorded
            keypressTimeout = undefined;
            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors). Ignore if we've
            // already captured the event.
            if (!event || lastCapturedEvent === event) {
                return;
            }
            lastCapturedEvent = event;
            handler({ event: event, name: name });
        };
    };
    /**
     * Wraps addEventListener to capture keypress UI events
     * @param handler function that will be triggered
     * @returns wrapped keypress events handler
     * @hidden
     */
    var keypressEventHandler = function (handler) {
        // debounce timeout is triggered, we will only capture
        // a single breadcrumb from the FIRST target (acceptable?)
        return function (event) {
            var target;
            try {
                target = event.target;
            }
            catch (e) {
                // just accessing event properties can throw an exception in some rare circumstances
                // see: https://github.com/getsentry/raven-js/issues/838
                return;
            }
            var tagName = target && target.tagName;
            // only consider keypress events on actual input elements
            // this will disregard keypress targeting body (e.g. tabbing
            // through elements, hotkeys, etc)
            if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)) {
                return;
            }
            // record first keypress in a series, but ignore subsequent
            // keypress until debounce clears
            !keypressTimeout && domEventHandler('input', handler)(event);
            clearTimeout(keypressTimeout);
            keypressTimeout = window.setTimeout(function () {
                keypressTimeout = undefined;
            }, debounceDuration);
        };
    };
    return [domEventHandler, keypressEventHandler];
};
export var applyBreadcrumb = function (maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs) {
    if (maxBreadcrumbs === void 0) { maxBreadcrumbs = 20; }
    if (onAddBreadcrumb === void 0) { onAddBreadcrumb = id; }
    if (onMaxBreadcrumbs === void 0) { onMaxBreadcrumbs = function (bs, max) { return bs.slice(-max); }; }
    var breadcrumbs = [];
    var addBreadcrumb = function (breadcrumb) {
        var processed = onAddBreadcrumb(breadcrumb);
        if (processed) {
            var mergedBreadcrumb = __assign(__assign({}, processed), { timestamp: breadcrumb.timestamp || now() });
            breadcrumbs =
                maxBreadcrumbs >= 0 && breadcrumbs.length + 1 > maxBreadcrumbs
                    ? onMaxBreadcrumbs(__spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false), maxBreadcrumbs)
                    : __spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false);
        }
    };
    return [function () { return breadcrumbs; }, addBreadcrumb];
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/base/node_modules/@slardar/sdk-web/esm/monitors/breadcrumb/util.js.map