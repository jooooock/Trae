import { __assign, __read, __spreadArray } from "tslib";
import { applyRecord, arrayIncludes, uuid } from '@slardar/sdk-template';
import { JS_ERROR_EV_TYPE, HTTP_EV_TYPE, RESOURCE_EV_TYPE, LONG_TASK_EV_TYPE, ACTION_EV_TYPE, PAGEVIEW_EV_TYPE, } from '../../constants';
import { htmlTreeAsString, applyPerformance, applyMutationObserver, now as absoluteNow, addListenerToDocument, } from '../../utils';
import { waitActionComplete, getActionName, isValidTarget, DEFAULT_ATTR_NAME } from './util';
var SUPPORT_TYPES = ["click" /* CLICK */];
var EVENT_LISTENER_OPTIONS = { capture: true };
var MIN_LONG_TASK = 50;
var MAX_ACTIVITY_DELAY = 10000;
/**
 * Hook XHR & fetch to monitor the number of incomplete requests on the current page.
 */
export var applyIncompleteReq = function (tearDownGroup, _a, notify) {
    var _b = __read(_a, 2), xhrObserver = _b[0], fetchObserver = _b[1];
    var _c = __read(applyRecord(), 3), incompleteReq = _c[0], before = _c[1], after = _c[2];
    var uniqId = 0;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 1), _method = _b[0];
        var requestId = (uniqId += 1);
        before(requestId, absoluteNow());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    tearDownGroup.push(fetchObserver[0](function () {
        var requestId = (uniqId += 1);
        before(requestId, absoluteNow());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    return incompleteReq;
};
export var actionGetterWithFetchObserver = function (setCurrentContext, tearDownGroup, _a, config) {
    var _b = __read(_a, 4), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3];
    var types = config.types, pure = config.pure;
    var currentPayload = null;
    var lastPayload = null;
    var reportWithContext = undefined;
    var requestStartAndEnd = [];
    var longtaskDuration = 0;
    var _c = __read(applyPerformance(performance), 2), now = _c[1];
    var reportActionIfAllowed = function (force) {
        // no action metrics || no payload || not force but there are still pending requests
        if (!currentPayload ||
            (!pure && !Object.keys(currentPayload.metrics).length) ||
            (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        // set long task duration
        currentPayload.metrics[LONG_TASK_EV_TYPE] &&
            (currentPayload.metrics[LONG_TASK_EV_TYPE].duration = longtaskDuration);
        // set request duration
        var requestDuration = requestStartAndEnd.length > 0 ? Math.max.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) - Math.min.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) : 0;
        currentPayload.metrics[HTTP_EV_TYPE] && (currentPayload.metrics[HTTP_EV_TYPE].duration = requestDuration);
        // end time
        var actionDuration = now() - currentPayload.start_time;
        reportWithContext &&
            reportWithContext({
                ev_type: ACTION_EV_TYPE,
                payload: __assign(__assign({}, currentPayload), { duration: actionDuration, frontend_time: actionDuration - requestDuration }),
            });
        // reset action after report current action
        resetAction();
    };
    var resetAction = function () {
        complete();
        // refresh lastPayload so that delay-type events can be correctly attach action id
        currentPayload &&
            (lastPayload = {
                start_time: currentPayload.start_time,
                id: currentPayload.id,
            });
        currentPayload = null;
        requestStartAndEnd = [];
        longtaskDuration = 0;
    };
    var calculateMetric = function (ev_type) {
        var _a, _b;
        currentPayload &&
            (currentPayload.metrics[ev_type] = {
                count: ((_b = (_a = currentPayload.metrics[ev_type]) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0) + 1,
            });
    };
    var _d = __read(waitActionComplete(window, reportActionIfAllowed, resetAction, MAX_ACTIVITY_DELAY), 3), start = _d[0], notify = _d[1], complete = _d[2];
    // notify if meet xhr and fetch
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    // notify if meet mutation change
    var _e = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _e[0], disconnect = _e[1];
    observe();
    tearDownGroup.push(disconnect);
    tearDownGroup.push(complete);
    // notify if meet longtask
    tearDownGroup.push(longtaskObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration;
        notify();
        // calculate longtask
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (currentPayload && currentPayload.start_time <= startTime + MIN_LONG_TASK) {
            longtaskDuration = longtaskDuration + duration;
            calculateMetric(LONG_TASK_EV_TYPE);
        }
    }));
    // notify if meet resource
    tearDownGroup.push(resourceObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration, initiatorType = _a.initiatorType;
        notify();
        if (currentPayload && currentPayload.start_time < startTime) {
            // calculate http
            if (['xmlhttprequest', 'fetch'].includes(initiatorType)) {
                // the reason for calculating HTTP duration here is that incompleteReq cannot get the correct start and end times
                requestStartAndEnd.push(startTime, startTime + duration);
                calculateMetric(HTTP_EV_TYPE);
            }
            // calculate resource
            if (!['xmlhttprequest', 'fetch', 'beacon'].includes(initiatorType)) {
                calculateMetric(RESOURCE_EV_TYPE);
            }
        }
    }));
    // attach action id to other data
    var applyOtherReport = function (ev) {
        // if there is a new Page View, forcefully settle the current action
        if (ev.ev_type === PAGEVIEW_EV_TYPE) {
            reportActionIfAllowed(true);
            resetAction();
            return;
        }
        // because http needs to wait timing so http event belongs to the delay-type events, need special correction.
        if (ev.ev_type === HTTP_EV_TYPE) {
            var startTime = ev.payload.response.timing && ev.payload.response.timing.startTime;
            if (!startTime)
                return;
            if (currentPayload && startTime > currentPayload.start_time)
                return currentPayload.id;
            if (lastPayload && startTime > lastPayload.start_time)
                return lastPayload.id;
            return;
        }
        // due to the event loop, the starting time of long task will be earlier than the time of interactive trigger.
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (ev.ev_type === LONG_TASK_EV_TYPE) {
            var startTime = ev.payload.longtasks.length && ev.payload.longtasks[0].startTime + MIN_LONG_TASK;
            if (currentPayload && startTime && startTime > currentPayload.start_time)
                return currentPayload.id;
            return;
        }
        if (!currentPayload) {
            return;
        }
        // calculate js error and resource
        // because JS error and resource error are synchronous events, they can be attached here.
        if (ev.ev_type === JS_ERROR_EV_TYPE || ev.ev_type === RESOURCE_EV_TYPE) {
            calculateMetric(ev.ev_type);
        }
        return currentPayload.id;
    };
    var initAction = function (target, type) {
        // refresh action id in common
        var actionId = uuid();
        var _a = __read(applyPerformance(performance), 2), now = _a[1];
        // init payload
        currentPayload = {
            start_time: now(),
            id: actionId,
            type: type,
            target: target,
            metrics: {},
        };
        reportWithContext = setCurrentContext();
        start();
    };
    var handleEvent = function (e) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        if (!(e.target instanceof HTMLElement) || !isValidTarget(e.target)) {
            return;
        }
        var name = getActionName(e.target, DEFAULT_ATTR_NAME);
        if (!name) {
            return;
        }
        initAction({ name: name, path: htmlTreeAsString(e.target) }, e.type);
    };
    types &&
        types.forEach(function (t) {
            if (arrayIncludes(SUPPORT_TYPES, t)) {
                tearDownGroup.push(addListenerToDocument(document, t, handleEvent, EVENT_LISTENER_OPTIONS));
            }
        });
    var startAction = function (name, type) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        initAction({ name: name }, type);
    };
    return [applyOtherReport, startAction];
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/base/node_modules/@slardar/sdk-web/esm/monitors/action/index.js.map