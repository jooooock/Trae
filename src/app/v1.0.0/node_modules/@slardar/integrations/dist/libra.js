'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};

var DEFAULT_PREFIX = 'libra_';
var DEFAULT_CAPACITY = 30;
var LIBRA_INTEGRATION_NAME = 'libra';
var defaultLibraOptions = {
    prefix: DEFAULT_PREFIX,
    isHook: true,
    isPause: true,
    capacity: DEFAULT_CAPACITY,
    isResume: true,
};
// dependent on pause integration
var libra = function (tea, options) {
    var restoreFns = [];
    return {
        name: LIBRA_INTEGRATION_NAME,
        setup: function (client) {
            var _a = __assign(__assign({}, defaultLibraOptions), options), prefix = _a.prefix, isHook = _a.isHook, isPause = _a.isPause, capacity = _a.capacity, isResume = _a.isResume;
            if (isPause && !client.pause)
                return;
            // hook tea getVar, when user invoke it, we will add its test.
            if (isHook && tea.getVar) {
                restoreFns.push(hookObjectProperty(tea, 'getVar', function (origin) {
                    return function (name, defaultValue, callback) {
                        try {
                            addTest(name);
                            // eslint-disable-next-line no-empty
                        }
                        catch (error) { }
                        origin.apply(tea, [name, defaultValue, callback]);
                    };
                })());
            }
            // invoke tea.getAllVars to get the vid of ab test
            function _waitTeaValues(cb) {
                var _a, _b;
                // pause client utils getAllVars invoke callback to avoid sending event with out-of-date context.
                isPause && ((_a = client.pause) === null || _a === void 0 ? void 0 : _a.pauseAction({ capacity: capacity, isResume: isResume }));
                //  make sure getAllVars invoke before any getVar in the new page
                (_b = tea.getAllVars) === null || _b === void 0 ? void 0 : _b.call(tea, function (values) {
                    var _a;
                    cb(values);
                    // resume client
                    isPause && ((_a = client.pause) === null || _a === void 0 ? void 0 : _a.startAction());
                });
            }
            function _getKey(testName) {
                return prefix + testName;
            }
            function addTest(testName) {
                _waitTeaValues(function (testValues) {
                    var _a;
                    if (!testValues[testName] || !testValues[testName].vid) {
                        return;
                    }
                    // context plugin is loaded synchronously
                    (_a = client.context) === null || _a === void 0 ? void 0 : _a.set(_getKey(testName), testValues[testName].vid);
                });
            }
            function removeTest(testName) {
                var _a;
                (_a = client.context) === null || _a === void 0 ? void 0 : _a.delete(_getKey(testName));
            }
            function getAllTests() {
                if (client.context) {
                    return Object.keys(client.context.toString())
                        .filter(function (key) { return key.startsWith(prefix); })
                        .map(function (key) { return key.substring(prefix.length); });
                }
            }
            function clearTest() {
                if (client.context) {
                    Object.keys(client.context.toString()).forEach(function (key) {
                        var _a;
                        if (key.startsWith(prefix)) {
                            (_a = client.context) === null || _a === void 0 ? void 0 : _a.delete(key);
                        }
                    });
                }
            }
            client.on('init', function () {
                client.provide(LIBRA_INTEGRATION_NAME, { addTest: addTest, removeTest: removeTest, getAllTests: getAllTests, clearTest: clearTest });
            });
            restoreFns.push(clearTest);
        },
        tearDown: function () { return restoreFns.forEach(function (fn) { return fn(); }); },
    };
};

exports.LIBRA_INTEGRATION_NAME = LIBRA_INTEGRATION_NAME;
exports.libra = libra;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/integrations/dist/libra.js.map
