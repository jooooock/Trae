import { __awaiter, __generator } from "tslib";
import 'fake-indexeddb/auto';
import test from 'ava';
import { createStore, get, update } from 'idb-keyval';
import sinon from 'sinon';
import { IntegrationPlugin, stringifyBatch } from '@slardar/sdk-template';
import { createBrowserSender } from '@slardar/sdk-web';
import { getOffline, IndexedDB_Name, IndexedDB_Store_Name, insertData, offlineIntegration, onlineListener, spliceStore, SendIntervalTime, CONTEXT_FLAG, } from '../offline';
import { browserBuilder, createTestWebClient, sleep } from './common';
var browserEnv = require('browser-env');
browserEnv();
test('getOffline', function (t) {
    var sb = sinon.createSandbox();
    sb.stub(window.navigator, 'onLine').value(false);
    var isOffline = getOffline();
    t.true(isOffline());
    sb.stub(window.navigator, 'onLine').value(true);
    t.false(isOffline());
});
test('onlineListener', function (t) {
    var cb = sinon.fake();
    var tearDown = onlineListener(cb);
    t.assert(cb.notCalled);
    window.dispatchEvent(new window.Event('online'));
    t.assert(cb.calledOnce);
    window.dispatchEvent(new window.Event('online'));
    t.assert(cb.calledTwice);
    tearDown();
    t.assert(cb.calledTwice);
});
test('insertData', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var offlineStore, data_1, data_2, data_3, data_4, data_5;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                offlineStore = createStore('test', 'test');
                return [4 /*yield*/, insertData(offlineStore, 'key_1', ['1', '2'])];
            case 1:
                _a.sent();
                return [4 /*yield*/, get('key_1', offlineStore)];
            case 2:
                data_1 = _a.sent();
                t.deepEqual(data_1, ['1', '2']);
                return [4 /*yield*/, insertData(offlineStore, 'key_1', ['3', '4'])];
            case 3:
                _a.sent();
                return [4 /*yield*/, get('key_1', offlineStore)];
            case 4:
                data_2 = _a.sent();
                t.deepEqual(data_2, ['1', '2', '3', '4']);
                return [4 /*yield*/, insertData(offlineStore, 'key_1', ['5', '6'], 5)];
            case 5:
                _a.sent();
                return [4 /*yield*/, get('key_1', offlineStore)];
            case 6:
                data_3 = _a.sent();
                t.deepEqual(data_3, ['2', '3', '4', '5', '6']);
                return [4 /*yield*/, insertData(offlineStore, 'key_1', ['7'], 5)];
            case 7:
                _a.sent();
                return [4 /*yield*/, get('key_1', offlineStore)];
            case 8:
                data_4 = _a.sent();
                t.deepEqual(data_4, ['3', '4', '5', '6', '7']);
                return [4 /*yield*/, insertData(offlineStore, 'key_1', ['8'], 6)];
            case 9:
                _a.sent();
                return [4 /*yield*/, get('key_1', offlineStore)];
            case 10:
                data_5 = _a.sent();
                t.deepEqual(data_5, ['3', '4', '5', '6', '7', '8']);
                return [2 /*return*/];
        }
    });
}); });
test('spliceStore', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var offlineStore, data_1, removeData_1, data_2, removeData_2, data_3;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                offlineStore = createStore('test', 'test');
                return [4 /*yield*/, insertData(offlineStore, 'key_2', ['1', '2', '3', '4', '5'])];
            case 1:
                _a.sent();
                return [4 /*yield*/, get('key_2', offlineStore)];
            case 2:
                data_1 = _a.sent();
                t.deepEqual(data_1, ['1', '2', '3', '4', '5']);
                return [4 /*yield*/, spliceStore(offlineStore, 'key_2', 2)];
            case 3:
                removeData_1 = _a.sent();
                t.deepEqual(removeData_1, ['1', '2']);
                return [4 /*yield*/, get('key_2', offlineStore)];
            case 4:
                data_2 = _a.sent();
                t.deepEqual(data_2, ['3', '4', '5']);
                return [4 /*yield*/, spliceStore(offlineStore, 'key_2', 5)];
            case 5:
                removeData_2 = _a.sent();
                t.deepEqual(removeData_2, ['3', '4', '5']);
                return [4 /*yield*/, get('key_2', offlineStore)];
            case 6:
                data_3 = _a.sent();
                t.deepEqual(data_3, []);
                return [2 /*return*/];
        }
    });
}); });
test.skip('offlineIntegration should work on offline', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sb, transport, client, bid, customEvent, offlineStore, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                sb = sinon.createSandbox();
                sb.stub(window.navigator, 'onLine').value(false);
                transport = {
                    post: sinon.fake(),
                    get: sinon.fake(),
                };
                client = createTestWebClient({
                    transport: transport,
                    builder: browserBuilder,
                    createSender: function () {
                        return createBrowserSender({
                            size: 20,
                            endpoint: 'test.com',
                            transport: transport,
                        });
                    },
                });
                IntegrationPlugin(client);
                bid = 'test_offline';
                client.init({
                    bid: bid,
                    integrations: [offlineIntegration()],
                });
                client.start();
                // 等待 requestIdleCallback
                return [4 /*yield*/, sleep(500)];
            case 1:
                // 等待 requestIdleCallback
                _a.sent();
                customEvent = {
                    ev_type: 'custom',
                    payload: {
                        type: 'log',
                        content: 'custom_content',
                    },
                };
                client.report(customEvent);
                return [4 /*yield*/, sleep(500)];
            case 2:
                _a.sent();
                offlineStore = createStore(IndexedDB_Name, IndexedDB_Store_Name);
                return [4 /*yield*/, get(bid, offlineStore)];
            case 3:
                data = (_a.sent());
                t.true(data.length === 1);
                t.is(data[0].ev_type, 'custom');
                t.deepEqual(data[0].payload, customEvent.payload);
                t.assert(transport.post.notCalled);
                window.dispatchEvent(new window.Event('online'));
                return [4 /*yield*/, sleep(500)];
            case 4:
                _a.sent();
                t.assert(transport.post.calledOnce);
                t.deepEqual(transport.post.args[0][0].data, stringifyBatch([customEvent]));
                return [2 /*return*/];
        }
    });
}); });
test.serial('offlineIntegration should work when transport.post trigger fail', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var sb, transport, client, bid, customEvent, offlineStore, data, customEvent_2, data_2, client_2, client_2_fake_fn, postData, data_3, restoreData;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                sb = sinon.createSandbox();
                sb.stub(window.navigator, 'onLine').value(true);
                transport = {
                    post: sinon.fake(),
                    get: sinon.fake(),
                };
                client = createTestWebClient({
                    transport: transport,
                    createSender: function () {
                        return createBrowserSender({
                            size: 20,
                            endpoint: 'test.com',
                            transport: transport,
                        });
                    },
                    builder: browserBuilder,
                });
                IntegrationPlugin(client);
                bid = 'test_offline';
                client.init({
                    bid: bid,
                    integrations: [offlineIntegration()],
                });
                client.start();
                // 等待 requestIdleCallback
                return [4 /*yield*/, sleep(500)];
            case 1:
                // 等待 requestIdleCallback
                _a.sent();
                customEvent = {
                    ev_type: 'custom',
                    payload: {
                        type: 'log',
                        content: 'custom_content',
                    },
                };
                client.report(customEvent);
                return [4 /*yield*/, sleep(1000)
                    // trigger callback fail error
                ];
            case 2:
                _a.sent();
                // trigger callback fail error
                transport.post.args[0][0].fail('transport fail error');
                offlineStore = createStore(IndexedDB_Name, IndexedDB_Store_Name);
                return [4 /*yield*/, get(bid, offlineStore)];
            case 3:
                data = (_a.sent());
                t.true(data.length === 1);
                t.is(data[0].ev_type, 'custom');
                t.deepEqual(data[0].payload, customEvent.payload);
                customEvent_2 = {
                    ev_type: 'custom',
                    payload: {
                        type: 'log',
                        content: 'custom_content_2',
                    },
                };
                client.report(customEvent_2);
                return [4 /*yield*/, sleep(1000)
                    // trigger callback fail error again
                ];
            case 4:
                _a.sent();
                // trigger callback fail error again
                transport.post.args[1][0].fail('transport fail error');
                return [4 /*yield*/, get(bid, offlineStore)];
            case 5:
                data_2 = (_a.sent());
                t.true(data_2.length === 2);
                t.is(data_2[1].ev_type, 'custom');
                t.deepEqual(data_2[1].payload, customEvent_2.payload);
                client_2 = createTestWebClient({
                    transport: transport,
                    createSender: function () {
                        return createBrowserSender({
                            size: 20,
                            endpoint: 'test.com',
                            transport: transport,
                        });
                    },
                    builder: browserBuilder,
                });
                client_2;
                IntegrationPlugin(client_2);
                client_2.init({
                    bid: bid,
                    integrations: [offlineIntegration()],
                });
                client_2_fake_fn = sinon.fake();
                client_2.on('beforeSend', client_2_fake_fn);
                client_2.start();
                // clear offline data when Client re-init
                return [4 /*yield*/, sleep(500)];
            case 6:
                // clear offline data when Client re-init
                _a.sent();
                t.assert(transport.post.calledThrice);
                postData = JSON.parse(transport.post.args[2][0].data);
                t.deepEqual(postData.list[0].payload, customEvent.payload);
                t.deepEqual(postData.list[1].payload, customEvent_2.payload);
                t.is(postData.list[0].common.context[CONTEXT_FLAG], '1');
                t.is(postData.list[1].common.context[CONTEXT_FLAG], '1');
                return [4 /*yield*/, get(bid, offlineStore)];
            case 7:
                data_3 = (_a.sent());
                t.true(data_3.length === 0);
                // it will re-store when trigger post.fail
                transport.post.args[2][0].fail('transport fail error');
                return [4 /*yield*/, sleep(500)];
            case 8:
                _a.sent();
                return [4 /*yield*/, get(bid, offlineStore)];
            case 9:
                restoreData = (_a.sent());
                t.true(restoreData.length === 2);
                return [2 /*return*/];
        }
    });
}); });
test.serial('offlineIntegration should send 50 count every time', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var bid, store, presetDataLength, maxSendSize, maxStoreEvents, data_1, transport, client, sendData, data_2, data_3, sendData_2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                bid = 'test_offline_resend';
                store = createStore(IndexedDB_Name, IndexedDB_Store_Name);
                presetDataLength = 100;
                maxSendSize = 50;
                maxStoreEvents = 200;
                return [4 /*yield*/, update(bid, function () {
                        return JSON.parse(JSON.stringify(new Array(presetDataLength).fill('')));
                    }, store)];
            case 1:
                _a.sent();
                return [4 /*yield*/, get(bid, store)];
            case 2:
                data_1 = _a.sent();
                t.is(data_1.length, presetDataLength);
                transport = {
                    post: sinon.fake(),
                    get: sinon.fake(),
                };
                client = createTestWebClient({
                    transport: transport,
                    createSender: function () {
                        return createBrowserSender({
                            size: 20,
                            endpoint: 'test.com',
                            transport: transport,
                        });
                    },
                    builder: browserBuilder,
                });
                IntegrationPlugin(client);
                client.init({
                    bid: bid,
                    integrations: [offlineIntegration({ maxSendSize: maxSendSize, maxStoreEvents: maxStoreEvents })],
                });
                client.start();
                return [4 /*yield*/, sleep(1000)];
            case 3:
                _a.sent();
                sendData = JSON.parse(transport.post.args[0][0].data);
                t.is(sendData.list.length, maxSendSize);
                return [4 /*yield*/, get(bid, store)];
            case 4:
                data_2 = _a.sent();
                t.is(data_2.length, presetDataLength - maxSendSize);
                t.assert(transport.post.calledOnce);
                transport.post.args[0][0].success();
                return [4 /*yield*/, sleep(SendIntervalTime)
                    // keep sending the rest of data
                ];
            case 5:
                _a.sent();
                return [4 /*yield*/, get(bid, store)];
            case 6:
                data_3 = _a.sent();
                t.is(data_3.length, 0);
                t.assert(transport.post.calledTwice);
                sendData_2 = JSON.parse(transport.post.args[1][0].data);
                t.is(sendData_2.list.length, presetDataLength - maxSendSize);
                return [2 /*return*/];
        }
    });
}); });//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/integrations/esm/__test__/offline.spec.js.map