import { __awaiter, __generator } from "tslib";
import test from 'ava';
import { createTestWebClient } from 'sdk-web/src/utils/__test__/util';
import sinon from 'sinon';
import { ContextPlugin, IntegrationPlugin, withCommandArray } from '@slardar/sdk-template';
import { libra } from '../libra';
import { pause } from '../pause';
function createMockTestValues() {
    return {
        test1: { val: 1, vid: '1' },
        test2: { val: 2, vid: '2' },
    };
}
function mockTea() {
    return {
        getVar: sinon.stub(),
        getAllVars: sinon.stub().callsFake(function (cb) {
            cb(createMockTestValues());
        }),
    };
}
function mockAsyncTea() {
    return {
        getVar: sinon.stub(),
        getAllVars: sinon.stub().callsFake(function (cb) {
            setTimeout(function () { return cb(createMockTestValues()); }, 100);
        }),
    };
}
function createMockClient(tea, options, isLoadPause) {
    if (tea === void 0) { tea = mockTea(); }
    if (isLoadPause === void 0) { isLoadPause = true; }
    var originTea = { getVar: tea.getVar, getAllVars: tea.getAllVars };
    var client = createTestWebClient();
    ContextPlugin(client);
    client = withCommandArray(client);
    IntegrationPlugin(client);
    client.init({
        // pause must before libra
        integrations: isLoadPause ? [pause(), libra(tea, options)] : [libra(tea, options)],
        bid: '',
    });
    var reportCb = sinon.stub();
    client.on('report', reportCb);
    return {
        client: client,
        tea: tea,
        originTea: originTea,
        reportCb: reportCb,
    };
}
function createMockReport(name) {
    return {
        ev_type: 'custom',
        payload: {
            type: 'event',
            name: name,
        },
    };
}
test('should add test to context', function (t) {
    var _a, _b, _c;
    var client = createMockClient().client;
    var context = client.context;
    (_a = client.libra) === null || _a === void 0 ? void 0 : _a.addTest('test1');
    t.falsy(context.get('test1'));
    t.is(context.get('libra_test1'), '1');
    (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test2');
    t.falsy(context.get('test2'));
    t.is(context.get('libra_test2'), '2');
    (_c = client.libra) === null || _c === void 0 ? void 0 : _c.addTest('test3');
    t.falsy(context.get('test3'));
    t.falsy(context.get('libra_test3'));
});
test('should remove test to context', function (t) {
    var _a, _b, _c;
    var client = createMockClient().client;
    var context = client.context;
    (_a = client.libra) === null || _a === void 0 ? void 0 : _a.addTest('test1');
    (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test2');
    (_c = client.libra) === null || _c === void 0 ? void 0 : _c.removeTest('test1');
    t.falsy(context.get('test1'));
    t.is(context.get('libra_test2'), '2');
});
test('should get all test name in context', function (t) {
    var _a, _b, _c, _d;
    var client = createMockClient().client;
    (_a = client.libra) === null || _a === void 0 ? void 0 : _a.addTest('test1');
    (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test2');
    (_c = client.libra) === null || _c === void 0 ? void 0 : _c.addTest('test3');
    t.deepEqual((_d = client.libra) === null || _d === void 0 ? void 0 : _d.getAllTests(), ['test1', 'test2']);
});
test('should clear test', function (t) {
    var _a, _b, _c, _d;
    var client = createMockClient().client;
    var context = client.context;
    (_a = client.libra) === null || _a === void 0 ? void 0 : _a.addTest('test1');
    (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test2');
    (_c = client.libra) === null || _c === void 0 ? void 0 : _c.addTest('test3');
    context.set('test4', '4');
    (_d = client.libra) === null || _d === void 0 ? void 0 : _d.clearTest();
    t.is(Object.keys(context.toString()).length, 1);
    t.is(context.get('test4'), '4');
});
test('should not hook tea.getVar if isHook = false', function (t) {
    var _a;
    var _b = createMockClient(mockTea(), { isHook: false }), client = _b.client, tea = _b.tea, originTea = _b.originTea;
    t.deepEqual(tea, originTea);
    var context = client.context;
    (_a = tea.getVar) === null || _a === void 0 ? void 0 : _a.call(tea, 'test1', '111', sinon.stub());
    t.falsy(context.get('test1'));
    t.falsy(context.get('libra_test1'));
});
test('should hook tea.getVar if isHook = true', function (t) {
    var _a, _b, _c;
    var _d = createMockClient(mockTea(), { isHook: true }), client = _d.client, tea = _d.tea, originTea = _d.originTea;
    var context = client.context;
    t.notDeepEqual(tea, originTea);
    var mockCb = sinon.stub();
    (_a = tea.getVar) === null || _a === void 0 ? void 0 : _a.call(tea, 'test1', '111', mockCb);
    t.falsy(context.get('test1'));
    t.is(context.get('libra_test1'), '1');
    t.is(Object.keys(context.toString()).length, 1);
    t.deepEqual(originTea.getVar.getCall(0).args, ['test1', '111', mockCb]);
    // repeat same test name
    (_b = tea.getVar) === null || _b === void 0 ? void 0 : _b.call(tea, 'test1', '222', mockCb);
    t.falsy(context.get('test1'));
    t.is(context.get('libra_test1'), '1');
    t.is(Object.keys(context.toString()).length, 1);
    originTea.getVar.reset();
    (_c = tea.getVar) === null || _c === void 0 ? void 0 : _c.call(tea, 'test2', '111', mockCb);
    t.falsy(context.get('test2'));
    t.is(context.get('libra_test2'), '2');
    t.is(Object.keys(context.toString()).length, 2);
    t.deepEqual(originTea.getVar.getCall(0).args, ['test2', '111', mockCb]);
});
test('should pause client when tea.getAllVars has been not invoked, if options.isPause = true', function (t) {
    var _a, _b;
    var _c = createMockClient(mockAsyncTea(), { isPause: true }), client = _c.client, reportCb = _c.reportCb;
    var context = client.context;
    (_a = client.libra) === null || _a === void 0 ? void 0 : _a.addTest('test1');
    t.falsy(context.get('libra_test1'));
    client.report(createMockReport('1'));
    client.report(createMockReport('2'));
    t.is((_b = client.pause) === null || _b === void 0 ? void 0 : _b.getQueueSize(), 2);
    t.false(reportCb.called);
});
test.serial('should resume client when tea.getAllVars has been invoked, if options.isPause = true', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var clock, _a, client, reportCb, context;
    var _b, _c, _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                clock = sinon.useFakeTimers();
                _a = createMockClient(mockAsyncTea(), { isPause: true }), client = _a.client, reportCb = _a.reportCb;
                context = client.context;
                (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test1');
                t.falsy(context.get('libra_test1'));
                client.report(createMockReport('1'));
                client.report(createMockReport('2'));
                t.is((_c = client.pause) === null || _c === void 0 ? void 0 : _c.getQueueSize(), 2);
                t.false(reportCb.called);
                return [4 /*yield*/, clock.tickAsync(101)];
            case 1:
                _e.sent();
                t.is((_d = client.pause) === null || _d === void 0 ? void 0 : _d.getQueueSize(), 0);
                t.is(reportCb.callCount, 2);
                t.is(context.get('libra_test1'), '1');
                clock.restore();
                return [2 /*return*/];
        }
    });
}); });
test.serial('should do nothing, if pause integration does not load and isPause = true', function (t) {
    var client = createMockClient(mockAsyncTea(), { isPause: true }, false).client;
    t.falsy(client.libra);
});
test.serial('should not pause client anymore, if options.isPause = false', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, client, reportCb, clock, context;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _a = createMockClient(mockAsyncTea(), { isPause: false }), client = _a.client, reportCb = _a.reportCb;
                clock = sinon.useFakeTimers();
                context = client.context;
                (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test1');
                t.falsy(context.get('libra_test1'));
                client.report(createMockReport('1'));
                client.report(createMockReport('2'));
                t.is(reportCb.callCount, 2);
                return [4 /*yield*/, clock.tickAsync(101)];
            case 1:
                _c.sent();
                t.is(context.get('libra_test1'), '1');
                clock.restore();
                return [2 /*return*/];
        }
    });
}); });
test.serial('should resume client when queue is full, if options.isResume = true', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, client, reportCb, clock, context;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _a = createMockClient(mockAsyncTea(), { capacity: 3, isResume: true }), client = _a.client, reportCb = _a.reportCb;
                clock = sinon.useFakeTimers();
                context = client.context;
                (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test1');
                t.falsy(context.get('libra_test1'));
                client.report(createMockReport('1'));
                client.report(createMockReport('2'));
                t.falsy(context.get('libra_test1'));
                t.is(reportCb.callCount, 0);
                // full
                client.report(createMockReport('3'));
                t.is(reportCb.callCount, 3);
                t.falsy(context.get('libra_test1'));
                client.report(createMockReport('4'));
                t.is(reportCb.callCount, 4);
                return [4 /*yield*/, clock.tickAsync(101)];
            case 1:
                _c.sent();
                t.is(context.get('libra_test1'), '1');
                client.report(createMockReport('5'));
                t.is(reportCb.callCount, 5);
                clock.restore();
                return [2 /*return*/];
        }
    });
}); });
test.serial('should stop client and discard report event when queue is full, if options.isResume = false', function (t) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, client, reportCb, clock, context, report1, report2, report3, report4;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _a = createMockClient(mockAsyncTea(), { capacity: 3, isResume: false }), client = _a.client, reportCb = _a.reportCb;
                clock = sinon.useFakeTimers();
                context = client.context;
                (_b = client.libra) === null || _b === void 0 ? void 0 : _b.addTest('test1');
                t.falsy(context.get('libra_test1'));
                report1 = createMockReport('1');
                report2 = createMockReport('1');
                report3 = createMockReport('1');
                report4 = createMockReport('1');
                client.report(report1);
                client.report(report2);
                t.falsy(context.get('libra_test1'));
                t.is(reportCb.callCount, 0);
                // full
                client.report(report3);
                t.is(reportCb.callCount, 0);
                t.falsy(context.get('libra_test1'));
                client.report(report4);
                t.is(reportCb.callCount, 0);
                t.falsy(context.get('libra_test1'));
                return [4 /*yield*/, clock.tickAsync(101)];
            case 1:
                _c.sent();
                t.is(context.get('libra_test1'), '1');
                t.is(reportCb.callCount, 3);
                t.deepEqual(reportCb.getCall(0).args, [report2]);
                t.deepEqual(reportCb.getCall(1).args, [report3]);
                t.deepEqual(reportCb.getCall(2).args, [report4]);
                client.report(createMockReport('5'));
                t.is(reportCb.callCount, 4);
                clock.restore();
                return [2 /*return*/];
        }
    });
}); });
test('beforeDestroy', function (t) {
    var _a, _b;
    var _c = createMockClient(), client = _c.client, tea = _c.tea, originTea = _c.originTea;
    var context = client.context;
    context.set('other', 1);
    var mockCb = sinon.stub();
    (_a = tea.getVar) === null || _a === void 0 ? void 0 : _a.call(tea, 'test1', '111', mockCb);
    t.is(context.get('libra_test1'), '1');
    (_b = tea.getVar) === null || _b === void 0 ? void 0 : _b.call(tea, 'test2', '111', mockCb);
    t.is(context.get('libra_test2'), '2');
    t.not(tea.getVar, originTea.getVar);
    client.destroy();
    // clear libra context
    t.is(Object.keys(context.toString()).length, 1);
    t.is(context.get('other'), '1');
    // unhook
    t.is(tea.getVar, originTea.getVar);
});//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/integrations/esm/__test__/libra.spec.js.map