import { __awaiter, __generator } from "tslib";
/* eslint-disable @typescript-eslint/no-misused-promises */
import { createStore, update } from 'idb-keyval';
import { stringifyBatch } from '@slardar/sdk-template';
import { getDefaultBrowser, applyRequestIdleCallback } from '@slardar/sdk-web';
export var OFFLINE_INTEGRATION_NAME = 'offline';
export var IndexedDB_Name = "__" + OFFLINE_INTEGRATION_NAME + "__db__";
export var IndexedDB_Store_Name = "__" + OFFLINE_INTEGRATION_NAME + "__store__";
var MaxSendSize = 60;
var MaxStoreEvents = 60;
export var SendIntervalTime = 2000;
export var CONTEXT_FLAG = "_is_" + OFFLINE_INTEGRATION_NAME + "_";
export var offlineIntegration = function (props) {
    var tearDownGroup = [];
    return {
        name: OFFLINE_INTEGRATION_NAME,
        setup: function (client) {
            var win = getDefaultBrowser();
            if (!win || !indexedDB)
                return;
            var maxStoreEvents = (props && props.maxStoreEvents) || MaxStoreEvents;
            var maxSendSize = (props && props.maxSendSize) || MaxSendSize;
            var isPostDataFailed = false;
            var _a = client.config(), transport = _a.transport, bid = _a.bid;
            var storeKey = bid;
            var sender = client.getSender();
            var isOffline = getOffline();
            var requestIdleCallback = applyRequestIdleCallback(win);
            /**
             * report the data where cached on indexedDB
             * @param data
             * @param fail
             */
            var postData = function (data, success, fail) {
                transport.post({
                    url: sender.getEndpoint(),
                    data: data,
                    success: success,
                    fail: function (err) {
                        fail(err, data);
                    },
                });
            };
            var initialization = function () {
                var offlineStore = createStore(IndexedDB_Name, IndexedDB_Store_Name);
                var handleFailCallback = function (_err, batchStringData) {
                    var data;
                    try {
                        var batchData = JSON.parse(batchStringData);
                        data = batchData.list;
                    }
                    catch (_a) {
                        // do nothing
                    }
                    isPostDataFailed = true;
                    if (data) {
                        data.forEach(function (event) { return (event.common.context[CONTEXT_FLAG] = '1'); });
                        void insertData(offlineStore, storeKey, data, maxStoreEvents);
                    }
                };
                var sendEvents = function () { return __awaiter(void 0, void 0, void 0, function () {
                    var events;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, spliceStore(offlineStore, storeKey, maxSendSize)];
                            case 1:
                                events = _a.sent();
                                if (events.length && !isPostDataFailed) {
                                    postData(stringifyBatch(events), function () { return setTimeout(function () { return void sendEvents(); }, SendIntervalTime); }, handleFailCallback);
                                }
                                return [2 /*return*/];
                        }
                    });
                }); };
                sender.fail && sender.fail(handleFailCallback);
                tearDownGroup.push(onlineListener(sendEvents));
                // send events immediately as soon as initialization completes
                if (!isOffline())
                    void sendEvents();
            };
            var onStart = function () {
                return requestIdleCallback(function () {
                    void initialization();
                });
            };
            client.on('start', onStart);
            tearDownGroup.push(function () { return client.off('start', onStart); });
        },
        tearDown: function () { return tearDownGroup.forEach(function (fn) { return fn(); }); },
    };
};
export function insertData(store, storeKey, events, maxStoreEvents) {
    if (maxStoreEvents === void 0) { maxStoreEvents = MaxStoreEvents; }
    return __awaiter(this, void 0, void 0, function () {
        var error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, update(storeKey, function (oldData) {
                            if (!Array.isArray(oldData))
                                return events;
                            var mergedData = oldData.concat(events);
                            return mergedData.length > maxStoreEvents
                                ? mergedData.slice(mergedData.length - maxStoreEvents, mergedData.length)
                                : mergedData;
                        }, store)];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    // may be throw error like an object can't be cloned
                    console.info('indexedDB update error', error_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
export function spliceStore(store, storeKey, deleteCount) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = [];
                    return [4 /*yield*/, update(storeKey, function (val) {
                            if (val) {
                                result = val.splice(0, deleteCount);
                                return val;
                            }
                            return [];
                        }, store)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
/**
 * return false if window or navigator.onLine is undefined
 * @returns
 */
export function getOffline() {
    var window = getDefaultBrowser();
    if (!(window && 'navigator' in window && 'onLine' in window.navigator))
        return function () { return false; };
    return function () { return !window.navigator.onLine; };
}
export function onlineListener(callback) {
    var window = getDefaultBrowser();
    if (window && 'addEventListener' in window) {
        window.addEventListener('online', callback);
        return function () { return window.removeEventListener('online', callback); };
    }
    return function () { };
}//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/integrations/esm/offline.js.map