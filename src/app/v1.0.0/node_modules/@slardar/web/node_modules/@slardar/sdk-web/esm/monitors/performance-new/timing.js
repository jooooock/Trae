import { __read } from "tslib";
import { PERFORMANCE_TIMING_EV_TYPE } from '../../constants';
import { applyPerformance, getDefaultPerformance } from '../../utils';
import { applySendOnceAndTearDown } from './util';
export var TIMING_METRIC_NAME = "timing" /* timing */;
var getTiming = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), loadObserver = _b[0], getActivatedObserver = _b[1], unloadObserver = _b[2];
    var performance = getDefaultPerformance();
    var _c = __read(applyPerformance(performance), 3), timing = _c[0], now = _c[1], getEntriesByType = _c[2];
    var wrapTiming = function (isBounced) {
        var navigation = getEntriesByType('navigation')[0];
        var responseStart = navigation && navigation.responseStart;
        // In some cases no value is reported by the browser (for privacy/security reasons)
        // and in other cases (bugs) the value is negative or is larger than the current page time
        if (!responseStart || responseStart <= 0 || responseStart > now()) {
            navigation = undefined;
        }
        return {
            ev_type: PERFORMANCE_TIMING_EV_TYPE,
            payload: {
                isBounced: isBounced,
                timing: timing,
                navigation_timing: navigation,
            },
        };
    };
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapTiming, report, tearDownGroup);
    tearDownGroup.push(unloadObserver[0](function () {
        sendOnceAndTearDown(true);
    }));
    var loadCallback = function () {
        // need to dynamic get activatedObserver because it is executed asynchronously
        var activatedObserver = getActivatedObserver();
        var activatedCallback = function () {
            sendOnceAndTearDown(false);
        };
        // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        tearDownGroup.push(function () { return activatedObserver[1](activatedCallback); });
        activatedObserver[0](activatedCallback);
    };
    // loadObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return loadObserver[1](loadCallback); });
    loadObserver[0](loadCallback);
};
export var TIMING = [TIMING_METRIC_NAME, getTiming];//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/web/node_modules/@slardar/sdk-web/esm/monitors/performance-new/timing.js.map