import { __assign, __read } from "tslib";
import { noop, isString, checkIfHit } from '@slardar/sdk-template';
import { HTTP_EV_TYPE } from '../../constants';
import { now, getFullUrl } from '../../utils';
import { isSensitiveHeader, applySendOnce, handleWithExtractUrl } from './util';
export var httpGetterWithFetchObserver = function (tearDownGroup, _a, fetchConfig) {
    var _b = __read(_a, 2), fetchObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = fetchConfig.setTraceHeader, ignoreUrls = fetchConfig.ignoreUrls, setContextAtReq = fetchConfig.setContextAtReq, extractUrl = fetchConfig.extractUrl;
    // eslint-disable-next-line compat/compat
    var Headers = window.Headers;
    // eslint-disable-next-line compat/compat
    var Request = window.Request;
    if (!Request || !Headers)
        return;
    tearDownGroup.push(fetchObserver[0](function (_a) {
        var _b = __read(_a, 2), req = _b[0], options = _b[1];
        var url = getFullUrl(req instanceof Request ? req.url : req);
        if (!isHttpURL(url) || checkIfHit(ignoreUrls, url)) {
            return noop;
        }
        setTraceHeader &&
            setTraceHeader(url, function (key, value) { return addHeader(key, value, req, options, Request, Headers); });
        var reportWithContext = setContextAtReq();
        var _start = now();
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            url === entry.name && !timing && (timing = entry);
        });
        return function (res) {
            var payload = getEventParams(req, options, res, Request, Headers, fetchConfig, _start);
            var reportFetchData = applySendOnce(function (data) {
                timing && (data.response.timing = timing);
                handleWithExtractUrl(data, extractUrl);
                reportWithContext && reportWithContext({ ev_type: HTTP_EV_TYPE, payload: data });
                resourceTearDown();
            });
            setTimeout(function () {
                reportFetchData(payload);
            }, 1000);
        };
    }));
};
var isHttpURL = function (url) {
    if (!isString(url)) {
        return false;
    }
    var _a = __read(url.split(':'), 2), protocol = _a[0], path = _a[1];
    return !path || protocol === 'http' || protocol === 'https';
};
var isRequest = function (req, Request) {
    return req instanceof Request;
};
var addHeader = function (key, value, req, options, Request, Headers) {
    var _a;
    if (isRequest(req, Request)) {
        req.headers.set(key, value);
    }
    else if (options.headers instanceof Headers) {
        options.headers.set(key, value);
    }
    else {
        options.headers = __assign(__assign({}, options.headers), (_a = {}, _a[key] = value, _a));
    }
};
export var getFetchMethod = function (req, options, Request) {
    var method = (options && options.method) || 'get';
    if (isRequest(req, Request)) {
        method = req.method || method;
    }
    return method.toLowerCase();
};
var mergeHeaders = function (Headers) {
    var headers = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        headers[_i - 1] = arguments[_i];
    }
    try {
        return headers.reduce(function (sum, cur) {
            // eslint-disable-next-line compat/compat
            new Headers(cur || {}).forEach(function (val, key) { return !isSensitiveHeader(key, val) && (sum[key] = val); });
            return sum;
        }, {});
    }
    catch (_a) {
        return {};
    }
};
var getFetchBody = function (req, options, Request) {
    if (isRequest(req, Request)) {
        return req.body;
    }
    else {
        return options === null || options === void 0 ? void 0 : options.body;
    }
};
var getEventParams = function (req, options, res, Request, Headers, props, _start) {
    var params = {
        api: 'fetch',
        request: {
            method: getFetchMethod(req, options, Request),
            timestamp: _start,
            url: getFullUrl(req instanceof Request ? req.url : req),
            headers: mergeHeaders(Headers, req.headers, options.headers),
        },
        response: {
            status: (res && res.status) || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    var setRequestBodyIfAllowed = function () {
        var _a;
        collectBodyOnError && (params.request.body = (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString());
    };
    if (res) {
        try {
            var resHeaders = mergeHeaders(Headers, res.headers);
            params.response.headers = resHeaders;
            try {
                // only when the content-type includes 'application/json' can convert to JSON.
                ;
                (resHeaders['content-type'] || '').indexOf('application/json') !== -1 &&
                    extraExtractor &&
                    res
                        .clone()
                        .json()
                        .then(function (o) {
                        var _a;
                        var extra = extraExtractor(o, params, (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString());
                        if (extra) {
                            params.extra = extra;
                            params.response.is_custom_error = true;
                            setRequestBodyIfAllowed();
                        }
                    })
                        .catch(noop);
            }
            catch (_o) {
                // do nothing
            }
            res.status >= 400 && setRequestBodyIfAllowed();
        }
        catch (_a) {
            // do nothing
        }
    }
    else {
        setRequestBodyIfAllowed();
    }
    return params;
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/web/node_modules/@slardar/sdk-web/esm/monitors/http/fetch.js.map