'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_SIZE = 10;
var DEFAULT_WAIT = 1000;
var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};
function createBatchSender(config) {
    var transport = config.transport;
    var endpoint = config.endpoint, _a = config.size, size = _a === void 0 ? DEFAULT_SIZE : _a, _b = config.wait, wait = _b === void 0 ? DEFAULT_WAIT : _b;
    var batch = [];
    var tid = 0;
    var fail;
    var sender = {
        getSize: function () {
            return size;
        },
        getWait: function () {
            return wait;
        },
        setSize: function (v) {
            size = v;
        },
        setWait: function (v) {
            wait = v;
        },
        getEndpoint: function () {
            return endpoint;
        },
        setEndpoint: function (v) {
            endpoint = v;
        },
        send: function (e) {
            batch.push(e);
            if (batch.length >= size) {
                sendBatch.call(this);
            }
            clearTimeout(tid);
            tid = setTimeout(sendBatch.bind(this), wait);
        },
        flush: function () {
            clearTimeout(tid);
            sendBatch.call(this);
        },
        getBatchData: function () {
            return batch.length ? stringifyBatch(batch) : '';
        },
        clear: function () {
            clearTimeout(tid);
            batch = [];
        },
        fail: function (cb) {
            fail = cb;
        },
    };
    function sendBatch() {
        if (!batch.length) {
            return;
        }
        var data = this.getBatchData();
        transport.post({
            url: endpoint,
            data: data,
            fail: function (err) {
                fail && fail(err, data);
            },
        });
        batch = [];
    }
    return sender;
}

var EVENTS = [
    'init',
    'start',
    'config',
    'beforeDestroy',
    'provide',
    'beforeReport',
    'report',
    'beforeBuild',
    'build',
    'beforeSend',
    'send',
    'beforeConfig',
];

var noop = function () { return ({}); };
function id(v) {
    return v;
}

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isUndefined(o) {
    return o === undefined;
}
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
var objProto = Object.prototype;
// https://stackoverflow.com/a/5878101
function isPlainObject(o) {
    if (isObject(o)) {
        if (typeof Object.getPrototypeOf === 'function') {
            var proto = Object.getPrototypeOf(o);
            return proto === objProto || proto === null;
        }
        // cannot test, requires ES3
        /* istanbul ignore next */
        return objProto.toString.call(o) === '[object Object]';
    }
    return false;
}
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isBoolean(o) {
    return typeof o === 'boolean';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isString(o) {
    return typeof o === 'string';
}
function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            /* istanbul ignore next */
            return true;
        case '[object DOMError]':
            return true;
        case '[object DOMException]':
            /* istanbul ignore next */
            return true;
        default:
            /* istanbul ignore next */
            return wat instanceof Error;
    }
}
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
function isErrorEvent(what) {
    return Object.prototype.toString.call(what) === '[object ErrorEvent]';
}
function isPromiseRejectionEvent(what) {
    return Object.prototype.toString.call(what) === '[object PromiseRejectionEvent]';
}

function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
// 把source对象中的内容深度赋给target, 数组合并
function mergeDeepConcatArray() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    var result = {};
    var k = 0;
    while (k < source.length) {
        result = _mergeDeepMergeArray(result, source[k++]);
    }
    return result;
}
// 递归赋值
function _mergeDeepMergeArray(target, source) {
    var result = __assign({}, target);
    for (var key in source) {
        if (hasKey(source, key) && source[key] !== undefined) {
            if (isObject(source[key]) && isPlainObject(source[key])) {
                result[key] = _mergeDeepMergeArray(isObject(target[key]) ? target[key] : {}, source[key]);
            }
            else if (isArray(source[key]) && isArray(target[key])) {
                result[key] = _mergeDeepArray(target[key], source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
    }
    return result;
}
function _mergeDeepArray(target, source) {
    var _target = isArray(target) ? target : [];
    var _source = isArray(source) ? source : [];
    return Array.prototype.concat.call(_target, _source).map(function (v) {
        if (v instanceof RegExp) {
            return v;
        }
        else if (isObject(v) && isPlainObject(v)) {
            return _mergeDeepMergeArray({}, v);
        }
        else if (isArray(v)) {
            return _mergeDeepArray([], v);
        }
        else {
            return v;
        }
    });
}
// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};
/**
 * 按路径访问对象属性
 * @param target 待访问对象
 * @param property 访问属性路径
 * @param { (target: any, property: string): any } visitor 访问器
 */
var safeVisit = function (target, path, visitor) {
    var _a, _b;
    var paths = path.split('.');
    var _c = __read(paths), method = _c[0], rest = _c.slice(1);
    while (target && rest.length > 0) {
        target = target[method];
        _a = rest, _b = __read(_a), method = _b[0], rest = _b.slice(1);
    }
    if (!target) {
        return undefined;
    }
    return visitor(target, method);
};
/**
 *  按路径调用函数
 * @param target 待调用对象，如 `client`
 * @param methods 待调用方法路径，可能是一级路径 `client.start`, 或者是多级命令 `client.context.set`
 * @param args 调用参数
 */
var safeCall = function (target, method, args) {
    return safeVisit(target, method, function (obj, property) {
        if (obj && property in obj && isFunction(obj[property])) {
            try {
                return obj[property].apply(obj, args);
            }
            catch (err) {
                // ignore
                return undefined;
            }
        }
    });
};
var applyRecord = function () {
    var record = {};
    var set = function (key, val) { return (record[key] = val); };
    var del = function (key) { return delete record[key]; };
    return [record, set, del];
};
var pick = function (obj, keys) {
    if (!obj || !isObject(obj))
        return obj;
    return keys.reduce(function (prev, cur) {
        prev[cur] = obj[cur];
        return prev;
    }, {});
};

var camelToKebab = function (str) {
    return str.replace(/([a-z])([A-Z])/g, function (_, a, b) { return a + "-" + b.toLowerCase(); });
};
function getRegexp(ignore) {
    if (!isArray(ignore)) {
        return null;
    }
    return ignore.length ? joinRegExp(ignore) : null;
}
function joinRegExp(patterns) {
    var sources = [];
    var len = patterns.length;
    for (var i = 0; i < len; i++) {
        var pattern = patterns[i];
        if (isString(pattern)) {
            sources.push(pattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'));
        }
        else if (pattern && pattern.source) {
            sources.push(pattern.source);
        }
    }
    return new RegExp(sources.join('|'), 'i');
}
var checkIfHit = function (rules, url) {
    var Rgx = getRegexp(rules || []);
    return !!Rgx && Rgx.test(url);
};
function safeStringify(a) {
    try {
        return isString(a) ? a : JSON.stringify(a);
    }
    catch (err) {
        return '[FAILED_TO_STRINGIFY]:' + String(err);
    }
}

function createContextAgent() {
    var context = {};
    var stringified = {};
    var contextAgent = {
        set: function (k, v) {
            context[k] = v;
            stringified[k] = safeStringify(v);
            return contextAgent;
        },
        merge: function (ctx) {
            context = __assign(__assign({}, context), ctx);
            Object.keys(ctx).forEach(function (key) {
                stringified[key] = safeStringify(ctx[key]);
            });
            return contextAgent;
        },
        delete: function (k) {
            delete context[k];
            delete stringified[k];
            return contextAgent;
        },
        clear: function () {
            context = {};
            stringified = {};
            return contextAgent;
        },
        get: function (k) {
            return stringified[k];
        },
        toString: function () {
            return __assign({}, stringified);
        },
    };
    return contextAgent;
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};

var getPrintString = function () {
    // @ts-expect-error
    if (''.padStart) {
        return function (str, prefixLength) {
            if (prefixLength === void 0) { prefixLength = 8; }
            return str.padStart(prefixLength, ' ');
        };
    }
    return function (str) { return str; };
};
var printString = getPrintString();
var errCount = 0;
var error = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.error.apply(console, __spreadArray(['[SDK]', Date.now(), printString("" + errCount++)], __read(args), false));
};
var warnCount = 0;
var warn = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.warn.apply(console, __spreadArray(['[SDK]', Date.now(), printString("" + warnCount++)], __read(args), false));
};

var isHitBySampleRate = function (sampleRate) {
    if (Math.random() < Number(sampleRate)) {
        return true;
    }
    return false;
};
var isHitByRandom = function (random, sampleRate) {
    if (random < Number(sampleRate)) {
        return true;
    }
    return false;
};

var runProcessors = function (fns) {
    return function (e) {
        var r = e;
        for (var i = 0; i < fns.length; i++) {
            if (r) {
                try {
                    r = fns[i](r);
                }
                catch (err) {
                    error(err);
                }
            }
            else {
                break;
            }
        }
        return r;
    };
};
var runFilters = function (fns) {
    return function (e) {
        var r = true;
        for (var i = 0; i < fns.length; i++) {
            if (r) {
                try {
                    r = fns[i](e);
                }
                catch (err) {
                    error(err);
                }
            }
            else {
                break;
            }
        }
        return r;
    };
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};
var wrapFilters = function (originObservable, filters) {
    var _a = __read(originObservable, 1), subscribe = _a[0];
    var filteredObserver = function (next, tearDown) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        var unsubscribe = subscribe(function (o) {
            var hitFilter = runFilters(filters)(o);
            return hitFilter ? next(o) : noop;
        });
        tearDown(function () {
            unsubscribe();
        });
    };
    return filteredObserver;
};

function createDestroyAgent() {
    var destroyed = false;
    var data = {};
    var removeTearDownGroup = function (tearDownGroup) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                try {
                    v();
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { }
            });
        tearDownGroup.length = 0;
    };
    var removeByPluginName = function (pluginName) {
        data[pluginName] &&
            data[pluginName].forEach(function (e) {
                removeTearDownGroup(e[1]);
            });
        data[pluginName] = undefined;
    };
    var removeByEvType = function (evType) {
        Object.keys(data).forEach(function (k) {
            data[k] &&
                data[k].forEach(function (e) {
                    if (e[0] === evType) {
                        removeTearDownGroup(e[1]);
                    }
                });
        });
    };
    return {
        /**
         * register tearDownGroup for a single plugin.
         */
        set: function (pluginName, evType, tearDownGroup) {
            if (data[pluginName])
                data[pluginName].push([evType, tearDownGroup]);
            else
                data[pluginName] = [[evType, tearDownGroup]];
            // auto remove tearDownGroup if destroyed
            destroyed && removeTearDownGroup(tearDownGroup);
        },
        has: function (pluginName) {
            return !!data[pluginName];
        },
        /**
         * remove tearDownGroup for a single plugin.
         */
        remove: removeByPluginName,
        /**
         * remove tearDownGroup by event type
         */
        removeByEvType: removeByEvType,
        /**
         * clear all tearDownGroup
         */
        clear: function () {
            destroyed = true;
            Object.keys(data).forEach(function (k) {
                removeByPluginName(k);
            });
        },
    };
}
/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

function createClient(creationConfig) {
    var builder = creationConfig.builder, createSender = creationConfig.createSender, createDefaultConfig = creationConfig.createDefaultConfig, createConfigManager = creationConfig.createConfigManager, userConfigNormalizer = creationConfig.userConfigNormalizer, initConfigNormalizer = creationConfig.initConfigNormalizer, validateInitConfig = creationConfig.validateInitConfig;
    var sender;
    var configManager;
    var handlers = {};
    EVENTS.forEach(function (e) { return (handlers[e] = []); });
    var inited = false;
    var started = false;
    var destroyed = false;
    // 缓存 start 之前 build 的事件
    var preStartQueue = [];
    // 禁止通过 provide 挂载的字段名
    var reservedNames = [];
    var destroyAgent = createDestroyAgent();
    var client = {
        getBuilder: function () { return builder; },
        getSender: function () { return sender; },
        getPreStartQueue: function () { return preStartQueue; },
        init: function (c) {
            if (inited) {
                warn('already inited');
                return;
            }
            if (c && isObject(c) && validateInitConfig(c)) {
                var defaultConfig = createDefaultConfig(c);
                if (!defaultConfig) {
                    throw new Error('defaultConfig missing');
                }
                var initConfig = initConfigNormalizer(c);
                configManager = createConfigManager(defaultConfig);
                configManager.setConfig(initConfig);
                configManager.onChange(function () {
                    handle('config');
                });
                sender = createSender(configManager.getConfig());
                if (!sender) {
                    throw new Error('sender missing');
                }
                inited = true;
                handle('init', true);
            }
            else {
                throw new Error('invalid InitConfig, init failed');
            }
        },
        set: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(c);
            }
        },
        config: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(userConfigNormalizer(c));
            }
            return configManager === null || configManager === void 0 ? void 0 : configManager.getConfig();
        },
        provide: function (name, value) {
            if (arrayIncludes(reservedNames, name)) {
                warn("cannot provide " + name + ", reserved");
                return;
            }
            client[name] = value;
            handle('provide', false, name);
        },
        start: function () {
            var _this = this;
            if (!inited) {
                return;
            }
            if (started) {
                return;
            }
            configManager === null || configManager === void 0 ? void 0 : configManager.onReady(function () {
                started = true;
                handle('start', true);
                preStartQueue.forEach(function (e) { return _this.build(e); });
                preStartQueue.length = 0;
            });
        },
        report: function (data) {
            if (!data) {
                return;
            }
            var preReport = runProcessors(handlers['beforeReport'])(data);
            if (!preReport) {
                return;
            }
            var processed = runProcessors(handlers['report'])(preReport);
            if (!processed) {
                return;
            }
            if (started) {
                this.build(processed);
            }
            else {
                preStartQueue.push(processed);
            }
        },
        build: function (data) {
            if (!started) {
                return;
            }
            var preBuild = runProcessors(handlers['beforeBuild'])(data);
            if (!preBuild) {
                return;
            }
            var built = builder.build(preBuild);
            if (!built) {
                return;
            }
            var processed = runProcessors(handlers['build'])(built);
            if (!processed) {
                return;
            }
            this.send(processed);
        },
        send: function (data) {
            if (!started) {
                return;
            }
            var processed = runProcessors(handlers['beforeSend'])(data);
            if (processed) {
                sender.send(processed);
                handle('send', false, processed);
            }
        },
        destroy: function () {
            destroyAgent.clear();
            destroyed = true;
            preStartQueue.length = 0;
            handle('beforeDestroy', true);
        },
        on: function (ev, handler) {
            if ((ev === 'init' && inited) || (ev === 'start' && started) || (ev === 'beforeDestroy' && destroyed)) {
                try {
                    ;
                    handler();
                }
                catch (_err) {
                    // ignore
                }
            }
            else if (handlers[ev]) {
                handlers[ev].push(handler);
            }
        },
        off: function (ev, handler) {
            if (handlers[ev])
                handlers[ev] = arrayRemove(handlers[ev], handler);
        },
        destroyAgent: destroyAgent,
    };
    reservedNames = Object.keys(client);
    return client;
    function handle(ev, once) {
        if (once === void 0) { once = false; }
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        handlers[ev].forEach(function (f) {
            try {
                f.apply(void 0, __spreadArray([], __read(args), false));
            }
            catch (_err) {
                // ignore
            }
        });
        if (once) {
            handlers[ev].length = 0;
        }
    }
}

var ContextPlugin = function (client) {
    var contextAgent = createContextAgent();
    client.provide('context', contextAgent);
    client.on('report', function (ev) {
        if (!ev.extra) {
            ev.extra = {};
        }
        ev.extra.context = contextAgent.toString();
        return ev;
    });
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var withCommandArray = function (client, captureContext, applyArgsWithContext) {
    // 缓存需要异步插件来消费的命令
    var cache = {};
    var newClient = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var methodPath = args[0];
        if (!methodPath)
            return;
        var method = methodPath.split('.')[0];
        // 捕获上下文，等异步插件加载后传入
        if (!(method in newClient)) {
            var cachedCommands = cache[method] || [];
            // 区分预收集来的上下文与普通上下文
            var capturedContext = (_a = captureContext === null || captureContext === void 0 ? void 0 : captureContext(client)) !== null && _a !== void 0 ? _a : {};
            cachedCommands.push(__spreadArray([capturedContext], __read(args), false));
            cache[method] = cachedCommands;
            return;
        }
        return safeCall(newClient, methodPath, [].slice.call(args, 1));
    };
    hookObjectProperty(client, 'provide', function (origin) {
        return function (name, value) {
            newClient[name] = value;
            origin.call(client, name, value);
        };
    })();
    for (var nextKey in client) {
        // Avoid bugs when hasOwnProperty is shadowed
        if (Object.prototype.hasOwnProperty.call(client, nextKey)) {
            newClient[nextKey] = client[nextKey];
        }
    }
    client.on('provide', function (name) {
        if (cache[name]) {
            cache[name].forEach(function (cachedCommands) {
                var _a = __read(cachedCommands), capturedContext = _a[0], args = _a.slice(1);
                applyArgsWithContext === null || applyArgsWithContext === void 0 ? void 0 : applyArgsWithContext(client, capturedContext, args);
            });
            cache[name] = null;
        }
    });
    return newClient;
};

function IntegrationPlugin(client, runAfterSetup) {
    client.on('init', function () {
        var nameList = [];
        var applyIntegrations = function (integrations) {
            integrations.forEach(function (integration) {
                var integrationName = integration.name;
                if (!arrayIncludes(nameList, integrationName)) {
                    nameList.push(integrationName);
                    integration.setup(client);
                    runAfterSetup && runAfterSetup(integrationName, integration.setup);
                    client.destroyAgent.set(integrationName, integrationName, [
                        function () {
                            nameList = arrayRemove(nameList, integrationName);
                            integration.tearDown && integration.tearDown();
                        },
                    ]);
                }
            });
        };
        client.provide('applyIntegrations', applyIntegrations);
        var config = client.config();
        if (config && config.integrations) {
            applyIntegrations(config.integrations);
        }
    });
}

var SubjectSpacer = '_';
var getSubjectKeyWithoutVersion = function (subjectKey) {
    return subjectKey.split(SubjectSpacer)[0];
};
function SubjectPlugin(client, globalSubjectMap) {
    var subjectMap = globalSubjectMap || {};
    var filterMap = {};
    // filter key is subject key but without subject spacer and subject version, and it only takes effect on subsequent observers
    var setFilter = function (subjectKeyWithoutVersion, filter) {
        if (!filterMap[subjectKeyWithoutVersion])
            filterMap[subjectKeyWithoutVersion] = [];
        filterMap[subjectKeyWithoutVersion].push(filter);
    };
    var initSubject = function (_a) {
        var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
        var filterKey = getSubjectKeyWithoutVersion(subjectKey);
        var filters = !!filterKey && filterMap[filterKey];
        if (!subjectMap[subjectKey])
            subjectMap[subjectKey] = createSafeObserver(observer, function () {
                subjectMap[subjectKey] = undefined;
            });
        if (!filters)
            return subjectMap[subjectKey];
        return initPrivateSubject(client, [
            subjectKey,
            wrapFilters(subjectMap[subjectKey], filters),
        ]);
    };
    client.provide('setFilter', setFilter);
    client.provide('initSubject', initSubject);
    client.provide('getSubject', function (key) { return subjectMap[key]; });
    client.provide('privateSubject', {});
}
/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultHistory() {
    // eslint-disable-next-line compat/compat
    return getDefaultBrowser() && window.history;
}
function getDefaultPerformance() {
    if (getDefaultBrowser() && isObject(window.performance))
        return window.performance;
}
function getDefaultXMLHttpRequest() {
    if (typeof XMLHttpRequest === 'function' && isFunction(XMLHttpRequest))
        return XMLHttpRequest;
}
function getDefaultMutationObserver() {
    if (getDefaultBrowser() && isFunction(window.MutationObserver))
        return window.MutationObserver;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}
function getDefaultRaf() {
    if (getDefaultBrowser() && 'requestAnimationFrame' in window) {
        return window.requestAnimationFrame;
    }
}
function getDefaultCaf() {
    if (getDefaultBrowser() && 'cancelAnimationFrame' in window) {
        return window.cancelAnimationFrame;
    }
}
function getDefaultNavigator() {
    if (getDefaultBrowser() && 'navigator' in window) {
        return window.navigator;
    }
}
function getDefaultNetworkInformation() {
    var navigator = getDefaultNavigator();
    if (navigator) {
        return navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    }
}
function getCurrentScript() {
    if (!document)
        return null;
    if (document.currentScript)
        return document.currentScript;
    // IE 8-10 support script readyState
    // IE 11+ support stack trace
    try {
        throw new Error();
    }
    catch (err) {
        // Find the second match for the "at" string to get file src url from stack.
        // Specifically works with the format of stack traces in IE.
        var i = 0;
        var stackDetails = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i.exec(err.stack);
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        var scriptLocation = (stackDetails && stackDetails[2]) || false;
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        var line = (stackDetails && stackDetails[3]) || 0;
        var currentLocation = document.location.href.replace(document.location.hash, '');
        var inlineScriptSource = '';
        var scripts = document.getElementsByTagName('script'); // Live NodeList collection
        if (scriptLocation === currentLocation) {
            var pageSource = document.documentElement.outerHTML;
            var inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
            inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
        }
        for (; i < scripts.length; i++) {
            // If ready state is interactive, return the script tag
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            if (scripts[i].readyState === 'interactive') {
                return scripts[i];
            }
            // If src matches, return the script tag
            if (scripts[i].src === scriptLocation) {
                return scripts[i];
            }
            // If inline source matches, return the script tag
            if (scriptLocation === currentLocation &&
                scripts[i].innerHTML &&
                scripts[i].innerHTML.trim() === inlineScriptSource) {
                return scripts[i];
            }
        }
        // If no match, return null
        return null;
    }
}

function getFullUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url)
        return '';
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}
function parseUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url) {
        return {
            url: url,
            protocol: '',
            domain: '',
            query: '',
            path: '',
            hash: '',
        };
    }
    var a = document.createElement('a');
    a.href = url;
    var path = a.pathname || '/';
    /* istanbul ignore next */
    if (path[0] !== '/') {
        path = '/' + path;
    }
    return {
        url: a.href,
        protocol: a.protocol.slice(0, -1),
        domain: a.hostname,
        query: a.search.substring(1),
        path: path,
        hash: a.hash,
    };
}
function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var reportWithCurrentContext = function (client, timeRequiresAdjustment) {
    if (timeRequiresAdjustment === void 0) { timeRequiresAdjustment = false; }
    var overrides = getOverrides(client);
    timeRequiresAdjustment && (overrides.timestamp = now());
    return function (ev) {
        client.report(__assign(__assign({}, ev), { overrides: overrides }));
    };
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client);
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = __assign(__assign({}, getOverrides(client)), getViewOverrides(newConfig));
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};
var FIRST_PV_SUBJECT_NAME = 'f_view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyFirstPV = function (client) {
    return function (_, tearDown) {
        var firstOverrides = getOverrides(client);
        tearDown(noop, function (subscriber) {
            firstOverrides && subscriber(firstOverrides);
        });
    };
};

// 获取全局注册表
var getGlobalRegistry = function (global) {
    if (!global)
        return;
    if (!global.__SLARDAR_REGISTRY__) {
        global.__SLARDAR_REGISTRY__ = {
            Slardar: {
                plugins: [],
                errors: [],
                subject: {},
            },
        };
    }
    return global.__SLARDAR_REGISTRY__.Slardar;
};
var reportSelfError = function () {
    var errorInfo = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        errorInfo[_i] = arguments[_i];
    }
    var registry = getGlobalRegistry(getDefaultBrowser());
    if (!registry)
        return;
    if (!registry.errors) {
        registry.errors = [];
    }
    registry.errors.push(errorInfo);
};

var applyMutationObserver = function (MutationObserver, callback) {
    // eslint-disable-next-line compat/compat
    var observer = MutationObserver && new MutationObserver(callback);
    var observe = function (target, options) {
        observer && target && observer.observe(target, options);
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
var applyAnimationFrame = function (document, originRAF, originCAF, force) {
    var requestAnimationFrame = 
    // eslint-disable-next-line compat/compat
    !isFunction(originRAF) || (force && document && document.hidden)
        ? function (cb) {
            cb(0);
            return 0;
        }
        : originRAF;
    var cancelAnimationFrame = isFunction(originCAF) ? originCAF : noop;
    /**
     * 以 animationFrame 调用函数，如果一帧内多次调用，则会取消前面的调用
     */
    var af;
    var scheduleAnimationFrame = function (cb) {
        af && cancelAnimationFrame(af);
        af = requestAnimationFrame(cb);
    };
    return [scheduleAnimationFrame, requestAnimationFrame, cancelAnimationFrame];
};
var applyPerformance = function (performance) {
    // eslint-disable-next-line compat/compat
    var timing = (performance && performance.timing) || undefined;
    var now = function () {
        if (performance && performance.now)
            return performance.now();
        var time = Date.now ? Date.now() : +new Date();
        var start = (timing && timing.navigationStart) || 0;
        return time - start;
    };
    var getEntriesByType = function (type) {
        var getEntriesByType = (performance || {}).getEntriesByType;
        return (isFunction(getEntriesByType) && getEntriesByType.call(performance, type)) || [];
    };
    var getEntriesByName = function (name) {
        var getEntriesByName = (performance || {}).getEntriesByName;
        return (isFunction(getEntriesByName) && getEntriesByName.call(performance, name)) || [];
    };
    var clearResourceTiming = function () {
        var clearResourceTimings = (performance || {}).clearResourceTimings;
        isFunction(clearResourceTimings) && clearResourceTimings.call(performance);
    };
    return [timing, now, getEntriesByType, clearResourceTiming, getEntriesByName];
};

var captureCurrentContext = function (client) {
    var capturedContext = {
        url: getLocationUrl(),
        timestamp: now(),
    };
    var config = client.config();
    if (config === null || config === void 0 ? void 0 : config.pid) {
        capturedContext.pid = config.pid;
    }
    if (client === null || client === void 0 ? void 0 : client['context']) {
        capturedContext.context = client['context'].toString();
    }
    return capturedContext;
};
// only works for sync report
// async report won't trigger 'report' immediately, es.g. sri
var syncReportWithCapturedContext = function (client, ctx) {
    return function (fn) {
        var inject = function (ev) {
            ev.overrides = ctx;
            return ev;
        };
        client.on('report', inject);
        fn();
        client.off('report', inject);
    };
};

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
function clearTimerWithTearDowns(timer, tearDowns) {
    timer && tearDowns.push(function () { return clearTimeout(timer); });
}
function onPageLoad(callback) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    if (document.readyState === 'complete') {
        callback();
        return;
    }
    addListenerToWindow(window, 'load', function () {
        setTimeout(function () {
            callback();
        }, 0);
    }, false);
}
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};
var onPageUnload = function (cb) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var _a = __read(invokeCallbackOnce(cb), 1), invokeCbOnce = _a[0];
    ['unload', 'beforeunload', 'pagehide'].forEach(function (ev) {
        addListenerToWindow(window, ev, invokeCbOnce, false);
    });
};
var onPageNextShow = function (cb) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var removeListener = noop;
    var onVisibilityChange = function () {
        if (document.visibilityState === 'visible') {
            cb();
            removeListener();
        }
    };
    removeListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChange, true);
};
var loadScript = function (url, callback) {
    var _a;
    /* istanbul ignore next */
    var document = getDefaultDocument();
    // untestable for now
    /* istanbul ignore next */
    if (document) {
        var script = document.createElement('script');
        script.src = url;
        script.crossOrigin = 'anonymous';
        script.onload = callback;
        (_a = document.head) === null || _a === void 0 ? void 0 : _a.appendChild(script);
    }
};
var getConfig = function (c, defaultConfig) {
    if (isObject(c)) {
        return __assign(__assign({}, defaultConfig), c);
    }
    else {
        return c ? defaultConfig : false;
    }
};

var isSupportEncrypt = function () { return !!btoa && !!atob; };
function encodeToBase64(content) {
    if (!isSupportEncrypt())
        return content;
    return btoa(encodeURI(content));
}
function decodeWithBase64(base64) {
    if (!isSupportEncrypt())
        return base64;
    return decodeURI(atob(base64));
}

var getStorageWithDecoding = function (name) {
    try {
        var value = localStorage.getItem(name);
        var ret = value;
        if (value && typeof value === 'string') {
            ret = JSON.parse(decodeWithBase64(value));
        }
        // get 时无需刷新 expires，在后续的 configManager 中的 set 会刷新
        var _a = ret, expires = _a.expires, content = __rest(_a, ["expires"]);
        return expires >= now() ? content : undefined;
    }
    catch (_e) {
        return undefined;
    }
};
var setStorageWithEncoding = function (key, value, expires) {
    if (expires <= 0)
        return;
    try {
        localStorage.setItem(key, encodeToBase64(JSON.stringify(__assign(__assign({}, value), { expires: now() + expires }))));
    }
    catch (_o) {
        // do nothing
    }
};
var DEFAULT_STORAGE_EXPIRES = 90 * 24 * 60 * 60 * 1000;
var formatStorageExpires = function (storageExpires) {
    if (storageExpires === false)
        return 0;
    if (storageExpires === true || storageExpires === undefined || !isNumber(storageExpires))
        return DEFAULT_STORAGE_EXPIRES;
    return storageExpires;
};

var XHR_SUBJECT_NAME = 'xhr_0';
var getReportPathRegExp = function () {
    var SELF_REPORT_PATH_REGEXP = new RegExp('\\/monitor_web\\/collect|\\/monitor_browser\\/collect\\/batch', 'i');
    return function (url) { return SELF_REPORT_PATH_REGEXP.test(url); };
};
var hookOpen = function (open) {
    return function () {
        var _a;
        var openOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            openOptions[_i] = arguments[_i];
        }
        _a = __read(openOptions, 2), this._method = _a[0], this._url = _a[1];
        return open.apply(this, openOptions);
    };
};
var hookSetHeader = function (setRequestHeader) {
    return function () {
        var setOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            setOptions[_i] = arguments[_i];
        }
        this._reqHeaders = this._reqHeaders || {};
        var _a = __read(setOptions, 2), name = _a[0], value = _a[1];
        this._reqHeaders[name] = value;
        return setRequestHeader && setRequestHeader.apply(this, setOptions);
    };
};
var hookOnreadystatechange = function (xhr, endNext) {
    return hookMethodDangerously(xhr, 'onreadystatechange', function (origin) {
        return function () {
            var ev = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ev[_i] = arguments[_i];
            }
            // @ts-expect-error
            this.readyState === 4 && endNext(xhr);
            return origin && origin.apply(this, ev);
        };
    });
};
var hookSend = function (send, next) {
    var hitReportPath = getReportPathRegExp();
    return function () {
        var sendOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sendOptions[_i] = arguments[_i];
        }
        this._start = now();
        this._data = sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions[0];
        // not trigger the xhr subject if hit the report path
        if (!hitReportPath(this._url)) {
            var endNext = next([this._method, this._url, this._start, this]);
            hookOnreadystatechange(this, endNext)();
        }
        return send.apply(this, sendOptions);
    };
};
var applyXHR = function (xhr) {
    return function (next, tearDown) {
        if (!xhr)
            return;
        var tearDownGroup = [];
        tearDownGroup.push(hookMethodDangerously(xhr, 'open', hookOpen)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'setRequestHeader', hookSetHeader)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'send', hookSend)(next));
        tearDown(function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    };
};
var FETCH_SUBJECT_NAME = 'fetch_0';
var hookFetch = function (_fetch, next) {
    return function (req, options) {
        if (options === void 0) { options = {}; }
        var endNext = next([req, options]);
        var fetchPromise = _fetch(req, options);
        fetchPromise.then(function (res) {
            // @ts-expect-error
            endNext(res);
        }, function () {
            // @ts-expect-error
            endNext(undefined);
        });
        return fetchPromise;
    };
};
var observeFetch = function (next, tearDown) {
    var global = getDefaultBrowser();
    if (!global || !fetch)
        return;
    var tearDownGroup = [];
    tearDownGroup.push(hookMethodDangerously(global, 'fetch', hookFetch)(next));
    tearDown(function () {
        tearDownGroup.forEach(function (e) { return e(); });
    });
};
var fetchSubject = [FETCH_SUBJECT_NAME, observeFetch];

var RESOURCE_TYPE = ['resource']; // used by resourceMonitor / resourceErrorMonitor / HttpMonitor
var LONGTASK_TYPE = ['longtask']; // used by ttiMonitor / longtaskMonitor / actionMonitor / mpfidMonitor
var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type, durationThreshold) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            var options = { type: type, buffered: true };
            !isUndefined(durationThreshold) && (options.durationThreshold = durationThreshold);
            observer.observe(options);
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerf = function (Ob, pipe, types) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), observe = _a[0], disconnect = _a[2];
    observe(types);
    return disconnect;
};
var LONGTASK_SUBJECT_NAME = 'longtask_0';
var observeLongtask = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, LONGTASK_TYPE));
};
var longtaskSubject = [LONGTASK_SUBJECT_NAME, observeLongtask];
var RESOURCE_SUBJECT_NAME = 'resource_0';
var observeResource = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, RESOURCE_TYPE));
};
var resourceSubject = [RESOURCE_SUBJECT_NAME, observeResource];

var PAGEVIEW_EV_TYPE = 'pageview';
var SESSION_EV_TYPE = 'session';
var JS_ERROR_EV_TYPE = 'js_error';
var HTTP_EV_TYPE = 'http';
var RESOURCE_ERROR_EV_TYPE = 'resource_error';
var RESOURCE_EV_TYPE = 'resource';
var CUSTOM_EV_TYPE = 'custom';
var PERFORMANCE_METRIC_EV_TYPE = 'performance';
var LONG_TASK_EV_TYPE = 'performance_longtask';
var BLANK_SCREEN_EV_TYPE = 'blank_screen';
var ACTION_EV_TYPE = 'action';

var VERSION = '03';
var SAMPLED = '01';
var TRACEPARENT = 'traceparent';
var DEFAULT_TRACE_CONFIG = {
    sampleRate: 1,
    origins: [],
};
var uuid4 = function () {
    var crypto = window && (window.crypto || window.msCrypto);
    if (crypto !== void 0 && crypto.getRandomValues) {
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        var pad = function (num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = "0" + v;
            }
            return v;
        };
        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[x]/g, function () {
        var r = (Math.random() * 16) | 0;
        return r.toString(16);
    });
};
var setTraceContext = function (traceConfig) {
    var config = getConfig(traceConfig, DEFAULT_TRACE_CONFIG);
    if (!config)
        return;
    var sampled = isHitBySampleRate(config.sampleRate);
    if (!sampled)
        return;
    return function (url, cb) {
        var origins = config.origins;
        if (origins.length && checkIfHit(origins, url)) {
            cb(TRACEPARENT, VERSION + "-" + uuid4() + "-" + uuid4().substring(16) + "-" + SAMPLED);
        }
    };
};

var headerKeyRe = new RegExp('(cookie|auth|jwt|token|key|ticket|secret|credential|session|password)', 'i');
var headerValueRe = new RegExp('(bearer|session)', 'i');
var isSensitiveHeader = function (key, value) {
    if (!key || !value)
        return true;
    return headerKeyRe.test(key) || headerValueRe.test(value);
};
var applySendOnce = function (cb) {
    var hasInvoked = false;
    return function (metric) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb(metric);
    };
};
/**
 * Handles the full URL and payload with optional URL extraction.
 *
 * @param {string} fullUrl - The full URL to handle.
 * @param {HttpPayload} payload - The payload object to handle. Will be mutated in function inside.
 * @param {function} extractUrl - (Optional) A function to extract the URL from the full URL.
 */
var handleWithExtractUrl = function (payload, extractUrl) {
    try {
        if (extractUrl) {
            var original_url = payload.request.url;
            payload.request.url = extractUrl(original_url);
            payload.extra = __assign(__assign({}, payload.extra), { original_url: original_url });
            // Since PerformanceResourceTiming.toJSON only works for >= Chrome V45,
            // back-end will assign payload.response.timing.name to payload.request.url after data reported
        }
    }
    catch (_e) {
        // do nothing
    }
};

var httpGetterWithXhrObserver = function (tearDownGroup, _a, xhrConfig) {
    var _b = __read(_a, 2), xhrObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = xhrConfig.setTraceHeader, ignoreUrls = xhrConfig.ignoreUrls, setContextAtReq = xhrConfig.setContextAtReq, extractUrl = xhrConfig.extractUrl;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 4); _b[0]; var _url = _b[1]; _b[2]; var xhr = _b[3];
        if (!_url)
            return noop;
        var fullUrl = getFullUrl(_url);
        if (checkIfHit(ignoreUrls, fullUrl))
            return noop;
        setTraceHeader && setTraceHeader(fullUrl, function (key, value) { return xhr.setRequestHeader(key, value); });
        var reportWithContext = setContextAtReq();
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            fullUrl === entry.name && !timing && (timing = entry);
        });
        return function (xhrAfterReady) {
            var payload = getEventParams$1(xhrAfterReady, xhrConfig);
            setTimeout(function () {
                timing && (payload.response.timing = timing);
                handleWithExtractUrl(payload, extractUrl);
                reportWithContext && reportWithContext({ ev_type: HTTP_EV_TYPE, payload: payload });
                resourceTearDown();
            }, 100);
        };
    }));
};
function formatXHRAllResponseHeaders(headers) {
    if (isString(headers) && headers) {
        return headers.split('\r\n').reduce(function (result, line) {
            if (isString(line)) {
                var _a = __read(line.split(': '), 2), name_1 = _a[0], value = _a[1];
                !isSensitiveHeader(name_1, value) && (result[name_1.toLowerCase()] = value);
            }
            return result;
        }, {});
    }
    return {};
}
function formatRequestHeaders(headers) {
    return Object.keys(headers).reduce(function (result, name) {
        !isSensitiveHeader(name, headers[name]) && (result[name.toLowerCase()] = headers[name]);
        return result;
    }, {});
}
var getEventParams$1 = function (xhr, props) {
    var _method = xhr._method, _reqHeaders = xhr._reqHeaders, _url = xhr._url, _start = xhr._start, _data = xhr._data;
    var fullUrl = getFullUrl(_url);
    var params = {
        api: 'xhr',
        request: {
            url: fullUrl,
            method: (_method || '').toLowerCase(),
            headers: _reqHeaders && formatRequestHeaders(_reqHeaders),
            timestamp: _start,
        },
        response: {
            status: xhr.status || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    if (typeof xhr.getAllResponseHeaders === 'function') {
        params.response.headers = formatXHRAllResponseHeaders(xhr.getAllResponseHeaders());
    }
    var status = params.response.status;
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    try {
        var extra = extraExtractor === null || extraExtractor === void 0 ? void 0 : extraExtractor(xhr.response, params, _data);
        extra && (params.extra = extra);
        extra && (params.response.is_custom_error = true);
        // 非 2xx , 3xx 请求，上传request body
        if (collectBodyOnError && (extra || status >= 400)) {
            params.request.body = _data ? "" + _data : undefined;
            params.response.body = xhr.response ? "" + xhr.response : undefined;
        }
    }
    catch (_o) {
        // do nothing
    }
    return params;
};

function getPluginConfig(client, pluginName, defaultConfig) {
    var _a;
    var c = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[pluginName];
    return getConfig(c, defaultConfig);
}

var AJAX_MONITOR_PLUGIN_NAME = 'ajax';
var defaultConfig$3 = {
    autoWrap: true,
    setContextAtReq: function () { return id; },
    ignoreUrls: [],
    collectBodyOnError: false,
};
function AjaxMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig$3);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var xhrConfig = __assign(__assign({}, config), { setContextAtReq: function () { return reportWithCurrentContext(client, true); }, setTraceHeader: setTraceContext(config.trace) });
    var getResourceSubject = function () { return initSubjectInGlobal(client, resourceSubject); };
    xhrConfig.autoWrap &&
        httpGetterWithXhrObserver(tearDownGroup, [
            initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
            getResourceSubject,
        ], xhrConfig);
    registerTearDownGroup(client, AJAX_MONITOR_PLUGIN_NAME, HTTP_EV_TYPE, tearDownGroup);
    client.provide('wrapXhr', function (Xhr) {
        function Ctor() {
            var xhr = new Xhr();
            httpGetterWithXhrObserver(tearDownGroup, [createSafeObserver(applyXHR(xhr)), getResourceSubject], xhrConfig);
            return xhr;
        }
        Ctor.prototype = new Xhr();
        ['DONE', 'HEADERS_RECIEVED', 'LOADING', 'OPENED', 'UNSENT'].forEach(function (key) {
            Ctor[key] = Xhr[key];
        });
        return Ctor;
    });
}
function AjaxMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[AJAX_MONITOR_PLUGIN_NAME];
        AjaxMonitorBasePlugin(client, config);
    });
}

var httpGetterWithFetchObserver = function (tearDownGroup, _a, fetchConfig) {
    var _b = __read(_a, 2), fetchObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = fetchConfig.setTraceHeader, ignoreUrls = fetchConfig.ignoreUrls, setContextAtReq = fetchConfig.setContextAtReq, extractUrl = fetchConfig.extractUrl;
    // eslint-disable-next-line compat/compat
    var Headers = window.Headers;
    // eslint-disable-next-line compat/compat
    var Request = window.Request;
    if (!Request || !Headers)
        return;
    tearDownGroup.push(fetchObserver[0](function (_a) {
        var _b = __read(_a, 2), req = _b[0], options = _b[1];
        var url = getFullUrl(req instanceof Request ? req.url : req);
        if (!isHttpURL(url) || checkIfHit(ignoreUrls, url)) {
            return noop;
        }
        setTraceHeader &&
            setTraceHeader(url, function (key, value) { return addHeader(key, value, req, options, Request, Headers); });
        var reportWithContext = setContextAtReq();
        var _start = now();
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            url === entry.name && !timing && (timing = entry);
        });
        return function (res) {
            var payload = getEventParams(req, options, res, Request, Headers, fetchConfig, _start);
            var reportFetchData = applySendOnce(function (data) {
                timing && (data.response.timing = timing);
                handleWithExtractUrl(data, extractUrl);
                reportWithContext && reportWithContext({ ev_type: HTTP_EV_TYPE, payload: data });
                resourceTearDown();
            });
            setTimeout(function () {
                reportFetchData(payload);
            }, 1000);
        };
    }));
};
var isHttpURL = function (url) {
    if (!isString(url)) {
        return false;
    }
    var _a = __read(url.split(':'), 2), protocol = _a[0], path = _a[1];
    return !path || protocol === 'http' || protocol === 'https';
};
var isRequest = function (req, Request) {
    return req instanceof Request;
};
var addHeader = function (key, value, req, options, Request, Headers) {
    var _a;
    if (isRequest(req, Request)) {
        req.headers.set(key, value);
    }
    else if (options.headers instanceof Headers) {
        options.headers.set(key, value);
    }
    else {
        options.headers = __assign(__assign({}, options.headers), (_a = {}, _a[key] = value, _a));
    }
};
var getFetchMethod = function (req, options, Request) {
    var method = (options && options.method) || 'get';
    if (isRequest(req, Request)) {
        method = req.method || method;
    }
    return method.toLowerCase();
};
var mergeHeaders = function (Headers) {
    var headers = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        headers[_i - 1] = arguments[_i];
    }
    try {
        return headers.reduce(function (sum, cur) {
            // eslint-disable-next-line compat/compat
            new Headers(cur || {}).forEach(function (val, key) { return !isSensitiveHeader(key, val) && (sum[key] = val); });
            return sum;
        }, {});
    }
    catch (_a) {
        return {};
    }
};
var getFetchBody = function (req, options, Request) {
    if (isRequest(req, Request)) {
        return req.body;
    }
    else {
        return options === null || options === void 0 ? void 0 : options.body;
    }
};
var getEventParams = function (req, options, res, Request, Headers, props, _start) {
    var params = {
        api: 'fetch',
        request: {
            method: getFetchMethod(req, options, Request),
            timestamp: _start,
            url: getFullUrl(req instanceof Request ? req.url : req),
            headers: mergeHeaders(Headers, req.headers, options.headers),
        },
        response: {
            status: (res && res.status) || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    var setRequestBodyIfAllowed = function () {
        var _a;
        collectBodyOnError && (params.request.body = (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString());
    };
    if (res) {
        try {
            var resHeaders = mergeHeaders(Headers, res.headers);
            params.response.headers = resHeaders;
            try {
                // only when the content-type includes 'application/json' can convert to JSON.
                ;
                (resHeaders['content-type'] || '').indexOf('application/json') !== -1 &&
                    extraExtractor &&
                    res
                        .clone()
                        .json()
                        .then(function (o) {
                        var _a;
                        var extra = extraExtractor(o, params, (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString());
                        if (extra) {
                            params.extra = extra;
                            params.response.is_custom_error = true;
                            setRequestBodyIfAllowed();
                        }
                    })
                        .catch(noop);
            }
            catch (_o) {
                // do nothing
            }
            res.status >= 400 && setRequestBodyIfAllowed();
        }
        catch (_a) {
            // do nothing
        }
    }
    else {
        setRequestBodyIfAllowed();
    }
    return params;
};

var FETCH_MONITOR_PLUGIN_NAME = 'fetch';
var defaultConfig$2 = {
    autoWrap: true,
    setContextAtReq: function () { return id; },
    ignoreUrls: [],
    collectBodyOnError: false,
};
function FetchMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig$2);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var fetchConfig = __assign(__assign({}, config), { setContextAtReq: function () { return reportWithCurrentContext(client, true); }, setTraceHeader: setTraceContext(config.trace) });
    var getResourceObserver = function () { return initSubjectInGlobal(client, resourceSubject); };
    fetchConfig.autoWrap &&
        httpGetterWithFetchObserver(tearDownGroup, [initSubjectInGlobal(client, fetchSubject), getResourceObserver], fetchConfig);
    registerTearDownGroup(client, FETCH_MONITOR_PLUGIN_NAME, HTTP_EV_TYPE, tearDownGroup);
    client.provide('wrapFetch', function (f) {
        var newFetch = undefined;
        httpGetterWithFetchObserver(tearDownGroup, [
            createSafeObserver(function (next) {
                newFetch = hookFetch(f, next);
            }),
            getResourceObserver,
        ], fetchConfig);
        return newFetch;
    });
}
function FetchMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[FETCH_MONITOR_PLUGIN_NAME];
        FetchMonitorBasePlugin(client, config);
    });
}

var ERROR_FIELDS = ['name', 'message', 'stack', 'filename', 'lineno', 'colno'];
var normalize = function (ex) {
    var error;
    if (!isError(ex)) {
        if (isPlainObject(ex) || isEvent(ex) || isString(ex)) {
            error = {
                message: safeStringify(ex),
            };
        }
    }
    else {
        error = pick(ex, ERROR_FIELDS);
    }
    return error;
};
var normalizeError = function (event) {
    return normalize(event.error);
};
var normalizeException = function (event) {
    var _a;
    // dig the object of the rejection out of known event types
    try {
        var error = void 0;
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in event) {
            error = event.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in event && 'reason' in event.detail) {
            error = event.detail.reason;
        }
        if (error) {
            var rejectionError = normalize(error);
            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
            return __assign(__assign({}, rejectionError), { name: (_a = (rejectionError && rejectionError.name)) !== null && _a !== void 0 ? _a : 'UnhandledRejection' });
        }
    }
    catch (_oO) {
        // no-empty
    }
};
var normalizeUnknownError = function (exception) {
    if (isErrorEvent(exception)) {
        return normalizeError(exception);
    }
    else if (isPromiseRejectionEvent(exception)) {
        return normalizeException(exception);
    }
    else {
        return normalize(exception);
    }
};

var JS_ERROR_MONITOR_PLUGIN_NAME = 'jsError';

var HIDDEN_SUBJECT_NAME = 'hidden_3';
var visibilityStateIsHidden = function (d) { return d.visibilityState === 'hidden'; };
var observeHidden = function (next, tearDown) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    // some browsers have buggy implementations of visibilitychange,
    // so we use pagehide in addition, just to be safe.
    var onVisibilityChangeOrPageHide = function (event) {
        next(event.type === 'pagehide' || visibilityStateIsHidden(document));
    };
    var removeVisibilityListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChangeOrPageHide, true);
    var removePageHideListener = addListenerToWindow(window, 'pagehide', onVisibilityChangeOrPageHide, true);
    tearDown(function () {
        removeVisibilityListener();
        removePageHideListener();
    }, function (subscriber) {
        subscriber(visibilityStateIsHidden(document));
    });
};
/**
 * When subscribing to hiddenSubject, it's important to note that it may immediately and synchronously trigger.
 */
var hiddenSubject = [HIDDEN_SUBJECT_NAME, observeHidden];
var LOAD_SUBJECT_NAME = 'load_1';
var readyStateIsComplete = function (d) { return d.readyState === 'complete'; };
var observeLoad = function (next, tearDown) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onLoad = function () {
        // queue a task so the callback runs after `loadEventEnd`
        setTimeout(function () {
            next();
            onceTriggered = true;
        }, 0);
    };
    if (readyStateIsComplete(document)) {
        onLoad();
    }
    else {
        removeListener = addListenerToWindow(window, 'load', onLoad, false);
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to loadSubject, it's important to note that it may immediately and synchronously trigger.
 */
var loadSubject = [LOAD_SUBJECT_NAME, observeLoad];
var UNLOAD_SUBJECT_NAME = 'unload_0';
var observeUnload = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    var _a = __read(invokeCallbackOnce(next), 1), invokeCbOnce = _a[0];
    var unloadEventList = ['unload', 'beforeunload', 'pagehide'];
    var handler = function () {
        invokeCbOnce();
    };
    var tearDowns = [];
    unloadEventList.forEach(function (ev) {
        tearDowns.push(addListenerToWindow(window, ev, handler, false));
    });
    tearDown(function () {
        tearDowns.forEach(function (e) { return e(); });
    });
};
var unloadSubject = [UNLOAD_SUBJECT_NAME, observeUnload];
var ACTIVATED_SUBJECT_NAME = 'activated_0';
var observeActivated = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onActivated = function () {
        next();
        onceTriggered = true;
    };
    // @ts-expect-error
    if (document && document.prerendering) {
        removeListener = addListenerToDocument(document, 'prerenderingchange', onActivated, true);
    }
    else {
        onActivated();
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to activatedSubject, it's important to note that it may immediately and synchronously trigger.
 */
var activatedSubject = [ACTIVATED_SUBJECT_NAME, observeActivated];

var HISTORY_SUBJECT_NAME = 'history_0';
var HASH_SUBJECT_NAME = 'hash_0';
var observeHistory = function (next, tearDown) {
    var history = getDefaultHistory();
    var window = getDefaultBrowser();
    if (!history || !window)
        return;
    var restoreFns = [];
    var historyChangeListener = function () { return next(location.href); };
    var hookStateChange = function (origin) {
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            try {
                origin.apply(history, params);
            }
            finally {
                historyChangeListener();
            }
        };
    };
    restoreFns.push(hookObjectProperty(history, 'pushState', hookStateChange)(), hookObjectProperty(history, 'replaceState', hookStateChange)());
    restoreFns.push(addListenerToWindow(window, 'popstate', historyChangeListener, true));
    tearDown(function () {
        restoreFns.forEach(function (fn) { return fn(); });
    });
};
var observeHash = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var hashChangeListener = function () { return next(location.href); };
    var removeListener = addListenerToWindow(window, 'hashchange', hashChangeListener, true);
    tearDown(function () {
        removeListener();
    });
};
var hashSubject = [HASH_SUBJECT_NAME, observeHash];
var historySubject = [HISTORY_SUBJECT_NAME, observeHistory];

var getDefaultExtractor = function (routeMode) { return function (url) {
    var _a;
    if (routeMode === 'hash') {
        return ((_a = parseUrl(url).hash) === null || _a === void 0 ? void 0 : _a.replace(/^#/, '')) || '/';
    }
    else {
        return parseUrl(url).path;
    }
}; };
var getViewId = function (pid) { return joinWithSeparator(pid, now()); };
var joinWithSeparator = function (a, b) { return a + "_" + b; };
var applyOnPidChange = function (cb, initPid, firstOriginPid, onPidUpdate) {
    // store originalPid from url
    var originalPid = firstOriginPid;
    // store finalPid send to server
    var finalPid = initPid;
    // set init pid in config
    onPidUpdate && onPidUpdate(initPid);
    var onPidChange = function (source, newPid, customPid) {
        // newPid is extractPid from url, should send pageview if changed, no matter customPid changed
        if (source !== "user_set" /* user_set */ && newPid !== originalPid) {
            originalPid = newPid;
            finalPid = customPid !== null && customPid !== void 0 ? customPid : originalPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
            // newPid is by user set, should send pageview if not equal to finalPid
        }
        else if (source === "user_set" /* user_set */ && newPid !== finalPid) {
            finalPid = newPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
        }
    };
    var sendInit = function () {
        initPid && cb("init" /* init */, initPid);
    };
    return [onPidChange, sendInit];
};
var applyOnUrlChange = function (cb, initUrl) {
    var url = initUrl;
    var onUrlChange = function (source, newUrl) {
        if (newUrl !== url) {
            url = newUrl;
            cb(source, url);
        }
    };
    return [onUrlChange];
};
var wrapPageview = function (source, pid) { return ({
    ev_type: PAGEVIEW_EV_TYPE,
    payload: {
        pid: pid,
        source: source,
    },
}); };
var applyReportPageview = function (report) {
    return function (source, pid) {
        report(wrapPageview(source, pid));
    };
};
var isManualMode = function (routeMode) { return routeMode === 'manual'; };
var ERROR_WEIGHT = 'error_weight';
var DURATION_APDEX = 'duration_apdex';
var PREF_APDEX = 'perf_apdex';
var ACTION_KEY = 'action';
var getDefaultApdexDetail = function () {
    var _a;
    return _a = {
            error_count: [0, 0, 0, 0],
            duration_count: [0, 0, 0]
        },
        _a[PREF_APDEX] = {},
        _a;
};
var getRank = function (apdex, setting) {
    var total = apdex[0 /* satisfying */] + apdex[1 /* tolerable */] + apdex[2 /* frustrating */];
    var s_percent = apdex[0 /* satisfying */] / total;
    var f_percent = apdex[2 /* frustrating */] / total;
    return f_percent > setting.frustrating_threshold
        ? 2 /* frustrating */
        : s_percent > setting.satisfying_threshold || total === 0
            ? 0 /* satisfying */
            : 1 /* tolerable */;
};
var calculateSpentTime = function () {
    // record spent time
    var spentTime = 0;
    var lastShowTimeStamp = undefined;
    var handleHidden = function (isHidden) {
        if (isHidden) {
            if (!lastShowTimeStamp)
                return;
            // set spentTime and reset last show timestamp
            spentTime += now() - lastShowTimeStamp;
            lastShowTimeStamp = undefined;
        }
        else {
            lastShowTimeStamp = now();
        }
    };
    var getSpentTime = function () {
        // correct the value of the last spent
        lastShowTimeStamp && (spentTime += now() - lastShowTimeStamp);
        var time = spentTime;
        // reset status
        spentTime = 0;
        lastShowTimeStamp = now();
        return time;
    };
    return [handleHidden, getSpentTime];
};
var applyCalculateWight = function (calculateDuration, calculateError) {
    return function (ev, apdexSetting) {
        var payload = ev.payload;
        switch (ev.ev_type) {
            case PERFORMANCE_METRIC_EV_TYPE:
                var name_1 = payload.name;
                if (payload.isSupport) {
                    calculateDuration(apdexSetting[PREF_APDEX], name_1, payload.value);
                }
                break;
            case ACTION_EV_TYPE:
                calculateDuration(apdexSetting[PREF_APDEX], ACTION_KEY, payload.duration || 0);
                break;
            case JS_ERROR_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 0);
                break;
            case HTTP_EV_TYPE:
                if (payload.response.is_custom_error || payload.response.status >= 400) {
                    calculateError(apdexSetting[ERROR_WEIGHT], 1);
                }
                else {
                    var timing = payload.response.timing;
                    timing && calculateDuration(apdexSetting[DURATION_APDEX], 0, timing.duration);
                }
                break;
            case RESOURCE_ERROR_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 2);
                break;
            case BLANK_SCREEN_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 3);
                break;
            case RESOURCE_EV_TYPE:
                calculateDuration(apdexSetting[DURATION_APDEX], 1, payload.duration);
                break;
            case LONG_TASK_EV_TYPE:
                payload.longtasks.forEach(function (l) {
                    calculateDuration(apdexSetting[DURATION_APDEX], 2, l.duration);
                });
                break;
        }
    };
};
var calculateApdex = function () {
    var apdexWeight;
    var apdexDetail;
    var initApdex = function () {
        apdexWeight = [0, 0, 0];
        apdexDetail = getDefaultApdexDetail();
    };
    // init apdex first
    initApdex();
    var calculateDurationWeight = function (weight, nameOrIndex, value) {
        var rules = weight && weight[nameOrIndex];
        // make sure all value is valuable
        if (!rules || value <= 0)
            return;
        var level = value < (rules[0 /* satisfying */].threshold || 0)
            ? 0 /* satisfying */
            : value > (rules[1 /* tolerable */].threshold || 0)
                ? 2 /* frustrating */
                : 1 /* tolerable */;
        apdexWeight[level] += rules[level].weight;
        if (typeof nameOrIndex === 'string') {
            var name_2 = joinWithSeparator(nameOrIndex, level);
            var value_1 = apdexDetail[PREF_APDEX][name_2];
            apdexDetail[PREF_APDEX][name_2] = (value_1 || 0) + 1;
        }
        else {
            level === 2 /* frustrating */ && (apdexDetail.duration_count[nameOrIndex] += 1);
        }
    };
    var calculateErrorWeight = function (weight, index) {
        if (!weight)
            return;
        apdexWeight[2 /* frustrating */] += weight[index];
        apdexDetail.error_count[index] += 1;
    };
    var getApdex = function () {
        return [apdexWeight, apdexDetail];
    };
    return [calculateDurationWeight, calculateErrorWeight, getApdex, initApdex];
};
var calculateSession = function () {
    var sessionPayload = {
        // use the current initialized time as start is more appropriate than navigationStart
        start: now(),
        end: 0,
        time_spent: 0,
        is_bounced: false,
        entry: '',
        exit: '',
        p_count: 0,
        a_count: 0,
    };
    var handleUnload = function (sessionApdexInfo, lastPage) {
        var _a = __read(sessionApdexInfo, 3), rank = _a[0], apdex = _a[1], apdex_detail = _a[2];
        sessionPayload.end = now();
        sessionPayload.time_spent += (lastPage && lastPage.time_spent) || 0;
        sessionPayload.last_page = lastPage;
        sessionPayload.p_count += 1;
        sessionPayload.rank = rank;
        sessionPayload.apdex = apdex;
        sessionPayload.apdex_detail = apdex_detail;
        var d = getDefaultDocument();
        d && (sessionPayload.is_bounced = !readyStateIsComplete(d));
    };
    var handlePageview = function (lastPage, newPid) {
        sessionPayload.time_spent += lastPage.time_spent;
        sessionPayload.p_count += 1;
        sessionPayload.exit = newPid;
    };
    var handleAction = function () {
        sessionPayload.a_count += 1;
    };
    var setEntry = function (entry) {
        sessionPayload.entry = entry;
        sessionPayload.exit = entry;
    };
    var getSessionPayload = function () { return sessionPayload; };
    return [handleUnload, handlePageview, handleAction, setEntry, getSessionPayload];
};

var pvGetterWithRouteObserver = function (report, tearDownGroup, routeObservers, config) {
    var sendInitFlag = config.sendInit, initPid = config.initPid, routeMode = config.routeMode, extractPid = config.extractPid, onPidUpdate = config.onPidUpdate;
    var extractPidFromUrl = isManualMode(routeMode) ? function () { return ''; } : getDefaultExtractor(routeMode);
    var customPidFromUrl = extractPid || (function () { return undefined; });
    var getFinalPid = function (url) { var _a; return (_a = customPidFromUrl(url)) !== null && _a !== void 0 ? _a : extractPidFromUrl(url); };
    var _a = __read(applyOnPidChange(applyReportPageview(report), initPid || getFinalPid(location.href), extractPidFromUrl(location.href), onPidUpdate), 2), onPidChange = _a[0], sendInit = _a[1];
    if (!isManualMode(routeMode)) {
        var _b = __read(applyOnUrlChange(function (sources, url) { return onPidChange(sources, extractPidFromUrl(url), customPidFromUrl(url)); }, ''), 1), onUrlChange_1 = _b[0];
        routeObservers.length &&
            routeObservers.forEach(function (routeObserver) {
                return tearDownGroup.push(routeObserver[0](function (value) { return onUrlChange_1(routeMode, value); }));
            });
    }
    if (sendInitFlag) {
        sendInit();
    }
    return [onPidChange.bind(null, "user_set" /* user_set */)];
};

var apdexGetterWithHiddenObserver = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), hiddenObserver = _b[0], unloadObserver = _b[1];
    var onlyPageApdex = config.apdex === 2;
    // record last page detail and current page info
    var currentPageInfo = undefined;
    var lastPidPayload = undefined;
    // apdex setting get from server, and not report any thing if not setting
    var apdexSetting = undefined;
    var apdexStarted = false;
    var _c = __read(calculateApdex(), 4), calculateDurationWeight = _c[0], calculateErrorWeight = _c[1], getApdex = _c[2], resetApdex = _c[3];
    var _d = __read(calculateApdex(), 4), calculateSessionDurationWeight = _d[0], calculateSessionErrorWeight = _d[1], getSessionApdex = _d[2], resetSessionApdex = _d[3];
    var _e = __read(calculateSession(), 5), handleUnload = _e[0], handlePageview = _e[1], handleAction = _e[2], setEntry = _e[3], getSessionPayload = _e[4];
    // record spent time
    var _f = __read(calculateSpentTime(), 2), handleHidden = _f[0], getSpentTime = _f[1];
    tearDownGroup.push(hiddenObserver[0](handleHidden));
    // send session event if need
    !onlyPageApdex &&
        tearDownGroup.push(unloadObserver[0](function () {
            if (!apdexStarted)
                return;
            var _a = __read(getSessionApdex(), 2), apdex = _a[0], detail = _a[1];
            var sessionRank = getRank(apdex, apdexSetting);
            handleUnload([sessionRank, apdex, detail], getPagePayload());
            report({
                ev_type: SESSION_EV_TYPE,
                payload: getSessionPayload(),
            });
            resetSessionApdex();
        }));
    var handlePageviewWeight = applyCalculateWight(calculateDurationWeight, calculateErrorWeight);
    var handleSessionWeight = applyCalculateWight(calculateSessionDurationWeight, calculateSessionErrorWeight);
    var handleSend = function (ev) {
        // make sure already have apdex setting and currentPid
        if (!apdexStarted)
            return;
        // always handle session weight if session flag is open
        if (!onlyPageApdex) {
            handleSessionWeight(ev, apdexSetting);
            ev.ev_type === ACTION_EV_TYPE && handleAction();
        }
        // discard asynchronous data to avoid affecting the apdex of the current pid.
        if (ev.common.pid !== currentPageInfo[1])
            return;
        handlePageviewWeight(ev, apdexSetting);
    };
    var getPagePayload = function () {
        var _a = __read(getApdex(), 2), apdex = _a[0], detail = _a[1];
        return {
            start: currentPageInfo[0],
            pid: currentPageInfo[1],
            view_id: currentPageInfo[2],
            end: now(),
            time_spent: getSpentTime(),
            apdex: apdex,
            rank: getRank(apdex, apdexSetting),
            detail: detail,
        };
    };
    var handlePageviewChange = function (newPid, newViewId) {
        // if no current page info, init current page, else settle current page and reset status
        if (!currentPageInfo) {
            currentPageInfo = [now(), newPid, newViewId];
            // set entry to session
            setEntry(newPid);
            // set started status
            apdexStarted = !!(apdexSetting && currentPageInfo);
            return;
        }
        if (apdexStarted) {
            // set last pid payload
            lastPidPayload = getPagePayload();
            // send last pid payload to session
            handlePageview(lastPidPayload, newPid);
        }
        // reset status
        currentPageInfo = [now(), newPid, newViewId];
        resetApdex();
    };
    var reportPageviewWithApdex = function (ev) {
        apdexStarted && (ev.payload.last = lastPidPayload);
        report(ev);
    };
    var setApdexSetting = function (apdex) {
        if (!apdex) {
            // teardown all effect
            tearDownGroup.forEach(function (e) { return e(); });
            tearDownGroup.length = 0;
            return;
        }
        apdexSetting = apdex;
        apdexStarted = !!(apdexSetting && currentPageInfo);
    };
    tearDownGroup.push(function () {
        apdexStarted = false;
    });
    return [handlePageviewChange, handleSend, reportPageviewWithApdex, setApdexSetting];
};

var PAGEVIEW_MONITOR_PLUGIN_NAME = 'pageview';
var defaultConfig$1 = {
    sendInit: true,
    routeMode: 'history',
    apdex: 2,
};
function PageviewMonitorBasePlugin(client, c) {
    var _a;
    var config = getConfig(c, defaultConfig$1);
    if (!config || !getDefaultLocation()) {
        return;
    }
    var routeMode = config.routeMode, apdex = config.apdex;
    var report = client.report.bind(client);
    var handlePageviewChange = noop;
    // apdex start
    if (apdex) {
        var apdexTearDownGroup = [];
        var _b = __read(apdexGetterWithHiddenObserver(client.report.bind(client), apdexTearDownGroup, [initSubjectInGlobal(client, hiddenSubject), initSubjectInGlobal(client, unloadSubject)], config), 4), handlePageview = _b[0], handleSend_1 = _b[1], reportWithApdex = _b[2], setApdexSetting_1 = _b[3];
        report = reportWithApdex;
        handlePageviewChange = handlePageview;
        client.on('send', handleSend_1);
        apdexTearDownGroup.push(function () { return client.off('send', handleSend_1); });
        client.on('start', function () {
            setApdexSetting_1(client.config().apdex);
        });
        registerTearDownGroup(client, PAGEVIEW_MONITOR_PLUGIN_NAME, SESSION_EV_TYPE, apdexTearDownGroup);
    }
    // apdex end
    var tearDownGroup = [];
    var _c = __read(pvGetterWithRouteObserver(report, tearDownGroup, isManualMode(routeMode) ? [] : [client.initSubject(hashSubject), client.initSubject(historySubject)], __assign(__assign({}, config), { initPid: (_a = client.config()) === null || _a === void 0 ? void 0 : _a.pid, onPidUpdate: function (pid) {
            var viewId = getViewId(pid);
            // the apdex score must be settled when reporting, needs to know the change before reporting
            handlePageviewChange(pid, viewId);
            client.set({ pid: pid, viewId: viewId, actionId: undefined });
        } })), 1), sendPageview = _c[0];
    initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
    var onConfig = function () {
        sendPageview(client.config().pid);
    };
    client.on('config', onConfig);
    tearDownGroup.push(function () { return client.off('config', onConfig); });
    registerTearDownGroup(client, PAGEVIEW_MONITOR_PLUGIN_NAME, PAGEVIEW_EV_TYPE, tearDownGroup);
    client.provide('sendPageview', sendPageview);
}
function PageviewMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[PAGEVIEW_MONITOR_PLUGIN_NAME];
        PageviewMonitorBasePlugin(client, config);
    });
}

var defaultMetricContext = {
    isSupport: true,
    isPolyfill: false,
    isBounced: false,
    isCustom: false,
    type: 'perf',
};
var initMetric = function (name, value) {
    return __assign({ name: name, value: value }, defaultMetricContext);
};

var applySendOnceAndTearDown = function (wrapPerformanceMetric, report, tearDownGroup) {
    var hasInvoked = false;
    return function (metric) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                v();
            });
        tearDownGroup.length = 0;
        if (hasInvoked)
            return;
        hasInvoked = true;
        report && report(wrapPerformanceMetric(metric));
    };
};
var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: PERFORMANCE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
var getNavigationEntry = function () {
    var performance = getDefaultPerformance();
    var _a = __read(applyPerformance(performance), 3), getEntriesByType = _a[2];
    return getEntriesByType('navigation')[0];
};
var getActivationStart = function () {
    var navEntry = getNavigationEntry();
    // @ts-expect-error
    return (navEntry && navEntry.activationStart) || 0;
};

var FCP_ENTRY_NAME = 'first-contentful-paint';
var FP_ENTRY_NAME = 'first-paint';
var Paint_Type = 'paint';
var getPaint = function (entryName, metricName, report, tearDownGroup, _a) {
    var _b = __read(_a, 3), activatedObserver = _b[0], getHiddenObserver = _b[1], getUnloadObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var document = getDefaultDocument();
    var metric = initMetric(metricName, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!performance || !PerformanceObserver || !document) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var handleActivated = function () {
        // if the page is initially hidden or still hidden after prerendering
        // that means the tab was activated in a background state, so it is marked as unsupported
        if (visibilityStateIsHidden(document)) {
            metric.isSupport = false;
            sendOnceAndTearDown(metric);
            return;
        }
        var invokePaint = function (_a) {
            var startTime = _a.startTime;
            // should be relative to page activation rather than navigation start if the page was pre-rendered.
            // but in cases where `activationStart` occurs after the FP or FCP, this time should be clamped at 0.
            var activatedTimeStamp = getActivationStart();
            metric.value = startTime < activatedTimeStamp ? 0 : startTime - activatedTimeStamp;
            sendOnceAndTearDown(metric);
        };
        var _a = __read(applyPerformance(performance), 5), getEntriesByName = _a[4];
        var paint = getEntriesByName(entryName)[0];
        if (paint) {
            invokePaint(paint);
            return;
        }
        tearDownGroup.push(observePerf(PerformanceObserver, function (entry) {
            entry.name === entryName && invokePaint(entry);
        }, [Paint_Type]));
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            metric.isBounced = true;
            sendOnceAndTearDown(metric);
        }));
        var hiddenCallback = function (isHidden) {
            if (isHidden) {
                // if initially not hidden but suddenly becomes hidden, then the metric can be settle.
                sendOnceAndTearDown(metric);
            }
        };
        // hiddenObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        var hiddenObserver = getHiddenObserver();
        tearDownGroup.push(function () { return hiddenObserver[1](hiddenCallback); });
        hiddenObserver[0](hiddenCallback);
    };
    // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return activatedObserver[1](handleActivated); });
    activatedObserver[0](handleActivated);
};

var TTI_METRIC_NAME = 'tti';
var GET_METHOD = 'get';
var QUIET_TIME_LIMIT = 5000;
/**
 * start 方法开启一个调度器，传入回调和调度时间
 * reschedule 重新以一个更长的时间调度
 * stop 停止调度
 */
var applyScheduler = function (now) {
    var timerActiveTime = -Infinity;
    var timerId = undefined;
    var callback;
    var clearTime = function () { return window.clearTimeout(timerId); };
    var reschedule = function (futureTime) {
        if (timerActiveTime > futureTime || !callback) {
            return;
        }
        clearTime();
        timerId = window.setTimeout(callback, futureTime - now());
        timerActiveTime = futureTime;
    };
    var start = function (cb, futureTime) {
        callback = cb;
        reschedule(futureTime);
    };
    var stop = function () {
        clearTime();
        callback = undefined;
    };
    return [start, stop, reschedule];
};
/**
 * Computes the time (in milliseconds since requestStart) that the network was
 * last known to have >2 requests in-flight.
 */
var calcLastNet2Busy = function (undoneReqStarts, observedResReqs, now) {
    if (undoneReqStarts.length > 2) {
        return now();
    }
    var endpoints = [];
    for (var i = 0; i < observedResReqs.length; i++) {
        endpoints.push([observedResReqs[i].start, 0 /* S */], [observedResReqs[i].end, 1 /* E */]);
    }
    for (var i = 0; i < undoneReqStarts.length; i++) {
        endpoints.push([undoneReqStarts[i], 0 /* S */]);
    }
    endpoints.sort(function (a, b) { return a[0] - b[0]; });
    var currentActive = undoneReqStarts.length;
    for (var i = endpoints.length - 1; i >= 0; i--) {
        var _a = __read(endpoints[i], 2), timestamp = _a[0], type = _a[1];
        switch (type) {
            case 0 /* S */:
                currentActive--;
                break;
            case 1 /* E */:
                currentActive++;
                if (currentActive > 2) {
                    return timestamp;
                }
                break;
        }
    }
    // If we reach here, we were never network 2-busy.
    return 0;
};
var getRequestTimes = function (requestTimes) {
    var keys = Object.keys(requestTimes);
    var result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < keys.length; i++) {
        var val = requestTimes[keys[i]];
        if (typeof val === 'number') {
            result.push(val);
        }
    }
    return result;
};
/**
 * 监听包含 ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'] 标签的 dom 变更
 */
var observeResFetchMutations = function (MutationObserver, callback) {
    var requestCreatingNodeNames = ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'];
    function subtreeContainsNodeName(nodes, nodeNames) {
        for (var i = 0; i < nodes.length; i++) {
            if (arrayIncludes(nodeNames, nodes[i].nodeName.toLowerCase()) ||
                (nodes[i].children &&
                    subtreeContainsNodeName(nodes[i].children, nodeNames))) {
                return true;
            }
        }
        return false;
    }
    var _a = __read(applyMutationObserver(MutationObserver, function (mutations) {
        for (var i = 0; i < mutations.length; i++) {
            if ((mutations[i].type === 'childList' &&
                subtreeContainsNodeName(mutations[i].addedNodes, requestCreatingNodeNames)) ||
                (mutations[i].type === 'attributes' &&
                    arrayIncludes(requestCreatingNodeNames, mutations[i].target.nodeName.toLowerCase()))) {
                callback(mutations[i]);
            }
        }
    }), 2), observe = _a[0], disconnect = _a[1];
    return [
        function () {
            return observe(document, {
                attributes: true,
                childList: true,
                subtree: true,
                attributeFilter: ['href', 'src'],
            });
        },
        disconnect,
    ];
};
/**
 * Returns either a manually set min value or the time since
 * domContentLoadedEventEnd and navigationStart. If the
 * domContentLoadedEventEnd data isn't available, `null` is returned.
 * @return {number|null}
 */
var getMinValue = function (timing) {
    var _a = timing || {}, domContentLoadedEventEnd = _a.domContentLoadedEventEnd, _b = _a.navigationStart, navigationStart = _b === void 0 ? 0 : _b;
    return domContentLoadedEventEnd ? domContentLoadedEventEnd - navigationStart : null;
};
/**
 * Computes the TTI value...
 * @param {number} searchStart
 * @param {number} minValue
 * @param {number} lastKnownNetwork2Busy
 * @param {number} currentTime
 * @param {!Array<{start: (number), end: (number)}>} longTasks
 * @return {number|null}
 */
var computeTTI = function (searchStart, minValue, lastKnownNetwork2Busy, currentTime, longTasks) {
    // Have not reached network 2-quiet yet.
    if (currentTime - lastKnownNetwork2Busy < QUIET_TIME_LIMIT) {
        return null;
    }
    var maybeFCI = longTasks.length === 0 ? searchStart : longTasks[longTasks.length - 1].end;
    // Main thread has not been quiet for long enough.
    if (currentTime - maybeFCI < QUIET_TIME_LIMIT) {
        return null;
    }
    return Math.max(maybeFCI, minValue);
};
var pushLongTaskIntoList = function (entry, list) {
    var startTime = entry.startTime, duration = entry.duration;
    entry.start = startTime;
    entry.end = startTime + duration;
    list.push(entry);
};
var getLastBusyAndLongTasks = function (tearDownGroup, _a, entries) {
    var _b = __read(_a, 5), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3], MutationObserver = _b[4];
    return function (reschedule, now$1) {
        var longTasks = [];
        var networkRequests = [];
        var _a = __read(applyRecord(), 3), incompleteInitReqStartTimes = _a[0], before = _a[1], after = _a[2];
        entries.forEach(function (entry) {
            if (entry.entryType === LONGTASK_TYPE[0]) {
                pushLongTaskIntoList(entry, longTasks);
            }
        });
        var uniqId = 0;
        tearDownGroup.push(xhrObserver[0](function (_a) {
            var _b = __read(_a, 1), _method = _b[0];
            if ((_method || '').toLowerCase() !== GET_METHOD)
                return noop;
            var requestId = (uniqId += 1);
            before(requestId, now());
            return function () {
                after(requestId);
            };
        }));
        tearDownGroup.push(fetchObserver[0](function (_a) {
            var _b = __read(_a, 2), req = _b[0], options = _b[1];
            if (!window.Request || getFetchMethod(req, options, window.Request) !== GET_METHOD)
                return noop;
            var requestId = (uniqId += 1);
            before(requestId, now());
            return function () {
                after(requestId);
            };
        }));
        var _b = __read((MutationObserver && observeResFetchMutations(MutationObserver, function () { return reschedule(now$1() + QUIET_TIME_LIMIT); })) || [], 2), observeRes = _b[0], stopObserveRes = _b[1];
        observeRes && observeRes();
        var getLastBusy = function () { return calcLastNet2Busy(getRequestTimes(incompleteInitReqStartTimes), networkRequests, now$1); };
        stopObserveRes && tearDownGroup.push(stopObserveRes);
        tearDownGroup.push(longtaskObserver[0](function (entry) {
            pushLongTaskIntoList(entry, longTasks);
            var startTime = entry.startTime, duration = entry.duration;
            // 遇到 longTask 则在 longTask 5秒后 checkTTI
            reschedule(startTime + duration + QUIET_TIME_LIMIT);
        }));
        tearDownGroup.push(resourceObserver[0](function (_a) {
            var fetchStart = _a.fetchStart, responseEnd = _a.responseEnd;
            networkRequests.push({
                start: fetchStart,
                end: responseEnd,
            });
            // 遇到 resource 加载，则在最后一次 busy 5 秒后 checkTTI
            reschedule(getLastBusy() + QUIET_TIME_LIMIT);
        }));
        tearDownGroup.push(function () {
            longTasks.length = 0;
            networkRequests.length = 0;
        });
        return [longTasks, getLastBusy];
    };
};
var getTTI = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 5), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3], pvObserver = _b[4];
    var metric = initMetric(TTI_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    var performance = getDefaultPerformance();
    var PerformanceObserver = getDefaultPerformanceObserver();
    var _c = config || {}, _d = _c.entries, entries = _d === void 0 ? [] : _d, snippetObserver = _c.observer;
    tearDownGroup.push(function () {
        snippetObserver && snippetObserver.disconnect();
        entries.length = 0;
    });
    if (!window ||
        !XMLHttpRequest ||
        !performance ||
        !PerformanceObserver ||
        (PerformanceObserver.supportedEntryTypes &&
            !arrayIncludes(PerformanceObserver.supportedEntryTypes || [], LONGTASK_TYPE[0]))) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var _e = __read(applyPerformance(performance), 5), timing = _e[0], now = _e[1], getEntriesByName = _e[4];
    var _f = __read(applyScheduler(now), 3), startSchedule = _f[0], stopSchedule = _f[1], reschedule = _f[2];
    var _g = __read(getLastBusyAndLongTasks(tearDownGroup, [xhrObserver, fetchObserver, longtaskObserver, resourceObserver, getDefaultMutationObserver()], entries)(reschedule, now), 2), longTasks = _g[0], getLastBusy = _g[1];
    tearDownGroup.push(stopSchedule);
    var checkTTI = function (ttiCallback) {
        var firstContentfulPaint = getEntriesByName(FCP_ENTRY_NAME)[0];
        var maybeFCI = computeTTI((firstContentfulPaint ? firstContentfulPaint.startTime : getMinValue(timing)) || 0, getMinValue(timing) || 0, getLastBusy(), now(), longTasks);
        if (!maybeFCI)
            return reschedule(now() + 1000);
        ttiCallback(maybeFCI);
    };
    var reportTTI = function (value) {
        metric.value = value;
        sendOnceAndTearDown(metric);
    };
    var lastLongTask = longTasks[longTasks.length - 1];
    startSchedule(function () { return checkTTI(reportTTI); }, Math.max(getLastBusy() + QUIET_TIME_LIMIT, lastLongTask ? lastLongTask.end : 0));
    tearDownGroup.push(pvObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var TTI_MONITOR_PLUGIN_NAME = 'tti';
function TTIMonitorBasePlugin(client) {
    var tearDownGroup = [];
    getTTI(reportWithCurrentContext(client), tearDownGroup, [
        initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
        initSubjectInGlobal(client, fetchSubject),
        initSubjectInGlobal(client, longtaskSubject),
        initSubjectInGlobal(client, resourceSubject),
        initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
    ], client.pp);
    registerTearDownGroup(client, TTI_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDownGroup);
}
function TTIMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, TTI_MONITOR_PLUGIN_NAME, {});
        if (!config) {
            return;
        }
        TTIMonitorBasePlugin(client);
    });
}

var FMP_METRIC_NAME = 'fmp';
var DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var getScore = function (element, depth, exist, ignoreTags) {
    if (!element || ignoreTags.indexOf(element.tagName) > -1) {
        return 0;
    }
    var _a = element.children, children = _a === void 0 ? [] : _a;
    var score = [].slice
        .call(children)
        .reduceRight(function (sum, child) { return sum + getScore(child, depth + 1, sum > 0, ignoreTags); }, 0);
    if (score <= 0 && !exist) {
        if (!isFunction(element.getBoundingClientRect)) {
            return 0;
        }
        var _b = element.getBoundingClientRect() || {}, top_1 = _b.top, height = _b.height;
        if (top_1 > window.innerHeight || height <= 0) {
            return 0;
        }
    }
    return score + 1 + 0.5 * depth;
};
var getFMPInternal = function (_a) {
    var _b = _a === void 0 ? [] : _a, _c = __read(_b), first = _c[0], rest = _c.slice(1);
    return ((rest &&
        rest.reduce(function (_a, cur) {
            var _b = __read(_a, 2), prev = _b[0], target = _b[1];
            var diff = cur.score - prev.score;
            return [cur, cur.time >= prev.time && target.rate < diff ? { time: cur.time, rate: diff } : target];
        }, [first, { time: first === null || first === void 0 ? void 0 : first.time, rate: 0 }])[1].time) ||
        0);
};
var getFMP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), loadObserver = _b[0], pvObserver = _b[1];
    var document = getDefaultDocument();
    var MutationObserver = getDefaultMutationObserver();
    var performance = getDefaultPerformance();
    var navigationStart = (performance && performance.timing && performance.timing.navigationStart) || undefined;
    var metric = initMetric(FMP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!document || !MutationObserver || !navigationStart) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var startTime = now();
    var list = [];
    var record = function () {
        return list.push({
            time: now() - startTime,
            // eslint-disable-next-line compat/compat
            score: getScore(document && document.body, 1, false, DEFAULT_IGNORE_TAGS),
        });
    };
    var raf = getDefaultRaf();
    var caf = getDefaultCaf();
    var _c = __read(applyAnimationFrame(document, raf, caf, true), 1), scheduleAF = _c[0];
    // 持续监听 dom 变化，记录下时间和得分
    // scheduleAF 可以避免强制回流，同时真正的变更是在animationFrame 中
    var _d = __read(applyMutationObserver(MutationObserver, function () { return scheduleAF(record); }), 2), observe = _d[0], disconnect = _d[1];
    var triggerFMP = function (timeGap) {
        if (timeGap === void 0) { timeGap = 0; }
        var fmp = getFMPInternal(list);
        metric.value = fmp ? fmp + timeGap : 0;
        sendOnceAndTearDown(metric);
        list.length = 0;
    };
    var timeGap = startTime - (navigationStart || 0);
    observe(document, { subtree: true, childList: true });
    tearDownGroup.push(disconnect);
    tearDownGroup.push(pvObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
    tearDownGroup.push(loadObserver[0](function () {
        clearTimerWithTearDowns(window.setTimeout(function () {
            triggerFMP(timeGap);
        }, 200), tearDownGroup);
    }));
};

var FMP_MONITOR_PLUGIN_NAME = 'fmp';
var defaultConfig = {
    renderType: 'CSR',
};
function FMPMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig; }
    var tearDownGroup = [];
    if (config.renderType === 'SSR') {
        // @ts-expect-error
        getPaint(FP_ENTRY_NAME, FMP_MONITOR_PLUGIN_NAME, reportWithCurrentContext(client), tearDownGroup, [
            initSubjectInGlobal(client, activatedSubject),
            function () { return initSubjectInGlobal(client, hiddenSubject); },
            function () { return initSubjectInGlobal(client, unloadSubject); },
        ]);
    }
    else {
        getFMP(reportWithCurrentContext(client), tearDownGroup, [
            initSubjectInGlobal(client, loadSubject),
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
        ]);
    }
    registerTearDownGroup(client, FMP_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDownGroup);
}
function FMPMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, FMP_MONITOR_PLUGIN_NAME, defaultConfig);
        if (!config) {
            return;
        }
        FMPMonitorBasePlugin(client, config);
    });
}

var CUSTOM_EVENT_TYPE = 'event';
var CUSTOM_LOG_TYPE = 'log';
var normalizeCustomEventData = function (raw) {
    if (!raw || !isObject(raw)) {
        return;
    }
    // name is required
    if (!raw['name'] || !isString(raw['name'])) {
        return;
    }
    var res = {
        name: raw['name'],
        type: CUSTOM_EVENT_TYPE,
    };
    if ('metrics' in raw && isObject(raw['metrics'])) {
        var rMetrics = raw['metrics'];
        var metrics = {};
        for (var k in rMetrics) {
            if (isNumber(rMetrics[k])) {
                metrics[k] = rMetrics[k];
            }
        }
        res.metrics = metrics;
    }
    if ('categories' in raw && isObject(raw['categories'])) {
        var rCategories = raw['categories'];
        var categories = {};
        for (var k in rCategories) {
            categories[k] = safeStringify(rCategories[k]);
        }
        res.categories = categories;
    }
    return res;
};
var normalizeCustomLogData = function (raw) {
    if (!raw || !isObject(raw)) {
        return;
    }
    // content is required
    if (!raw['content'] || !isString(raw['content'])) {
        return;
    }
    var rContent = raw['content'];
    var res = {
        content: safeStringify(rContent),
        type: CUSTOM_LOG_TYPE,
        level: 'info',
    };
    if ('level' in raw) {
        res.level = raw['level'];
    }
    if ('extra' in raw && isObject(raw['extra'])) {
        var rExtra = raw['extra'];
        var metrics = {};
        var categories = {};
        for (var k in rExtra) {
            if (isNumber(rExtra[k])) {
                metrics[k] = rExtra[k];
            }
            else {
                categories[k] = safeStringify(rExtra[k]);
            }
        }
        res.metrics = metrics;
        res.categories = categories;
    }
    return res;
};
var CustomPlugin = function (client) {
    var sendEvent = function (data) {
        var normalized = normalizeCustomEventData(data);
        if (normalized) {
            client.report({
                ev_type: CUSTOM_EV_TYPE,
                payload: normalized,
                extra: {
                    timestamp: now(),
                },
            });
        }
    };
    var sendLog = function (data) {
        var normalized = normalizeCustomLogData(data);
        if (normalized) {
            client.report({
                ev_type: CUSTOM_EV_TYPE,
                payload: normalized,
                extra: {
                    timestamp: now(),
                },
            });
        }
    };
    client.provide('sendEvent', sendEvent);
    client.provide('sendLog', sendLog);
};

function getNetworkType(netInfo) {
    return (netInfo === null || netInfo === void 0 ? void 0 : netInfo.effectiveType) || (netInfo === null || netInfo === void 0 ? void 0 : netInfo.type) || '';
}
var InjectNetworkTypePlugin = function (client) {
    var netInfo = getDefaultNetworkInformation();
    var network_type = getNetworkType(netInfo);
    if (netInfo) {
        netInfo.onchange = function () {
            network_type = getNetworkType(netInfo);
        };
    }
    client.on('report', function (ev) {
        return __assign(__assign({}, ev), { extra: __assign(__assign({}, (ev.extra || {})), { network_type: network_type }) });
    });
};

/* eslint-disable @typescript-eslint/prefer-for-of */
var withSampleRate = function (ev, sampleRate) {
    var common = ev.common || {};
    common.sample_rate = sampleRate;
    ev.common = common;
    return ev;
};
var hitFnWithRandom = function (preCalc, sampleRate, isHitBySampleRate, random, isHitByRandom) {
    return preCalc
        ? (function (h) { return function () {
            return h;
        }; })(isHitByRandom(random, sampleRate))
        : function () { return isHitBySampleRate(sampleRate); };
};
var parseValues = function (values, type) {
    return values.map(function (v) {
        switch (type) {
            case 'number':
                return Number(v);
            case 'boolean':
                return v === '1';
            case 'string': // default to string
            default:
                return String(v);
        }
    });
};
var checkVal = function (val, values, op) {
    switch (op) {
        case 'eq':
            return arrayIncludes(values, val);
        case 'neq':
            return !arrayIncludes(values, val);
        case 'gt':
            return val > values[0];
        case 'gte':
            return val >= values[0];
        case 'lt':
            return val < values[0];
        case 'lte':
            return val <= values[0];
        case 'regex':
            return Boolean(val.match(new RegExp(values.join('|'))));
        case 'not_regex':
            return !val.match(new RegExp(values.join('|')));
        default: {
            // unknown op
            return false;
        }
    }
};
var checkFilter = function (ev, field, op, values) {
    var val = safeVisit(ev, field, function (t, p) {
        return t[p];
    });
    if (val === undefined) {
        return false;
    }
    var field_type = isBoolean(val) ? 'bool' : isNumber(val) ? 'number' : 'string';
    return checkVal(val, parseValues(values, field_type), op);
};
var matchFilter = function (ev, filter) {
    try {
        return filter.type === 'rule'
            ? checkFilter(ev, filter.field, filter.op, filter.values)
            : filter.type === 'and'
                ? filter.children.every(function (f) { return matchFilter(ev, f); })
                : filter.children.some(function (f) { return matchFilter(ev, f); });
    }
    catch (e) {
        reportSelfError(e);
        return false;
    }
};
var getHitMap = function (rules, preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom) {
    var hitMap = {};
    Object.keys(rules).forEach(function (name) {
        var _a = rules[name], enable = _a.enable, sample_rate = _a.sample_rate, conditional_sample_rules = _a.conditional_sample_rules;
        if (enable) {
            hitMap[name] = {
                enable: enable,
                sample_rate: sample_rate,
                effectiveSampleRate: sample_rate * baseRate,
                hit: hitFnWithRandom(preCalcHit, sample_rate, isHitBySampleRate, random, isHitByRandom),
            };
            if (conditional_sample_rules) {
                hitMap[name].conditional_hit_rules = conditional_sample_rules.map(function (_a) {
                    var s = _a.sample_rate, filter = _a.filter;
                    return ({
                        sample_rate: s,
                        hit: hitFnWithRandom(preCalcHit, s, isHitBySampleRate, random, isHitByRandom),
                        effectiveSampleRate: s * baseRate,
                        filter: filter,
                    });
                });
            }
        }
        else {
            hitMap[name] = {
                enable: enable,
                hit: function () {
                    /* istanbul ignore next */
                    return false;
                },
                sample_rate: 0,
                effectiveSampleRate: 0,
            };
        }
    });
    return hitMap;
};
var getSampler = function (userId, config, isHitBySampleRate, isHitByRandom, destroyFns) {
    if (!config)
        return id;
    // r的设计是为了允许外部传入随机数，用于彻底实现按用户采样
    var baseRate = config.sample_rate, include_users = config.include_users, sample_granularity = config.sample_granularity, rules = config.rules, _a = config.r, random = _a === void 0 ? Math.random() : _a;
    // 用户名单采样
    var userHit = arrayIncludes(include_users, userId);
    if (userHit) {
        return function (ev) { return withSampleRate(ev, 1); };
    }
    // should pre calculate hit
    var preCalcHit = sample_granularity === 'session';
    var baseHit = hitFnWithRandom(preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom);
    var hitMap = getHitMap(rules, preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom);
    return function (ev) {
        var _a;
        // 总采样必须命中才有后续
        if (!baseHit()) {
            preCalcHit && destroyFns[0]();
            return false;
        }
        // 未配置的事件类型
        if (!(ev.ev_type in hitMap)) {
            return withSampleRate(ev, baseRate);
        }
        // 忽略未开启的事件类型
        if (!hitMap[ev.ev_type].enable) {
            preCalcHit && destroyFns[1](ev.ev_type);
            return false;
        }
        // 跳过采样配置
        if ((_a = ev.common) === null || _a === void 0 ? void 0 : _a.sample_rate) {
            return ev;
        }
        var hitConfig = hitMap[ev.ev_type];
        var conditions = hitConfig.conditional_hit_rules;
        if (conditions) {
            // 先判断条件采样
            for (var i = 0; i < conditions.length; i++) {
                if (matchFilter(ev, conditions[i].filter)) {
                    if (conditions[i].hit()) {
                        return withSampleRate(ev, conditions[i].effectiveSampleRate);
                    }
                    // 条件匹配后不再搜索
                    return false;
                }
            }
        }
        // 事件类型采样
        if (!hitConfig.hit()) {
            // not hit ev_type and no condition, destroy side effect
            !(conditions && conditions.length) && preCalcHit && destroyFns[1](ev.ev_type);
            return false;
        }
        // 事件类型默认采样已经命中
        return withSampleRate(ev, hitConfig.effectiveSampleRate);
    };
};
var SamplePlugin = function (client) {
    client.on('start', function () {
        var _a = client.config(), userId = _a.userId, sample = _a.sample;
        var destroyFns = [
            function () {
                client.destroy();
            },
            function (ev_type) {
                client.destroyAgent.removeByEvType(ev_type);
            },
        ];
        var sampler = getSampler(userId, sample, isHitBySampleRate, isHitByRandom, destroyFns);
        client.on('build', sampler);
    });
};

/* eslint-disable @typescript-eslint/prefer-optional-chain */
var getBeaconTransport = function () {
    var window = getDefaultBrowser();
    // eslint-disable-next-line compat/compat
    return window && window.navigator.sendBeacon
        ? {
            get: function () { },
            post: function (url, data) {
                // eslint-disable-next-line compat/compat
                window.navigator.sendBeacon(url, data);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

var request = function (method, options, XMLHttpRequest) {
    var url = options.url, data = options.data, _a = options.success, success = _a === void 0 ? noop : _a, _b = options.fail, fail = _b === void 0 ? noop : _b, _c = options.getResponseText, getResponseText = _c === void 0 ? noop : _c, _d = options.withCredentials, withCredentials = _d === void 0 ? false : _d;
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = withCredentials;
    xhr.open(method, url, true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onload = function () {
        getResponseText === null || getResponseText === void 0 ? void 0 : getResponseText(this.responseText);
        try {
            if (this.responseText) {
                var result = JSON.parse(this.responseText);
                success(result);
            }
            else {
                success({});
            }
        }
        catch (e) {
            fail(e);
        }
    };
    xhr.onerror = function () {
        fail(new Error('Network request failed'));
    };
    xhr.onabort = function () {
        /* istanbul ignore next */
        fail(new Error('Network request aborted'));
    };
    xhr.send(data);
};
var getXhrTransport = function () {
    var XMLHttpRequest = getDefaultXMLHttpRequest();
    return XMLHttpRequest
        ? {
            useBeacon: true,
            get: function (options) {
                request('GET', options, XMLHttpRequest);
            },
            post: function (options) {
                request('POST', options, XMLHttpRequest);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

// createSender has side effects(register onClose behavior)
// so it must be create lazily
function createBrowserSender(config) {
    var sender = createBatchSender(config);
    var originSend = sender.send;
    // send the cached data immediately upon unload
    onPageUnload(function () {
        // use sendBeacon if allowed
        if (config.transport.useBeacon) {
            var beaconTransport_1 = getBeaconTransport();
            var data = sender.getBatchData();
            if (data) {
                beaconTransport_1.post(sender.getEndpoint(), data);
                sender.clear();
            }
            // some data may still be generated during unload
            sender.send = function (data) {
                beaconTransport_1.post(sender.getEndpoint(), stringifyBatch([data]));
            };
            // in webview, page can still be resurrected even after the `unload` event has been triggered
            onPageNextShow(function () {
                sender.send = originSend;
            });
        }
        else {
            // if not use sendBeacon, flush the data list by default
            sender.flush();
        }
    });
    return sender;
}

var REPORT_DOMAIN = "mon-i18n.tiktokv.com";
var SETTINGS_DOMAIN = REPORT_DOMAIN;
var PLUGINS_LOAD_PREFIX = "https:" + "//" + ("sf16-short-va.bytedapm.com") + "/slardar/fe/sdk-web/plugins";
var SDK_VERSION = "1.12.7" ;
var SDK_NAME = 'SDK_SLARDAR_WEB';
var SETTINGS_PATH = '/monitor_web/settings/browser-settings';
var BATCH_REPORT_PATH = "/monitor_browser/collect/batch/";
var STORAGE_PREFIX = 'SLARDAR';
var USER_ID_COOKIE_NAME = 'MONITOR_WEB_ID';
var DEVICE_ID_COOKIE_NAME = 'MONITOR_DEVICE_ID';
var DEFAULT_IGNORE_PATHS = ['/log/sentry/', BATCH_REPORT_PATH, SETTINGS_PATH];
var DEFAULT_SAMPLE_GRANULARITY = 'session';
var EXTRA_INDEPENDENT_PLUGINS = ['blankScreen', 'action'];
var DEFAULT_SAMPLE_CONFIG = {
    sample_rate: 1,
    include_users: [],
    sample_granularity: DEFAULT_SAMPLE_GRANULARITY,
    rules: {},
};
var DEFAULT_SENDER_SIZE = 20;

var isDebug = '';
function loadPluginsOnPageLoad(client, registry, lp) {
    if (lp === void 0) { lp = loadPlugins; }
    onPageLoad(function () {
        client.on('init', function () {
            lp(client, registry);
        });
    });
}
var loadCombinedPlugins = function (combinedPlugins, client, registry, ld) {
    if (ld === void 0) { ld = loadNow; }
    var _a = client.config(), plugins = _a.plugins, pluginBundle = _a.pluginBundle;
    // combined plugins
    var combinedPluginsToLoad = combinedPlugins.filter(function (name) { return plugins[name] && !client.destroyAgent.has(name); });
    var applyCombinedPlugins = function () { return combinedPluginsToLoad.forEach(function (name) { return applyPlugin(client, name, registry); }); };
    combinedPluginsToLoad.every(function (name) { return doesPluginExistInRegistry(name, registry); })
        ? applyCombinedPlugins()
        : ld(client, { name: pluginBundle.name }, applyCombinedPlugins);
};
var loadIndependentPlugins = function (independentPlugins, client, registry, ld) {
    if (ld === void 0) { ld = loadNow; }
    var plugins = client.config().plugins;
    independentPlugins
        .filter(function (name) { return plugins[name] && !client.destroyAgent.has(name); })
        .forEach(function (name) {
        if (doesPluginExistInRegistry(name, registry)) {
            applyPlugin(client, name, registry);
        }
        else {
            ld(client, { name: name, config: plugins[name] }, function () { return applyPlugin(client, name, registry); });
        }
    });
};
var reloadWithClient = function (client) {
    return function (pluginName, pluginConfig) {
        var _a;
        var pluginBundle = client.config().pluginBundle;
        client.destroyAgent.has(pluginName) && client.destroyAgent.remove(pluginName);
        pluginConfig !== undefined && client.set({ plugins: __assign(__assign({}, client.config().plugins), (_a = {}, _a[pluginName] = pluginConfig, _a)) });
        pluginBundle && ~pluginBundle.plugins.indexOf(pluginName)
            ? loadCombinedPlugins([pluginName], client)
            : loadIndependentPlugins([pluginName], client);
    };
};
function loadPlugins(client, registry, ld) {
    if (ld === void 0) { ld = loadNow; }
    var pluginBundle = client.config().pluginBundle;
    var combinedPlugins = pluginBundle ? pluginBundle.plugins : [];
    loadCombinedPlugins(combinedPlugins, client, registry, ld);
    loadIndependentPlugins(EXTRA_INDEPENDENT_PLUGINS, client, registry, ld);
    client.provide('reloadPlugin', reloadWithClient(client));
}
function loadNow(client, _a, runAfterLoadScript, ls) {
    var name = _a.name, config = _a.config;
    if (ls === void 0) { ls = loadScript; }
    var path = getPluginPath(client, name, config);
    ls(path, function () {
        runAfterLoadScript();
    });
}
function getPluginPath(client, name, config) {
    var _a;
    return (_a = config === null || config === void 0 ? void 0 : config.path) !== null && _a !== void 0 ? _a : client.config().pluginPathPrefix + "/" + camelToKebab(name) + "." + SDK_VERSION + "." + isDebug + "js";
}
function applyPlugin(client, name, registry) {
    if (registry === void 0) { registry = getGlobalRegistry(getDefaultBrowser()); }
    if (!registry)
        return;
    var plugin = getPluginFromRegistry(registry, name);
    if (!plugin) {
        warn('[loader].applyPlugin not found', name);
        return;
    }
    try {
        // perhaps integration has already set up
        if (client.destroyAgent.has(name)) {
            return;
        }
        plugin.apply(client);
    }
    catch (err) {
        reportSelfError(err);
        warn('[loader].applyPlugin failed', name, err);
    }
}
function getPluginFromRegistry(registry, name) {
    return registry.plugins.filter(function (l) { return l.name === name && l.version === SDK_VERSION; })[0];
}
function doesPluginExistInRegistry(name, registry) {
    if (registry === void 0) { registry = getGlobalRegistry(getDefaultBrowser()); }
    if (!registry || !registry.plugins)
        return false;
    if (getPluginFromRegistry(registry, name))
        return true;
    return false;
}
/**
 * Registers a plugin by adding it to the global registry.
 *
 * @param {string} name - The name of the plugin to register.
 * @param {PluginApplyFnForVol} apply - The function to apply the plugin.
 * @param {Registry} registry - The registry to add the plugin to.
 * @return {void}
 */
function register(name, apply, registry) {
    if (registry === void 0) { registry = getGlobalRegistry(getDefaultBrowser()); }
    if (!registry || !registry.plugins)
        return;
    if (getPluginFromRegistry(registry, name)) {
        return;
    }
    registry.plugins.push({
        name: name,
        version: SDK_VERSION,
        apply: apply,
    });
}

function normalizeInitConfig(config) {
    var plugins = config.plugins || {};
    for (var k in plugins) {
        if (plugins[k] && !isObject(plugins[k])) {
            plugins[k] = {};
        }
    }
    return __assign(__assign({}, config), { plugins: plugins });
}
function validateInitConfig(config) {
    return isObject(config) && 'bid' in config;
}
function normalizeUserConfig(config) {
    return __assign({}, config);
}
function parseServerConfig(serverConfig) {
    var _a;
    if (!serverConfig) {
        return {};
    }
    var sample = serverConfig.sample, plugins = serverConfig.plugins, timestamp = serverConfig.timestamp, _b = serverConfig.quota_rate, quota_rate = _b === void 0 ? 1 : _b, apdex = serverConfig.apdex;
    if (!sample) {
        return {};
    }
    var sample_rate = sample.sample_rate, _c = sample.sample_granularity, sample_granularity = _c === void 0 ? DEFAULT_SAMPLE_GRANULARITY : _c, include_users = sample.include_users, _d = sample.rules, rules = _d === void 0 ? [] : _d;
    return {
        sample: {
            include_users: include_users,
            sample_rate: sample_rate * quota_rate,
            sample_granularity: sample_granularity,
            rules: rules.reduce(function (prev, cur) {
                var name = cur.name, enable = cur.enable, sample_rate = cur.sample_rate, conditional_sample_rules = cur.conditional_sample_rules;
                prev[name] = {
                    enable: enable,
                    sample_rate: sample_rate,
                    conditional_sample_rules: conditional_sample_rules,
                };
                return prev;
            }, {}),
        },
        plugins: {
            heatmap: (_a = plugins === null || plugins === void 0 ? void 0 : plugins.heatmap) !== null && _a !== void 0 ? _a : false,
        },
        apdex: apdex,
        serverTimestamp: timestamp,
    };
}

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var getReportUrl = function (domain, path) {
    if (path === void 0) { path = BATCH_REPORT_PATH; }
    return "" + (domain && domain.indexOf('//') >= 0 ? '' : 'https://') + domain + path;
};
var getSettingsUrl = function (domain, path) {
    if (path === void 0) { path = SETTINGS_PATH; }
    return "" + (domain && domain.indexOf('//') >= 0 ? '' : 'https://') + domain + path;
};
var getDefaultSessionId = function () {
    return uuid();
};
var toObservableArray = function (arr) {
    var observers = [];
    arr.observe = function (o) {
        observers.push(o);
    };
    arr.push = function () {
        var _a;
        var vs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            vs[_i] = arguments[_i];
        }
        vs.forEach(function (v) {
            observers.forEach(function (o) { return o(v); });
        });
        return (_a = [].push).call.apply(_a, __spreadArray([arr], __read(vs), false));
    };
    return arr;
};
var getGlobalName = function () {
    var _a, _b, _c;
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (window && document) {
        return (((_c = (_b = (_a = getCurrentScript()) === null || _a === void 0 ? void 0 : _a.getAttribute('src')) === null || _b === void 0 ? void 0 : _b.match(/globalName=(.+)$/)) === null || _c === void 0 ? void 0 : _c[1]) || 'Slardar');
    }
};
var getGlobalInstance = function () {
    var window = getDefaultBrowser();
    var globalName = getGlobalName();
    if (window && globalName) {
        return window[globalName];
    }
};
var getStorageKey = function (bid) { return STORAGE_PREFIX + bid; };
/**
 * glue code for storage security. Maybe it could remove in one year later
 * @param key storage key
 * @returns
 */
var glueCodeForStorageSecurity = function (key, expires) {
    try {
        var value = localStorage.getItem(key);
        // btoa(encodeURI('{')) === JTdC
        // old content:{ userId: '', deviceId: '' }
        if (!value || !isSupportEncrypt() || value[0] !== '{')
            return;
        setStorageWithEncoding(key, JSON.parse(value), expires);
    }
    catch (error) {
        // do nothing
    }
};
var getDefaultUserIdAndDeviceId = function (bid, expires) {
    if (bid === void 0) { bid = ''; }
    var randomIdInfo = {
        userId: uuid(),
        deviceId: uuid(),
    };
    // <= 0 时，不移除现 localStorage 数据，只是不取和不存
    if (expires <= 0)
        return randomIdInfo;
    var key = getStorageKey(bid);
    glueCodeForStorageSecurity(key, expires);
    return getStorageWithDecoding(key) || randomIdInfo;
};
var hasSetStorageItem = function (bid) {
    if (bid === void 0) { bid = ''; }
    var key = getStorageKey(bid);
    return !!getStorageWithDecoding(key);
};
var setStorageUserIdAndDeviceId = function (config) {
    var bid = config.bid, userId = config.userId, deviceId = config.deviceId, storageExpires = config.storageExpires;
    var key = getStorageKey(bid);
    setStorageWithEncoding(key, {
        userId: userId,
        deviceId: deviceId,
    }, formatStorageExpires(storageExpires));
};

var configHolder = {
    get: function () {
        return this.__SLARDAR__REPALCE__HOLDER__;
    },
};
var createBrowserConfigManager = function (defaultConfig) {
    // the merged config
    var config = defaultConfig;
    // save it so we know when initConfig is set
    var initConfig;
    // save UserConfig so we can merge with priority
    var userConfig = {};
    // save the original server config, from sdk-server or from get_setting response
    var serverConfig = configHolder.get();
    // cache the parsed ServerConfig, used in merge
    var parsedServerConfig;
    // call when ready to start(with initConfig and serverConfig)
    var onReady = noop;
    // call when config changed
    var onChange = noop;
    return {
        getConfig: function () {
            return config;
        },
        setConfig: function (c) {
            userConfig = __assign(__assign({}, userConfig), (c || {}));
            updateConfig();
            if (!initConfig) {
                // handle init
                initConfig = c;
                if (config.useLocalConfig || !config.bid) {
                    // when useLocalConfig is true, ignore serverConfig
                    parsedServerConfig = {};
                    onReady();
                }
                else if (serverConfig) {
                    // check injected serverConfig
                    handleServerConfig();
                }
                else {
                    // get serverConfig from server
                    getServerConfig(config.transport, config.domain, config.bid, function (res) {
                        serverConfig = res;
                        handleServerConfig();
                    });
                }
            }
            return config;
        },
        onChange: function (fn) {
            onChange = fn;
        },
        onReady: function (fn) {
            onReady = function () {
                setStorageUserIdAndDeviceId(config);
                fn();
            };
            if (parsedServerConfig) {
                onReady();
            }
        },
    };
    function updateConfig() {
        // merge priority: UserConfig > ServerConfig > CurrentConfig(including default config)
        var newConfig = __assign(__assign(__assign({}, defaultConfig), (parsedServerConfig || {})), userConfig);
        newConfig.plugins = mergeDeepConcatArray(defaultConfig.plugins, (parsedServerConfig === null || parsedServerConfig === void 0 ? void 0 : parsedServerConfig.plugins) || {}, userConfig.plugins || {});
        newConfig.sample = mergeSampleConfig(mergeSampleConfig(defaultConfig.sample, parsedServerConfig === null || parsedServerConfig === void 0 ? void 0 : parsedServerConfig.sample), userConfig.sample);
        config = newConfig;
        onChange();
    }
    function handleServerConfig() {
        parsedServerConfig = parseServerConfig(serverConfig);
        updateConfig();
        onReady();
    }
};
function getServerConfig(transport, domain, bid, cb) {
    transport.get({
        withCredentials: true,
        url: getSettingsUrl(domain) + "?bid=" + bid + "&store=1",
        success: function (res) {
            cb(res.data || {});
        },
        fail: function () {
            cb({ sample: { sample_rate: 0.001 } });
        },
    });
}
function mergeSampleConfig(a, b) {
    if (!a || !b)
        return a || b;
    var res = __assign(__assign({}, a), b);
    res.include_users = __spreadArray(__spreadArray([], __read((a.include_users || [])), false), __read((b.include_users || [])), false);
    res.rules = __spreadArray(__spreadArray([], __read(Object.keys(a.rules || {})), false), __read(Object.keys(b.rules || {})), false).reduce(function (obj, key) {
        var _a, _b;
        if (!(key in obj)) {
            if (key in (a.rules || {}) && key in (b.rules || {})) {
                obj[key] = __assign(__assign({}, a.rules[key]), b.rules[key]);
                obj[key].conditional_sample_rules = __spreadArray(__spreadArray([], __read((a.rules[key].conditional_sample_rules || [])), false), __read((b.rules[key].conditional_sample_rules || [])), false);
            }
            else {
                obj[key] = ((_a = a.rules) === null || _a === void 0 ? void 0 : _a[key]) || ((_b = b.rules) === null || _b === void 0 ? void 0 : _b[key]);
            }
        }
        return obj;
    }, {});
    return res;
}

var browserBuilder = {
    build: function (e) {
        return {
            ev_type: e.ev_type,
            payload: e.payload,
            common: __assign(__assign({}, (e.extra || {})), (e.overrides || {})),
        };
    },
};

var addEnvToSendEvent = function (ev, config) {
    // The data needs immediate injection during the reporting process
    var _a = config || {}, _b = _a.pid, pid = _b === void 0 ? '' : _b, _c = _a.viewId, viewId = _c === void 0 ? '' : _c;
    var extra = {
        url: getLocationUrl(),
        timestamp: now(),
        sdk_version: SDK_VERSION,
        sdk_name: SDK_NAME,
        pid: pid,
        view_id: viewId,
    };
    return __assign(__assign({}, ev), { extra: __assign(__assign({}, extra), (ev.extra || {})) });
};
var InjectEnvPlugin = function (client) {
    client.on('report', function (ev) {
        return addEnvToSendEvent(ev, client.config());
    });
};

var EV_METHOD_MAP = {
    sri: 'reportSri',
    st: 'reportResourceError',
    err: 'captureException',
    reject: 'captureException',
};
var createStore = function (evMap) {
    return Object.keys(evMap).reduce(function (prev, cur) {
        prev[cur] = [];
        return prev;
    }, {});
};
var reverseMap = function (map) {
    return Object.keys(map).reduce(function (prev, cur) {
        if (prev[map[cur]])
            prev[map[cur]].push(cur);
        else
            prev[map[cur]] = [cur];
        return prev;
    }, {});
};
var getStoreOrConsume = function (client, store, evMap) {
    return function (type, data, timestamp, url) {
        var _a;
        if (timestamp === void 0) { timestamp = now(); }
        if (url === void 0) { url = location.href; }
        var capturedContext = __assign(__assign({}, captureCurrentContext(client)), { url: url, timestamp: timestamp });
        if (store[type]) {
            if (client[evMap[type]]) {
                syncReportWithCapturedContext(client, capturedContext)(function () {
                    client[evMap[type]](data);
                });
            }
            else {
                (_a = store[type]) === null || _a === void 0 ? void 0 : _a.push([data, capturedContext]);
            }
        }
    };
};
var getConsumeStored = function (client, store, evMethods) { return function (name) {
    if (name in evMethods) {
        evMethods[name].forEach(function (e) {
            var _a;
            (_a = store[e]) === null || _a === void 0 ? void 0 : _a.forEach(function (_a) {
                var _b = __read(_a, 2), event = _b[0], capturedContext = _b[1];
                syncReportWithCapturedContext(client, capturedContext)(function () {
                    client[name](event);
                });
            });
            // 置空，不再消费
            store[e] = null;
        });
    }
}; };
var filterIfPluginDisabled = function (config, type) {
    if (type === 'err') {
        return (safeVisit(config, "plugins." + JS_ERROR_MONITOR_PLUGIN_NAME + ".onerror", function (target, property) { return target[property]; }) !==
            false);
    }
    if (type === 'reject') {
        return (safeVisit(config, "plugins." + JS_ERROR_MONITOR_PLUGIN_NAME + ".onunhandledrejection", function (target, property) { return target[property]; }) !== false);
    }
    return true;
};
var PrecollectPlugin = function (client, evMap) {
    var _a;
    if (evMap === void 0) { evMap = EV_METHOD_MAP; }
    var store = createStore(evMap);
    var evMethods = reverseMap(evMap);
    var storeOrConsume = getStoreOrConsume(client, store, evMap);
    // 继续消费后续预收集数据
    if (((_a = client.p) === null || _a === void 0 ? void 0 : _a.a) && 'observe' in client.p.a) {
        // 注册预收集消费回调
        client.p.a.observe(function (_a) {
            var _b = __read(_a, 5); _b[0]; var type = _b[1], data = _b[2], timestamp = _b[3], url = _b[4];
            var config = client.config();
            filterIfPluginDisabled(config, type) && storeOrConsume(type, data, timestamp, url);
        });
    }
    client.on('init', function () {
        var _a;
        // 消费已经收集的预收集数据
        var config = client.config();
        (_a = client.p) === null || _a === void 0 ? void 0 : _a.a.forEach(function (_a) {
            var _b = __read(_a, 5); _b[0]; var type = _b[1], data = _b[2], timestamp = _b[3], url = _b[4];
            filterIfPluginDisabled(config, type) && storeOrConsume(type, data, timestamp, url);
        });
        // 由于已经消费，置空所有预收集的数据
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        client.p && client.p.a && (client.p.a.length = 0);
        // 消费后续的预收集
        client.provide('precollect', function (type, data, timestamp, url) {
            if (timestamp === void 0) { timestamp = now(); }
            if (url === void 0) { url = location.href; }
            filterIfPluginDisabled(config, type) && storeOrConsume(type, data, timestamp, url);
        });
    });
    // consume stored data when provided
    client.on('provide', getConsumeStored(client, store, evMethods));
};

var buildSelfErrorEvent = function (ev) {
    var _a = __read(ev, 2), err = _a[0], extra = _a[1];
    return {
        ev_type: JS_ERROR_EV_TYPE,
        payload: {
            error: normalizeUnknownError(err),
            breadcrumbs: [],
            extra: extra || {},
        },
        extra: {
            bid: 'slardar_sdk',
        },
    };
};
var DEFAULT_OBSERVE_ERROR_RATE = 0.001;
var ObserveErrorPlugin = function (client, rate) {
    if (rate === void 0) { rate = DEFAULT_OBSERVE_ERROR_RATE; }
    var registry = getGlobalRegistry(getDefaultBrowser());
    // 如果没有获取到注册表 或者已经observe了，则不操作
    if (!registry)
        return;
    if (!registry.errors) {
        registry.errors = [];
    }
    if ('observe' in registry.errors)
        return;
    if (!isHitBySampleRate(rate))
        return;
    // 挂载observe方法
    registry.errors = toObservableArray(registry.errors);
    // 消费已挂载的错误
    registry.errors.forEach(function (e) {
        client.report(buildSelfErrorEvent(e));
    });
    // 注册observe回调用
    registry.errors.observe(function (e) {
        client.report(buildSelfErrorEvent(e));
    });
};

var MAX_RTT = 700;
/**
 * This plugin is bound with BrowserConfigManager, so it can't be extract into @sdk/web
 */
var TimeCalibrationPlugin = function (client) {
    var startTime;
    var hasCalibrated = false;
    client.on('init', function () {
        startTime = new Date().getTime();
        client.on('config', function () {
            var _a;
            var serverTime = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.serverTimestamp;
            if (isNaN(serverTime) || Number(serverTime) <= 0 || hasCalibrated) {
                return;
            }
            hasCalibrated = true;
            var endTime = new Date().getTime();
            var potential_rtt = endTime - startTime;
            if (potential_rtt < MAX_RTT && serverTime) {
                var diff_1 = serverTime - (endTime + startTime) / 2;
                // if diff in [-600000, 0], considered to be caused by cache
                if (!isNaN(diff_1) && (diff_1 > 0 || diff_1 < -600000)) {
                    client.on('beforeBuild', function (ev) {
                        var _a;
                        return __assign(__assign({}, ev), { extra: __assign(__assign({}, ((_a = ev.extra) !== null && _a !== void 0 ? _a : {})), { sdk_offset: diff_1 !== null && diff_1 !== void 0 ? diff_1 : 0 }) });
                    });
                }
            }
        });
    });
};

var addConfigToReportEvent = function (ev, config) {
    var extra = {};
    extra.bid = config.bid;
    extra.user_id = config.userId;
    extra.device_id = config.deviceId;
    extra.session_id = config.sessionId;
    extra.release = config.release;
    extra.env = config.env;
    return __assign(__assign({}, ev), { extra: __assign(__assign({}, extra), (ev.extra || {})) });
};
var InjectConfigPlugin = function (client) {
    client.on('beforeBuild', function (ev) {
        return addConfigToReportEvent(ev, client.config());
    });
};

var InjectQueryPlugin = function (client) {
    client.on('start', function () {
        var bid = client.config().bid;
        var sender = client.getSender();
        sender.setEndpoint(sender.getEndpoint() + ("?biz_id=" + bid));
    });
};

var getDefaultConfig = function (c) {
    var storageExpires = formatStorageExpires(c.storageExpires);
    var storageInfo = getDefaultUserIdAndDeviceId(c.bid, storageExpires);
    return {
        bid: '',
        pid: '',
        viewId: getViewId('_'),
        userId: storageInfo.userId,
        deviceId: storageInfo.deviceId,
        storageExpires: storageExpires,
        sessionId: getDefaultSessionId(),
        domain: REPORT_DOMAIN,
        pluginBundle: {
            name: 'commonMonitors',
            plugins: ['breadcrumb', 'jsError', 'performance', 'resourceError', 'resource'],
        },
        pluginPathPrefix: PLUGINS_LOAD_PREFIX,
        plugins: {
            ajax: { ignoreUrls: DEFAULT_IGNORE_PATHS },
            fetch: { ignoreUrls: DEFAULT_IGNORE_PATHS },
            breadcrumb: {},
            pageview: {},
            jsError: {},
            resource: {},
            resourceError: {},
            performance: {},
            tti: {},
            fmp: {},
            blankScreen: false,
            heatmap: false,
        },
        release: '',
        env: 'production',
        sample: DEFAULT_SAMPLE_CONFIG,
        transport: getXhrTransport(),
    };
};
var createMinimalBrowserClient = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.createSender, createSender = _c === void 0 ? function (config) {
        return createBrowserSender({
            size: DEFAULT_SENDER_SIZE,
            endpoint: getReportUrl(config.domain),
            transport: config.transport,
        });
    } : _c, _d = _b.builder, builder = _d === void 0 ? browserBuilder : _d, _e = _b.createDefaultConfig, createDefaultConfig = _e === void 0 ? getDefaultConfig : _e;
    var client = createClient({
        validateInitConfig: validateInitConfig,
        initConfigNormalizer: normalizeInitConfig,
        userConfigNormalizer: normalizeUserConfig,
        createSender: createSender,
        builder: builder,
        createDefaultConfig: createDefaultConfig,
        createConfigManager: createBrowserConfigManager,
    });
    ObserveErrorPlugin(client);
    ContextPlugin(client);
    var subjectMap = getGlobalRegistry(getDefaultBrowser());
    SubjectPlugin(client, subjectMap && subjectMap.subject);
    TimeCalibrationPlugin(client);
    InjectConfigPlugin(client);
    InjectEnvPlugin(client);
    InjectNetworkTypePlugin(client);
    InjectQueryPlugin(client);
    var commandClient = withCommandArray(client, captureCurrentContext, function (c, ctx, args) {
        return syncReportWithCapturedContext(c, ctx)(function () {
            var _a = __read(args), method = _a[0], others = _a.slice(1);
            client[method].apply(client, __spreadArray([], __read(others), false));
        });
    });
    // add plugin after with command array
    IntegrationPlugin(commandClient, register);
    return commandClient;
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
/* eslint-disable no-unused-labels */
var _a;
var PluginMap = (_a = {},
    _a[PAGEVIEW_MONITOR_PLUGIN_NAME] = PageviewMonitorPlugin,
    _a[AJAX_MONITOR_PLUGIN_NAME] = AjaxMonitorPlugin,
    _a[FETCH_MONITOR_PLUGIN_NAME] = FetchMonitorPlugin,
    _a[TTI_MONITOR_PLUGIN_NAME] = TTIMonitorPlugin,
    _a[FMP_MONITOR_PLUGIN_NAME] = FMPMonitorPlugin,
    _a);
var createBrowserClient = function (config) {
    if (config === void 0) { config = {}; }
    var client = createMinimalBrowserClient(config);
    SamplePlugin(client);
    PrecollectPlugin(client);
    CustomPlugin(client);
    // register and apply plugins
    Object.keys(PluginMap).forEach(function (pluginName) {
        register(pluginName, PluginMap[pluginName]);
        PluginMap[pluginName](client);
    });
    // Because loadPluginsOnPageLoad is dependent on page_load and client.on('init', ...), it must be called after the preset plugins are loaded to avoid early fetching independent plugins like 'pageview...'
    loadPluginsOnPageLoad(client);
    // allow creating other instances using the current instance
    client.provide('create', createBrowserClient);
    return client;
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var PRECOLLECT = 'precollect';
var BOTTOM_UP_TIME = 1000 * 60 * 5;
function npmPreCollect(window, client) {
    // precollect error
    if ('addEventListener' in window) {
        client.pcErr = function (ev) {
            ev = ev || window.event;
            var target = ev.target || ev.srcElement || {};
            if (target instanceof Element || target instanceof HTMLElement) {
                client(PRECOLLECT, 'st', {
                    tagName: target.tagName,
                    url: target.getAttribute('href') || target.getAttribute('src'),
                });
            }
            else {
                client(PRECOLLECT, 'err', ev.error);
            }
        };
        client.pcRej = function (ev) {
            ev = ev || window.event;
            client(PRECOLLECT, 'reject', ev.reason || (ev.detail && ev.detail.reason));
        };
        var tearDowns_1 = [];
        tearDowns_1.push(addListenerToWindow(window, 'error', client.pcErr, true));
        tearDowns_1.push(addListenerToWindow(window, 'unhandledrejection', client.pcRej, true));
        // bottom-up cleanup logic, if user not start client or load async script error
        setTimeout(function () {
            tearDowns_1.forEach(function (fn) { return fn(); });
        }, BOTTOM_UP_TIME);
    }
    // precollect performance
    if ('PerformanceObserver' in window && 'PerformanceLongTaskTiming' in window) {
        client.pp = { entries: [] };
        client.pp.observer = new PerformanceObserver(function (list) {
            client.pp.entries = client.pp.entries.concat(list.getEntries());
        });
        client.pp.observer.observe({
            entryTypes: ['longtask'],
        });
        // bottom-up cleanup logic, if user not start client or load async script error
        setTimeout(function () {
            client.pp.observer.disconnect();
        }, BOTTOM_UP_TIME);
    }
}

var browserClient = createBrowserClient();
var win = getDefaultBrowser();
win && npmPreCollect(win, browserClient);

exports.BATCH_REPORT_PATH = BATCH_REPORT_PATH;
exports.DEFAULT_IGNORE_PATHS = DEFAULT_IGNORE_PATHS;
exports.DEFAULT_SAMPLE_CONFIG = DEFAULT_SAMPLE_CONFIG;
exports.DEFAULT_SAMPLE_GRANULARITY = DEFAULT_SAMPLE_GRANULARITY;
exports.DEFAULT_SENDER_SIZE = DEFAULT_SENDER_SIZE;
exports.DEVICE_ID_COOKIE_NAME = DEVICE_ID_COOKIE_NAME;
exports.EV_METHOD_MAP = EV_METHOD_MAP;
exports.EXTRA_INDEPENDENT_PLUGINS = EXTRA_INDEPENDENT_PLUGINS;
exports.InjectConfigPlugin = InjectConfigPlugin;
exports.InjectEnvPlugin = InjectEnvPlugin;
exports.InjectQueryPlugin = InjectQueryPlugin;
exports.ObserveErrorPlugin = ObserveErrorPlugin;
exports.PLUGINS_LOAD_PREFIX = PLUGINS_LOAD_PREFIX;
exports.PluginMap = PluginMap;
exports.PrecollectPlugin = PrecollectPlugin;
exports.REPORT_DOMAIN = REPORT_DOMAIN;
exports.SDK_NAME = SDK_NAME;
exports.SDK_VERSION = SDK_VERSION;
exports.SETTINGS_DOMAIN = SETTINGS_DOMAIN;
exports.SETTINGS_PATH = SETTINGS_PATH;
exports.STORAGE_PREFIX = STORAGE_PREFIX;
exports.TimeCalibrationPlugin = TimeCalibrationPlugin;
exports.USER_ID_COOKIE_NAME = USER_ID_COOKIE_NAME;
exports.addConfigToReportEvent = addConfigToReportEvent;
exports.addEnvToSendEvent = addEnvToSendEvent;
exports.applyPlugin = applyPlugin;
exports.browserBuilder = browserBuilder;
exports.buildSelfErrorEvent = buildSelfErrorEvent;
exports.configHolder = configHolder;
exports.createBrowserClient = createBrowserClient;
exports.createBrowserConfigManager = createBrowserConfigManager;
exports.createMinimalBrowserClient = createMinimalBrowserClient;
exports.createStore = createStore;
exports['default'] = browserClient;
exports.doesPluginExistInRegistry = doesPluginExistInRegistry;
exports.filterIfPluginDisabled = filterIfPluginDisabled;
exports.getConsumeStored = getConsumeStored;
exports.getDefaultConfig = getDefaultConfig;
exports.getDefaultSessionId = getDefaultSessionId;
exports.getDefaultUserIdAndDeviceId = getDefaultUserIdAndDeviceId;
exports.getGlobalInstance = getGlobalInstance;
exports.getGlobalName = getGlobalName;
exports.getPluginFromRegistry = getPluginFromRegistry;
exports.getReportUrl = getReportUrl;
exports.getServerConfig = getServerConfig;
exports.getSettingsUrl = getSettingsUrl;
exports.getStorageKey = getStorageKey;
exports.getStoreOrConsume = getStoreOrConsume;
exports.glueCodeForStorageSecurity = glueCodeForStorageSecurity;
exports.hasSetStorageItem = hasSetStorageItem;
exports.loadCombinedPlugins = loadCombinedPlugins;
exports.loadIndependentPlugins = loadIndependentPlugins;
exports.loadNow = loadNow;
exports.loadPlugins = loadPlugins;
exports.loadPluginsOnPageLoad = loadPluginsOnPageLoad;
exports.mergeSampleConfig = mergeSampleConfig;
exports.normalizeInitConfig = normalizeInitConfig;
exports.normalizeUserConfig = normalizeUserConfig;
exports.parseServerConfig = parseServerConfig;
exports.register = register;
exports.reverseMap = reverseMap;
exports.setStorageUserIdAndDeviceId = setStorageUserIdAndDeviceId;
exports.toObservableArray = toObservableArray;
exports.validateInitConfig = validateInitConfig;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/web/euttp/index.cjs.js.map
