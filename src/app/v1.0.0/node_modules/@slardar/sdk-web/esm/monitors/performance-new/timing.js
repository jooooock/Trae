import { __read } from "tslib";
import { PERFORMANCE_TIMING_EV_TYPE } from '../../constants';
import { applyPerformance, getDefaultPerformance } from '../../utils';
import { applySendOnceAndTearDown } from './util';
export var TIMING_METRIC_NAME = "timing" /* timing */;
var getTiming = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), loadObserver = _b[0], unloadObserver = _b[1];
    var performance = getDefaultPerformance();
    var _c = __read(applyPerformance(performance), 3), getEntriesByType = _c[2];
    var wrapTiming = function (isBounced) {
        var timing = (performance && performance.timing) || undefined;
        var navigation = getEntriesByType('navigation')[0];
        return {
            ev_type: PERFORMANCE_TIMING_EV_TYPE,
            payload: {
                isBounced: isBounced,
                timing: timing,
                navigation_timing: navigation,
            },
        };
    };
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapTiming, report, tearDownGroup);
    tearDownGroup.push(unloadObserver[0](function () {
        sendOnceAndTearDown(true);
    }));
    var loadCallback = function () {
        sendOnceAndTearDown(false);
    };
    // loadObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return loadObserver[1](loadCallback); });
    loadObserver[0](loadCallback);
};
export var TIMING = [TIMING_METRIC_NAME, getTiming];//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/sdk-web/esm/monitors/performance-new/timing.js.map