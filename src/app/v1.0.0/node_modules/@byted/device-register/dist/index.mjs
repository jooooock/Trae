import systemInformation from 'systeminformation';
import os from 'os';
import Registry from 'winreg';
import crypto from 'crypto';
import { promisify } from 'util';
import child_process from 'child_process';
import fs from 'fs/promises';
import zlib from 'zlib';
import JSONBig from 'json-bigint';
import fetch from 'node-fetch';

function memoize(func) {
    let cache = null;
    return function () {
        if (cache === null) {
            cache = func();
        }
        return cache;
    };
}

async function getDiskSerial() {
    const disks = await systemInformation.diskLayout();
    if (disks.length > 0) {
        return disks[0].serialNum.toUpperCase().replace(/ /g, '_');
    }
    return '';
}
const memoizedGetDiskSerial = memoize(getDiskSerial);

async function getGraphicResolution() {
    const graphics = await systemInformation.graphics();
    if (graphics.displays?.length > 0) {
        // 注意这里与原版 C SDK 行为不一致，C SDK 使用了缩放后的分辨率，我们取实际分辨率
        const x = graphics.displays[0]?.resolutionX || 0;
        const y = graphics.displays[0]?.resolutionY || 0;
        return `${x}x${y}`;
    }
    return '0x0';
}
const memoizedGetGraphicResolution = memoize(getGraphicResolution);

var DrPlatform;
(function (DrPlatform) {
    DrPlatform[DrPlatform["UNKNOWN"] = 0] = "UNKNOWN";
    DrPlatform[DrPlatform["MAC"] = 1] = "MAC";
    DrPlatform[DrPlatform["WIN"] = 2] = "WIN";
    DrPlatform[DrPlatform["LINUX"] = 3] = "LINUX";
})(DrPlatform || (DrPlatform = {}));
const DR_TARGET_PLATFORM = (() => {
    if (typeof process === 'undefined') {
        return DrPlatform.UNKNOWN;
    }
    switch (process.platform) {
        case 'win32':
            return DrPlatform.WIN;
        case 'darwin':
            return DrPlatform.MAC;
        case 'linux':
        case 'freebsd':
        case 'openbsd':
        case 'netbsd':
        case 'freebsd':
        case 'aix':
            return DrPlatform.LINUX;
        default:
            return DrPlatform.UNKNOWN;
    }
})();
const OS_NAME = (() => {
    switch (DR_TARGET_PLATFORM) {
        case DrPlatform.WIN:
            return 'Windows';
        case DrPlatform.MAC:
            return 'MacOS';
        case DrPlatform.LINUX:
            return 'Linux';
        default:
            return '';
    }
})();
const DEVICE_PLATFORM = (() => {
    switch (DR_TARGET_PLATFORM) {
        case DrPlatform.WIN:
            return 'PC';
        case DrPlatform.MAC:
            return 'MacOS';
        case DrPlatform.LINUX:
            return 'PC';
        default:
            return '';
    }
})();

const AES_BLOCK_SIZE = 16;
var KeySize;
(function (KeySize) {
    KeySize[KeySize["AES128"] = 16] = "AES128";
    KeySize[KeySize["AES192"] = 14] = "AES192";
    KeySize[KeySize["AES256"] = 32] = "AES256";
})(KeySize || (KeySize = {}));

const AES_CBC_IV_SIZE = AES_BLOCK_SIZE;

const SHA512_HASH_SIZE = 64;
function sha512Calculate(buffer) {
    const hash = crypto.createHash('sha512');
    hash.update(buffer);
    return Uint8Array.from(hash.digest());
}

const KEY_SEED_SIZE = 32;
const KEY_SALT_SIZE = 64;
const APP_HEAD_SIZE = 6;
const APP_MAGIC_0 = 0x74;
const APP_MAGIC_1 = 0x63;
const APP_HEAD_VERSION_M = 0x5;
const APP_HEAD_3 = 0x10;
const APP_HEAD_VERSION_1 = 0x0;
const APP_HEAD_VERSION_2 = 0x0;
const PP_MAGIC_0 = 0x12;
const PP_MAGIC_1 = 0x39;
const PP_HEAD_VERSION_M = 0x20;
const PP_HEAD_3 = 0x20;
const PP_HEAD_VERSION_1 = 0x02;
const PP_HEAD_VERSION_2 = 0x03;
var EncryptVersion;
(function (EncryptVersion) {
    EncryptVersion[EncryptVersion["AES"] = 1] = "AES";
    EncryptVersion[EncryptVersion["AES_PRIVATE"] = 2] = "AES_PRIVATE";
    EncryptVersion[EncryptVersion["SS_V31"] = 3] = "SS_V31";
    EncryptVersion[EncryptVersion["SS_V32"] = 4] = "SS_V32";
    EncryptVersion[EncryptVersion["SS_V33"] = 5] = "SS_V33";
    EncryptVersion[EncryptVersion["SS_V2"] = 6] = "SS_V2";
    EncryptVersion[EncryptVersion["SS_V1"] = 7] = "SS_V1";
    EncryptVersion[EncryptVersion["UNKNOWN"] = 8] = "UNKNOWN";
})(EncryptVersion || (EncryptVersion = {}));
const p_salt_1 = new Uint8Array([
    0xbf, 0xc0, 0xd8, 0xfa, 0x7a, 0xf6, 0xdc, 0x61, 0x1f, 0xfe, 0x62, 0x1b, 0x08, 0x48, 0x47, 0xb0,
    0x87, 0x63, 0x60, 0x12, 0x7f, 0x65, 0xcb, 0x68, 0xd3, 0x66, 0xbf, 0x7d, 0x25, 0x48, 0x96, 0x9c,
    0x33, 0xe5, 0x79, 0x23, 0x11, 0x99, 0x8d, 0xb1, 0x6e, 0x83, 0x96, 0x80, 0xac, 0xff, 0xfe, 0x06,
    0x12, 0x8c, 0x37, 0x3e, 0xec, 0xf9, 0x87, 0x40, 0x87, 0x0c, 0x75, 0x04, 0x59, 0x95, 0xa8, 0xd1,
]);
const p_salt_2 = new Uint8Array([
    0xf6, 0xcc, 0x1a, 0xe8, 0xe8, 0x46, 0x81, 0x6d, 0xdf, 0x92, 0xa9, 0xf2, 0x17, 0xf1, 0x69, 0x91,
    0x32, 0xc4, 0xa5, 0x2a, 0xfe, 0x78, 0x03, 0x36, 0xf4, 0xcf, 0xd1, 0x55, 0x35, 0x06, 0x8a, 0x6a,
    0xaf, 0x94, 0x1f, 0xcc, 0xba, 0xba, 0xa5, 0xb6, 0x57, 0x8e, 0x31, 0x0a, 0x27, 0x6e, 0x1a, 0x9a,
    0x56, 0x38, 0xad, 0x7d, 0x12, 0x40, 0xc6, 0xe1, 0x63, 0x63, 0x53, 0x52, 0xbf, 0x86, 0x4c, 0xaa,
]);
/// The salt array
/// real salt[i] = salt_1[i] ^ salt_2[i]
const salt_1 = Uint8Array.from([
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25
]);
const salt_2 = Uint8Array.from([
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
]);
function applogSalt(saltLength, version = EncryptVersion.AES) {
    const slat = new Uint8Array(saltLength);
    if (version === EncryptVersion.AES_PRIVATE) {
        for (let i = 0; i < saltLength; i++) {
            slat[i] = p_salt_1[i] ^ p_salt_2[i];
        }
    }
    else if (version === EncryptVersion.AES) {
        for (let i = 0; i < saltLength; i++) {
            slat[i] = salt_1[i] ^ salt_2[i];
        }
    }
    return slat;
}
function applogAesKey(key, aesKeyLength, ivLength, version = EncryptVersion.AES) {
    const bufferLength = SHA512_HASH_SIZE + KEY_SALT_SIZE;
    const buffer = new Uint8Array(bufferLength);
    const keyHash = sha512Calculate(key);
    const salt = applogSalt(KEY_SALT_SIZE, version);
    buffer.set(keyHash, 0);
    buffer.set(salt, SHA512_HASH_SIZE);
    // 计算 buffer 的哈希值并覆盖 buffer 的开头部分
    const bufferHash = sha512Calculate(buffer);
    buffer.set(bufferHash, 0);
    const aesKey = buffer.slice(0, aesKeyLength);
    const iv = buffer.slice(aesKeyLength, aesKeyLength + ivLength);
    return { aesKey, iv };
}

function aesCbcDecryptWithKey(aesKey, iv, inBuffer) {
    if (inBuffer.length % AES_BLOCK_SIZE !== 0) {
        return new Uint8Array(0);
    }
    const decipher = crypto.createDecipheriv('aes-128-cbc', aesKey, iv);
    const decrypted = Buffer.concat([decipher.update(Buffer.from(inBuffer)), decipher.final()]);
    return Uint8Array.from(decrypted);
}

function applogCheckHeader(data) {
    if (data[2] === PP_HEAD_VERSION_M &&
        data[3] === PP_HEAD_3 &&
        data[4] === PP_HEAD_VERSION_1 &&
        data[5] === PP_HEAD_VERSION_2 &&
        data[0] === PP_MAGIC_0 &&
        data[1] === PP_MAGIC_1) {
        return EncryptVersion.AES_PRIVATE;
    }
    if (data[0] !== APP_MAGIC_0 || data[1] !== APP_MAGIC_1) {
        return EncryptVersion.UNKNOWN;
    }
    if (data[2] === APP_HEAD_VERSION_M &&
        data[3] === APP_HEAD_3 &&
        data[4] === APP_HEAD_VERSION_1 &&
        data[5] === APP_HEAD_VERSION_2) {
        return EncryptVersion.AES;
    }
    if (data[2] === 0x03 && data[3] < 0x16) {
        if (data[4] === 0 && data[5] === 0x01) {
            return EncryptVersion.SS_V31;
        }
        if (data[4] === 0 && data[5] === 0x02) {
            return EncryptVersion.SS_V32;
        }
        if (data[4] === 0 && data[5] === 0x03) {
            return EncryptVersion.SS_V33;
        }
    }
    if (data[2] === 0x02 && data[3] < 0x16) {
        return EncryptVersion.SS_V2;
    }
    if (data[2] === 0x01 && data[3] < 0x16) {
        return EncryptVersion.SS_V1;
    }
    return EncryptVersion.UNKNOWN;
}
function applogGetHeaderKey(data, keyLength) {
    const version = applogCheckHeader(data);
    if (version !== EncryptVersion.AES && version !== EncryptVersion.AES_PRIVATE) {
        return {
            version: EncryptVersion.UNKNOWN,
            key: new Uint8Array(0),
        };
    }
    return {
        version,
        key: data.slice(APP_HEAD_SIZE, APP_HEAD_SIZE + keyLength),
    };
}
function applogDecrypt(dataIn) {
    const keyLength = KEY_SEED_SIZE;
    const { version, key } = applogGetHeaderKey(dataIn, keyLength);
    if (key.length !== KEY_SEED_SIZE) {
        return new Uint8Array(0);
    }
    const aesKeyLength = KeySize.AES128;
    const ivLength = AES_CBC_IV_SIZE;
    const { aesKey, iv } = applogAesKey(key, aesKeyLength, ivLength, version);
    const bufferOut = aesCbcDecryptWithKey(aesKey, iv, dataIn.slice(KEY_SEED_SIZE + APP_HEAD_SIZE));
    if (bufferOut.length > 0) {
        /// hash check
        const hash = sha512Calculate(bufferOut.slice(SHA512_HASH_SIZE));
        if (new Array(SHA512_HASH_SIZE).every((_, index) => hash[index] === bufferOut[index])) {
            return bufferOut.slice(SHA512_HASH_SIZE);
        }
        else {
            return new Uint8Array(0);
        }
    }
    else {
        return new Uint8Array(0);
    }
}

function safeBigInt(value, fallback) {
    if (value === undefined) {
        return fallback;
    }
    try {
        return BigInt(value);
    }
    catch (error) {
        return fallback;
    }
}
class DrCacheInfo {
    static parse(text) {
        const formats = text.split(DrCacheInfo.SPLITTER).filter(Boolean);
        const parts = {};
        for (let i = 0; i < formats.length - 1; i++) {
            const current = formats[i];
            const next = formats[i + 1];
            if (current.length > 1 && current.endsWith('=') && !next.endsWith('=')) {
                const key = formats[i].slice(0, -1);
                const value = key === 'uuid' ? next : next.replace(/\D.*/, ''); // 如果不是文本的话，扔掉匹配到的非数字和之后的字符，增加健壮性
                parts[key] = value;
            }
        }
        return new DrCacheInfo(parseInt(parts.version, 10) || 0, safeBigInt(parts.dr_did, 0n), safeBigInt(parts.iid, 0n), parts.active_success === '1', parts.activated === '1', parts.uuid || '');
    }
    static stringify(value) {
        return `version=${value.version}dr_did=${value.deviceId}iid=${value.installId}active_success=${value.isActiveSuccess ? 1 : 0}activated=${value.isActivated ? 1 : 0}uuid=${value.uuid}`;
    }
    constructor(version, did, iid, isActiveSuccess, isActivated, uuid) {
        this.version = version;
        this.deviceId = did;
        this.installId = iid;
        this.isActiveSuccess = isActiveSuccess;
        this.isActivated = isActivated;
        this.uuid = uuid;
    }
    isValidVersion() {
        // 主线分支是 3，支持 looki 的分支是 4，虽然不支持 looki id，但可以解析 looki 的 cache
        return this.version === DrCacheInfo.DR_CACHE_VERSION || this.version === 4;
    }
    toString() {
        return DrCacheInfo.stringify(this);
    }
}
DrCacheInfo.DR_CACHE_VERSION = 3;
DrCacheInfo.SPLITTER = /(version=|dr_did=|iid=|active_success=|activated=|uuid=|looki_did=|row_did=)/;

function aesCbcEncryptWithKey(aesKey, iv, inBuffer) {
    const cipher = crypto.createCipheriv('aes-128-cbc', aesKey, iv);
    const encrypted = Buffer.concat([cipher.update(Buffer.from(inBuffer)), cipher.final()]);
    return Uint8Array.from(encrypted);
}

function applogKeyGenerate(keyLength) {
    const key = new Uint8Array(keyLength);
    for (let i = 0; i < keyLength; i++) {
        key[i] = Math.floor(Math.random() * 256);
    }
    return key;
}
function applogHeaderKey(key) {
    const bufferOut = new Uint8Array(key.length + APP_HEAD_SIZE);
    bufferOut[0] = APP_MAGIC_0;
    bufferOut[1] = APP_MAGIC_1;
    bufferOut[2] = APP_HEAD_VERSION_M;
    bufferOut[3] = APP_HEAD_3;
    bufferOut[4] = APP_HEAD_VERSION_1;
    bufferOut[5] = APP_HEAD_VERSION_2;
    bufferOut.set(key, APP_HEAD_SIZE);
    return bufferOut;
}
function applogDecoratedInternal(dataIn) {
    const aesKeyLength = KeySize.AES128; // size_t
    const ivLength = AES_CBC_IV_SIZE; // size_t
    const key = applogKeyGenerate(KEY_SEED_SIZE);
    const { aesKey, iv } = applogAesKey(key, aesKeyLength, ivLength);
    const encryptData = new Uint8Array(SHA512_HASH_SIZE + dataIn.length);
    /// hash check
    const hash = sha512Calculate(dataIn);
    encryptData.set(hash, 0);
    /// original data
    encryptData.set(dataIn, SHA512_HASH_SIZE);
    const header = applogHeaderKey(key);
    const body = aesCbcEncryptWithKey(aesKey, iv, encryptData);
    if (body.length > 0) {
        const bufferOut = new Uint8Array(header.length + body.length);
        bufferOut.set(header, 0);
        bufferOut.set(body, header.length);
        return bufferOut;
    }
    return new Uint8Array(0);
}
function applogDecorated(dataIn) {
    return applogDecoratedInternal(dataIn);
}

// type RegValueType = string | string[] | number | bigint | Buffer | undefined;
// REG_SZ -> value
// REG_MULTI_SZ -> value.split(',')
// REG_EXPAND_SZ -> value
// REG_DWORD -> parseInt(value, 16)
// REG_QWORD -> BigInt(value)
// REG_BINARY -> Buffer.from(value, 'hex')
// REG_NONE -> undefined
// only support buffer
async function readValueFromReg(regPath, keyName) {
    const reg = new Registry({
        hive: Registry.HKCU, // HKEY_CURRENT_USER
        key: regPath,
    });
    return new Promise((resolve) => {
        reg.get(keyName, (err, result) => {
            if (err || result.type !== Registry.REG_BINARY) {
                resolve(undefined);
            }
            else {
                resolve(Buffer.from(result.value, 'hex'));
            }
        });
    });
}
// only support buffer
async function writeValueToReg(regPath, keyName, value) {
    const reg = new Registry({
        hive: Registry.HKCU, // HKEY_CURRENT_USER
        key: regPath,
    });
    return new Promise((resolve, reject) => {
        reg.set(keyName, Registry.REG_BINARY, value.toString('hex'), (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(undefined);
            }
        });
    });
}
const DR_CACHE_REG_KEY = 'Info';
async function drCacheLoad$3(cachePath) {
    const buffer = await readValueFromReg(cachePath, DR_CACHE_REG_KEY);
    if (buffer) {
        const decData = applogDecrypt(new Uint8Array(buffer));
        const data = new TextDecoder('utf-8').decode(decData);
        if (data.startsWith('version')) {
            const drCacheInfo = DrCacheInfo.parse(data);
            if (drCacheInfo.isValidVersion()) {
                return drCacheInfo;
            }
        }
    }
    return undefined;
}
async function drCacheStore$3(drCacheInfo, cachePath) {
    if (!drCacheInfo.isValidVersion()) {
        throw new Error('drCacheInfo version is not current version');
    }
    const buffer = new Uint8Array(Buffer.from(drCacheInfo.toString(), 'utf-8'));
    const encData = applogDecorated(buffer);
    await writeValueToReg(cachePath, DR_CACHE_REG_KEY, Buffer.from(encData));
}

const DEFAULT_MAC_ADDRESS = '02:00:00:00:00:00';
const invalidMacAddresses = new Set([
    '00:00:00:00:00:00',
    'ff:ff:ff:ff:ff:ff',
    'ac:de:48:00:11:22'
]);
function validateMacAddress(candidate) {
    const tempCandidate = candidate.replace(/\-/g, ':').toLowerCase();
    return !invalidMacAddresses.has(tempCandidate);
}
function getMacAddressOnMac() {
    const preferredNICs = ['en0', 'en1', 'en2', 'llw0'];
    const ifaces = os.networkInterfaces();
    for (const preferredNIC of preferredNICs) {
        const networkInterface = ifaces[preferredNIC];
        if (networkInterface) {
            for (const { mac, internal } of networkInterface) {
                if (!internal && validateMacAddress(mac)) {
                    return mac;
                }
            }
        }
    }
    return DEFAULT_MAC_ADDRESS; // 都没有就算了
}
async function getMacAddressOnWindows() {
    const cachePath = '\\SOFTWARE\\DeviceInfo\\MacAddr';
    const cache = await readValueFromReg(cachePath, 'mac');
    if (cache) {
        return cache.toString('utf-8');
    }
    const ifaces = os.networkInterfaces();
    // TODO 需要优化 windows 上取 mac 逻辑
    for (const name in ifaces) {
        const networkInterface = ifaces[name];
        if (networkInterface) {
            for (const { mac, internal } of networkInterface) {
                if (!internal && validateMacAddress(mac)) {
                    writeValueToReg(cachePath, 'mac', Buffer.from(mac, 'utf-8'));
                    return mac;
                }
            }
        }
    }
    return DEFAULT_MAC_ADDRESS; // 都没有就算了
}
function getMacAddressOnLinux() {
    const preferredNICs = ['wlan0', 'eth0', 'eth1', 'eth2'];
    const ifaces = os.networkInterfaces();
    for (const preferredNIC of preferredNICs) {
        const networkInterface = ifaces[preferredNIC];
        if (networkInterface) {
            for (const { mac, internal } of networkInterface) {
                if (!internal && validateMacAddress(mac)) {
                    return mac;
                }
            }
        }
    }
    return DEFAULT_MAC_ADDRESS; // 都没有就算了
}
async function getMacAddress() {
    switch (DR_TARGET_PLATFORM) {
        case DrPlatform.MAC:
            return getMacAddressOnMac();
        case DrPlatform.WIN:
            return await getMacAddressOnWindows();
        case DrPlatform.LINUX:
            return getMacAddressOnLinux();
    }
    return DEFAULT_MAC_ADDRESS;
}
const memoizedGetMacAddress = memoize(getMacAddress);

async function getOsRelease() {
    if (DR_TARGET_PLATFORM === DrPlatform.WIN) {
        return os.release(); // windows 上是相同的
    }
    // posix 系统上 os release 与 kernel version 不等同
    const osInfo = await systemInformation.osInfo();
    return osInfo.release;
}
const memoizedGetOsRelease = memoize(getOsRelease);

function getTimeZoneInfo() {
    const date = new Date();
    const offset = -date.getTimezoneOffset();
    return {
        timeZone: offset / 60,
        tzOffset: offset * 60,
        tzName: Intl.DateTimeFormat().resolvedOptions().timeZone.toLocaleLowerCase(),
    };
}

const SDK_VERSION_MAJOR = 0;
const SDK_VERSION_MINOR = 0;
const SDK_VERSION_PATCH = 2;
const SDK_VERSION_CODE = SDK_VERSION_MAJOR * 100 + SDK_VERSION_MINOR * 10 + SDK_VERSION_PATCH;
const SDK_VERSION_NAME = `${SDK_VERSION_MAJOR}.${SDK_VERSION_MINOR}.${SDK_VERSION_PATCH}`;

const execAsync = promisify(child_process.exec);
function cbParseKeychainLoad(result) {
    const b64DecodeData = new Uint8Array(Buffer.from(result, 'base64'));
    const decData = applogDecrypt(b64DecodeData);
    const data = new TextDecoder('utf-8').decode(decData);
    if (data.startsWith('version')) {
        const drCacheInfo = DrCacheInfo.parse(data);
        if (drCacheInfo.isValidVersion()) {
            return drCacheInfo;
        }
    }
    return undefined;
}
async function drCacheLoad$2(name) {
    const command = `security -i find-generic-password -l 'BDdr_${name}' -a Info -w`;
    try {
        const { stdout } = await execAsync(command);
        return cbParseKeychainLoad(stdout.toString());
    }
    catch (error) {
        return undefined;
    }
}
async function drCacheStore$2(drCacheInfo, name) {
    if (!drCacheInfo.isValidVersion()) {
        throw new Error('drCacheInfo version is not current version');
    }
    const buffer = new Uint8Array(Buffer.from(drCacheInfo.toString(), 'utf-8'));
    const encData = applogDecorated(buffer);
    const b64OutStr = Buffer.from(encData).toString('base64');
    const command = `security add-generic-password -s 'BDdr_${name}' -a Info -U -w ${b64OutStr}`;
    await execAsync(command);
}

async function drCacheLoad$1(cachePath) {
    if (!cachePath) {
        return undefined;
    }
    try {
        await fs.access(cachePath);
    }
    catch {
        return undefined;
    }
    const buffer = new Uint8Array(await fs.readFile(cachePath));
    const decData = applogDecrypt(buffer);
    const data = new TextDecoder('utf-8').decode(decData);
    if (data.startsWith('version')) {
        const drCacheInfo = DrCacheInfo.parse(data);
        if (drCacheInfo.isValidVersion()) {
            return drCacheInfo;
        }
    }
    return undefined;
}
async function drCacheStore$1(drCacheInfo, cachePath) {
    if (!drCacheInfo.isValidVersion() || !cachePath) {
        throw new Error('drCacheInfo version is not current version');
    }
    const buffer = new Uint8Array(Buffer.from(drCacheInfo.toString(), 'utf-8'));
    const encData = applogDecorated(buffer);
    await fs.writeFile(cachePath, encData);
}

async function drCacheLoad(name, cachePath) {
    if (DR_TARGET_PLATFORM === DrPlatform.MAC && name) {
        return await drCacheLoad$2(name);
    }
    else if (DR_TARGET_PLATFORM === DrPlatform.WIN && cachePath) {
        return await drCacheLoad$3(cachePath);
    }
    else if (DR_TARGET_PLATFORM === DrPlatform.LINUX && cachePath) {
        return await drCacheLoad$1(cachePath);
    }
    return undefined;
}
async function drCacheStore(drCacheInfo, name, cachePath) {
    if (DR_TARGET_PLATFORM === DrPlatform.MAC && name) {
        await drCacheStore$2(drCacheInfo, name);
    }
    else if (DR_TARGET_PLATFORM === DrPlatform.WIN && cachePath) {
        await drCacheStore$3(drCacheInfo, cachePath);
    }
    else if (DR_TARGET_PLATFORM === DrPlatform.LINUX && cachePath) {
        await drCacheStore$1(drCacheInfo, cachePath);
    }
}

async function getSystem() {
    const system = await systemInformation.system();
    return {
        model: system.model.replace(' ', '_'),
        uuid: system.uuid.toUpperCase(),
        sku: system.sku,
        serial: system.serial,
    };
}
const memoizedGetSystem = memoize(getSystem);
getSystem();

class DeviceRegister {
    // appInfo结构如下:
    // {
    //     "id": 677332,
    //     "channel": "stable",
    //     "package": "com.trae.app",
    //     "name": "Trae",
    //     "version": "1.0.0",
    //     "region": "US",
    //     "language": "zh-cn"
    // }
    // config结构如下:
    // {
    //     "cachePath": "",
    //     "force": false,
    //     "newUserMode": false,
    //     "registryUrl": "https://log.byteoversea.com/service/2/desktop/device_register/",
    //     "activeUrl": "https://log.byteoversea.com/service/2/app_alert_check/",
    //     "logger": {}
    // }
    constructor(appInfo, config) {
        debugger
        this.appInfo = appInfo;
        this.force = config.force ?? false;
        this.newUserMode = config.newUserMode ?? false;
        this.cachePath = config.cachePath;
        this.registryUrl = config.registryUrl;
        this.activeUrl = config.activeUrl;
        this.logger = config.logger ?? {};
        if (this.logger?.debug) {
            this.logger?.debug?.(`[DeviceRegister] (constructor) start with appInfo: ${JSON.stringify(appInfo)}, config: ${JSON.stringify(config)}`);
        }
        if (this.logger?.trace) {
            this.logger?.trace?.(`[DeviceRegister] (constructor) parsed config: force: ${this.force}, newUserMode: ${this.newUserMode}, cachePath: ${this.cachePath}, registryUrl: ${this.registryUrl}, activeUrl: ${this.activeUrl}`);
        }
    }
    setForce(force) {
        this.force = force;
    }
    setNewUserMode(newUserMode) {
        this.newUserMode = newUserMode;
    }
    setCachePath(cachePath) {
        this.cachePath = cachePath;
    }
    async loadCache() {
        if (this.logger?.trace) {
            this.logger?.trace?.(`[DeviceRegister] (loadCache) with force: ${this.force}, newUserMode: ${this.newUserMode}, cachePath: ${this.cachePath}`);
        }
        const uuid = DR_TARGET_PLATFORM === DrPlatform.MAC
          ? (await memoizedGetSystem()).uuid
          : (await memoizedGetDiskSerial());
        if (this.logger?.trace) {
            this.logger?.trace?.(`[DeviceRegister] (loadCache) uuid: ${uuid}`);
        }
        const cache = await drCacheLoad(this.appInfo.name, this.cachePath);
        if (cache) {
            if (this.logger?.trace) {
                this.logger?.trace?.(`[DeviceRegister] (loadCache) get cahce.`);
            }
            if (cache.deviceId > 0n && cache.installId !== 0n) {
                if (cache.uuid === uuid) {
                    this.logger?.info && this.logger?.info?.(`[DeviceRegister] (loadCache) cache uuid match, return cache ${cache.toString()}.`);
                    return cache;
                }
            }
        }
    }
    async storeCache(cache) {
        this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (storeCache): ${cache.toString()}`);
        await drCacheStore(cache, this.appInfo.name, this.cachePath);
        this.logger?.info && this.logger?.info?.(`[DeviceRegister] (storeCache) done.`);
    }
    async genRegistryRequestUrl() {
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (genRegistryRequestUrl) start.`);
        const [system, osRelease, diskSerial] = await Promise.all([
            memoizedGetSystem(),
            memoizedGetOsRelease(),
            DR_TARGET_PLATFORM === DrPlatform.MAC ? Promise.resolve('') : memoizedGetDiskSerial(),
        ]);
        const params = {
            aid: this.appInfo.id,
            channel: this.appInfo.channel,
            os: OS_NAME,
            os_version: osRelease,
            device_platform: DEVICE_PLATFORM,
            version_code: this.appInfo.version,
        };
        if (DR_TARGET_PLATFORM === DrPlatform.MAC) {
            params['macos_uuid'] = system.uuid;
            params['macos_serial'] = system.serial;
        }
        else {
            params['pc_uuid'] = system.uuid;
            params['pc_serial'] = diskSerial;
        }
        const url = `${this.registryUrl}?${Object.keys(params).map(key => `${key}=${params[key]}`).join('&')}`;
        this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (genRegistryRequestUrl) url: ${url}`);
        return url;
    }
    async genRegistryRequestBody() {
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (genRegistryRequestBody) start.`);
        const timeZoneInfo = getTimeZoneInfo();
        const [macAddress, osRelease, system, resolution, diskSerial,] = await Promise.all([
            memoizedGetMacAddress(),
            memoizedGetOsRelease(),
            memoizedGetSystem(),
            memoizedGetGraphicResolution(),
            DR_TARGET_PLATFORM === DrPlatform.MAC ? Promise.resolve('') : memoizedGetDiskSerial(),
        ]);
        const header = {
            device_id: 0,
            install_id: 0,
            os: OS_NAME,
            device_platform: DEVICE_PLATFORM,
            sdk_version: SDK_VERSION_NAME,
            sdk_version_code: SDK_VERSION_CODE,
            aid: this.appInfo.id,
            mc: macAddress,
            channel: this.appInfo.channel,
            package: this.appInfo.package,
            language: this.appInfo.language,
            app_version: this.appInfo.version,
            os_version: osRelease,
            device_model: system.model,
            time_zone: timeZoneInfo.timeZone,
            tz_name: timeZoneInfo.tzName,
            tz_offset: timeZoneInfo.tzOffset,
            resolution,
            app_region: this.appInfo.region,
            app_language: this.appInfo.language,
            display_name: this.appInfo.name,
            new_user_mode: Number(this.newUserMode),
        };
        if (DR_TARGET_PLATFORM === DrPlatform.MAC) {
            header['macos_uuid'] = system.uuid;
            header['macos_serial'] = system.serial;
            header['sku'] = system.sku;
        }
        else {
            header['pc_uuid'] = system.uuid;
            header['pc_serial'] = diskSerial;
        }
        const body = {
            header,
            _gen_time: Math.floor(Date.now() / 1000),
            magic_tag: 'ss_app_log',
        };
        this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (genRegistryRequestBody) header: ${JSON.stringify(header)}, body: ${JSON.stringify(body)}`);
        return body;
    }
    async genActiveRequestUrl(did, iid) {
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (genActiveRequestUrl) start.`);
        const [system, diskSerial] = await Promise.all([
            memoizedGetSystem(),
            DR_TARGET_PLATFORM === DrPlatform.MAC ? Promise.resolve('') : memoizedGetDiskSerial(),
        ]);
        const params = {
            aid: this.appInfo.id,
            app_name: this.appInfo.name,
            version_code: this.appInfo.version,
            channel: this.appInfo.channel,
            os: OS_NAME,
            device_platform: DEVICE_PLATFORM,
            device_id: did.toString(),
            iid: iid.toString(),
        };
        if (DR_TARGET_PLATFORM === DrPlatform.MAC) {
            params['macos_uuid'] = system.uuid;
            params['macos_serial'] = system.serial;
        }
        else {
            params['pc_uuid'] = system.uuid;
            params['pc_serial'] = diskSerial;
        }
        const url = `${this.activeUrl}?${Object.keys(params).map(key => `${key}=${params[key]}`).join('&')}`;
        this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (genActiveRequestUrl) url: ${url}`);
        return url;
    }
    async getDidFromCache() {
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (getDidFromCache) start.`);
        const cache = await this.loadCache();
        this.logger?.info && this.logger?.info?.(`[DeviceRegister] (getDidFromCache) cache: ${cache?.toString()}`);
        return {
            deviceId: cache?.deviceId ?? 0n,
            installId: cache?.installId ?? 0n,
        };
    }
    async registry() {
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (registry) start.`);
        const [url, body] = await Promise.all([
            this.genRegistryRequestUrl(),
            this.genRegistryRequestBody(),
        ]);
        const json = JSON.stringify(body);
        this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (registry) url: ${url}, body: ${json}`);
        const buf = new Uint8Array(await zlib.gzipSync(Buffer.from(json, 'utf-8')));
        const decData = applogDecorated(buf);
        if (decData.length === 0) {
            this.logger?.error && this.logger?.error?.(`[DeviceRegister] (registry) applogDecorated failed.`);
            return { deviceId: 0n, installId: 0n };
        }
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (registry) decData success.`);
        try {
            const res = await fetch(url, {
                method: 'POST',
                body: Buffer.from(decData),
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'TTNetwork PC',
                },
            });
            this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (registry) res: ${res.status}`);
            if (res.status === 200) {
                const text = await res.text();
                const result = JSONBig.parse(text);
                this.logger?.info && this.logger?.info?.(`[DeviceRegister] (registry) result: ${text}`);
                return {
                    deviceId: BigInt(result.device_id ?? 0),
                    installId: BigInt(result.install_id ?? 0),
                    isNewUser: !!result.new_user,
                };
            }
        }
        catch (e) {
            this.logger?.error && this.logger?.error?.(`[DeviceRegister] (registry) failed: ${e}`);
        }
        this.logger?.error && this.logger?.error?.(`[DeviceRegister] (registry) failed.`);
        return { deviceId: 0n, installId: 0n, isNewUser: false };
    }
    async active(deviceId, installId) {
        this.logger?.trace && this.logger?.trace?.(`[DeviceRegister] (active) start.`);
        const url = await this.genActiveRequestUrl(deviceId, installId);
        this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (active) url: ${url}`);
        try {
            const res = await fetch(url, { method: 'POST', headers: { 'User-Agent': 'TTNetwork PC' } });
            this.logger?.debug && this.logger?.debug?.(`[DeviceRegister] (active) res: ${res.status}`);
            if (res.status === 200) {
                const result = await res.json();
                this.logger?.info && this.logger?.info?.(`[DeviceRegister] (active) result: ${JSON.stringify(result)}`);
                const isActiveSuccess = result?.message === 'success';
                const isActivated = !!result?.data?.is_activated;
                return {
                    isActiveSuccess,
                    isActivated,
                };
            }
        }
        catch (e) {
            this.logger?.error && this.logger?.error?.(`[DeviceRegister] (active) failed: ${e}`);
        }
        this.logger?.error && this.logger?.error?.(`[DeviceRegister] (active) failed.`);
        return {
            isActiveSuccess: false,
            isActivated: false,
        };
    }
    async registryAndActive() {
        if (this.logger?.trace) {
            this.logger?.trace?.(`[DeviceRegister] (registryAndActive) start.`);
        }
        if (!this.force && !this.newUserMode) {
            const cache = await this.loadCache();
            if (cache) {
                if (this.logger?.debug) {
                    this.logger?.debug?.(`[DeviceRegister] (registryAndActive) cache: ${cache.toString()}`);
                }
                return {
                    deviceId: cache.deviceId,
                    installId: cache.installId,
                    isActiveSuccess: false,
                    isActivated: false,
                };
            }
        }

        if (this.logger?.trace) {
            this.logger?.trace?.(`[DeviceRegister] (registryAndActive) registry start.`);
        }
        const registryResult = await this.registry();
        if (this.logger?.debug) {
            this.logger?.debug?.(`[DeviceRegister] (registryAndActive) registry result: did: ${registryResult.deviceId}, iid: ${registryResult.installId}`);
        }

        if (registryResult.deviceId === 0n || registryResult.installId === 0n) {
            if (this.logger?.error) {
                this.logger?.error?.(`[DeviceRegister] (registryAndActive) registry failed.`);
            }
            return {
                deviceId: registryResult.deviceId,
                installId: registryResult.installId,
                isActiveSuccess: false,
                isActivated: false,
            };
        }

        if (this.logger?.trace) {
            this.logger?.trace?.(`[DeviceRegister] (registryAndActive) active start.`);
        }
        if (!this.newUserMode && !registryResult.isNewUser) {
            return {
                deviceId: registryResult.deviceId,
                installId: registryResult.installId,
                isActiveSuccess: true,
                isActivated: true,
            };
        }

        const activeResult = await this.active(registryResult.deviceId, registryResult.installId);
        if (this.logger?.debug) {
            this.logger?.debug?.(`[DeviceRegister] (registryAndActive) active result: isActiveSuccess: ${activeResult.isActiveSuccess}, isActivated: ${activeResult.isActivated}`);
        }
        if (activeResult.isActiveSuccess) {
            const cache = new DrCacheInfo(
              DrCacheInfo.DR_CACHE_VERSION,
              registryResult.deviceId,
              registryResult.installId,
              activeResult.isActiveSuccess,
              activeResult.isActivated,
              DR_TARGET_PLATFORM === DrPlatform.MAC
                ? (await memoizedGetSystem()).uuid
                : (await memoizedGetDiskSerial())
            );
            this.storeCache(cache);
            if (this.logger?.debug) {
                this.logger?.debug?.(`[DeviceRegister] (registryAndActive) store cache: ${cache.toString()}`);
            }
        } else {
            if (this.logger?.error) {
                this.logger?.error?.(`[DeviceRegister] (registryAndActive) active failed.`);
            }
        }
        const result = {
            deviceId: registryResult.deviceId,
            installId: registryResult.installId,
            isActiveSuccess: activeResult.isActiveSuccess,
            isActivated: activeResult.isActivated,
        };
        if (this.logger?.debug) {
            this.logger?.debug?.(`[DeviceRegister] (registryAndActive) result: ${JSONBig.stringify(result)}`);
        }
        return result;
    }
}

export { DeviceRegister };
