"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.httpPlugin = exports.HttpController = void 0;
const got_1 = __importDefault(require("got"));
const events_1 = require("events");
const path_1 = require("path");
const constants_1 = require("./constants");
const utility_1 = require("./utility");
function tryJSONParseString(str) {
    try {
        return JSON.parse(str || '{}');
    }
    catch (_a) {
        return {};
    }
}
class HttpController extends events_1.EventEmitter {
    constructor(options, channelDomain) {
        super();
        this.options = options;
        this.channelDomain = channelDomain;
        this.pending = false;
        this.queue = [];
        this.name = 'http';
    }
    get concurrent() {
        return this.options.concurrent || 10;
    }
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pending)
                return;
            this.pending = true;
            const tasks = this.queue.splice(0, this.concurrent);
            const jobs = [];
            const { event_verify_url, retry, timeout } = this.options;
            let hasSucceed = false;
            /**
             * pending status must be updated no matter this turn of flush succeed or not
             */
            try {
                if (tasks.length) {
                    if (event_verify_url) {
                        this.pluginContext.logger.trace('verify %d events with event verify url: %s', tasks.length);
                        const byteio = (0, got_1.default)(event_verify_url, {
                            method: 'POST',
                            retry: retry,
                            json: tasks.map(({ event }) => (Object.assign(Object.assign({}, event), { verbose: 1 }))),
                            timeout: timeout,
                        })
                            .then((res) => {
                            this.pluginContext.logger.trace('verify events %o result %s', tasks.map((t) => t.id), res.body);
                        })
                            .catch((error) => {
                            const stack = error === null || error === void 0 ? void 0 : error.stack;
                            const message = error === null || error === void 0 ? void 0 : error.message;
                            if (stack && message) {
                                this.pluginContext.logger.error('network error: %s $o', message, stack);
                            }
                            else {
                                this.pluginContext.logger.error('network error: %o', error);
                            }
                        });
                        jobs.push(byteio);
                    }
                    this.pluginContext.logger.trace('with channel domain %s', this.channelDomain);
                    const mario = (0, got_1.default)((0, path_1.join)(this.channelDomain, constants_1.pathMap.REPORT_PATH), {
                        method: 'POST',
                        retry: retry,
                        json: tasks.map(({ event }) => (Object.assign(Object.assign({}, event), { verbose: 1 }))),
                        timeout: timeout,
                    })
                        .then((res) => {
                        hasSucceed = true;
                        this.pluginContext.logger.trace('sent events %o result %s', tasks.map(({ id }) => id), res.body);
                    })
                        .catch((error) => {
                        const stack = error === null || error === void 0 ? void 0 : error.stack;
                        const message = error === null || error === void 0 ? void 0 : error.message;
                        if (stack && message) {
                            this.pluginContext.logger.trace('network error: %s %o', message, stack);
                        }
                        else {
                            this.pluginContext.logger.trace('network error: %o', error);
                        }
                    });
                    jobs.push(mario);
                }
                yield Promise.all(jobs).finally(() => {
                    var _a, _b;
                    for (const { event } of tasks) {
                        this.emit('end', {
                            event,
                            hasSucceed,
                        });
                        (_b = (_a = this.options).onEnd) === null || _b === void 0 ? void 0 : _b.call(_a, event, hasSucceed);
                    }
                });
            }
            finally {
                this.pending = false;
            }
            if (this.queue.length > 0) {
                this.flush();
            }
            else {
                this.pluginContext.logger.trace('queue drained, last sent %d', tasks.length);
                this.emit('drain', {
                    lastEvents: tasks,
                    hasSucceed,
                });
            }
        });
    }
    install(context) {
        this.pluginContext = context;
    }
    onSendEvent({ event, id }) {
        const { events: batch } = event, others = __rest(event, ["events"]);
        const groupedEvents = (0, utility_1.divide)(batch, 50).map((group) => ({
            id,
            event: Object.assign(Object.assign({}, others), { events: group }),
        }));
        this.queue.push(...groupedEvents);
        this.flush();
    }
    getVar(name, options) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const { header, user } = this.pluginContext.metaInfo;
            const abRequestConfig = Object.assign(Object.assign(Object.assign(Object.assign({ aid: header.app_id }, header), user), options === null || options === void 0 ? void 0 : options.extraProperties), { custom: Object.assign(Object.assign({}, tryJSONParseString(header.custom)), options === null || options === void 0 ? void 0 : options.extraProperties.custom) });
            this.pluginContext.logger.trace('abRequest config: %o', abRequestConfig);
            const result = yield this.abRequest(abRequestConfig, {
                timeout: options === null || options === void 0 ? void 0 : options.timeout,
            });
            if ((_a = result[name]) === null || _a === void 0 ? void 0 : _a.vid) {
                const { user_unique_id, uuid } = (_b = options === null || options === void 0 ? void 0 : options.extraProperties) !== null && _b !== void 0 ? _b : {};
                this.pluginContext.logger.trace('abtest_exposure name: %s, vid: %s, val: %o', name, result[name].vid, result[name].val);
                this.pluginContext.collect([
                    {
                        extra: {
                            ab_sdk_version: String(result[name].vid),
                        },
                        name: 'abtest_exposure',
                        params: {},
                    },
                ], {
                    user: {
                        user_unique_id: user_unique_id || uuid,
                    },
                    header: {
                        ab_sdk_version: String(result[name].vid),
                    },
                });
            }
            return (_d = (_c = result[name]) === null || _c === void 0 ? void 0 : _c.val) !== null && _d !== void 0 ? _d : options === null || options === void 0 ? void 0 : options.defaultValue;
        });
    }
    getAllVars(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { header, user } = this.pluginContext.metaInfo;
            const abRequestConfig = Object.assign(Object.assign(Object.assign(Object.assign({ aid: header.app_id }, header), user), options === null || options === void 0 ? void 0 : options.extraProperties), { custom: Object.assign(Object.assign({}, tryJSONParseString(header.custom)), options === null || options === void 0 ? void 0 : options.extraProperties.custom) });
            this.pluginContext.logger.trace('abRequest config: %o', abRequestConfig);
            return this.abRequest(abRequestConfig, {
                timeout: options === null || options === void 0 ? void 0 : options.timeout,
            });
        });
    }
    abRequest(header, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let url;
            try {
                const parser = new URL(this.options.abServiceOrigin);
                parser.pathname = constants_1.pathMap.ABConfigPath;
                url = parser.toJSON();
                this.pluginContext.logger.trace('request abtest config with url %s', url);
            }
            catch (error) {
                this.pluginContext.logger.error('invalid service origin %O', error);
            }
            if (!url)
                return {};
            const resultPromise = (0, got_1.default)(url, {
                method: 'POST',
                json: {
                    header,
                },
                responseType: 'json',
                timeout: options.timeout,
            }).then((res) => {
                var _a;
                this.pluginContext.logger.trace('abRequest response %O', res.body);
                return (_a = res.body) === null || _a === void 0 ? void 0 : _a.data;
            });
            const result = yield resultPromise.catch((error) => {
                this.pluginContext.logger.error('unexpected_error_when_request_ab_ata');
                this.pluginContext.logger.error(error);
            });
            return result || {};
        });
    }
}
exports.HttpController = HttpController;
function httpPlugin(options) {
    const channelDomain = options.channel_domain || (options.channel && constants_1.ReportURL[options.channel]);
    if (!channelDomain) {
        throw new Error(`plugin 'http': channel or channel_domain can't be both undefined`);
    }
    return new HttpController(options, channelDomain);
}
exports.httpPlugin = httpPlugin;
