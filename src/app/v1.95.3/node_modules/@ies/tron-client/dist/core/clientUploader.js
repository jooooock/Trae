"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TronClientUploader = void 0;
const clientBase_1 = require("./clientBase");
const logger_1 = __importDefault(require("./logger"));
const lodash_1 = require("lodash");
const api_1 = __importStar(require("./api"));
const child_process_1 = require("child_process");
const UPLOAD_MANIFEST_API = '/api/sdk/build_callback';
// 上传 Manifest
class TronClientUploader extends clientBase_1.TronClientBase {
    constructor(config) {
        config.external = false; // "上传 Manifest" 仅支持内网
        config.region = config.region === 'boe' ? 'boe' : 'cn'; // "上传 Manifest" 对于线上仅支持上传到 CN 然后自动同步到其他地区
        super(config);
        (0, api_1.setToken)(config.token);
        this.branch = this.getBranch();
        this.buildId = this.getbuildId();
    }
    /**
     * get current gitlab runner pipeline id
     */
    getbuildId() {
        return Number(process.env.CI_PIPELINE_ID) || 0;
    }
    /**
     * get current working branch
     */
    getBranch() {
        return process.env.CI_COMMIT_REF_NAME || (0, child_process_1.execSync)('git symbolic-ref --short -q HEAD').toString().trim();
    }
    /**
     * check for update
     */
    checkForUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            return api_1.default
                .get(`${clientBase_1.CHECK_API}?pid=${this.pid}&uid=&branch=${this.branch}&buildId=`)
                .then(res => {
                logger_1.default.info(`update info: ${JSON.stringify(res, null, 2)}`);
                return res;
            });
        });
    }
    /**
     * upload manifests to tron
     * @param manifests upload manifest
     */
    uploadManifest(manifests) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isRunnerEnv()) {
                logger_1.default.info('current in gitlab runner build process');
                this._isManifestValid(manifests);
                logger_1.default.info('manifest is valid');
                manifests = this._addBranch(manifests);
                yield api_1.default.post(UPLOAD_MANIFEST_API, {
                    pid: this.pid,
                    buildId: this.getbuildId(),
                    jobId: process.env.CI_JOB_ID,
                    manifest: manifests,
                });
                logger_1.default.info('upload manifest success, payload is: ', JSON.stringify({
                    pid: this.pid,
                    buildId: this.getbuildId(),
                    jobId: process.env.CI_JOB_ID,
                    manifest: manifests,
                }, null, 2));
                return Promise.resolve();
            }
            else {
                const message = 'not in runner environment, abort upload process';
                throw new Error(message);
            }
        });
    }
    /**
     * add branch in manifests
     * @param manifests upload manifest
     */
    _addBranch(manifests) {
        for (const [arch, manifest] of Object.entries(manifests)) {
            if (manifest.branch) {
                continue;
            }
            else {
                manifest.branch = this.getBranch();
                logger_1.default.info(`add branch to ${arch} manifest`);
            }
        }
        return manifests;
    }
    /**
     * detect if current is in gitlab runner environment
     */
    _isRunnerEnv() {
        if (process.env.CI_PIPELINE_ID && process.env.CI_JOB_ID) {
            return true;
        }
        return false;
    }
    /**
     * validate manifest is effective
     * @param manifests upload manifest
     */
    _isManifestValid(manifests) {
        Object.keys(manifests).forEach(key => {
            if (!['win32', 'darwin', 'linux'].includes(key)) {
                throw new Error('custom manifest key is not valid');
            }
        });
        Object.values(manifests).forEach((value) => {
            if (!value.version) {
                throw new Error('verson must be configured');
            }
            else if (!(0, lodash_1.isString)(value.version)) {
                throw new Error('verson must be a string');
            }
            if (!value.branch && value.branch !== undefined) {
                throw new Error('if branch is empty, sdk will add branch for you, or leave it to empty');
            }
            else if (value.branch && !(0, lodash_1.isString)(value.branch)) {
                throw new Error('branch must be a string');
            }
            if (!value.urls) {
                throw new Error('urls must be configured');
            }
            else {
                if (!(0, lodash_1.isArray)(value.urls)) {
                    throw new Error('urls must be an array');
                }
                if ((0, lodash_1.isEmpty)(value.urls)) {
                    throw new Error('urls is empty thus not allowed to upload');
                }
            }
            if (value.branch && !(0, lodash_1.isString)(value.branch)) {
                throw new Error('branch must exists and is a string');
            }
            if (value.extra && !(0, lodash_1.isObject)(value.extra)) {
                throw new Error('extra must be an object');
            }
        });
    }
}
exports.TronClientUploader = TronClientUploader;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@ies/tron-client/dist/core/clientUploader.js.map