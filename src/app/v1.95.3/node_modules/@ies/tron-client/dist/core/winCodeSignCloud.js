"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCloudSignPath = exports.traverseSignFileCloud = exports.signFileCloud = exports.sleep = void 0;
const path_1 = require("path");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const logger_1 = __importDefault(require("./logger"));
const utils_1 = require("./utils");
const tea_1 = require("./tea");
const os_1 = require("os");
const signtool = process.env.TRON_CLOUD_SIGN_TOOL_PATH || (0, path_1.join)('C:', 'workspace', 'signature', 'SignTool.exe');
const interval = 5000; // 5s
const PLATFORM = (0, os_1.platform)();
const USER = process.env.USER || '';
// 云签要用的证书 ID 和 Token，Tron TCC 会配置一个默认公用的 Douyin 证书，业务也可在构建页面自定义证书
const CERT_ID = process.env.TRON_CLOUD_SIGN_CERT_ID || '';
const CERT_TOKEN = process.env.TRON_CLOUD_SIGN_CERT_TOKEN || '';
const DONT_SKIP_SIGNED_FILE = process.env.TRON_CLOUD_SIGN_DONT_SKIP_SIGNED_FILE || '';
const TIME_STAMP_SERVER = 'http://timestamp.digicert.com';
const TIME_STAMP_BYTEDANCE = 'http://timestamp.bytedance.net';
const sleep = (time) => new Promise(resolve => {
    setTimeout(() => {
        resolve();
    }, time);
});
exports.sleep = sleep;
const verifySignature = (path) => {
    var _a, _b;
    try {
        const out = (0, child_process_1.execSync)(`Get-AuthenticodeSignature "${path}" | ConvertTo-Json -Compress`, {
            shell: 'powershell.exe',
        }).toString();
        const signatrueInfo = JSON.parse(out);
        if (signatrueInfo.Status === 0 && ((_b = (_a = signatrueInfo.SignerCertificate) === null || _a === void 0 ? void 0 : _a.Thumbprint) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            // logger.log(`code sign validate passed: ${path}`);
            return {
                isVerified: true,
                message: 'success',
            };
        }
        const message = `verify signature not passed, reason: ${signatrueInfo.StatusMessage}`;
        return {
            isVerified: false,
            message,
        };
    }
    catch (e) {
        const message = `system poweshell.exe call failed for reason: ${(e === null || e === void 0 ? void 0 : e.message) || e}`;
        return {
            isVerified: true,
            message,
        };
    }
};
const executeSignJob = (configuration, retryCount = 0) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.default.log('executeSignJob configuration:', JSON.stringify(configuration));
    const { timeStampServer } = configuration.options || {};
    const timestamp = Date.now();
    try {
        const out = (0, child_process_1.execSync)(`${signtool} sign -bcsu "https://code-signing.byted.org" -bcsci ${CERT_ID} -bcsat ${CERT_TOKEN} -tr ${timeStampServer || (retryCount === 1 ? TIME_STAMP_BYTEDANCE : TIME_STAMP_SERVER)} "${configuration.path}"`, { encoding: 'utf-8' });
        if (out && /Exception\:|Error\:/.test(out)) {
            throw out;
        }
        yield (0, tea_1.sendEvent)('sign_success_rate', {
            result: 'success',
            signType: 'cloud',
            message: '',
            platform: PLATFORM,
            system: USER,
            createdTime: timestamp,
        });
        return out;
    }
    catch (e) {
        retryCount++;
        if (retryCount <= 1) {
            logger_1.default.log(`code sign failed for reason: ${e}, will retry 5s later`);
            yield (0, exports.sleep)(interval);
            return yield executeSignJob(configuration, retryCount);
        }
        yield (0, tea_1.sendEvent)('sign_success_rate', {
            result: 'failed',
            signType: 'cloud',
            message: JSON.stringify((e === null || e === void 0 ? void 0 : e.output) || {}),
            platform: PLATFORM,
            system: USER,
            createdTime: timestamp,
        });
        yield (0, exports.sleep)(interval);
        throw e;
    }
});
const signFileCloud = (configuration) => __awaiter(void 0, void 0, void 0, function* () {
    if (!(0, fs_1.existsSync)(configuration.path)) {
        logger_1.default.error(`code sign path ${configuration.path} not exists`);
        process.exit(1);
    }
    if (!configuration.options) {
        configuration.options = {};
    }
    // if already signed, skip sign for preformance improvement
    if (!DONT_SKIP_SIGNED_FILE && (0, path_1.extname)(configuration.path) !== '.exe') {
        const { isVerified } = verifySignature(configuration.path);
        if (isVerified) {
            logger_1.default.info('file already signed, skip sign', configuration.path);
            return;
        }
    }
    try {
        const out = yield executeSignJob(configuration);
        logger_1.default.log(out.slice(0, 1).toLowerCase() + out.slice(1));
        if (process.env.TRON_SKIP_CODESIGN_VERIFY !== 'true') {
            try {
                const patterns = (JSON.parse(process.env.TRON_SKIP_CONESIGN_VERIFY_PATTERNS || '[]') || []).map(pattern => new RegExp(pattern));
                const matchedPattern = patterns.find(pattern => pattern.test(configuration.path));
                if (!matchedPattern) {
                    const { isVerified, message } = verifySignature(configuration.path);
                    if (!isVerified) {
                        logger_1.default.error(message);
                        throw new Error(message);
                    }
                    logger_1.default.log(`code sign validate passed: ${configuration.path}`);
                }
                else {
                    logger_1.default.log(`verify signature skiped for file ${configuration.path}, matched pattern ${matchedPattern}`);
                }
            }
            catch (e) {
                logger_1.default.error('`TRON_SKIP_CONESIGN_VERIFY_FILES` is not valid, please check if it is an array of RegExp pattern string');
            }
        }
        else {
            logger_1.default.log(`verify signature skiped for file ${configuration.path}`);
        }
    }
    catch (e) {
        logger_1.default.error(e);
        logger_1.default.error(`code sign for file ${configuration.path} failed`);
        process.exit(1);
    }
});
exports.signFileCloud = signFileCloud;
const examinePath = (path) => {
    if (!(0, fs_1.existsSync)(path)) {
        return 'PATH_NOT_EXISTS';
    }
    else if (!(0, fs_1.statSync)(path).isDirectory()) {
        return 'PATH_IS_NOT_DIR';
    }
    else {
        return 'PASSED';
    }
};
/**
 * traverse sign file in a folder
 * @param dirPath path to scan and sign
 * @param exts file ext name array
 * @param configuration other code sign meta
 */
function traverseSignFileCloud(dirPath, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = examinePath(dirPath);
        switch (result) {
            case 'PASSED':
                break;
            case 'PATH_NOT_EXISTS':
                logger_1.default.error('code sign path path not exists');
                process.exit(1);
            case 'PATH_IS_NOT_DIR':
                logger_1.default.error('code sign path path not exists');
                process.exit(1);
            default:
                break;
        }
        if (configuration.deep === undefined) {
            configuration.deep = true;
        }
        const paths = (0, fs_1.readdirSync)(dirPath);
        logger_1.default.log(`code sign scaning in ${dirPath}`);
        for (const path of paths) {
            const subPath = (0, path_1.resolve)(dirPath, path);
            const info = (0, fs_1.statSync)(subPath);
            if (info.isDirectory() && configuration.deep) {
                yield traverseSignFileCloud(subPath, configuration);
            }
            else {
                const ext = (0, path_1.extname)(subPath);
                if (configuration.exts.includes(ext)) {
                    yield (0, exports.signFileCloud)({
                        path: subPath,
                        options: configuration,
                    });
                }
            }
        }
    });
}
exports.traverseSignFileCloud = traverseSignFileCloud;
(0, utils_1.checkSDKVersion)();
const getCloudSignPath = () => __filename;
exports.getCloudSignPath = getCloudSignPath;
exports.default = exports.signFileCloud;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@ies/tron-client/dist/core/winCodeSignCloud.js.map