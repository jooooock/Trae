"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignPath = exports.traverseSignFile = exports.signFile = void 0;
const path_1 = require("path");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const logger_1 = __importDefault(require("./logger"));
const utils_1 = require("./utils");
const signtool = process.env.TRON_SIGN_TOOL || (0, path_1.join)('C:', 'workspace', 'signature', 'wosigncodecmd.exe');
// 【待废弃】Windows EV 证书的 SHA1 及 密码。
// 现在都推荐用新的云签了：https://bytedance.larkoffice.com/wiki/BNDSw39ERiIXfvkGjpBcKqvAnPd
const certificateSha1 = process.env.TRON_SIGN_CERT || '';
const password = process.env.TRON_SIGN_PASSWORD || '';
const lock = process.env.TRON_SIGN_LOCK || (0, path_1.join)('C:', 'workspace', 'signature', 'tron-sign.lock');
const timeout = 3 * 60 * 1000; // 180s then consider lock file is expired
const interval = 5000; // 5s
let prevContent = '';
let examineCount = 0;
const examineIfLockFileSealed = () => {
    let currentContent = '';
    try {
        currentContent = (0, fs_1.readFileSync)(lock).toString();
        prevContent = prevContent || currentContent;
    }
    catch (e) {
        // this means lock file doesnt exits, reset
        logger_1.default.info('no signing job detect, will continue signing now');
        examineCount = 0;
        prevContent = '';
        return true;
    }
    if (prevContent !== currentContent) {
        examineCount = 0;
        prevContent = '';
        logger_1.default.info('another signing job detected, queueing...');
    }
    else {
        examineCount++;
        if (examineCount > timeout / interval) {
            logger_1.default.info(`has checked for ${examineCount} times, sealed signing job deteced, will remove it then continue signing now`);
            // reset
            examineCount = 0;
            prevContent = '';
            return true;
        }
        logger_1.default.info(`has checked for ${examineCount} times, will check again ${interval / 1000}s later`);
    }
    return false;
};
const verifySignature = (path, sha1) => {
    var _a, _b;
    try {
        const out = (0, child_process_1.execSync)(`Get-AuthenticodeSignature "${path}" | ConvertTo-Json -Compress`, {
            shell: 'powershell.exe',
        }).toString();
        const signatrueInfo = JSON.parse(out);
        if (signatrueInfo.Status === 0) {
            if (((_b = (_a = signatrueInfo.SignerCertificate) === null || _a === void 0 ? void 0 : _a.Thumbprint) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === sha1.toLowerCase()) {
                logger_1.default.log(`code sign validate passed: ${path}`);
                return null;
            }
            else {
                return 'verify signature not passed, reason: certificateSha1 of the binary is not same as project certificateSha1';
            }
        }
        return `verify signature not passed, reason: ${signatrueInfo.StatusMessage}`;
    }
    catch (e) {
        return `system poweshell.exe call failed for reason: ${(e === null || e === void 0 ? void 0 : e.message) || e}`;
    }
};
const waitForSignThenMakeLockFile = (path) => {
    if (!(0, fs_1.existsSync)(lock)) {
        (0, fs_1.writeFileSync)(lock, path);
    }
    else {
        logger_1.default.info(`current has other signing job, will check for job queue ${interval / 1000}s later`);
        const sealed = examineIfLockFileSealed();
        if (sealed) {
            logger_1.default.info(`last sign has exists for ${timeout / 60 / 1000}min${timeout / 60 / 1000 > 1 ? 's' : ''}, will remove it then continue code sign`);
            (0, fs_1.writeFileSync)(lock, path);
        }
        else {
            (0, utils_1.sleep)(interval);
            return waitForSignThenMakeLockFile(path);
        }
    }
};
const removeLockFile = () => {
    logger_1.default.warn('terminate signal reviced, will stop signing now');
    try {
        (0, fs_1.unlinkSync)(lock);
    }
    catch (e) { }
};
const addLockFileListener = () => {
    process.on('SIGHUP', removeLockFile);
    process.on('SIGTERM', removeLockFile);
    process.on('SIGQUIT', removeLockFile);
};
const removeLockFileListener = () => {
    process.off('SIGHUP', removeLockFile);
    process.off('SIGTERM', removeLockFile);
    process.off('SIGQUIT', removeLockFile);
};
const executeSignJob = (configuration, retryCount = 0) => {
    try {
        const out = (0, child_process_1.execSync)(`${signtool} sign /dig ${configuration.hash} /tp ${configuration.options.certificateSha1 || certificateSha1} /p ${configuration.options.password || password} /hide /tr ${configuration.options.timeStampServer} /file "${configuration.path}"`, { encoding: 'utf-8' });
        if (out && /Exception\:|Error\:/.test(out)) {
            throw out;
        }
        return out;
    }
    catch (e) {
        retryCount++;
        if (retryCount <= 1) {
            logger_1.default.log(`code sign failed for reason: ${e}, will retry 5s later`);
            (0, utils_1.sleep)(interval);
            return executeSignJob(configuration, retryCount);
        }
        throw e;
    }
};
/**
 * @deprecated please use signFileCloud
 */
const signFile = (configuration) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.default.warn(`\n\n\n\n\n ----------------
  【废弃提示】方法 signFile 已经废弃，请使用新方法 signFileCloud 替代，
  详情见文档：https://bytedance.larkoffice.com/wiki/BNDSw39ERiIXfvkGjpBcKqvAnPd
  ---------------- \n\n`);
    if (!(0, fs_1.existsSync)(configuration.path)) {
        logger_1.default.error(`code sign path ${configuration.path} not exists`);
        process.exit(1);
    }
    waitForSignThenMakeLockFile(configuration.path);
    addLockFileListener();
    try {
        const out = executeSignJob(configuration);
        logger_1.default.log(out.slice(0, 1).toLowerCase() + out.slice(1));
        if (process.env.TRON_SKIP_CODESIGN_VERIFY !== 'true') {
            try {
                const patterns = (JSON.parse(process.env.TRON_SKIP_CONESIGN_VERIFY_PATTERNS || '[]') || []).map(pattern => new RegExp(pattern));
                const matchedPattern = patterns.find(pattern => pattern.test(configuration.path));
                if (!matchedPattern) {
                    const reason = verifySignature(configuration.path, configuration.options.certificateSha1 || certificateSha1);
                    if (reason) {
                        logger_1.default.error(reason);
                        throw new Error(reason);
                    }
                }
                else {
                    logger_1.default.log(`verify signature skiped for file ${configuration.path}, matched pattern ${matchedPattern}`);
                }
            }
            catch (e) {
                logger_1.default.error('`TRON_SKIP_CONESIGN_VERIFY_FILES` is not valid, please check if it is an array of RegExp pattern string');
            }
        }
        else {
            logger_1.default.log(`verify signature skiped for file ${configuration.path}`);
        }
    }
    catch (e) {
        logger_1.default.error(e);
        logger_1.default.error(`code sign for file ${configuration.path} failed`);
        (0, fs_1.unlinkSync)(lock);
        removeLockFileListener();
        process.exit(1);
    }
    try {
        (0, fs_1.unlinkSync)(lock);
    }
    catch (e) {
        logger_1.default.error('other signing job detected');
    }
    removeLockFileListener();
});
exports.signFile = signFile;
const examinePath = (path) => {
    if (!(0, fs_1.existsSync)(path)) {
        return 'PATH_NOT_EXISTS';
    }
    else if (!(0, fs_1.statSync)(path).isDirectory()) {
        return 'PATH_IS_NOT_DIR';
    }
    else {
        return 'PASSED';
    }
};
/**
 * traverse sign file in a folder
 * @param dirPath path to scan and sign
 * @param exts file ext name array
 * @param configuration other code sign meta
 * @deprecated please use signFileCloud
 */
const traverseSignFile = (dirPath, configuration) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.default.warn(`\n\n\n\n\n ----------------
  【废弃提示】方法 traverseSignFile 已经废弃，请使用新方法 traverseSignFileCloud 替代，
  详情见文档：https://bytedance.larkoffice.com/wiki/BNDSw39ERiIXfvkGjpBcKqvAnPd
  ---------------- \n\n`);
    const result = examinePath(dirPath);
    switch (result) {
        case 'PASSED':
            break;
        case 'PATH_NOT_EXISTS':
            logger_1.default.error('code sign path path not exists');
            process.exit(1);
        case 'PATH_IS_NOT_DIR':
            logger_1.default.error('code sign path path not exists');
            process.exit(1);
        default:
            break;
    }
    if (configuration.deep === undefined) {
        configuration.deep = true;
    }
    const paths = (0, fs_1.readdirSync)(dirPath);
    logger_1.default.log(`code sign scaning in ${dirPath}`);
    for (const path of paths) {
        const subPath = (0, path_1.resolve)(dirPath, path);
        const info = (0, fs_1.statSync)(subPath);
        if (info.isDirectory() && configuration.deep) {
            yield (0, exports.traverseSignFile)(subPath, configuration);
        }
        else {
            const ext = (0, path_1.extname)(subPath);
            if (configuration.exts.includes(ext)) {
                yield (0, exports.signFile)({
                    path: subPath,
                    hash: configuration.hash,
                    options: configuration,
                });
            }
        }
    }
});
exports.traverseSignFile = traverseSignFile;
(0, utils_1.checkSDKVersion)();
/**
 * @deprecated please use getCloudSignPath
 */
const getSignPath = () => {
    logger_1.default.warn(`\n\n\n\n\n ----------------
  【废弃提示】方法 getSignPath 已经废弃，请使用新方法 getCloudSignPath 替代，
  详情见文档：https://bytedance.larkoffice.com/wiki/BNDSw39ERiIXfvkGjpBcKqvAnPd
  ---------------- \n\n`);
    return __filename;
};
exports.getSignPath = getSignPath;
exports.default = exports.signFile;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@ies/tron-client/dist/core/winCodeSignLocal.js.map