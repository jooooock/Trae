'use strict';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var StarlingError = /** @class */ (function (_super) {
    __extends(StarlingError, _super);
    function StarlingError(code, message, originError) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.message = message;
        _this.originError = originError;
        _this.name = 'StarlingError';
        _this.code = code;
        _this.message = message;
        _this.originError = originError;
        if (Error.captureStackTrace)
            Error.captureStackTrace(_this, _this.constructor);
        return _this;
    }
    return StarlingError;
}(Error));
var MAP_ERROR = {
    CHECK_VERSION_ERROR: {
        ERROR_CODE: 100,
        ERROR_MESSAGE: 'Request for checkVersion failed!'
    },
    LOAD_TEXT_ERROR: {
        ERROR_CODE: 101,
        ERROR_MESSAGE: 'Request for loadText failed!'
    },
    TEST_ERROR: {
        ERROR_CODE: 102,
        ERROR_MESSAGE: 'Request for loadTestText failed!'
    },
    API_PARAMS_ERROR: {
        ERROR_CODE: 103,
        ERROR_MESSAGE: 'Request failed, confirm your apiKey and namespace is correct'
    },
    PARAMS_ERROR: {
        ERROR_CODE: 110,
        ERROR_MESSAGE: 'Check your params, parameter apiKey, namespace and zoneHost is required!'
    },
    PARAMS_ERROR_2: {
        ERROR_CODE: 111,
        ERROR_MESSAGE: 'Check your params, parameter request and store is required!'
    },
    CACHE_ERROR: {
        ERROR_CODE: 112,
        ERROR_MESSAGE: 'Cache error!'
    },
    VERSION_NOT_FOUND: {
        ERROR_CODE: 120,
        ERROR_MESSAGE: 'Version is not found, please check your param [version]!'
    },
    OTHER_ERROR: {
        ERROR_CODE: 200,
        ERROR_MESSAGE: 'Something Wrong!'
    }
};

var defaultOptions = {
    zone: 'CN',
    locale: 'zh',
    timeout: 15000,
    test: false,
    mode: 'normal',
    format: 'merged',
    lazyUpdate: false,
    fallbackLang: ['zh'],
    tracker: function () { },
    cache: true,
    cdn: ''
};
function createOptions(options) {
    options = Object.assign({}, defaultOptions, options);
    var namespace = options.namespace, apiKey = options.apiKey;
    var request = options.request, store = options.store, zoneHost = options.zoneHost, test = options.test, cdn = options.cdn;
    if (test)
        options.mode = 'test';
    options.namespace = namespace = namespace
        ? Array.isArray(namespace)
            ? namespace
            : [namespace]
        : [];
    options.apiKey = apiKey = apiKey || options.api_key;
    if (!request || (!cdn && !store)) {
        var _a = MAP_ERROR.PARAMS_ERROR_2, ERROR_CODE = _a.ERROR_CODE, ERROR_MESSAGE = _a.ERROR_MESSAGE;
        throw new StarlingError(ERROR_CODE, ERROR_MESSAGE, null);
    }
    if (!apiKey || !namespace.length || (!cdn && !zoneHost)) {
        var _b = MAP_ERROR.PARAMS_ERROR, ERROR_CODE = _b.ERROR_CODE, ERROR_MESSAGE = _b.ERROR_MESSAGE;
        throw new StarlingError(ERROR_CODE, ERROR_MESSAGE, null);
    }
    return options;
}

var Request = /** @class */ (function () {
    function Request(options) {
        this.options = options;
        this.options = options;
    }
    Request.prototype.getText = function (namespace, localVersion) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._request(namespace, localVersion)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    Request.prototype.getTexts = function (namespaces) {
        var _this = this;
        return Promise.all(namespaces.map(function (_a) {
            var ns = _a[0], version = _a[1];
            return _this.getText(ns, version);
        }));
    };
    Request.prototype._request = function (namespace, localVersion) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, getReleaseVersion, cdn, fallbackLang, locale, releaseVersion, url, _b, request, timeout, res, localesToTry, errors, _c, ERROR_CODE_1, ERROR_MESSAGE_1, _i, localesToTry_1, loc, res_1, _d, status_1, message_1, error_1, _e, status, message, _f, ERROR_CODE_2, ERROR_MESSAGE_2, _g, ERROR_CODE, ERROR_MESSAGE;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        _a = this.options, getReleaseVersion = _a.getReleaseVersion, cdn = _a.cdn, fallbackLang = _a.fallbackLang, locale = _a.locale;
                        releaseVersion = getReleaseVersion(namespace);
                        if (namespace && releaseVersion && localVersion) {
                            return [2 /*return*/, {}];
                        }
                        url = this.getUrl(namespace, localVersion);
                        _b = this.options, request = _b.request, timeout = _b.timeout;
                        if (!cdn) return [3 /*break*/, 7];
                        localesToTry = __spreadArrays([locale], fallbackLang);
                        errors = [] // 用于记录每次请求的错误
                        ;
                        _c = MAP_ERROR.LOAD_TEXT_ERROR, ERROR_CODE_1 = _c.ERROR_CODE, ERROR_MESSAGE_1 = _c.ERROR_MESSAGE;
                        _i = 0, localesToTry_1 = localesToTry;
                        _h.label = 1;
                    case 1:
                        if (!(_i < localesToTry_1.length)) return [3 /*break*/, 6];
                        loc = localesToTry_1[_i];
                        _h.label = 2;
                    case 2:
                        _h.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, request(this.getUrl(namespace, localVersion, loc), { timeout: timeout })];
                    case 3:
                        res_1 = _h.sent();
                        _d = res_1.data, status_1 = _d.status, message_1 = _d.message;
                        if (+status_1 === 200)
                            return [2 /*return*/, this._mapResponse(message_1)];
                        throw new StarlingError(ERROR_CODE_1, ERROR_MESSAGE_1);
                    case 4:
                        error_1 = _h.sent();
                        errors.push(error_1);
                        // 如果全部失败，则向上抛错
                        if (errors.length === localesToTry.length) {
                            return [2 /*return*/, this._mapResponse({ data: {}, updated: false })];
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 9];
                    case 7: return [4 /*yield*/, request(url, { timeout: timeout })];
                    case 8:
                        res = _h.sent();
                        _h.label = 9;
                    case 9:
                        _e = res.data, status = _e.status, message = _e.message;
                        // 200 表示成功，1000 表示参数异常
                        if (+status === 200)
                            return [2 /*return*/, this._mapResponse(message)
                                // 1001 releaseVersion 不存在
                            ];
                        // 1001 releaseVersion 不存在
                        if (+status === 1001) {
                            _f = MAP_ERROR.VERSION_NOT_FOUND, ERROR_CODE_2 = _f.ERROR_CODE, ERROR_MESSAGE_2 = _f.ERROR_MESSAGE;
                            throw new StarlingError(ERROR_CODE_2, ERROR_MESSAGE_2);
                        }
                        _g = MAP_ERROR.API_PARAMS_ERROR, ERROR_CODE = _g.ERROR_CODE, ERROR_MESSAGE = _g.ERROR_MESSAGE;
                        throw new StarlingError(ERROR_CODE, ERROR_MESSAGE);
                }
            });
        });
    };
    Request.prototype.getUrl = function (namespace, localVersion, fallbackLocale) {
        var _a = this.options, apiKey = _a.apiKey, locale = _a.locale, fallbackLang = _a.fallbackLang, zoneHost = _a.zoneHost, mode = _a.mode, getReleaseVersion = _a.getReleaseVersion, cdn = _a.cdn;
        var langs = [locale].concat(fallbackLang);
        var url = zoneHost + "/check_and_get_text/" + apiKey + "/" + mode + "/" + namespace + "?lang=" + langs;
        var releaseVersion = getReleaseVersion(namespace);
        if (releaseVersion) {
            url = zoneHost + "/text_by_release_version/" + apiKey + "/" + mode + "/" + namespace + "/" + releaseVersion + "?lang=" + langs;
        }
        if (typeof localVersion === 'string')
            url += "&version=" + localVersion;
        // cdn 方式不支持version 获取，统一改用 cdn 拉取
        if (cdn) {
            url = cdn + "/" + apiKey + "/" + mode + "/" + namespace + "/" + (fallbackLocale || locale) + ".json";
        }
        return url;
    };
    Request.prototype._mapResponse = function (res) {
        if (!res)
            return {};
        return Object.keys(res).reduce(function (acc, key) {
            var newKey = key.toLowerCase();
            acc[newKey] = res[key];
            return acc;
        }, {});
    };
    return Request;
}());

var LocalCache = /** @class */ (function () {
    function LocalCache(options) {
        this.options = options;
        this.options = options;
    }
    LocalCache.prototype._setCache = function (key, val, errCb) {
        if (this.options.cdn) {
            return;
        }
        try {
            return this.options.store.set(key, val);
        }
        catch (err) {
            var ERROR_CODE = MAP_ERROR.CACHE_ERROR.ERROR_CODE;
            this.options.tracker('cache_error', {
                code: ERROR_CODE,
                message: err.message,
                stack: err.stack
            });
            if (errCb) {
                errCb();
            }
            return;
        }
    };
    LocalCache.prototype._getCache = function (key) {
        var _a = this.options, store = _a.store, cache = _a.cache, cdn = _a.cdn;
        try {
            if (cdn) {
                return;
            }
            return cache && store.get(key);
        }
        catch (err) {
            var ERROR_CODE = MAP_ERROR.CACHE_ERROR.ERROR_CODE;
            this.options.tracker('cache_error', {
                code: ERROR_CODE,
                message: err.message,
                stack: err.stack
            });
            return;
        }
    };
    LocalCache.prototype.getVersion = function (namespace) {
        var _a = this.options, apiKey = _a.apiKey, locale = _a.locale, getReleaseVersion = _a.getReleaseVersion;
        var key = "version." + apiKey + "." + namespace + "." + locale;
        var releaseVersion = getReleaseVersion(namespace);
        if (releaseVersion) {
            key += "." + releaseVersion;
        }
        var text = this.getText(namespace);
        // 如果本地缓存被不小心清掉了，版本也不单独返回
        if (!text || typeof text !== 'object') {
            return null;
        }
        // 使用localforge情况下， text会是promise，也需要返回版本号
        if (typeof text === 'object' && text.then) {
            return this._getCache(key);
        }
        // text 是空对象时也不返回版本
        if (typeof text === 'object' && Object.keys(text || {}).length === 0) {
            return null;
        }
        return this._getCache(key);
    };
    LocalCache.prototype.getVersions = function (namespaces) {
        var _this = this;
        return Promise.all(namespaces.map(function (ns) { return _this.getVersion(ns); }));
    };
    LocalCache.prototype.getText = function (namespace) {
        var _a = this.options, apiKey = _a.apiKey, locale = _a.locale, getReleaseVersion = _a.getReleaseVersion;
        var key = "text." + apiKey + "." + namespace + "." + locale;
        var releaseVersion = getReleaseVersion(namespace);
        if (releaseVersion) {
            key += "." + releaseVersion;
        }
        return this._getCache(key);
    };
    // 允许 store 返回值为 promise，支持异步与缓存的交互
    LocalCache.prototype.getTexts = function (namespaces) {
        var _this = this;
        return Promise.all(namespaces.map(function (ns) { return _this.getText(ns); }));
    };
    // 更新指定的空间缓存
    LocalCache.prototype.refresh = function (namespaces, textRes, newVers, langArr) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, apiKey, getReleaseVersion, cache, promises, text;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, apiKey = _a.apiKey, getReleaseVersion = _a.getReleaseVersion, cache = _a.cache;
                        promises = [];
                        textRes.forEach(function (text, i) {
                            var textKey = "text." + apiKey + "." + namespaces[i] + "." + langArr[i];
                            var versionKey = "version." + apiKey + "." + namespaces[i] + "." + langArr[i];
                            var releaseVersion = getReleaseVersion(namespaces[i]);
                            if (releaseVersion) {
                                textKey += "." + releaseVersion;
                                versionKey += "." + releaseVersion;
                            }
                            if (cache) {
                                promises.push(_this._setCache(textKey, textRes[i], function () {
                                    _this.options.store.set(textKey, {});
                                }));
                                promises.push(_this._setCache(versionKey, newVers[i]));
                            }
                        });
                        // 等待缓存更新完成
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        // 等待缓存更新完成
                        _b.sent();
                        text = textRes.reduce(function (acc, cur) {
                            return Object.assign(acc, cur);
                        }, {});
                        return [2 /*return*/, text];
                }
            });
        });
    };
    return LocalCache;
}());

function mergeTexts(arr1, arr2) {
    var arr = arr2 ? arr1.concat(arr2) : arr1;
    return arr.reduce(function (acc, cur) {
        return Object.assign(acc, cur);
    }, {});
}
var NamespaceGroup = /** @class */ (function () {
    function NamespaceGroup(list) {
        if (list === void 0) { list = []; }
        this._list = [];
        this._list = list;
    }
    Object.defineProperty(NamespaceGroup.prototype, "length", {
        get: function () {
            return this._list.length;
        },
        enumerable: false,
        configurable: true
    });
    NamespaceGroup.prototype.getList = function () {
        return this._list;
    };
    NamespaceGroup.prototype.getNamespaces = function () {
        return this._list.map(function (item) { return item.namespace; });
    };
    NamespaceGroup.prototype.addNamespace = function (ns) {
        this._list.push(ns);
    };
    NamespaceGroup.prototype.insertTexts = function (textsArr) {
        this._list.forEach(function (ns, i) {
            ns.texts = textsArr[i];
        });
    };
    NamespaceGroup.prototype.sortByPrior = function () {
        this._list.sort(function (a, b) { return a.prior - b.prior; });
        return this._list;
    };
    NamespaceGroup.prototype.concat = function (nsg) {
        return new NamespaceGroup(this._list.concat(nsg.getList()));
    };
    return NamespaceGroup;
}());
var TextManager = /** @class */ (function () {
    function TextManager(request, localCache, options) {
        this._promiseRefresh = Promise.resolve(null);
        this.remote = request;
        this.local = localCache;
        this.options = options;
    }
    TextManager.prototype._checkVersions = function (namespaces) {
        return __awaiter(this, void 0, void 0, function () {
            var locale, localVersions, namespaceWithVersion, resArr, equalNs, diffNs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        locale = this.options.locale;
                        return [4 /*yield*/, this.local.getVersions(namespaces)];
                    case 1:
                        localVersions = _a.sent();
                        namespaceWithVersion = namespaces.map(function (ns, i) { return [ns, localVersions[i]]; });
                        return [4 /*yield*/, this.remote.getTexts(namespaceWithVersion)];
                    case 2:
                        resArr = _a.sent();
                        equalNs = new NamespaceGroup();
                        diffNs = new NamespaceGroup();
                        namespaces.forEach(function (ns, i) {
                            var _a = resArr[i], updated = _a.updated, version = _a.version, data = _a.data, lang = _a.lang;
                            if (!updated) {
                                equalNs.addNamespace({ namespace: ns, prior: i, version: localVersions[i], lang: locale });
                            }
                            else {
                                diffNs.addNamespace({ namespace: ns, prior: i, version: version, texts: data, lang: lang });
                            }
                        });
                        return [2 /*return*/, { equalNs: equalNs, diffNs: diffNs }];
                }
            });
        });
    };
    TextManager.prototype.waitForRefresh = function () {
        return this._promiseRefresh;
    };
    TextManager.prototype._refresh = function (diffNs) {
        var diffList = diffNs.getList();
        var nsArr = [];
        var versionArr = [];
        var txtArr = [];
        var langArr = [];
        diffList.forEach(function (i) {
            nsArr.push(i.namespace);
            versionArr.push(i.version);
            txtArr.push(i.texts);
            langArr.push(i.lang);
        });
        return this.local.refresh(nsArr, txtArr, versionArr, langArr);
    };
    TextManager.prototype._getLocalTexts = function (nsg) {
        return __awaiter(this, void 0, void 0, function () {
            var texts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.local.getTexts(nsg.getNamespaces())];
                    case 1:
                        texts = _a.sent();
                        nsg.insertTexts(texts);
                        return [2 /*return*/, texts];
                }
            });
        });
    };
    TextManager.prototype.load = function (namespaces) {
        return __awaiter(this, void 0, void 0, function () {
            var format, _a, equalNs, diffNs, texts, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        format = this.options.format;
                        return [4 /*yield*/, this._checkVersions(namespaces)];
                    case 1:
                        _a = _d.sent(), equalNs = _a.equalNs, diffNs = _a.diffNs;
                        if (!equalNs.length) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._getLocalTexts(equalNs)];
                    case 2:
                        _d.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _d.label = 4;
                    case 4:
                        texts = this._formatTexts(format, diffNs.concat(equalNs));
                        _c = diffNs.length;
                        if (!_c) return [3 /*break*/, 6];
                        return [4 /*yield*/, this._refresh(diffNs)];
                    case 5:
                        _c = (_d.sent());
                        _d.label = 6;
                    case 6:
                        return [2 /*return*/, {
                                texts: texts,
                                diffNs: diffNs.getNamespaces(),
                                equalNs: equalNs.getNamespaces()
                            }];
                }
            });
        });
    };
    /**
     * 获取本地缓存文案
     * @param namespaces 空间列表
     */
    TextManager.prototype._getCacheText = function (namespaces) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, locale, format, txtArr, versionArr, nsgList, nsg;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, locale = _a.locale, format = _a.format;
                        return [4 /*yield*/, this.local.getTexts(namespaces)];
                    case 1:
                        txtArr = _b.sent();
                        return [4 /*yield*/, this.local.getVersions(namespaces)];
                    case 2:
                        versionArr = _b.sent();
                        nsgList = txtArr
                            .map(function (txt, i) {
                            if (!txt)
                                return;
                            return {
                                namespace: namespaces[i],
                                version: versionArr[i],
                                lang: locale,
                                texts: txt
                            };
                        })
                            .filter(function (i) { return !!i; });
                        nsg = new NamespaceGroup(nsgList);
                        return [2 /*return*/, {
                                texts: this._formatTexts(format, nsg),
                                cacheAllLoaded: nsgList.length === txtArr.length
                            }];
                }
            });
        });
    };
    TextManager.prototype.lazyLoad = function (namespaces) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, texts, cacheAllLoaded, isLocalEmpty, res;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._getCacheText(namespaces)];
                    case 1:
                        _a = _b.sent(), texts = _a.texts, cacheAllLoaded = _a.cacheAllLoaded;
                        isLocalEmpty = Object.keys(texts).length === 0 || !cacheAllLoaded;
                        this._promiseRefresh = this.load(namespaces);
                        if (!isLocalEmpty) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._promiseRefresh];
                    case 2:
                        // 等待获取远程文案
                        res = _b.sent();
                        texts = res.texts;
                        _b.label = 3;
                    case 3: return [2 /*return*/, {
                            texts: texts,
                            diffNs: isLocalEmpty ? res && res.diffNs : [],
                            equalNs: isLocalEmpty ? res && res.equalNs : namespaces
                        }];
                }
            });
        });
    };
    TextManager.prototype._formatTexts = function (type, nsg) {
        if (type === 'splitted') {
            var list = nsg.getList();
            return list.reduce(function (acc, cur) {
                var namespace = cur.namespace, lang = cur.lang, texts = cur.texts, version = cur.version;
                acc[namespace] = { lang: lang, texts: texts, version: version };
                return acc;
            }, {});
        }
        else {
            // 保证文案合并的顺序，后面的空间会覆盖前面空间的文案。
            var textsArr = nsg.sortByPrior().map(function (i) { return i.texts; });
            return mergeTexts(textsArr);
        }
    };
    return TextManager;
}());

if (typeof Object.assign !== 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, 'assign', {
        value: function assign(target) {
            if (target === null || target === undefined) {
                throw new TypeError('Cannot convert undefined or null to object');
            }
            var to = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                // eslint-disable-next-line prefer-rest-params
                var nextSource = arguments[index];
                if (nextSource !== null && nextSource !== undefined) {
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}

var MAP_EVENT_NAME = {
    EVENT_EXCEPTION: 'client_exception',
    EVENT_LOAD: 'client_load',
    EVENT_CACHE: 'client_cache',
    EVENT_LOAD_TIME: 'client_load_time' // 文案获取时间
};
var PluginType;
(function (PluginType) {
    PluginType["AfterLoad"] = "afterLoad";
})(PluginType || (PluginType = {}));
var Starling = /** @class */ (function () {
    function Starling(options) {
        this.afterLoadPlugins = [];
        this.setConfig(options);
    }
    Starling.prototype._init = function (options) {
        var _this = this;
        this.options = createOptions(options);
        var _a = this.options, apiKey = _a.apiKey, locale = _a.locale, zoneHost = _a.zoneHost, request = _a.request, timeout = _a.timeout, fallbackLang = _a.fallbackLang, store = _a.store, lazyUpdate = _a.lazyUpdate, test = _a.test, mode = _a.mode, format = _a.format, cache = _a.cache, cdn = _a.cdn;
        // 需要上报的公共参数- mode zone locale apiKey
        var commonParams = {
            mode: lazyUpdate ? 'lazy' : test ? 'test' : 'prod',
            zone: zoneHost,
            cdn: cdn,
            locale: locale,
            apiKey: apiKey
        };
        this._tracker = function (name, attrs) {
            try {
                // 打点失败了不应该影响正常业务
                _this.options.tracker(name, __assign(__assign({}, commonParams), attrs));
            }
            catch (error) {
                console.log(error);
            }
        };
        var getReleaseVersion = this._getReleaseVersionByNamespace.bind(this);
        var requester = new Request({
            request: request,
            timeout: timeout,
            apiKey: apiKey,
            locale: locale,
            zoneHost: zoneHost,
            fallbackLang: fallbackLang,
            mode: mode,
            getReleaseVersion: getReleaseVersion,
            cdn: cdn
        });
        var localCache = new LocalCache({
            apiKey: apiKey,
            locale: locale,
            store: store,
            tracker: this._tracker,
            getReleaseVersion: getReleaseVersion,
            cache: cache,
            cdn: cdn
        });
        this._textManager = new TextManager(requester, localCache, { locale: locale, format: format });
        // init plugin
        this.initPlugin();
    };
    Starling.prototype.initPlugin = function () {
        var _this = this;
        var plugins = this.options.plugins || [];
        if (Array.isArray(plugins) && plugins.every(function (p) { return typeof p === 'object'; }))
            plugins.forEach(function (plugin) {
                if (plugin.type === PluginType.AfterLoad) {
                    _this.afterLoadPlugins.push(plugin);
                }
            });
    };
    Starling.prototype._getReleaseVersionByNamespace = function (ns) {
        var namespaces = this.options.namespace;
        var releaseVersion = this.options.version;
        var version = null;
        if (Array.isArray(releaseVersion)) {
            var index = namespaces.findIndex(function (v) { return v === ns; });
            version = releaseVersion[index];
        }
        else if (releaseVersion && typeof releaseVersion === 'object') {
            version = releaseVersion[ns];
        }
        else if (typeof releaseVersion === 'string') {
            version = releaseVersion;
        }
        return version;
    };
    /**
     * 用于修改 starling 配置项
     * @param config
     */
    Starling.prototype.setConfig = function (config) {
        var options = Object.assign({}, this.options, config);
        this._init(options);
    };
    /**
     * 用于 lazy 模式下判断本地文案更新是否完成。
     *
     * @return {Promise<texts>} 返回本地更新的文案
     */
    Starling.prototype.waitForRefresh = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._textManager.waitForRefresh()];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res ? res.texts : null];
                }
            });
        });
    };
    Starling.prototype._load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, namespace, lazyUpdate, namespaces, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, namespace = _a.namespace, lazyUpdate = _a.lazyUpdate;
                        namespaces = namespace;
                        if (!lazyUpdate) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._textManager.lazyLoad(namespaces)];
                    case 1:
                        result = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this._textManager.load(namespaces)];
                    case 3:
                        result = _b.sent();
                        _b.label = 4;
                    case 4: return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * 从远端按需拉取需要更新的文案，并返回文案。
     *
     * @param {(param: texts) => void} onSuccess 调用成功的回调函数
     * @param {(error: StarlingError)} onError 调用失败的回调函数
     * @return {Promise<texts>} 远端拉取的文案
     */
    Starling.prototype.load = function (onSuccess, onError) {
        return __awaiter(this, void 0, void 0, function () {
            var start, namespaces, result, diffNs, equalNs, texts_1, afterLoads, processedText, diffLen, equalLen, namespacesLen, ratio, err_1, cacheText;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = Date.now();
                        namespaces = this.options.namespace;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 10]);
                        this._tracker(MAP_EVENT_NAME.EVENT_LOAD, { state: 'start', version: '0.5.16' });
                        return [4 /*yield*/, this._load()];
                    case 2:
                        result = _a.sent();
                        diffNs = result.diffNs, equalNs = result.equalNs;
                        texts_1 = result.texts;
                        afterLoads = this.afterLoadPlugins;
                        if (!(Array.isArray(afterLoads) && afterLoads.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, afterLoads.reduce(function (pre, cur) {
                                return pre.then(function (text) {
                                    if (typeof cur.process === 'function') {
                                        return cur.process(text || texts_1, _this.options);
                                    }
                                    /* istanbul ignore next */
                                    return text;
                                });
                            }, Promise.resolve(texts_1))];
                    case 3:
                        processedText = _a.sent();
                        texts_1 = processedText || texts_1;
                        _a.label = 4;
                    case 4:
                        onSuccess && onSuccess(texts_1);
                        this._tracker(MAP_EVENT_NAME.EVENT_LOAD_TIME, { time: Date.now() - start });
                        this._tracker(MAP_EVENT_NAME.EVENT_LOAD, { state: 'success', version: '0.5.16' });
                        diffLen = diffNs.length;
                        equalLen = equalNs.length;
                        namespacesLen = namespaces.length;
                        ratio = (equalLen / namespacesLen).toFixed(2);
                        this._tracker(MAP_EVENT_NAME.EVENT_CACHE, {
                            diffLen: diffLen,
                            diff: diffNs.join(','),
                            equalLen: equalLen,
                            equal: equalNs.join(','),
                            namespaces: equalNs.join(','),
                            namespacesLen: namespacesLen,
                            ratio: ratio
                        });
                        return [2 /*return*/, texts_1];
                    case 5:
                        err_1 = _a.sent();
                        this._tracker(MAP_EVENT_NAME.EVENT_LOAD, { state: 'fail' });
                        this._tracker(MAP_EVENT_NAME.EVENT_EXCEPTION, {
                            code: err_1.code,
                            message: err_1.message,
                            stack: err_1.stack
                        });
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, this._textManager._getCacheText(namespaces)];
                    case 7:
                        cacheText = (_a.sent()).texts;
                        if (cacheText && typeof cacheText === 'object') {
                            err_1.response = { data: cacheText };
                        }
                        else {
                            /* istanbul ignore next */
                            err_1.response = { data: {} };
                        }
                        return [3 /*break*/, 9];
                    case 8:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 9:
                        // 如果用户传入了 onError，不应该再抛出一个异常
                        // 那样用户还需要再处理失败的 Promise，duck 不必
                        if (onError) {
                            onError(err_1);
                        }
                        else {
                            return [2 /*return*/, Promise.reject(err_1)];
                        }
                        return [3 /*break*/, 10];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    return Starling;
}());

module.exports = Starling;
