"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ILifeCycle = void 0;
exports.Alive = Alive;
const tslib_1 = require("tslib");
const logger_1 = require("../../common/logger");
const object_factory_1 = require("../../impl-registry/object-factory");
const enum_1 = require("../../typing/enum");
class ILifeCycle {
    constructor() {
        this._status = enum_1.LifeCycleStatus.ALIVE;
    }
    get isFinalized() {
        return this._status === enum_1.LifeCycleStatus.FINALIZED;
    }
    setFinalized(..._) {
        this._logger.info(`lifecycle finalized ${this.constructor.name}`);
        this._status = enum_1.LifeCycleStatus.FINALIZED;
    }
}
exports.ILifeCycle = ILifeCycle;
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], ILifeCycle.prototype, "_logger", void 0);
tslib_1.__decorate([
    Alive,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", void 0)
], ILifeCycle.prototype, "setFinalized", null);
function Alive(target, propertyKey, descriptor) {
    void propertyKey;
    const originalMethod = descriptor.value;
    const newMethod = function (...args) {
        if (this.isFinalized) {
            const message = `Method ${target.constructor.name}.${propertyKey} called after finalize`;
            this._logger.error(message, ...args);
            throw new Error(message);
        }
        return originalMethod.apply(this, args);
    };
    descriptor.value = newMethod;
    return descriptor;
}
