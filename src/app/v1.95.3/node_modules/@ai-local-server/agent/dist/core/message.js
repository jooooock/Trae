"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoDebugMessage = exports.messageMethodImplRegistry = exports.MessageEventImpl = void 0;
const tslib_1 = require("tslib");
const i_sse_event_handler_1 = require("../common/base/i-sse-event-handler");
const method_1 = require("../impl-registry/method");
const enum_1 = require("../typing/enum");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const i_life_cycle_1 = require("../common/base/i-life-cycle");
const object_factory_1 = require("../impl-registry/object-factory");
const utils_1 = require("../common/utils");
const cache_1 = require("../core/cache");
_a = tslib_1.__read((0, method_1.createMethodImplRegistry)(), 2), exports.MessageEventImpl = _a[0], exports.messageMethodImplRegistry = _a[1];
let AutoDebugMessage = class AutoDebugMessage extends i_sse_event_handler_1.AutoDebugSSEEventHandler {
    constructor() {
        super(...arguments);
        this._conclusion = [];
    }
    init(runId, listener) {
        this._runId = runId;
        void this._runId;
        this._listener = listener;
    }
    get conclusion() {
        return this._conclusion;
    }
    get attachment() {
        return this._attachment;
    }
    get methodImplRegistry() {
        return exports.messageMethodImplRegistry;
    }
    async onCreated(event) {
        this._logger.info(`message created`, JSON.stringify(event));
        this._data = event.data;
        void this._data;
    }
    async onDelta(event) {
        const { value, attachment } = event.data.delta.text;
        if (value) {
            await this.onTokens(value);
        }
        if (attachment) {
            this._logger.info("on receive attachment", JSON.stringify(event));
            await this.onAttachment(attachment);
        }
    }
    async onAttachment(attachment) {
        this._attachment = attachment;
        let patchList;
        try {
            patchList = utils_1.Utils.parseIncomingProtocol(JSON.parse(attachment.data));
        }
        catch (err) {
            this._logger.error("parse diff failed", err);
            return;
        }
        // LLM 没有 fix 时 attachment.data 为 "null"
        if (!patchList?.patches?.length) {
            this._logger.info("attachment data parsed null", attachment.data);
            return;
        }
        this._listener.onEvent({
            agentMessage: {
                diffList: lodash_1.default.uniqBy(patchList.patches, 'filePath').map((p) => {
                    return {
                        filePath: p.filePath,
                        // patch 从缓存读，返回完整内容
                        patch: this._cache.getFileCache({
                            runId: this._runId,
                            filePath: p.filePath,
                        }),
                    };
                }),
            },
        });
    }
    async onTokens(tokens) {
        this._conclusion.push(tokens);
        this._listener.onEvent({
            agentMessage: {
                content: tokens,
            },
        });
    }
    async onComplete(event) {
        this._logger.info("on message completed", JSON.stringify(event));
        this.setFinalized();
    }
};
exports.AutoDebugMessage = AutoDebugMessage;
tslib_1.__decorate([
    (0, object_factory_1.Inject)(),
    tslib_1.__metadata("design:type", cache_1.AutoDebugCache)
], AutoDebugMessage.prototype, "_cache", void 0);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.MessageEventImpl)(enum_1.AutoDebugSSEEventType.MESSAGE_CREATED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugMessage.prototype, "onCreated", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.MessageEventImpl)(enum_1.AutoDebugSSEEventType.MESSAGE_DELTA),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugMessage.prototype, "onDelta", null);
tslib_1.__decorate([
    i_life_cycle_1.Alive,
    (0, exports.MessageEventImpl)(enum_1.AutoDebugSSEEventType.MESSAGE_COMPLETED),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AutoDebugMessage.prototype, "onComplete", null);
exports.AutoDebugMessage = AutoDebugMessage = tslib_1.__decorate([
    object_factory_1.ExecutionInjectable
], AutoDebugMessage);
