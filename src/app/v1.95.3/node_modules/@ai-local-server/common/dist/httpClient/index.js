import { __decorate, __metadata } from "tslib";
import { SingletonInjectable } from '../common/injection';
import { Inject } from '@artus/injection';
import { AIRequestClient } from './aiClient';
import { AI_SEVER_REGION_MAP, RequestPathType } from '../common/constant';
import { AICommonOptionsHelper } from '../options';
import { Logger } from '../common/logger';
let HttpClient = class HttpClient {
    async generatePracticeTitle(request, options) {
        return await this._aiRequestClient.post(RequestPathType.PRACTICE_TITLE, request, {
            enableParser: true,
            ...options,
        });
    }
    async generatePracticeTestCase(request, options) {
        return await this._aiRequestClient.post(RequestPathType.PRACTICE_TEST_CASE, request, {
            ...options,
        });
    }
    async intentDetect(request, options) {
        try {
            return await this._aiRequestClient.post(RequestPathType.INTENT_DETECT, request, {
                timeout: 15 * 1000,
                ...options,
            });
        }
        catch (error) {
            this._logger.error(`fetch Intent Failed: ${error.message} `);
            return undefined;
        }
    }
    async chat(request, options) {
        return await this._aiRequestClient.post(RequestPathType.CHAT, request, {
            responseType: 'stream',
            ...options,
        });
    }
    async getIntentConfig(request, options) {
        const region = AI_SEVER_REGION_MAP[this._optionsHelper.region];
        return await this._aiRequestClient.get(RequestPathType.INTENT_CONFIG, { region, ...request }, {
            headers: {
                'x-app-version': 'default',
            },
            ...options,
        });
    }
    async feedback(request, options) {
        try {
            return await this._aiRequestClient.post(RequestPathType.FEEDBACK, request, { ...options });
        }
        catch (error) {
            this._logger.error(`feedback failed: ${error.message}`);
            return undefined;
        }
    }
    async getAppVersions(request, options) {
        try {
            return await this._aiRequestClient.get(RequestPathType.APP_VERSIONS, request, options);
        }
        catch (error) {
            this._logger.error(`fetch supported models failed: ${error.message}`);
            return undefined;
        }
    }
    async getFeatures(request, options) {
        try {
            return await this._aiRequestClient.get(RequestPathType.FEATURES, request, options);
        }
        catch (error) {
            this._logger.error(`fetch features failed: ${error.message}`);
            return undefined;
        }
    }
    async applyCodeSnippt(request, options) {
        return await this._aiRequestClient.post(RequestPathType.APPLY_CODE_SNIPPT, request, {
            responseType: 'stream',
            ...options,
        });
    }
    setInterceptors(options) {
        this._aiRequestClient.setInterceptors(options);
    }
    getHost() {
        return this._aiRequestClient.getHost();
    }
    getAppID() {
        return this._aiRequestClient.getAppID();
    }
};
__decorate([
    Inject(),
    __metadata("design:type", AIRequestClient)
], HttpClient.prototype, "_aiRequestClient", void 0);
__decorate([
    Inject(),
    __metadata("design:type", AICommonOptionsHelper)
], HttpClient.prototype, "_optionsHelper", void 0);
__decorate([
    Inject(),
    __metadata("design:type", Logger)
], HttpClient.prototype, "_logger", void 0);
HttpClient = __decorate([
    SingletonInjectable
], HttpClient);
export { HttpClient };
