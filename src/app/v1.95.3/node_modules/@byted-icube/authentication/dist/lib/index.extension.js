"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.extension.ts
var index_extension_exports = {};
__export(index_extension_exports, {
  AuthPlatformTypes: () => AuthPlatformTypes,
  ICubeAuthVSExtensionClient: () => ICubeAuthVSExtensionClient
});
module.exports = __toCommonJS(index_extension_exports);

// src/vscode/user.ts
var vscode = __toESM(require("vscode"));
function getToken() {
  return vscode.commands.executeCommand("icube.common.getToken");
}
function getUser() {
  return vscode.commands.executeCommand("icube.cloudide.getUser");
}

// src/vscode/cache.ts
var memoryStorage = {};
function save(prefix, data) {
  memoryStorage[prefix] = data;
}
function get(prefix) {
  return memoryStorage[prefix] || {};
}

// src/store.ts
var AuthCache = class {
  constructor(config) {
    this.config = config;
    __publicField(this, "_cache");
    this._cache = this._getCache(this.config.baseUrl) || {};
  }
  get(key) {
    return this._cache[key];
  }
  set(key, v) {
    this._cache[key] = v;
    this._saveCache(this._cache);
  }
  delete(key) {
    delete this._cache[key];
    this._saveCache(this._cache);
  }
  getToken(key) {
    const t = this.get(key);
    if (t) {
      const userToken = JSON.parse(t);
      if (validateUserToken(userToken)) {
        return userToken;
      }
    }
    this.delete(key);
  }
  clear() {
    this._cache = {};
    this._saveCache(this._cache, true);
  }
  _getCache(prefix) {
    return get(prefix, this.config.userId);
  }
  _saveCache(data, clear = false) {
    save(this.config.baseUrl, data, clear);
  }
};
function parseJwtToken(token) {
  try {
    const [, payload] = token.split(".");
    const { exp, data } = JSON.parse(atob(payload));
    return { token, expiredAt: exp, userId: data == null ? void 0 : data.id };
  } catch (error) {
    console.warn("parse jwt string token failed: \n", error);
    return void 0;
  }
}
function validateUserToken(token) {
  if (!token) {
    return false;
  }
  const REFRESH_TOKEN_DURATION = 5 * 60 * 1e3;
  if (typeof token === "string") {
    const parsed = parseJwtToken(token);
    if (!parsed) {
      return false;
    }
    const realExpTimestamp = Number(parsed.expiredAt) * 1e3;
    return realExpTimestamp - Date.now() > REFRESH_TOKEN_DURATION;
  }
  if ("expiredAt" in token) {
    return token.token && token.expiredAt && Date.parse(token.expiredAt) - Date.now() > REFRESH_TOKEN_DURATION;
  }
  return false;
}

// src/request.ts
function createTimeoutSignal(ms) {
  if (typeof AbortSignal !== "undefined" && AbortSignal.timeout) {
    return AbortSignal.timeout(ms);
  } else {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), ms);
    return controller.signal;
  }
}
function requestWithRetry(_0) {
  return __async(this, arguments, function* (url, options = {}) {
    const _a = options, {
      maxRetryTimes = 3,
      retryInterval = 1e3,
      timeout = 30 * 1e3,
      retryCondition = (r) => r.status >= 500
    } = _a, fetchOptions = __objRest(_a, [
      "maxRetryTimes",
      "retryInterval",
      "timeout",
      "retryCondition"
    ]);
    if (maxRetryTimes < 1) {
      throw new Error("maxRetryTimes should be greater than 1.");
    }
    let retryTimes = 0;
    let response;
    while (retryTimes < maxRetryTimes) {
      try {
        response = yield fetch(url, __spreadValues({
          mode: "cors",
          credentials: "include",
          // todo: 兼容低版本浏览器
          signal: createTimeoutSignal(timeout)
        }, fetchOptions));
        if (retryCondition(response)) {
          throw new Error("Request failed: should retry");
        }
        return response;
      } catch (e) {
        retryTimes++;
        console.warn(
          `Request failed: ${url}, ${e}, retrying ${retryTimes} times.`
        );
        yield new Promise((resolve) => setTimeout(resolve, retryInterval));
      }
    }
    console.error(`Request failed: ${url}, retrying ${retryTimes} times.`);
    return response;
  });
}
var baseUrl = "";
var webUrl = "";
var ideToken = "";
var redirectLoginUrl = "";
function setBaseUrl(newBaseUrl) {
  baseUrl = newBaseUrl;
}
function setWebUrl(newWebUrl) {
  webUrl = newWebUrl;
}
function setRedirectLoginUrl(url) {
  redirectLoginUrl = url;
}
function setIdeToken(token) {
  ideToken = token;
}
function getIdeToken() {
  return ideToken;
}
var defaultRequestOptions;
function setRequestOptions(options) {
  defaultRequestOptions = options;
}
function getRequestOptions() {
  return defaultRequestOptions;
}
var fetching = function(path, fetchOptions) {
  return __async(this, null, function* () {
    const url = path.includes("http") ? path : baseUrl + path;
    const defaultFetchOptions = getRequestOptions();
    const options = __spreadProps(__spreadValues(__spreadValues({
      method: "POST"
    }, defaultFetchOptions), fetchOptions), {
      headers: __spreadValues(__spreadProps(__spreadValues({}, defaultFetchOptions == null ? void 0 : defaultFetchOptions.headers), {
        "X-Cloudide-Token": ideToken,
        "Content-Type": "application/json"
      }), fetchOptions == null ? void 0 : fetchOptions.headers)
    });
    const response = yield requestWithRetry(url, options);
    if (response.ok) {
      return response;
    }
    throw new Error(
      `Request failed: url: ${url}, request: ${JSON.stringify(options)}, response: ${JSON.stringify(response)}`
    );
  });
};
function getGithubAuthUrl() {
  const clientId = "Iv1.80ad21cf142be33f";
  const redirectUrl = "";
  const state = encodeURIComponent(
    `twice_auth=true&redirect_url=${redirectUrl}`
  );
  const GITHUB_AUTH_URL = `https://github.com/login/oauth/authorize?client_id=${clientId}&state=${state}&redirect_uri=${encodeURIComponent(
    "https://ide-boei18n.bytedance.net/github-oauth-twice-redirect"
  )}`;
  return GITHUB_AUTH_URL;
}
function requestAppInfo(appName) {
  const OAuthMap = {
    ["GITHUB" /* Github */]: {
      isOauth: true,
      // "/cloudide/api/v3/public/github/CheckAuthorizationStatus",
      getAccessTokenUrl: "/cloudide/api/v3/public/github/GetAccessToken",
      oauthUrl: getGithubAuthUrl()
    },
    ["DEPLOY" /* Deploy */]: {
      isOauth: false,
      getAccessTokenUrl: "/cloudide/api/v3/common/GetDeploymentUserToken"
    }
  };
  if (appName in OAuthMap) {
    return Promise.resolve(OAuthMap[appName]);
  }
  return Promise.reject(new Error(`not supported appName ${appName}`));
}
function requestThirdPartyToken(getAccessTokenUrl) {
  return __async(this, null, function* () {
    const res = yield fetching(getAccessTokenUrl, {
      maxRetryTimes: 1
    });
    const data = yield res == null ? void 0 : res.json();
    if (data.ResponseMetadata.Error) {
      throw new Error(data.ResponseMetadata.Error.Message);
    }
    const { AccessToken } = data.Result;
    return {
      token: AccessToken
    };
  });
}
function requestSecondPartyToken(getAccessTokenUrl, token) {
  return __async(this, null, function* () {
    const res = yield fetching(getAccessTokenUrl, {
      headers: {
        "X-Cloudide-Token": token || ideToken
      }
    });
    const data = yield res == null ? void 0 : res.json();
    if (data.ResponseMetadata.Error) {
      throw new Error(data.ResponseMetadata.Error.Message);
    }
    const { Token, ExpiredAt } = data.Result;
    return {
      token: Token,
      expiredAt: ExpiredAt
    };
  });
}
function requestUserInfo(_0) {
  return __async(this, arguments, function* (param, fetchOptions = {}) {
    const res = yield fetching(
      (param == null ? void 0 : param.baseUrl) ? `${param == null ? void 0 : param.baseUrl}/cloudide/api/v3/public/GetUserInfo` : "/cloudide/api/v3/public/GetUserInfo",
      __spreadProps(__spreadValues({}, fetchOptions), {
        body: JSON.stringify(param)
      })
    );
    const data = yield res == null ? void 0 : res.json();
    if (data.ResponseMetadata.Error) {
      throw new Error(data.ResponseMetadata.Error.Message);
    }
    const { ScreenName, Gender, AvatarUrl, Description, TenantID, UserID } = data.Result;
    return __spreadValues({
      name: ScreenName,
      gender: Gender,
      avatar: AvatarUrl,
      description: Description,
      userId: UserID,
      tenantId: TenantID
    }, data.Result);
  });
}
function requestLogout(token) {
  return __async(this, null, function* () {
    const res = yield fetching("/cloudide/api/v3/public/Logout", {
      headers: {
        "X-Cloudide-Token": token || ideToken
      }
    });
    const data = yield res == null ? void 0 : res.json();
    if (data.ResponseMetadata.Error) {
      throw new Error(data.ResponseMetadata.Error.Message);
    }
  });
}

// src/vscode/index.ts
var vscode2 = __toESM(require("vscode"));
function redirectToLogin() {
  if (vscode2) {
    vscode2.commands.executeCommand("icube.common.redirectToLogin");
  }
}
function openPage(url) {
  return __async(this, null, function* () {
    if (vscode2) {
      const promise = new AuthUriHandler().wait();
      vscode2.env.asExternalUri(
        vscode2.Uri.parse(
          `${vscode2.env.uriScheme}://byted-ide.icube-remote/did-authenticate`
        )
      );
      vscode2.env.openExternal(vscode2.Uri.parse(url));
      yield promise;
    }
  });
}
var AuthUriHandler = class extends vscode2.EventEmitter {
  handleUri(uri) {
    this.fire(uri);
  }
  wait(token) {
    return Promise.race([
      new Promise((resolve, reject) => {
        token == null ? void 0 : token.onCancellationRequested(() => {
          reject(new Error("Cancelled"));
        });
        setTimeout(() => {
          reject(new Error("Timeout"));
        }, 60 * 1e3);
      }),
      new Promise((resolve, reject) => {
        this.event((uri) => {
          const query = new URLSearchParams(uri.query);
          const code = query.get("code");
          if (!code) {
            reject(new Error("No code"));
            return;
          }
          resolve(code);
        });
      })
    ]);
  }
};

// src/login.ts
function getUserToken(needLogin, fetchOptions) {
  return __async(this, null, function* () {
    try {
      const token = yield getToken(fetchOptions);
      setIdeToken(token.token);
      return token;
    } catch (e) {
      if (needLogin) {
        redirectToLogin();
      } else {
        throw new RedirectError(e.message || "login failed", {});
      }
    }
  });
}
function getThirdPartyToken(appName, needLogin) {
  return __async(this, null, function* () {
    const { getAccessTokenUrl, oauthUrl, isOauth } = yield requestAppInfo(appName);
    if (isOauth) {
      try {
        const token = yield requestThirdPartyToken(getAccessTokenUrl);
        return token;
      } catch (e) {
        if (needLogin && oauthUrl) {
          yield openPage(oauthUrl);
          return yield requestThirdPartyToken(getAccessTokenUrl);
        }
        throw new RedirectError(e.message || "login failed", {
          url: oauthUrl
        });
      }
    } else {
      return yield requestSecondPartyToken(getAccessTokenUrl);
    }
  });
}
var RedirectError = class extends Error {
  constructor(message, data) {
    super(message);
    this.data = data;
    this.name = "RedirectError";
  }
};

// src/index.ts
var AuthPlatformTypes = /* @__PURE__ */ ((AuthPlatformTypes2) => {
  AuthPlatformTypes2["Ide"] = "IDE";
  AuthPlatformTypes2["Github"] = "GITHUB";
  AuthPlatformTypes2["Deploy"] = "DEPLOY";
  return AuthPlatformTypes2;
})(AuthPlatformTypes || {});
var ICubeAuthClient = class {
  constructor(config, defaultRequestOptions2) {
    __publicField(this, "_cache");
    if (!(config == null ? void 0 : config.baseUrl)) {
      throw new Error("baseUrl is required");
    }
    setBaseUrl(config.baseUrl);
    if (config.webUrl) {
      setWebUrl(config.webUrl);
    }
    if (config.redirectLoginUrl) {
      setRedirectLoginUrl(config.redirectLoginUrl);
    }
    defaultRequestOptions2 && setRequestOptions(defaultRequestOptions2);
    this._cache = new AuthCache(config);
    const lastToken = this._cache.getToken("IDE");
    lastToken && setIdeToken(lastToken.token);
  }
  getAuthToken(_0) {
    return __async(this, arguments, function* (appName, options = { needLogin: false, force: false }) {
      const { needLogin, force, fetchOptions } = options;
      if (!force) {
        const lastToken = this._cache.getToken(appName);
        if (lastToken) {
          return lastToken;
        }
      }
      let getTokenP = null;
      switch (appName) {
        case "IDE" /* Ide */:
          getTokenP = getUserToken(needLogin, fetchOptions);
          break;
        case "GITHUB" /* Github */:
        case "DEPLOY" /* Deploy */:
          yield this.getAuthToken("IDE" /* Ide */, {
            needLogin
          });
          getTokenP = getThirdPartyToken(appName, needLogin);
          break;
        default:
          console.warn(`appName ${appName} is not supported`);
          break;
      }
      return getTokenP == null ? void 0 : getTokenP.then((token) => {
        if (token) {
          this._cache.set(appName, JSON.stringify(token));
        }
        return token;
      });
    });
  }
  updateTokenCache(appName, token) {
    this._cache.set(appName, JSON.stringify(token));
    if (appName === "IDE" /* Ide */) {
      setIdeToken(token.token);
    }
  }
  getUserInfo() {
    return __async(this, arguments, function* (options = {
      needLogin: false
    }) {
      const params = __spreadValues({}, options.params || options.requestOptions);
      delete options.params;
      delete options.requestOptions;
      yield this.getAuthToken("IDE" /* Ide */, options);
      return requestUserInfo(params, options.fetchOptions);
    });
  }
  logout(token) {
    return __async(this, null, function* () {
      if (!token && !getIdeToken()) {
        yield this.getAuthToken("IDE" /* Ide */, {
          needLogin: false
        });
      }
      yield requestLogout(token);
      this._cache.clear();
      redirectToLogin();
      return;
    });
  }
  requestDeployToken(ideToken2) {
    return __async(this, null, function* () {
      const { getAccessTokenUrl } = yield requestAppInfo(
        "DEPLOY" /* Deploy */
      );
      return yield requestSecondPartyToken(getAccessTokenUrl, ideToken2).then(
        (token) => {
          if (token) {
            this._cache.set("DEPLOY" /* Deploy */, JSON.stringify(token));
          }
          return token;
        }
      );
    });
  }
};

// src/index.extension.ts
var ICubeAuthVSExtensionClient = class _ICubeAuthVSExtensionClient extends ICubeAuthClient {
  getUserInfo() {
    return __async(this, arguments, function* (options = {
      needLogin: false
    }) {
      return yield getUser(options.requestOptions);
    });
  }
  getAuthToken(appName, options) {
    return __async(this, null, function* () {
      let token;
      switch (appName) {
        case "IDE" /* Ide */:
          token = yield __superGet(_ICubeAuthVSExtensionClient.prototype, this, "getAuthToken").call(this, "IDE" /* Ide */, options);
          break;
        case "GITHUB" /* Github */:
          token = yield __superGet(_ICubeAuthVSExtensionClient.prototype, this, "getAuthToken").call(this, "GITHUB" /* Github */, options);
          break;
        case "DEPLOY" /* Deploy */:
          token = yield __superGet(_ICubeAuthVSExtensionClient.prototype, this, "getAuthToken").call(this, "DEPLOY" /* Deploy */, options);
          break;
        default:
          return void 0;
      }
      if (typeof token === "string") {
        return parseJwtToken(token);
      }
      return token;
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthPlatformTypes,
  ICubeAuthVSExtensionClient
});
