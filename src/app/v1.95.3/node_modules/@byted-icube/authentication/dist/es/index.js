var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/web/cache.ts
import Cookies from "js-cookie";
var COOKIE_CACHE_KEY = "marscode_auth_token";
var joinCacheKey = (key) => `${COOKIE_CACHE_KEY}_${key}`;
var getPlatformFromCacheKey = (key) => key.replace(`${COOKIE_CACHE_KEY}_`, "");
var platformList = [
  "DEPLOY" /* Deploy */,
  "IDE" /* Ide */,
  "GITHUB" /* Github */
];
var cacheKeyWithPlatforms = platformList.map(joinCacheKey);
function save(_prefix, data, clear = false) {
  if (typeof window === "undefined") {
    return;
  }
  if (!data) {
    return;
  }
  if (clear) {
    clearAllCookieTokens();
    return;
  }
  Object.keys(data).forEach((key) => {
    const value = JSON.parse(data[key]);
    Cookies.set(joinCacheKey(key), JSON.stringify(value), {
      // 如果 token 本身传入了过期时间，则复用
      expires: (value == null ? void 0 : value.expiredAt) ? new Date(value.expiredAt) : (
        // 否则给 1 天的过期时间，比如 github
        new Date(Date.now() + 1 * 24 * 60 * 60 * 1e3)
      )
    });
  });
}
function clearAllCookieTokens() {
  cacheKeyWithPlatforms.forEach((it) => {
    Cookies.remove(it);
  });
}
function get(prefix, userId) {
  var _a;
  if (typeof window === "undefined") {
    return void 0;
  }
  try {
    let cookieValues;
    for (const key of cacheKeyWithPlatforms) {
      const cookiesCache = Cookies.get(key);
      if (cookiesCache) {
        const platform = getPlatformFromCacheKey(key);
        const parsed = JSON.parse(cookiesCache);
        const maybeUserId = userId || ((_a = window.__icube_runtime) == null ? void 0 : _a.userId);
        if (maybeUserId && (parsed == null ? void 0 : parsed.userId) && parsed.userId !== maybeUserId) {
          clearAllCookieTokens();
          break;
        }
        if (!cookieValues) {
          cookieValues = {};
        }
        cookieValues[platform] = cookiesCache;
      }
    }
    if (cookieValues) {
      return cookieValues;
    }
    const localStorageCache = window.localStorage.getItem(prefix);
    if (localStorageCache) {
      save(COOKIE_CACHE_KEY, JSON.parse(localStorageCache));
      window.localStorage.removeItem(prefix);
      return get(prefix);
    }
    return void 0;
  } catch (error) {
    console.error("[icube-authentication]: get token from cache failed", error);
    return void 0;
  }
}

// src/store.ts
var AuthCache = class {
  constructor(config) {
    this.config = config;
    __publicField(this, "_cache");
    this._cache = this._getCache(this.config.baseUrl) || {};
  }
  get(key) {
    return this._cache[key];
  }
  set(key, v) {
    this._cache[key] = v;
    this._saveCache(this._cache);
  }
  delete(key) {
    delete this._cache[key];
    this._saveCache(this._cache);
  }
  getToken(key) {
    const t = this.get(key);
    if (t) {
      const userToken = JSON.parse(t);
      if (validateUserToken(userToken)) {
        return userToken;
      }
    }
    this.delete(key);
  }
  clear() {
    this._cache = {};
    this._saveCache(this._cache, true);
  }
  _getCache(prefix) {
    return get(prefix, this.config.userId);
  }
  _saveCache(data, clear = false) {
    save(this.config.baseUrl, data, clear);
  }
};
function parseJwtToken(token) {
  try {
    const [, payload] = token.split(".");
    const { exp, data } = JSON.parse(atob(payload));
    return { token, expiredAt: exp, userId: data == null ? void 0 : data.id };
  } catch (error) {
    console.warn("parse jwt string token failed: \n", error);
    return void 0;
  }
}
function validateUserToken(token) {
  if (!token) {
    return false;
  }
  const REFRESH_TOKEN_DURATION = 5 * 60 * 1e3;
  if (typeof token === "string") {
    const parsed = parseJwtToken(token);
    if (!parsed) {
      return false;
    }
    const realExpTimestamp = Number(parsed.expiredAt) * 1e3;
    return realExpTimestamp - Date.now() > REFRESH_TOKEN_DURATION;
  }
  if ("expiredAt" in token) {
    return token.token && token.expiredAt && Date.parse(token.expiredAt) - Date.now() > REFRESH_TOKEN_DURATION;
  }
  return false;
}

// src/request.ts
function createTimeoutSignal(ms) {
  if (typeof AbortSignal !== "undefined" && AbortSignal.timeout) {
    return AbortSignal.timeout(ms);
  } else {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), ms);
    return controller.signal;
  }
}
async function requestWithRetry(url, options = {}) {
  const {
    maxRetryTimes = 3,
    retryInterval = 1e3,
    timeout = 30 * 1e3,
    retryCondition = (r) => r.status >= 500,
    ...fetchOptions
  } = options;
  if (maxRetryTimes < 1) {
    throw new Error("maxRetryTimes should be greater than 1.");
  }
  let retryTimes = 0;
  let response;
  while (retryTimes < maxRetryTimes) {
    try {
      response = await fetch(url, {
        mode: "cors",
        credentials: "include",
        // todo: 兼容低版本浏览器
        signal: createTimeoutSignal(timeout),
        ...fetchOptions
      });
      if (retryCondition(response)) {
        throw new Error("Request failed: should retry");
      }
      return response;
    } catch (e) {
      retryTimes++;
      console.warn(
        `Request failed: ${url}, ${e}, retrying ${retryTimes} times.`
      );
      await new Promise((resolve) => setTimeout(resolve, retryInterval));
    }
  }
  console.error(`Request failed: ${url}, retrying ${retryTimes} times.`);
  return response;
}
var baseUrl = "";
var webUrl = "";
var ideToken = "";
var redirectLoginUrl = "";
function setBaseUrl(newBaseUrl) {
  baseUrl = newBaseUrl;
}
function setWebUrl(newWebUrl) {
  webUrl = newWebUrl;
}
function getWebUrl() {
  return webUrl;
}
function setRedirectLoginUrl(url) {
  redirectLoginUrl = url;
}
function getRedirectUrl() {
  return redirectLoginUrl;
}
function setIdeToken(token) {
  ideToken = token;
}
function getIdeToken() {
  return ideToken;
}
var defaultRequestOptions;
function setRequestOptions(options) {
  defaultRequestOptions = options;
}
function getRequestOptions() {
  return defaultRequestOptions;
}
var fetching = async function(path, fetchOptions) {
  const url = path.includes("http") ? path : baseUrl + path;
  const defaultFetchOptions = getRequestOptions();
  const options = {
    method: "POST",
    ...defaultFetchOptions,
    ...fetchOptions,
    headers: {
      ...defaultFetchOptions == null ? void 0 : defaultFetchOptions.headers,
      "X-Cloudide-Token": ideToken,
      "Content-Type": "application/json",
      ...fetchOptions == null ? void 0 : fetchOptions.headers
    }
  };
  const response = await requestWithRetry(url, options);
  if (response.ok) {
    return response;
  }
  throw new Error(
    `Request failed: url: ${url}, request: ${JSON.stringify(options)}, response: ${JSON.stringify(response)}`
  );
};
async function requestUserToken(fetchOptions = {}) {
  const res = await fetching(
    "/cloudide/api/v3/common/GetUserToken",
    fetchOptions
  );
  const data = await (res == null ? void 0 : res.json());
  if (data.ResponseMetadata.Error) {
    throw new Error(data.ResponseMetadata.Error.Message);
  }
  const { Token, ExpiredAt, UserID } = data.Result;
  return {
    token: Token,
    expiredAt: ExpiredAt,
    userId: UserID
  };
}
function getGithubAuthUrl() {
  const clientId = "Iv1.80ad21cf142be33f";
  const redirectUrl = "";
  const state = encodeURIComponent(
    `twice_auth=true&redirect_url=${redirectUrl}`
  );
  const GITHUB_AUTH_URL = `https://github.com/login/oauth/authorize?client_id=${clientId}&state=${state}&redirect_uri=${encodeURIComponent(
    "https://ide-boei18n.bytedance.net/github-oauth-twice-redirect"
  )}`;
  return GITHUB_AUTH_URL;
}
function requestAppInfo(appName) {
  const OAuthMap = {
    ["GITHUB" /* Github */]: {
      isOauth: true,
      // "/cloudide/api/v3/public/github/CheckAuthorizationStatus",
      getAccessTokenUrl: "/cloudide/api/v3/public/github/GetAccessToken",
      oauthUrl: getGithubAuthUrl()
    },
    ["DEPLOY" /* Deploy */]: {
      isOauth: false,
      getAccessTokenUrl: "/cloudide/api/v3/common/GetDeploymentUserToken"
    }
  };
  if (appName in OAuthMap) {
    return Promise.resolve(OAuthMap[appName]);
  }
  return Promise.reject(new Error(`not supported appName ${appName}`));
}
async function requestThirdPartyToken(getAccessTokenUrl) {
  const res = await fetching(getAccessTokenUrl, {
    maxRetryTimes: 1
  });
  const data = await (res == null ? void 0 : res.json());
  if (data.ResponseMetadata.Error) {
    throw new Error(data.ResponseMetadata.Error.Message);
  }
  const { AccessToken } = data.Result;
  return {
    token: AccessToken
  };
}
async function requestSecondPartyToken(getAccessTokenUrl, token) {
  const res = await fetching(getAccessTokenUrl, {
    headers: {
      "X-Cloudide-Token": token || ideToken
    }
  });
  const data = await (res == null ? void 0 : res.json());
  if (data.ResponseMetadata.Error) {
    throw new Error(data.ResponseMetadata.Error.Message);
  }
  const { Token, ExpiredAt } = data.Result;
  return {
    token: Token,
    expiredAt: ExpiredAt
  };
}
async function requestUserInfo(param, fetchOptions = {}) {
  const res = await fetching(
    (param == null ? void 0 : param.baseUrl) ? `${param == null ? void 0 : param.baseUrl}/cloudide/api/v3/public/GetUserInfo` : "/cloudide/api/v3/public/GetUserInfo",
    {
      ...fetchOptions,
      body: JSON.stringify(param)
    }
  );
  const data = await (res == null ? void 0 : res.json());
  if (data.ResponseMetadata.Error) {
    throw new Error(data.ResponseMetadata.Error.Message);
  }
  const { ScreenName, Gender, AvatarUrl, Description, TenantID, UserID } = data.Result;
  return {
    name: ScreenName,
    gender: Gender,
    avatar: AvatarUrl,
    description: Description,
    userId: UserID,
    tenantId: TenantID,
    ...data.Result
  };
}
async function requestLogout(token) {
  const res = await fetching("/cloudide/api/v3/public/Logout", {
    headers: {
      "X-Cloudide-Token": token || ideToken
    }
  });
  const data = await (res == null ? void 0 : res.json());
  if (data.ResponseMetadata.Error) {
    throw new Error(data.ResponseMetadata.Error.Message);
  }
}

// src/web/index.ts
function redirectToLogin() {
  if (typeof window === "undefined") {
    return;
  }
  const customRedirectUrl = getRedirectUrl();
  if (customRedirectUrl) {
    window.location.href = customRedirectUrl;
    return;
  }
  const webUrl2 = getWebUrl();
  window.location.href = `${webUrl2}/login?redirect_url=${encodeURIComponent(location.href)}`;
}
function openPage(url, waitForClose = false) {
  if (typeof window === "undefined") {
    return;
  }
  const w = 600;
  const h = 600;
  const dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
  const systemZoom = width / window.screen.availWidth;
  const left = (width - w) / 2 / systemZoom + dualScreenLeft;
  const top = (height - h) / 2 / systemZoom + dualScreenTop;
  return new Promise((resolve, reject) => {
    const handler = window.open(
      url,
      "GitHubAuth",
      [
        "popup=yes",
        `width=${w}`,
        `height=${h}`,
        `left=${left}`,
        `top=${top}`
      ].join(",")
    );
    if (!handler) {
      return reject(new Error("Failed to open"));
    }
    handler.focus();
    if (!waitForClose) {
      return resolve("");
    }
    function msgHandler(e) {
      console.log("listen", e);
      if (e.origin === window.location.origin) {
        return resolve("");
      }
      window.removeEventListener("message", msgHandler);
    }
    window.addEventListener("message", msgHandler);
    const timer = setInterval(() => {
      if (handler == null ? void 0 : handler.closed) {
        timer && clearInterval(timer);
        return resolve("");
      }
    }, 1e3);
    setTimeout(
      () => {
        timer && clearInterval(timer);
        return reject(new Error("Oauth timeout."));
      },
      1e3 * 60 * 5
    );
  });
}

// src/web/user.ts
function getToken(fetchOptions) {
  return requestUserToken(fetchOptions);
}

// src/login.ts
async function getUserToken(needLogin, fetchOptions) {
  try {
    const token = await getToken(fetchOptions);
    setIdeToken(token.token);
    return token;
  } catch (e) {
    if (needLogin) {
      redirectToLogin();
    } else {
      throw new RedirectError(e.message || "login failed", {});
    }
  }
}
async function getThirdPartyToken(appName, needLogin) {
  const { getAccessTokenUrl, oauthUrl, isOauth } = await requestAppInfo(appName);
  if (isOauth) {
    try {
      const token = await requestThirdPartyToken(getAccessTokenUrl);
      return token;
    } catch (e) {
      if (needLogin && oauthUrl) {
        await openPage(oauthUrl);
        return await requestThirdPartyToken(getAccessTokenUrl);
      }
      throw new RedirectError(e.message || "login failed", {
        url: oauthUrl
      });
    }
  } else {
    return await requestSecondPartyToken(getAccessTokenUrl);
  }
}
var RedirectError = class extends Error {
  constructor(message, data) {
    super(message);
    this.data = data;
    this.name = "RedirectError";
  }
};

// src/index.ts
var AuthPlatformTypes = /* @__PURE__ */ ((AuthPlatformTypes2) => {
  AuthPlatformTypes2["Ide"] = "IDE";
  AuthPlatformTypes2["Github"] = "GITHUB";
  AuthPlatformTypes2["Deploy"] = "DEPLOY";
  return AuthPlatformTypes2;
})(AuthPlatformTypes || {});
var ICubeAuthClient = class {
  constructor(config, defaultRequestOptions2) {
    __publicField(this, "_cache");
    if (!(config == null ? void 0 : config.baseUrl)) {
      throw new Error("baseUrl is required");
    }
    setBaseUrl(config.baseUrl);
    if (config.webUrl) {
      setWebUrl(config.webUrl);
    }
    if (config.redirectLoginUrl) {
      setRedirectLoginUrl(config.redirectLoginUrl);
    }
    defaultRequestOptions2 && setRequestOptions(defaultRequestOptions2);
    this._cache = new AuthCache(config);
    const lastToken = this._cache.getToken("IDE");
    lastToken && setIdeToken(lastToken.token);
  }
  async getAuthToken(appName, options = { needLogin: false, force: false }) {
    const { needLogin, force, fetchOptions } = options;
    if (!force) {
      const lastToken = this._cache.getToken(appName);
      if (lastToken) {
        return lastToken;
      }
    }
    let getTokenP = null;
    switch (appName) {
      case "IDE" /* Ide */:
        getTokenP = getUserToken(needLogin, fetchOptions);
        break;
      case "GITHUB" /* Github */:
      case "DEPLOY" /* Deploy */:
        await this.getAuthToken("IDE" /* Ide */, {
          needLogin
        });
        getTokenP = getThirdPartyToken(appName, needLogin);
        break;
      default:
        console.warn(`appName ${appName} is not supported`);
        break;
    }
    return getTokenP == null ? void 0 : getTokenP.then((token) => {
      if (token) {
        this._cache.set(appName, JSON.stringify(token));
      }
      return token;
    });
  }
  updateTokenCache(appName, token) {
    this._cache.set(appName, JSON.stringify(token));
    if (appName === "IDE" /* Ide */) {
      setIdeToken(token.token);
    }
  }
  async getUserInfo(options = {
    needLogin: false
  }) {
    const params = {
      ...options.params || options.requestOptions
    };
    delete options.params;
    delete options.requestOptions;
    await this.getAuthToken("IDE" /* Ide */, options);
    return requestUserInfo(params, options.fetchOptions);
  }
  async logout(token) {
    if (!token && !getIdeToken()) {
      await this.getAuthToken("IDE" /* Ide */, {
        needLogin: false
      });
    }
    await requestLogout(token);
    this._cache.clear();
    redirectToLogin();
    return;
  }
  async requestDeployToken(ideToken2) {
    const { getAccessTokenUrl } = await requestAppInfo(
      "DEPLOY" /* Deploy */
    );
    return await requestSecondPartyToken(getAccessTokenUrl, ideToken2).then(
      (token) => {
        if (token) {
          this._cache.set("DEPLOY" /* Deploy */, JSON.stringify(token));
        }
        return token;
      }
    );
  }
};
export {
  AuthPlatformTypes,
  ICubeAuthClient
};
