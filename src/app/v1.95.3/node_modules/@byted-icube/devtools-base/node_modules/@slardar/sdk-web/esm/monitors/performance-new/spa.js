import { __read } from "tslib";
import { noop } from '@slardar/sdk-template';
import { applyMutationObserver } from '../../utils';
import { now } from '../../utils/date';
import { applyIncompleteReq } from '../action';
import { shouldIgnoreUrl, waitActionComplete } from '../action/util';
import { initMetric } from '../performance/util';
import { SPA_LOAD_METRIC_NAME, applyReportMetric } from './util';
var MAX_PAGE_DELAY = 30000;
export var getSPA = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 7), pvObserver = _b[0], clickObserver = _b[1], xhrObserver = _b[2], fetchObserver = _b[3], resourceObserver = _b[4], longtaskObserver = _b[5], MutationObserver = _b[6];
    var ignoreUrls = config.ignoreUrls;
    var spa_load_start = 0;
    var reportMetric = applyReportMetric(report);
    var startSPA = function () {
        spa_load_start = now();
        observe(document, {
            childList: true,
            subtree: true,
        });
        start();
    };
    var reportSPAIfAllowed = function (force) {
        // no spa start || not force but there are still pending requests
        if (!spa_load_start || (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        reportMetric(initMetric(SPA_LOAD_METRIC_NAME, now() - spa_load_start));
        endSPA();
    };
    var endSPA = function () {
        complete();
        spa_load_start = 0;
    };
    // get schedule function and set an empty forceClear
    var _c = __read(waitActionComplete(window, reportSPAIfAllowed, noop, MAX_PAGE_DELAY), 3), start = _c[0], notify = _c[1], complete = _c[2];
    // request
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify, ignoreUrls);
    // resource
    tearDownGroup.push(resourceObserver[0](function (_a) {
        var name = _a.name;
        if (shouldIgnoreUrl(ignoreUrls, name)) {
            return;
        }
        notify();
    }));
    // longtask
    tearDownGroup.push(longtaskObserver[0](notify));
    // dom
    var _d = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _d[0], disconnect = _d[1];
    tearDownGroup.push(disconnect);
    var isFirstPV = true;
    // start SPA when PV change
    tearDownGroup.push(pvObserver[0](function () {
        if (isFirstPV) {
            isFirstPV = false;
            return;
        }
        // force report last SPA
        reportSPAIfAllowed(true);
        // clear status
        endSPA();
        // start a new SPA metric
        startSPA();
    }));
    // force report last SPA and clear status when the click is triggered
    tearDownGroup.push(clickObserver[0](function () {
        // force report last SPA
        reportSPAIfAllowed(true);
        // clear status
        endSPA();
    }));
    // reset SPA status when tear down
    tearDownGroup.push(endSPA);
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/sdk-web/esm/monitors/performance-new/spa.js.map