import { __read, __values } from "tslib";
import { PERFORMANCE_METRIC_EV_TYPE, LONG_TASK_EV_TYPE } from '../../constants';
import { now, getDefaultPerformance, applyPerformance } from '../../utils';
import { initMetric } from '../performance/util';
export var applySendOnceAndTearDown = function (wrapPerformanceMetric, report, tearDownGroup) {
    var hasInvoked = false;
    return function (metric) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                v();
            });
        tearDownGroup.length = 0;
        if (hasInvoked)
            return;
        hasInvoked = true;
        report && report(wrapPerformanceMetric(metric));
    };
};
export var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: PERFORMANCE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
export var wrapLongtask = function (entry) { return ({
    ev_type: LONG_TASK_EV_TYPE,
    payload: {
        type: 'perf',
        longtasks: [entry],
    },
}); };
export var applyReportMetric = function (report) {
    return function (metric, overrides) {
        report(wrapPerformanceMetric(metric, overrides));
    };
};
export var SPA_LOAD_METRIC_NAME = 'spa_load';
export var getSPA = function (report) {
    var startTime = 0;
    var metric = initMetric(SPA_LOAD_METRIC_NAME, 0);
    var invokeCb = function (load_time) {
        metric.value = load_time;
        report && report(wrapPerformanceMetric(metric));
    };
    var performanceInit = function () {
        startTime = now();
    };
    var performanceSend = function () {
        invokeCb(now() - startTime);
        startTime = 0;
    };
    return [performanceInit, performanceSend];
};
export var getNavigationEntry = function () {
    var performance = getDefaultPerformance();
    var _a = __read(applyPerformance(performance), 3), getEntriesByType = _a[2];
    return getEntriesByType('navigation')[0];
};
export var getActivationStart = function () {
    var navEntry = getNavigationEntry();
    // @ts-expect-error
    return (navEntry && navEntry.activationStart) || 0;
};
export function getWorstElement(worstEntry) {
    var e_1, _a;
    var _b;
    var withNodeSources = (_b = worstEntry === null || worstEntry === void 0 ? void 0 : worstEntry.sources) === null || _b === void 0 ? void 0 : _b.filter(function (it) { return !!it.node; });
    if (!withNodeSources || !withNodeSources.length) {
        return undefined;
    }
    if (withNodeSources.length === 1) {
        return withNodeSources[0].node;
    }
    var worstScore = 0, worstElement;
    try {
        for (var withNodeSources_1 = __values(withNodeSources), withNodeSources_1_1 = withNodeSources_1.next(); !withNodeSources_1_1.done; withNodeSources_1_1 = withNodeSources_1.next()) {
            var source = withNodeSources_1_1.value;
            var score = getLayoutShiftScore(source);
            if (score > worstScore) {
                worstScore = score;
                worstElement = source.node;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (withNodeSources_1_1 && !withNodeSources_1_1.done && (_a = withNodeSources_1.return)) _a.call(withNodeSources_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return worstElement;
}
// calculate layout-shift-socre. algorithm detail: https://web.dev/articles/cls#layout-shift-score
export var getLayoutShiftScore = function (layoutShiftSource) {
    var previousRect = layoutShiftSource.previousRect, currentRect = layoutShiftSource.currentRect;
    var viewportWidth = window.innerWidth * window.devicePixelRatio;
    var viewportHeight = window.innerHeight * window.devicePixelRatio;
    var impactFraction = getImpactFraction();
    var distanceFraction = getDistanceFraction();
    return impactFraction * distanceFraction;
    function getImpactFraction() {
        var intersectionLeft = Math.max(currentRect.left, previousRect.left);
        var intersectionRight = Math.min(currentRect.right, previousRect.right);
        var intersectionTop = Math.max(currentRect.top, previousRect.top);
        var intersectionBottom = Math.min(currentRect.bottom, previousRect.bottom);
        var intersectionWidth = intersectionRight - intersectionLeft;
        var intersectionHeight = intersectionBottom - intersectionTop;
        // calculate intersection area
        var intersectionArea = intersectionWidth <= 0 || intersectionHeight <= 0 ? 0 : intersectionWidth * intersectionHeight;
        // (current area + previous area - intersection area) / (viewport area)
        return Math.min((currentRect.width * currentRect.height + previousRect.width * previousRect.height - intersectionArea) /
            (viewportHeight * viewportWidth), 1);
    }
    function getDistanceFraction() {
        var _a = getCurrentRectPosition(), x = _a.x, y = _a.y;
        var _b = getPreviousRectPosition(), previousX = _b.x, previousY = _b.y;
        // calculate max move distance
        var maxMoveDistance = Math.max(Math.abs(x - previousX), Math.abs(y - previousY));
        // calculate max viewport length
        var maxViewPortLength = Math.max(viewportWidth, viewportHeight);
        return Math.min(maxMoveDistance / maxViewPortLength, 1);
    }
    function getCurrentRectPosition() {
        // if not all attributes are 0, we can use the cls attributes directly
        if (currentRect.x !== 0 || currentRect.y !== 0 || currentRect.width !== 0 || currentRect.height !== 0) {
            return { x: currentRect.x, y: currentRect.y };
        }
        // else the element current is totally moves off the screen, but we don't known which direction it moves off from cls attributes
        // we simply assume it moves to the bottom side of the screen
        return { x: currentRect.x, y: viewportHeight };
    }
    function getPreviousRectPosition() {
        // if not all attributes are 0, we can use the cls attributes directly
        if (previousRect.x !== 0 || previousRect.y !== 0 || previousRect.width !== 0 || previousRect.height !== 0) {
            return { x: previousRect.x, y: previousRect.y };
        }
        // else the element previous is totally out of the screen, but we don't known which direction it moves in from cls attributes
        // we simply assume it moves in from the bottom side of screen
        return { x: previousRect.x, y: viewportHeight };
    }
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/sdk-web/esm/monitors/performance-new/util.js.map