import { __assign } from "tslib";
import { isNumber } from '@slardar/sdk-template';
import { JS_ERROR_EV_TYPE, HTTP_EV_TYPE, RESOURCE_ERROR_EV_TYPE, CUSTOM_EV_TYPE, PERFORMANCE_METRIC_EV_TYPE, PERFORMANCE_TIMING_EV_TYPE, LONG_TASK_EV_TYPE, } from '../../constants';
import { getDefaultPromise, applyRequestIdleCallback, now } from '../../utils';
export var DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
export var ERROR_RELATED_TYPE = [JS_ERROR_EV_TYPE, HTTP_EV_TYPE, RESOURCE_ERROR_EV_TYPE];
export var DEFAULT_THRESHOLD = 1.5;
export var MAX_RENDER_TIME = 10000;
export var MAX_CHECK_TIME = 8000;
export var DEFAULT_CHECK_TIME = 4000;
export var MAX_RELATED_TIME = 10000;
export var DEFAULT_T0_DATA_URL_QUALITY = 0.1;
export var DEFAULT_MAX_DEPTH = 4;
var CHECK_EXCLUSIVE_EV_TYPES = [
    PERFORMANCE_METRIC_EV_TYPE,
    LONG_TASK_EV_TYPE,
    PERFORMANCE_TIMING_EV_TYPE,
    CUSTOM_EV_TYPE,
];
export var isSkipBeforeCheck = function (ev) { return ~CHECK_EXCLUSIVE_EV_TYPES.indexOf(ev.ev_type); };
export var blankErrorCompare = function (relatedError, ev) {
    if (ERROR_RELATED_TYPE.indexOf(ev.ev_type) === -1)
        return relatedError;
    if (ev.ev_type === HTTP_EV_TYPE && ev.payload.response.status < 400) {
        return relatedError;
    }
    if (relatedError && ERROR_RELATED_TYPE.indexOf(relatedError.type) < ERROR_RELATED_TYPE.indexOf(ev.ev_type)) {
        return relatedError;
    }
    var message = '';
    switch (ev.ev_type) {
        case JS_ERROR_EV_TYPE:
            message = ev.payload.error.message;
            break;
        case HTTP_EV_TYPE:
            message = ev.payload.request.url;
            break;
        case RESOURCE_ERROR_EV_TYPE:
            message = ev.payload.url;
            break;
        default:
            break;
    }
    return { type: ev.ev_type, message: message, timestamp: now() };
};
var isSkipMeasure = function (element, depth) {
    return ~DEFAULT_IGNORE_TAGS.indexOf(element.tagName) || depth > DEFAULT_MAX_DEPTH;
};
var getBounding = function (element) {
    var _a = element.getBoundingClientRect(), width = _a.width, height = _a.height, top = _a.top;
    return { width: width, height: height, top: top };
};
export var getElementByRootSelector = function (rootSelector) {
    return rootSelector ? document.querySelector(rootSelector) : document.body;
};
export var measure = function (element, depth, sum, threshold) {
    if (depth === void 0) { depth = 0; }
    if (sum === void 0) { sum = 0; }
    if (threshold === void 0) { threshold = DEFAULT_THRESHOLD; }
    if (!element || isSkipMeasure(element, depth) || sum >= threshold) {
        return sum;
    }
    var score = (function () {
        // skip the first level element
        if (!depth)
            return 0;
        var _a = getBounding(element), top = _a.top, height = _a.height;
        // (1 << (depth - 1)) === Math.pow(2, depth - 1)
        return top > innerHeight || height <= 0 ? 0 : 1 / (1 << (depth - 1));
    })();
    return [].reduceRight.call(element.children, function (all, child) { return measure(child, depth + 1, all, threshold); }, sum + score);
};
/**
 * Serializes an HTML element and its children to a string representation.
 *
 * @param {Element | undefined | null} element - The element to serialize.
 * @param {number} [depth=0] - The depth of the element in the DOM tree.
 * @param {boolean} [onceAttributeFlag=true] - Whether to include the innerHeight attribute.
 * @return {string} The serialized string representation of the HTML element and its children.
 */
export function serializeDom2String(element, depth, onceAttributeFlag) {
    if (depth === void 0) { depth = 0; }
    if (onceAttributeFlag === void 0) { onceAttributeFlag = true; }
    if (!element || isSkipMeasure(element, depth))
        return '';
    var attributeGathering = __assign(__assign({}, getBounding(element)), { id: element.getAttribute('id'), class: element.getAttribute('class') });
    var attrString = Object.keys(attributeGathering).reduce(function (accumulator, key) {
        return "" + accumulator + (isNumber(attributeGathering[key]) || attributeGathering[key] ? " " + key + "=\"" + attributeGathering[key] + "\"" : '');
    }, '');
    var tagName = element.tagName.toLowerCase();
    var children = [].reduce.call(element.children, function (acc, child) { return acc + serializeDom2String(child, depth + 1, false); }, '');
    return "<" + tagName + attrString + (onceAttributeFlag ? " innerHeight=\"" + innerHeight + "\"" : '') + ">" + children + "</" + tagName + ">";
}
/* c8 ignore start */
export var screenshot = function (_a) {
    var _b;
    var cb = _a.cb, screenshotUrl = _a.screenshotUrl, window = _a.window, document = _a.document, mask = _a.mask, partialShot = _a.partialShot, quality = _a.quality, rootSelector = _a.rootSelector;
    if (!getDefaultPromise() || !window || !document) {
        return;
    }
    function onload() {
        var requestIdleCallback = applyRequestIdleCallback(window);
        requestIdleCallback(function () {
            window.html2canvas &&
                window.html2canvas((partialShot && rootSelector && document.querySelector(rootSelector)) || document.body, {
                    scale: 360 / window.innerWidth,
                    mask: mask,
                })
                    .then(function (canvas) {
                    cb(handleBase64(canvas.toDataURL('image/jpeg', quality)));
                })
                    .catch(function () {
                    cb(getBlankImageBase64());
                });
        });
    }
    if (window.html2canvas) {
        return onload();
    }
    var script = document.createElement('script');
    script.src = screenshotUrl;
    script.crossOrigin = 'anonymous';
    script.onload = onload;
    script.onerror = function () {
        cb();
    };
    // eslint-disable-next-line compat/compat
    (_b = document.head) === null || _b === void 0 ? void 0 : _b.appendChild(script);
};
/* c8 ignore end */
/**
 *
 * @param base64
 * @see https://html2canvas.hertzen.com/faq#why-is-the-produced-canvas-empty-or-cuts-off-half-way-through
 * @returns
 */
export function handleBase64(base64) {
    // if element's width or height is 0 or greater than maximum canvas size, html2canvas will return "data:," in base64
    return base64.slice(0, 10) === 'data:image' ? base64 : getBlankImageBase64();
}
/**
 * Creates a blank image of the specified width and height and returns it as a
 * base64-encoded JPEG data URL.
 *
 * @param {number} width - The desired width of the image in pixels.
 * @param {number} height - The desired height of the image in pixels.
 * @returns {string} The base64-encoded JPEG data URL of the blank image.
 */
/* c8 ignore start */
function getBlankImageBase64(width, height) {
    if (width === void 0) { width = 192; }
    if (height === void 0) { height = 108; }
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    if (ctx) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
    }
    return canvas.toDataURL('image/jpeg');
}
/* c8 ignore stop *///# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/sdk-web/esm/monitors/blank-screen/util.js.map