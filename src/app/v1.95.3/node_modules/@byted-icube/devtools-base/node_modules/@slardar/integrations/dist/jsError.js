'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
var objProto = Object.prototype;
// https://stackoverflow.com/a/5878101
function isPlainObject(o) {
    if (isObject(o)) {
        if (typeof Object.getPrototypeOf === 'function') {
            var proto = Object.getPrototypeOf(o);
            return proto === objProto || proto === null;
        }
        // cannot test, requires ES3
        /* istanbul ignore next */
        return objProto.toString.call(o) === '[object Object]';
    }
    return false;
}
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}
function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            /* istanbul ignore next */
            return true;
        case '[object DOMError]':
            return true;
        case '[object DOMException]':
            /* istanbul ignore next */
            return true;
        default:
            /* istanbul ignore next */
            return wat instanceof Error;
    }
}
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
function isErrorEvent(what) {
    return Object.prototype.toString.call(what) === '[object ErrorEvent]';
}
function isPromiseRejectionEvent(what) {
    return Object.prototype.toString.call(what) === '[object PromiseRejectionEvent]';
}

var pick = function (obj, keys) {
    if (!obj || !isObject(obj))
        return obj;
    return keys.reduce(function (prev, cur) {
        prev[cur] = obj[cur];
        return prev;
    }, {});
};

function getRegexp(ignore) {
    if (!isArray(ignore)) {
        return null;
    }
    return ignore.length ? joinRegExp(ignore) : null;
}
function joinRegExp(patterns) {
    var sources = [];
    var len = patterns.length;
    for (var i = 0; i < len; i++) {
        var pattern = patterns[i];
        if (isString(pattern)) {
            sources.push(pattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'));
        }
        else if (pattern && pattern.source) {
            sources.push(pattern.source);
        }
    }
    return new RegExp(sources.join('|'), 'i');
}
function safeStringify(a) {
    try {
        return isString(a) ? a : JSON.stringify(a);
    }
    catch (err) {
        return '[FAILED_TO_STRINGIFY]:' + String(err);
    }
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultXMLHttpRequest() {
    if (typeof XMLHttpRequest === 'function' && isFunction(XMLHttpRequest))
        return XMLHttpRequest;
}

// 获取全局注册表
var getGlobalRegistry = function (global) {
    if (!global)
        return;
    if (!global.__SLARDAR_REGISTRY__) {
        global.__SLARDAR_REGISTRY__ = {
            Slardar: {
                plugins: [],
                errors: [],
                subject: {},
            },
        };
    }
    return global.__SLARDAR_REGISTRY__.Slardar;
};
var reportSelfError = function () {
    var errorInfo = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        errorInfo[_i] = arguments[_i];
    }
    var registry = getGlobalRegistry(getDefaultBrowser());
    if (!registry)
        return;
    if (!registry.errors) {
        registry.errors = [];
    }
    registry.errors.push(errorInfo);
};

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var getConfig = function (c, defaultConfig) {
    if (isObject(c)) {
        return __assign(__assign({}, defaultConfig), c);
    }
    else {
        return c ? defaultConfig : false;
    }
};

var JS_ERROR_EV_TYPE = 'js_error';

var ERROR_FIELDS = ['name', 'message', 'stack', 'filename', 'lineno', 'colno'];
var normalize = function (ex) {
    var error;
    if (!isError(ex)) {
        if (isPlainObject(ex) || isEvent(ex) || isString(ex)) {
            error = {
                message: safeStringify(ex),
            };
        }
    }
    else {
        error = pick(ex, ERROR_FIELDS);
    }
    return error;
};
var normalizeError = function (event) {
    var normalizedError = normalize(event.error);
    // If normalizedError is null or undefined, return it immediately
    if (!normalizedError) {
        return normalizedError;
    }
    // when event.error does not have filename、colno、lineno, use event's
    var colno = event.colno, lineno = event.lineno, filename = event.filename;
    if (colno && !normalizedError.colno) {
        normalizedError.colno = String(colno);
    }
    if (lineno && !normalizedError.lineno) {
        normalizedError.lineno = String(lineno);
    }
    if (filename && !normalizedError.filename) {
        normalizedError.filename = filename;
    }
    return normalizedError;
};
var normalizeException = function (event) {
    var _a;
    // dig the object of the rejection out of known event types
    try {
        var error = void 0;
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in event) {
            error = event.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in event && 'reason' in event.detail) {
            error = event.detail.reason;
        }
        if (error) {
            var rejectionError = normalize(error);
            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
            return __assign(__assign({}, rejectionError), { name: (_a = (rejectionError && rejectionError.name)) !== null && _a !== void 0 ? _a : 'UnhandledRejection' });
        }
    }
    catch (_oO) {
        // no-empty
    }
};
var normalizeUnknownError = function (exception) {
    if (isErrorEvent(exception)) {
        return normalizeError(exception);
    }
    else if (isPromiseRejectionEvent(exception)) {
        return normalizeException(exception);
    }
    else {
        return normalize(exception);
    }
};

var DEFAULT_EVENT_TARGET = [
    'EventTarget',
    'Window',
    'Node',
    'ApplicationCache',
    'ChannelMergerNode',
    'EventSource',
    'FileReader',
    'HTMLUnknownElement',
    'IDBDatabase',
    'IDBRequest',
    'IDBTransaction',
    'MessagePort',
    'Notification',
    'SVGElementInstance',
    'Screen',
    'TextTrack',
    'TextTrackCue',
    'TextTrackList',
    'WebSocket',
    'Worker',
    'XMLHttpRequest',
    'XMLHttpRequestEventTarget',
    'XMLHttpRequestUpload',
];
var DEFAULT_TIME_FUNCTION = [
    'setTimeout',
    'setInterval',
    'requestAnimationFrame',
    'requestIdleCallback',
];
var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
var ADD_EVENT_LISTENER = 'addEventListener';
var REMOVE_EVENT_LISTENER = 'removeEventListener';
var DEFAULT_SOURCE_TYPE = 'capture-global';
var observeAsyncErrorWithSource = function (next, tearDown) {
    var window = getDefaultBrowser();
    var xhr = getDefaultXMLHttpRequest();
    var restoreFns = [];
    var wrap = function (fn, sourceData) {
        if (!isFunction(fn))
            return fn;
        var source = {
            type: DEFAULT_SOURCE_TYPE,
            data: __assign({}, sourceData),
        };
        var hookFn = (fn._w_ || (fn._w_ = function () {
            try {
                // NOTE: If you are a Slardar user, and you are seeing this stack frame, it
                //       means the Slardar SDK caught an error invoking your application code. This
                //       is expected behavior and NOT indicative of a bug with Slardar SDK.
                return (fn.handleEvent && isFunction(fn.handleEvent) ? fn.handleEvent : fn).apply(this, [].map.call(arguments, function (arg) { return wrap(arg, sourceData); }));
            }
            catch (e) {
                var error = normalize(e);
                error && next({ source: source, error: error });
                throw e;
            }
        }));
        hookFn._hook_ = true;
        return hookFn;
    };
    window && restoreFns.push.apply(restoreFns, __spreadArray([], __read(DEFAULT_TIME_FUNCTION.filter(function (timeFunc) { return window[timeFunc]; }).map(function (timeFunc) {
        return hookObjectProperty(window, timeFunc, function (origin) {
            return function (handler) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return (origin && origin.call.apply(origin, __spreadArray([this,
                    wrap(handler, {
                        function: timeFunc,
                    })], __read(params), false)));
            };
        }, false)();
    })), false));
    xhr &&
        xhr.prototype &&
        restoreFns.push(hookObjectProperty(xhr.prototype, 'send', function (origin) {
            return function () {
                var _this = this;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                // filter 防御一个 xhr 实例被多次 send 导致 wrap 多次的情况
                xmlHttpRequestProps
                    .filter(function (prop) { return _this[prop] && !_this[prop]._hook_; })
                    .forEach(function (prop) {
                    // never restore xhr instance callback
                    _this[prop] = wrap(_this[prop], { function: prop });
                });
                return origin.apply(this, params);
            };
        }, false)());
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var proto = window && window[target] && window[target].prototype;
        if (!proto || !proto[ADD_EVENT_LISTENER]) {
            return;
        }
        restoreFns.push(hookObjectProperty(proto, ADD_EVENT_LISTENER, function (origin) {
            return function (evName, fn, options) {
                try {
                    var handleEventFn = fn.handleEvent;
                    if (isFunction(handleEventFn)) {
                        fn.handleEvent = wrap(handleEventFn, { function: 'handleEvent', target: target });
                    }
                }
                catch (_a) {
                    //
                }
                return origin && origin.call(this, evName, wrap(fn, { function: ADD_EVENT_LISTENER, target: target }), options);
            };
        }, false)());
        restoreFns.push(hookObjectProperty(proto, REMOVE_EVENT_LISTENER, function (origin) {
            return function (eventName, fn, options) {
                if (fn === null || fn === void 0 ? void 0 : fn._w_) {
                    origin.call(this, eventName, fn._w_, options);
                }
                return origin.call(this, eventName, fn, options);
            };
        }, false)());
    });
    tearDown(function () { return restoreFns.forEach(function (fn) { return fn(); }); });
};
var ASYNC_ERROR_SUBJECT_NAME = 'async_error_0';
var asyncErrorWithSourceSubject = [
    ASYNC_ERROR_SUBJECT_NAME,
    observeAsyncErrorWithSource,
];

var ERROR_SUBJECT_NAME = 'err_0';
var observeError = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var removeListener = addListenerToWindow(window, 'error', next, true);
    tearDown(function () {
        removeListener();
    });
};
var errorSubject = [ERROR_SUBJECT_NAME, observeError];
var PROMISE_REJECTION_SUBJECT_NAME = 'perr_0';
var observePromiseRejection = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var removeListener = addListenerToWindow(window, 'unhandledrejection', next, true);
    tearDown(function () {
        removeListener();
    });
};
var promiseRejectionSubject = [
    PROMISE_REJECTION_SUBJECT_NAME,
    observePromiseRejection,
];

var isSameErrorString = function (current, previous) {
    return current && previous && current === previous;
};
var shouldDropEvent = function (currentError, previousError) {
    if (!currentError || !previousError) {
        return false;
    }
    if (isSameErrorString(currentError.message, previousError.message) &&
        isSameErrorString(currentError.stack, previousError.stack)) {
        return true;
    }
    return false;
};
var dedupe = function () {
    var __previousError;
    return function (currentError) {
        // just in case something goes wrong
        try {
            if (shouldDropEvent(currentError, __previousError)) {
                __previousError = currentError;
                return undefined;
            }
        }
        catch (e) {
            reportSelfError(e);
        }
        __previousError = currentError;
        return currentError;
    };
};

var jsErrorGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 3), errorObserver = _b[0], promiseRejectionObserver = _b[1], getAsyncErrorWithSourceObserver = _b[2];
    var ignoreErrors = config.ignoreErrors, onerror = config.onerror, onunhandledrejection = config.onunhandledrejection, dedupeFlag = config.dedupe, captureGlobalAsync = config.captureGlobalAsync;
    var ignoreRegExp = getRegexp(ignoreErrors);
    var dedupeFn = dedupe();
    var reportJsError = function (_a) {
        var error = _a.error, extra = _a.extra, react = _a.react, source = _a.source;
        var err = dedupeFlag ? dedupeFn(error) : error;
        if (!err || !err.message || (ignoreRegExp && ignoreRegExp.test(err.message))) {
            return;
        }
        report({
            ev_type: JS_ERROR_EV_TYPE,
            payload: {
                error: err,
                breadcrumbs: [],
                extra: extra,
                react: react,
                source: source,
            },
        });
    };
    onerror &&
        tearDownGroup.push(errorObserver[0](function (ev) { return reportJsError({ error: normalizeError(ev), source: { type: 'onerror' } }); }));
    onunhandledrejection &&
        tearDownGroup.push(promiseRejectionObserver[0](function (ev) {
            return reportJsError({ error: normalizeException(ev), source: { type: 'onunhandledrejection' } });
        }));
    captureGlobalAsync &&
        tearDownGroup.push(getAsyncErrorWithSourceObserver()[0](function (jsErrorPayload) {
            reportJsError(jsErrorPayload);
        }));
    return function (err, extra, react) {
        return reportJsError({ error: normalizeUnknownError(err), extra: extra, react: react, source: { type: 'manual' } });
    };
};

var JS_ERROR_MONITOR_PLUGIN_NAME = 'jsError';
var defaultConfig = {
    ignoreErrors: [],
    onerror: true,
    onunhandledrejection: true,
    captureGlobalAsync: false,
    dedupe: true,
};
function JsErrorMonitorBasePlugin(client, c) {
    // stop precollect listener no matter what is configured
    window.removeEventListener('error', client.pcErr, true);
    window.removeEventListener('unhandledrejection', client.pcRej, true);
    var config = getConfig(c, defaultConfig);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var reportJsError = jsErrorGetterWithContext(function (ev) {
        client.getBreadcrumbs && (ev.payload.breadcrumbs = client.getBreadcrumbs());
        client.report(ev);
    }, tearDownGroup, [
        initSubjectInGlobal(client, errorSubject),
        initSubjectInGlobal(client, promiseRejectionSubject),
        function () { return initSubjectInGlobal(client, asyncErrorWithSourceSubject); },
    ], config);
    registerTearDownGroup(client, JS_ERROR_MONITOR_PLUGIN_NAME, JS_ERROR_EV_TYPE, tearDownGroup);
    client.provide('captureException', reportJsError);
}

var JS_ERROR_INTEGRATION_NAME = JS_ERROR_MONITOR_PLUGIN_NAME;
var jsErrorPlugin = function (config) {
    if (config === void 0) { config = {}; }
    return ({
        name: JS_ERROR_INTEGRATION_NAME,
        setup: function (client) {
            JsErrorMonitorBasePlugin(client, config);
        },
    });
};

exports.JS_ERROR_INTEGRATION_NAME = JS_ERROR_INTEGRATION_NAME;
exports.jsErrorPlugin = jsErrorPlugin;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/jsError.js.map
