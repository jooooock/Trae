/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_SIZE = 10;
var DEFAULT_WAIT = 1000;
var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};
function createBatchSender(config) {
    var transport = config.transport;
    var endpoint = config.endpoint, _a = config.size, size = _a === void 0 ? DEFAULT_SIZE : _a, _b = config.wait, wait = _b === void 0 ? DEFAULT_WAIT : _b;
    var batch = [];
    var tid = 0;
    var fail;
    var sender = {
        getSize: function () {
            return size;
        },
        getWait: function () {
            return wait;
        },
        setSize: function (v) {
            size = v;
        },
        setWait: function (v) {
            wait = v;
        },
        getEndpoint: function () {
            return endpoint;
        },
        setEndpoint: function (v) {
            endpoint = v;
        },
        send: function (e) {
            batch.push(e);
            if (batch.length >= size) {
                sendBatch.call(this);
            }
            clearTimeout(tid);
            tid = setTimeout(sendBatch.bind(this), wait);
        },
        flush: function () {
            clearTimeout(tid);
            sendBatch.call(this);
        },
        getBatchData: function () {
            return batch.length ? stringifyBatch(batch) : '';
        },
        clear: function () {
            clearTimeout(tid);
            batch = [];
        },
        fail: function (cb) {
            fail = cb;
        },
    };
    function sendBatch() {
        if (!batch.length) {
            return;
        }
        var data = this.getBatchData();
        transport.post({
            url: endpoint,
            data: data,
            fail: function (err) {
                fail && fail(err, data);
            },
        });
        batch = [];
    }
    return sender;
}

var EVENTS = [
    'init',
    'start',
    'config',
    'beforeDestroy',
    'provide',
    'beforeReport',
    'report',
    'beforeBuild',
    'build',
    'beforeSend',
    'send',
    'beforeConfig',
];

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
var objProto = Object.prototype;
// https://stackoverflow.com/a/5878101
function isPlainObject(o) {
    if (isObject(o)) {
        if (typeof Object.getPrototypeOf === 'function') {
            var proto = Object.getPrototypeOf(o);
            return proto === objProto || proto === null;
        }
        // cannot test, requires ES3
        /* istanbul ignore next */
        return objProto.toString.call(o) === '[object Object]';
    }
    return false;
}
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isString(o) {
    return typeof o === 'string';
}
function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            /* istanbul ignore next */
            return true;
        case '[object DOMError]':
            return true;
        case '[object DOMException]':
            /* istanbul ignore next */
            return true;
        default:
            /* istanbul ignore next */
            return wat instanceof Error;
    }
}
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
function isErrorEvent(what) {
    return Object.prototype.toString.call(what) === '[object ErrorEvent]';
}
function isPromiseRejectionEvent(what) {
    return Object.prototype.toString.call(what) === '[object PromiseRejectionEvent]';
}

function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
// 把source对象中的内容深度赋给target, 数组合并
function mergeDeepConcatArray() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    var result = {};
    var k = 0;
    while (k < source.length) {
        result = _mergeDeepMergeArray(result, source[k++]);
    }
    return result;
}
// 递归赋值
function _mergeDeepMergeArray(target, source) {
    var result = __assign({}, target);
    for (var key in source) {
        if (hasKey(source, key) && source[key] !== undefined) {
            if (isObject(source[key]) && isPlainObject(source[key])) {
                result[key] = _mergeDeepMergeArray(isObject(target[key]) ? target[key] : {}, source[key]);
            }
            else if (isArray(source[key]) && isArray(target[key])) {
                result[key] = _mergeDeepArray(target[key], source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
    }
    return result;
}
function _mergeDeepArray(target, source) {
    var _target = isArray(target) ? target : [];
    var _source = isArray(source) ? source : [];
    return Array.prototype.concat.call(_target, _source).map(function (v) {
        if (v instanceof RegExp) {
            return v;
        }
        else if (isObject(v) && isPlainObject(v)) {
            return _mergeDeepMergeArray({}, v);
        }
        else if (isArray(v)) {
            return _mergeDeepArray([], v);
        }
        else {
            return v;
        }
    });
}
// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};
/**
 * 按路径访问对象属性
 * @param target 待访问对象
 * @param property 访问属性路径
 * @param { (target: any, property: string): any } visitor 访问器
 */
var safeVisit = function (target, path, visitor) {
    var _a, _b;
    var paths = path.split('.');
    var _c = __read(paths), method = _c[0], rest = _c.slice(1);
    while (target && rest.length > 0) {
        target = target[method];
        _a = rest, _b = __read(_a), method = _b[0], rest = _b.slice(1);
    }
    if (!target) {
        return undefined;
    }
    return visitor(target, method);
};
/**
 *  按路径调用函数
 * @param target 待调用对象，如 `client`
 * @param methods 待调用方法路径，可能是一级路径 `client.start`, 或者是多级命令 `client.context.set`
 * @param args 调用参数
 */
var safeCall = function (target, method, args) {
    return safeVisit(target, method, function (obj, property) {
        if (obj && property in obj && isFunction(obj[property])) {
            try {
                return obj[property].apply(obj, args);
            }
            catch (err) {
                // ignore
                return undefined;
            }
        }
    });
};
var pick = function (obj, keys) {
    if (!obj || !isObject(obj))
        return obj;
    return keys.reduce(function (prev, cur) {
        prev[cur] = obj[cur];
        return prev;
    }, {});
};

function safeStringify(a) {
    try {
        return isString(a) ? a : JSON.stringify(a);
    }
    catch (err) {
        return '[FAILED_TO_STRINGIFY]:' + String(err);
    }
}

function createContextAgent() {
    var context = {};
    var stringified = {};
    var contextAgent = {
        set: function (k, v) {
            context[k] = v;
            stringified[k] = safeStringify(v);
            return contextAgent;
        },
        merge: function (ctx) {
            context = __assign(__assign({}, context), ctx);
            Object.keys(ctx).forEach(function (key) {
                stringified[key] = safeStringify(ctx[key]);
            });
            return contextAgent;
        },
        delete: function (k) {
            delete context[k];
            delete stringified[k];
            return contextAgent;
        },
        clear: function () {
            context = {};
            stringified = {};
            return contextAgent;
        },
        get: function (k) {
            return stringified[k];
        },
        toString: function () {
            return __assign({}, stringified);
        },
    };
    return contextAgent;
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};

var getPrintString = function () {
    // @ts-expect-error
    if (''.padStart) {
        return function (str, prefixLength) {
            if (prefixLength === void 0) { prefixLength = 8; }
            return str.padStart(prefixLength, ' ');
        };
    }
    return function (str) { return str; };
};
var printString = getPrintString();
var errCount = 0;
var error = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.error.apply(console, __spreadArray(['[SDK]', Date.now(), printString("" + errCount++)], __read(args), false));
};
var warnCount = 0;
var warn = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.warn.apply(console, __spreadArray(['[SDK]', Date.now(), printString("" + warnCount++)], __read(args), false));
};

var isHitBySampleRate = function (sampleRate) {
    if (Math.random() < Number(sampleRate)) {
        return true;
    }
    return false;
};

var runProcessors = function (fns) {
    return function (e) {
        var r = e;
        for (var i = 0; i < fns.length; i++) {
            if (r) {
                try {
                    r = fns[i](r);
                }
                catch (err) {
                    error(err);
                }
            }
            else {
                break;
            }
        }
        return r;
    };
};
var runFilters = function (fns) {
    return function (e) {
        var r = true;
        for (var i = 0; i < fns.length; i++) {
            if (r) {
                try {
                    r = fns[i](e);
                }
                catch (err) {
                    error(err);
                }
            }
            else {
                break;
            }
        }
        return r;
    };
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};
var wrapFilters = function (originObservable, filters) {
    var _a = __read(originObservable, 1), subscribe = _a[0];
    var filteredObserver = function (next, tearDown) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        var unsubscribe = subscribe(function (o) {
            var hitFilter = runFilters(filters)(o);
            return hitFilter ? next(o) : noop;
        });
        tearDown(function () {
            unsubscribe();
        });
    };
    return filteredObserver;
};

function createDestroyAgent() {
    var destroyed = false;
    var data = {};
    var removeTearDownGroup = function (tearDownGroup) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                try {
                    v();
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { }
            });
        tearDownGroup.length = 0;
    };
    var removeByPluginName = function (pluginName) {
        data[pluginName] &&
            data[pluginName].forEach(function (e) {
                removeTearDownGroup(e[1]);
            });
        data[pluginName] = undefined;
    };
    var removeByEvType = function (evType) {
        Object.keys(data).forEach(function (k) {
            data[k] &&
                data[k].forEach(function (e) {
                    if (e[0] === evType) {
                        removeTearDownGroup(e[1]);
                    }
                });
        });
    };
    return {
        /**
         * register tearDownGroup for a single plugin.
         */
        set: function (pluginName, evType, tearDownGroup) {
            if (data[pluginName])
                data[pluginName].push([evType, tearDownGroup]);
            else
                data[pluginName] = [[evType, tearDownGroup]];
            // auto remove tearDownGroup if destroyed
            destroyed && removeTearDownGroup(tearDownGroup);
        },
        has: function (pluginName) {
            return !!data[pluginName];
        },
        /**
         * remove tearDownGroup for a single plugin.
         */
        remove: removeByPluginName,
        /**
         * remove tearDownGroup by event type
         */
        removeByEvType: removeByEvType,
        /**
         * clear all tearDownGroup
         */
        clear: function () {
            destroyed = true;
            Object.keys(data).forEach(function (k) {
                removeByPluginName(k);
            });
        },
    };
}

function createClient(creationConfig) {
    var builder = creationConfig.builder, createSender = creationConfig.createSender, createDefaultConfig = creationConfig.createDefaultConfig, createConfigManager = creationConfig.createConfigManager, userConfigNormalizer = creationConfig.userConfigNormalizer, initConfigNormalizer = creationConfig.initConfigNormalizer, validateInitConfig = creationConfig.validateInitConfig;
    var sender;
    var configManager;
    var handlers = {};
    EVENTS.forEach(function (e) { return (handlers[e] = []); });
    var inited = false;
    var started = false;
    var destroyed = false;
    // 缓存 start 之前 build 的事件
    var preStartQueue = [];
    // 禁止通过 provide 挂载的字段名
    var reservedNames = [];
    var destroyAgent = createDestroyAgent();
    var client = {
        getBuilder: function () { return builder; },
        getSender: function () { return sender; },
        getPreStartQueue: function () { return preStartQueue; },
        init: function (c) {
            if (inited) {
                warn('already inited');
                return;
            }
            if (c && isObject(c) && validateInitConfig(c)) {
                var defaultConfig = createDefaultConfig(c);
                if (!defaultConfig) {
                    throw new Error('defaultConfig missing');
                }
                var initConfig = initConfigNormalizer(c);
                configManager = createConfigManager(defaultConfig);
                configManager.setConfig(initConfig);
                configManager.onChange(function () {
                    handle('config');
                });
                sender = createSender(configManager.getConfig());
                if (!sender) {
                    throw new Error('sender missing');
                }
                inited = true;
                handle('init', true);
            }
            else {
                throw new Error('invalid InitConfig, init failed');
            }
        },
        set: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(c);
            }
        },
        config: function (c) {
            if (!inited) {
                return;
            }
            if (c && isObject(c)) {
                handle('beforeConfig', false, c);
                configManager === null || configManager === void 0 ? void 0 : configManager.setConfig(userConfigNormalizer(c));
            }
            return configManager === null || configManager === void 0 ? void 0 : configManager.getConfig();
        },
        provide: function (name, value) {
            if (arrayIncludes(reservedNames, name)) {
                warn("cannot provide " + name + ", reserved");
                return;
            }
            client[name] = value;
            handle('provide', false, name);
        },
        start: function () {
            var _this = this;
            if (!inited) {
                return;
            }
            if (started) {
                return;
            }
            configManager === null || configManager === void 0 ? void 0 : configManager.onReady(function () {
                started = true;
                handle('start', true);
                preStartQueue.forEach(function (e) { return _this.build(e); });
                preStartQueue.length = 0;
            });
        },
        report: function (data) {
            if (!data) {
                return;
            }
            var preReport = runProcessors(handlers['beforeReport'])(data);
            if (!preReport) {
                return;
            }
            var processed = runProcessors(handlers['report'])(preReport);
            if (!processed) {
                return;
            }
            if (started) {
                this.build(processed);
            }
            else {
                preStartQueue.push(processed);
            }
        },
        build: function (data) {
            if (!started) {
                return;
            }
            var preBuild = runProcessors(handlers['beforeBuild'])(data);
            if (!preBuild) {
                return;
            }
            var built = builder.build(preBuild);
            if (!built) {
                return;
            }
            var processed = runProcessors(handlers['build'])(built);
            if (!processed) {
                return;
            }
            this.send(processed);
        },
        send: function (data) {
            if (!started) {
                return;
            }
            var processed = runProcessors(handlers['beforeSend'])(data);
            if (processed) {
                sender.send(processed);
                handle('send', false, processed);
            }
        },
        destroy: function () {
            destroyAgent.clear();
            destroyed = true;
            preStartQueue.length = 0;
            handle('beforeDestroy', true);
        },
        on: function (ev, handler) {
            if ((ev === 'init' && inited) || (ev === 'start' && started) || (ev === 'beforeDestroy' && destroyed)) {
                try {
                    ;
                    handler();
                }
                catch (_err) {
                    // ignore
                }
            }
            else if (handlers[ev]) {
                handlers[ev].push(handler);
            }
        },
        off: function (ev, handler) {
            if (handlers[ev])
                handlers[ev] = arrayRemove(handlers[ev], handler);
        },
        destroyAgent: destroyAgent,
    };
    reservedNames = Object.keys(client);
    return client;
    function handle(ev, once) {
        if (once === void 0) { once = false; }
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        handlers[ev].forEach(function (f) {
            try {
                f.apply(void 0, __spreadArray([], __read(args), false));
            }
            catch (_err) {
                // ignore
            }
        });
        if (once) {
            handlers[ev].length = 0;
        }
    }
}

var ContextPlugin = function (client) {
    var contextAgent = createContextAgent();
    client.provide('context', contextAgent);
    client.on('report', function (ev) {
        if (!ev.extra) {
            ev.extra = {};
        }
        ev.extra.context = contextAgent.toString();
        return ev;
    });
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var withCommandArray = function (client, captureContext, applyArgsWithContext) {
    // 缓存需要异步插件来消费的命令
    var cache = {};
    var newClient = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var methodPath = args[0];
        if (!methodPath)
            return;
        var method = methodPath.split('.')[0];
        // 捕获上下文，等异步插件加载后传入
        if (!(method in newClient)) {
            var cachedCommands = cache[method] || [];
            // 区分预收集来的上下文与普通上下文
            var capturedContext = (_a = captureContext === null || captureContext === void 0 ? void 0 : captureContext(client)) !== null && _a !== void 0 ? _a : {};
            cachedCommands.push(__spreadArray([capturedContext], __read(args), false));
            cache[method] = cachedCommands;
            return;
        }
        return safeCall(newClient, methodPath, [].slice.call(args, 1));
    };
    hookObjectProperty(client, 'provide', function (origin) {
        return function (name, value) {
            newClient[name] = value;
            origin.call(client, name, value);
        };
    })();
    for (var nextKey in client) {
        // Avoid bugs when hasOwnProperty is shadowed
        if (Object.prototype.hasOwnProperty.call(client, nextKey)) {
            newClient[nextKey] = client[nextKey];
        }
    }
    client.on('provide', function (name) {
        if (cache[name]) {
            cache[name].forEach(function (cachedCommands) {
                var _a = __read(cachedCommands), capturedContext = _a[0], args = _a.slice(1);
                applyArgsWithContext === null || applyArgsWithContext === void 0 ? void 0 : applyArgsWithContext(client, capturedContext, args);
            });
            cache[name] = null;
        }
    });
    return newClient;
};

function IntegrationPlugin(client, runAfterSetup) {
    client.on('init', function () {
        var nameList = [];
        var applyIntegrations = function (integrations) {
            integrations.forEach(function (integration) {
                var integrationName = integration.name;
                if (!arrayIncludes(nameList, integrationName)) {
                    nameList.push(integrationName);
                    integration.setup(client);
                    runAfterSetup && runAfterSetup(integrationName, integration.setup);
                    client.destroyAgent.set(integrationName, integrationName, [
                        function () {
                            nameList = arrayRemove(nameList, integrationName);
                            integration.tearDown && integration.tearDown();
                        },
                    ]);
                }
            });
        };
        client.provide('applyIntegrations', applyIntegrations);
        var config = client.config();
        if (config && config.integrations) {
            applyIntegrations(config.integrations);
        }
    });
}

var SubjectSpacer = '_';
var getSubjectKeyWithoutVersion = function (subjectKey) {
    return subjectKey.split(SubjectSpacer)[0];
};
function SubjectPlugin(client, globalSubjectMap) {
    var subjectMap = globalSubjectMap || {};
    var filterMap = {};
    // filter key is subject key but without subject spacer and subject version, and it only takes effect on subsequent observers
    var setFilter = function (subjectKeyWithoutVersion, filter) {
        if (!filterMap[subjectKeyWithoutVersion])
            filterMap[subjectKeyWithoutVersion] = [];
        filterMap[subjectKeyWithoutVersion].push(filter);
    };
    var initSubject = function (_a) {
        var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
        var filterKey = getSubjectKeyWithoutVersion(subjectKey);
        var filters = !!filterKey && filterMap[filterKey];
        if (!subjectMap[subjectKey])
            subjectMap[subjectKey] = createSafeObserver(observer, function () {
                subjectMap[subjectKey] = undefined;
            });
        if (!filters)
            return subjectMap[subjectKey];
        return initPrivateSubject(client, [
            subjectKey,
            wrapFilters(subjectMap[subjectKey], filters),
        ]);
    };
    client.provide('setFilter', setFilter);
    client.provide('initSubject', initSubject);
    client.provide('getSubject', function (key) { return subjectMap[key]; });
    client.provide('privateSubject', {});
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultXMLHttpRequest() {
    if (typeof XMLHttpRequest === 'function' && isFunction(XMLHttpRequest))
        return XMLHttpRequest;
}
function getDefaultNavigator() {
    if (getDefaultBrowser() && 'navigator' in window) {
        return window.navigator;
    }
}
function getDefaultNetworkInformation() {
    var navigator = getDefaultNavigator();
    if (navigator) {
        return navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    }
}

function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

// 获取全局注册表
var getGlobalRegistry = function (global) {
    if (!global)
        return;
    if (!global.__SLARDAR_REGISTRY__) {
        global.__SLARDAR_REGISTRY__ = {
            Slardar: {
                plugins: [],
                errors: [],
                subject: {},
            },
        };
    }
    return global.__SLARDAR_REGISTRY__.Slardar;
};

var captureCurrentContext = function (client) {
    var capturedContext = {
        url: getLocationUrl(),
        timestamp: now(),
    };
    var config = client.config();
    if (config === null || config === void 0 ? void 0 : config.pid) {
        capturedContext.pid = config.pid;
    }
    if (client === null || client === void 0 ? void 0 : client['context']) {
        capturedContext.context = client['context'].toString();
    }
    return capturedContext;
};
// only works for sync report
// async report won't trigger 'report' immediately, es.g. sri
var syncReportWithCapturedContext = function (client, ctx) {
    return function (fn) {
        var inject = function (ev) {
            ev.overrides = ctx;
            return ev;
        };
        client.on('report', inject);
        fn();
        client.off('report', inject);
    };
};

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};
var onPageUnload = function (cb) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var _a = __read(invokeCallbackOnce(cb), 1), invokeCbOnce = _a[0];
    ['unload', 'beforeunload', 'pagehide'].forEach(function (ev) {
        addListenerToWindow(window, ev, invokeCbOnce, false);
    });
};
var onPageNextShow = function (cb) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var removeListener = noop;
    var onVisibilityChange = function () {
        if (document.visibilityState === 'visible') {
            cb();
            removeListener();
        }
    };
    removeListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChange, true);
};

var isSupportEncrypt = function () { return !!btoa && !!atob; };
function encodeToBase64(content) {
    if (!isSupportEncrypt())
        return content;
    return btoa(encodeURI(content));
}
function decodeWithBase64(base64) {
    if (!isSupportEncrypt())
        return base64;
    return decodeURI(atob(base64));
}

var getStorageWithDecoding = function (name) {
    try {
        var value = localStorage.getItem(name);
        var ret = value;
        if (value && typeof value === 'string') {
            ret = JSON.parse(decodeWithBase64(value));
        }
        // get 时无需刷新 expires，在后续的 configManager 中的 set 会刷新
        var _a = ret, expires = _a.expires, content = __rest(_a, ["expires"]);
        return expires >= now() ? content : undefined;
    }
    catch (_e) {
        return undefined;
    }
};
var setStorageWithEncoding = function (key, value, expires) {
    if (expires <= 0)
        return;
    try {
        localStorage.setItem(key, encodeToBase64(JSON.stringify(__assign(__assign({}, value), { expires: now() + expires }))));
    }
    catch (_o) {
        // do nothing
    }
};
var DEFAULT_STORAGE_EXPIRES = 90 * 24 * 60 * 60 * 1000;
var formatStorageExpires = function (storageExpires) {
    if (storageExpires === false)
        return 0;
    if (storageExpires === true || storageExpires === undefined || !isNumber(storageExpires))
        return DEFAULT_STORAGE_EXPIRES;
    return storageExpires;
};

var JS_ERROR_EV_TYPE = 'js_error';

var ERROR_FIELDS = ['name', 'message', 'stack', 'filename', 'lineno', 'colno'];
var normalize = function (ex) {
    var error;
    if (!isError(ex)) {
        if (isPlainObject(ex) || isEvent(ex) || isString(ex)) {
            error = {
                message: safeStringify(ex),
            };
        }
    }
    else {
        error = pick(ex, ERROR_FIELDS);
    }
    return error;
};
var normalizeError = function (event) {
    var normalizedError = normalize(event.error);
    // If normalizedError is null or undefined, return it immediately
    if (!normalizedError) {
        return normalizedError;
    }
    // when event.error does not have filename、colno、lineno, use event's
    var colno = event.colno, lineno = event.lineno, filename = event.filename;
    if (colno && !normalizedError.colno) {
        normalizedError.colno = String(colno);
    }
    if (lineno && !normalizedError.lineno) {
        normalizedError.lineno = String(lineno);
    }
    if (filename && !normalizedError.filename) {
        normalizedError.filename = filename;
    }
    return normalizedError;
};
var normalizeException = function (event) {
    var _a;
    // dig the object of the rejection out of known event types
    try {
        var error = void 0;
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in event) {
            error = event.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in event && 'reason' in event.detail) {
            error = event.detail.reason;
        }
        if (error) {
            var rejectionError = normalize(error);
            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
            return __assign(__assign({}, rejectionError), { name: (_a = (rejectionError && rejectionError.name)) !== null && _a !== void 0 ? _a : 'UnhandledRejection' });
        }
    }
    catch (_oO) {
        // no-empty
    }
};
var normalizeUnknownError = function (exception) {
    if (isErrorEvent(exception)) {
        return normalizeError(exception);
    }
    else if (isPromiseRejectionEvent(exception)) {
        return normalizeException(exception);
    }
    else {
        return normalize(exception);
    }
};

var getViewId = function (pid) { return joinWithSeparator(pid, now()); };
var joinWithSeparator = function (a, b) { return a + "_" + b; };

function getNetworkType(netInfo) {
    return (netInfo === null || netInfo === void 0 ? void 0 : netInfo.effectiveType) || (netInfo === null || netInfo === void 0 ? void 0 : netInfo.type) || '';
}
var InjectNetworkTypePlugin = function (client) {
    var netInfo = getDefaultNetworkInformation();
    var network_type = getNetworkType(netInfo);
    if (netInfo) {
        netInfo.onchange = function () {
            network_type = getNetworkType(netInfo);
        };
    }
    client.on('report', function (ev) {
        return __assign(__assign({}, ev), { extra: __assign(__assign({}, (ev.extra || {})), { network_type: network_type }) });
    });
};

/* eslint-disable @typescript-eslint/prefer-optional-chain */
var getBeaconTransport = function () {
    var window = getDefaultBrowser();
    // eslint-disable-next-line compat/compat
    return window && window.navigator.sendBeacon
        ? {
            get: function () { },
            post: function (url, data) {
                // eslint-disable-next-line compat/compat
                window.navigator.sendBeacon(url, data);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

var request = function (method, options, XMLHttpRequest) {
    var url = options.url, data = options.data, _a = options.success, success = _a === void 0 ? noop : _a, _b = options.fail, fail = _b === void 0 ? noop : _b, _c = options.getResponseText, getResponseText = _c === void 0 ? noop : _c, _d = options.withCredentials, withCredentials = _d === void 0 ? false : _d;
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = withCredentials;
    xhr.open(method, url, true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onload = function () {
        getResponseText === null || getResponseText === void 0 ? void 0 : getResponseText(this.responseText);
        try {
            if (this.status >= 400) {
                fail(new Error(this.responseText || this.statusText));
            }
            else if (this.responseText) {
                var result = JSON.parse(this.responseText);
                success(result);
            }
            else {
                // batch api response: status = 204 , responseText = ''
                success({});
            }
        }
        catch (e) {
            fail(e);
        }
    };
    xhr.onerror = function () {
        fail(new Error('Network request failed'));
    };
    xhr.onabort = function () {
        /* istanbul ignore next */
        fail(new Error('Network request aborted'));
    };
    xhr.send(data);
};
var getXhrTransport = function () {
    var XMLHttpRequest = getDefaultXMLHttpRequest();
    return XMLHttpRequest
        ? {
            useBeacon: true,
            get: function (options) {
                request('GET', options, XMLHttpRequest);
            },
            post: function (options) {
                request('POST', options, XMLHttpRequest);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

// createSender has side effects(register onClose behavior)
// so it must be create lazily
function createBrowserSender(config) {
    var sender = createBatchSender(config);
    var originSend = sender.send;
    // send the cached data immediately upon unload
    onPageUnload(function () {
        // use sendBeacon if allowed
        if (config.transport.useBeacon) {
            var beaconTransport_1 = getBeaconTransport();
            var data = sender.getBatchData();
            if (data) {
                beaconTransport_1.post(sender.getEndpoint(), data);
                sender.clear();
            }
            // some data may still be generated during unload
            sender.send = function (data) {
                beaconTransport_1.post(sender.getEndpoint(), stringifyBatch([data]));
            };
            // in webview, page can still be resurrected even after the `unload` event has been triggered
            onPageNextShow(function () {
                sender.send = originSend;
            });
        }
        else {
            // if not use sendBeacon, flush the data list by default
            sender.flush();
        }
    });
    return sender;
}

var REPORT_DOMAIN = "mon16-normal-useast5.tiktokv.us";
var PLUGINS_LOAD_PREFIX = "https:" + "//" + ("lf16-cdn-tos.tiktokcdn-us.com") + "/obj/static-tx/slardar/fe/sdk-web/plugins";
var SDK_VERSION = "1.14.1" ;
var SDK_NAME = 'SDK_SLARDAR_WEB';
var SETTINGS_PATH = '/monitor_web/settings/browser-settings';
var BATCH_REPORT_PATH = "/monitor_browser/collect/batch/";
var STORAGE_PREFIX = 'SLARDAR';
var DEFAULT_IGNORE_PATHS = ['/log/sentry/', BATCH_REPORT_PATH, SETTINGS_PATH];
var DEFAULT_SAMPLE_GRANULARITY = 'session';
var DEFAULT_SAMPLE_CONFIG = {
    sample_rate: 1,
    include_users: [],
    sample_granularity: DEFAULT_SAMPLE_GRANULARITY,
    rules: {},
};
var DEFAULT_SENDER_SIZE = 20;

function normalizeStrictFields(config) {
    var e_1, _a;
    var strictFields = ['userId', 'deviceId', 'sessionId', 'env'];
    try {
        for (var strictFields_1 = __values(strictFields), strictFields_1_1 = strictFields_1.next(); !strictFields_1_1.done; strictFields_1_1 = strictFields_1.next()) {
            var k = strictFields_1_1.value;
            if (!config[k]) {
                delete config[k];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (strictFields_1_1 && !strictFields_1_1.done && (_a = strictFields_1.return)) _a.call(strictFields_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return config;
}
function normalizeInitConfig(config) {
    var plugins = config.plugins || {};
    for (var k in plugins) {
        if (plugins[k] && !isObject(plugins[k])) {
            plugins[k] = {};
        }
    }
    return normalizeStrictFields(__assign(__assign({}, config), { plugins: plugins }));
}
function validateInitConfig(config) {
    return isObject(config) && 'bid' in config;
}
function normalizeUserConfig(config) {
    return normalizeStrictFields(__assign({}, config));
}
function parseServerConfig(serverConfig) {
    var _a;
    if (!serverConfig) {
        return {};
    }
    var sample = serverConfig.sample, plugins = serverConfig.plugins, timestamp = serverConfig.timestamp, _b = serverConfig.quota_rate, quota_rate = _b === void 0 ? 1 : _b, apdex = serverConfig.apdex;
    if (!sample) {
        return {};
    }
    var sample_rate = sample.sample_rate, _c = sample.sample_granularity, sample_granularity = _c === void 0 ? DEFAULT_SAMPLE_GRANULARITY : _c, include_users = sample.include_users, _d = sample.rules, rules = _d === void 0 ? [] : _d;
    return {
        sample: {
            include_users: include_users,
            sample_rate: sample_rate * quota_rate,
            sample_granularity: sample_granularity,
            rules: rules.reduce(function (prev, cur) {
                var name = cur.name, enable = cur.enable, sample_rate = cur.sample_rate, conditional_sample_rules = cur.conditional_sample_rules;
                prev[name] = {
                    enable: enable,
                    sample_rate: sample_rate,
                    conditional_sample_rules: conditional_sample_rules,
                };
                return prev;
            }, {}),
        },
        plugins: {
            heatmap: (_a = plugins === null || plugins === void 0 ? void 0 : plugins.heatmap) !== null && _a !== void 0 ? _a : false,
        },
        apdex: apdex,
        serverTimestamp: timestamp,
    };
}

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var getReportUrl = function (domain, path) {
    if (path === void 0) { path = BATCH_REPORT_PATH; }
    return "" + (domain && domain.indexOf('//') >= 0 ? '' : 'https://') + domain + path;
};
var getSettingsUrl = function (domain, path) {
    if (path === void 0) { path = SETTINGS_PATH; }
    return "" + (domain && domain.indexOf('//') >= 0 ? '' : 'https://') + domain + path;
};
var getDefaultSessionId = function () {
    return uuid();
};
var toObservableArray = function (arr) {
    var observers = [];
    arr.observe = function (o) {
        observers.push(o);
    };
    arr.push = function () {
        var _a;
        var vs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            vs[_i] = arguments[_i];
        }
        vs.forEach(function (v) {
            observers.forEach(function (o) { return o(v); });
        });
        return (_a = [].push).call.apply(_a, __spreadArray([arr], __read(vs), false));
    };
    return arr;
};
var getStorageKey = function (bid) { return STORAGE_PREFIX + bid; };
/**
 * glue code for storage security. Maybe it could remove in one year later
 * @param key storage key
 * @returns
 */
var glueCodeForStorageSecurity = function (key, expires) {
    try {
        var value = localStorage.getItem(key);
        // btoa(encodeURI('{')) === JTdC
        // old content:{ userId: '', deviceId: '' }
        if (!value || !isSupportEncrypt() || value[0] !== '{')
            return;
        setStorageWithEncoding(key, JSON.parse(value), expires);
    }
    catch (error) {
        // do nothing
    }
};
var getDefaultUserIdAndDeviceId = function (bid, expires) {
    if (bid === void 0) { bid = ''; }
    var randomIdInfo = {
        userId: uuid(),
        deviceId: uuid(),
    };
    // <= 0 时，不移除现 localStorage 数据，只是不取和不存
    if (expires <= 0)
        return randomIdInfo;
    var key = getStorageKey(bid);
    glueCodeForStorageSecurity(key, expires);
    var storageIdInfo = getStorageWithDecoding(key);
    return {
        userId: (storageIdInfo === null || storageIdInfo === void 0 ? void 0 : storageIdInfo.userId) || randomIdInfo.userId,
        deviceId: (storageIdInfo === null || storageIdInfo === void 0 ? void 0 : storageIdInfo.deviceId) || randomIdInfo.deviceId,
    };
};
var setStorageUserIdAndDeviceId = function (config) {
    var bid = config.bid, userId = config.userId, deviceId = config.deviceId, storageExpires = config.storageExpires;
    var key = getStorageKey(bid);
    setStorageWithEncoding(key, {
        userId: userId,
        deviceId: deviceId,
    }, formatStorageExpires(storageExpires));
};

var configHolder = {
    get: function () {
        return this.__SLARDAR__REPALCE__HOLDER__;
    },
};
var createBrowserConfigManager = function (defaultConfig) {
    // the merged config
    var config = defaultConfig;
    // save it so we know when initConfig is set
    var initConfig;
    // save UserConfig so we can merge with priority
    var userConfig = {};
    // save the original server config, from sdk-server or from get_setting response
    var serverConfig = configHolder.get();
    // cache the parsed ServerConfig, used in merge
    var parsedServerConfig;
    // call when ready to start(with initConfig and serverConfig)
    var onReady = noop;
    // call when config changed
    var onChange = noop;
    return {
        getConfig: function () {
            return config;
        },
        setConfig: function (c) {
            userConfig = __assign(__assign({}, userConfig), (c || {}));
            updateConfig();
            if (!initConfig) {
                // handle init
                initConfig = c;
                if (config.useLocalConfig || !config.bid) {
                    parsedServerConfig = {};
                    onReady();
                }
                else if (serverConfig) {
                    handleServerConfig();
                }
                else {
                    getServerConfig(config.transport, config.domain, config.bid, function (res) {
                        serverConfig = res;
                        handleServerConfig();
                    });
                }
            }
            return config;
        },
        onChange: function (fn) {
            onChange = fn;
        },
        onReady: function (fn) {
            onReady = function () {
                setStorageUserIdAndDeviceId(config);
                fn();
            };
            if (parsedServerConfig) {
                onReady();
            }
        },
    };
    function updateConfig() {
        var newConfig = __assign(__assign(__assign({}, defaultConfig), (parsedServerConfig || {})), userConfig);
        newConfig.plugins = mergeDeepConcatArray(defaultConfig.plugins, (parsedServerConfig === null || parsedServerConfig === void 0 ? void 0 : parsedServerConfig.plugins) || {}, userConfig.plugins || {});
        newConfig.sample = mergeSampleConfig(mergeSampleConfig(defaultConfig.sample, parsedServerConfig === null || parsedServerConfig === void 0 ? void 0 : parsedServerConfig.sample), userConfig.sample);
        config = newConfig;
        onChange();
    }
    function handleServerConfig() {
        parsedServerConfig = parseServerConfig(serverConfig);
        updateConfig();
        onReady();
    }
};
function getServerConfig(transport, domain, bid, cb) {
    transport.get({
        withCredentials: true,
        url: getSettingsUrl(domain) + "?bid=" + bid + "&store=1",
        success: function (res) {
            cb(res.data || {});
        },
        fail: function () {
            cb({ sample: { sample_rate: 0.001 } });
        },
    });
}
function mergeSampleConfig(a, b) {
    if (!a || !b)
        return a || b;
    var res = __assign(__assign({}, a), b);
    res.include_users = __spreadArray(__spreadArray([], __read((a.include_users || [])), false), __read((b.include_users || [])), false);
    res.rules = __spreadArray(__spreadArray([], __read(Object.keys(a.rules || {})), false), __read(Object.keys(b.rules || {})), false).reduce(function (obj, key) {
        var _a, _b;
        if (!(key in obj)) {
            if (key in (a.rules || {}) && key in (b.rules || {})) {
                obj[key] = __assign(__assign({}, a.rules[key]), b.rules[key]);
                obj[key].conditional_sample_rules = __spreadArray(__spreadArray([], __read((a.rules[key].conditional_sample_rules || [])), false), __read((b.rules[key].conditional_sample_rules || [])), false);
            }
            else {
                obj[key] = ((_a = a.rules) === null || _a === void 0 ? void 0 : _a[key]) || ((_b = b.rules) === null || _b === void 0 ? void 0 : _b[key]);
            }
        }
        return obj;
    }, {});
    return res;
}

var browserBuilder = {
    build: function (e) {
        return {
            ev_type: e.ev_type,
            payload: e.payload,
            common: __assign(__assign({}, (e.extra || {})), (e.overrides || {})),
        };
    },
};

function getPluginFromRegistry(registry, name) {
    return registry.plugins.filter(function (l) { return l.name === name && l.version === SDK_VERSION; })[0];
}
/**
 * Registers a plugin by adding it to the global registry.
 *
 * @param {string} name - The name of the plugin to register.
 * @param {PluginApplyFnForVol} apply - The function to apply the plugin.
 * @param {Registry} registry - The registry to add the plugin to.
 * @return {void}
 */
function register(name, apply, registry) {
    if (registry === void 0) { registry = getGlobalRegistry(getDefaultBrowser()); }
    if (!registry || !registry.plugins)
        return;
    if (getPluginFromRegistry(registry, name)) {
        return;
    }
    registry.plugins.push({
        name: name,
        version: SDK_VERSION,
        apply: apply,
    });
}

var addEnvToSendEvent = function (ev, config) {
    // The data needs immediate injection during the reporting process
    var _a = config || {}, _b = _a.pid, pid = _b === void 0 ? '' : _b, _c = _a.viewId, viewId = _c === void 0 ? '' : _c;
    var extra = {
        url: getLocationUrl(),
        timestamp: now(),
        sdk_version: SDK_VERSION,
        sdk_name: SDK_NAME,
        pid: pid,
        view_id: viewId,
    };
    return __assign(__assign({}, ev), { extra: __assign(__assign({}, extra), (ev.extra || {})) });
};
var InjectEnvPlugin = function (client) {
    client.on('report', function (ev) {
        return addEnvToSendEvent(ev, client.config());
    });
};

var buildSelfErrorEvent = function (ev) {
    var _a = __read(ev, 2), err = _a[0], extra = _a[1];
    return {
        ev_type: JS_ERROR_EV_TYPE,
        payload: {
            error: normalizeUnknownError(err),
            breadcrumbs: [],
            extra: extra || {},
        },
        extra: {
            bid: 'slardar_sdk',
        },
    };
};
var DEFAULT_OBSERVE_ERROR_RATE = 0.001;
var ObserveErrorPlugin = function (client, rate) {
    if (rate === void 0) { rate = DEFAULT_OBSERVE_ERROR_RATE; }
    var registry = getGlobalRegistry(getDefaultBrowser());
    // 如果没有获取到注册表 或者已经observe了，则不操作
    if (!registry)
        return;
    if (!registry.errors) {
        registry.errors = [];
    }
    if ('observe' in registry.errors)
        return;
    if (!isHitBySampleRate(rate))
        return;
    // 挂载observe方法
    registry.errors = toObservableArray(registry.errors);
    // 消费已挂载的错误
    registry.errors.forEach(function (e) {
        client.report(buildSelfErrorEvent(e));
    });
    // 注册observe回调用
    registry.errors.observe(function (e) {
        client.report(buildSelfErrorEvent(e));
    });
};

var MAX_RTT = 700;
/**
 * This plugin is bound with BrowserConfigManager, so it can't be extract into @sdk/web
 */
var TimeCalibrationPlugin = function (client) {
    var startTime;
    var hasCalibrated = false;
    client.on('init', function () {
        startTime = new Date().getTime();
        client.on('config', function () {
            var _a;
            var serverTime = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.serverTimestamp;
            if (isNaN(serverTime) || Number(serverTime) <= 0 || hasCalibrated) {
                return;
            }
            hasCalibrated = true;
            var endTime = new Date().getTime();
            var potential_rtt = endTime - startTime;
            if (potential_rtt < MAX_RTT && serverTime) {
                var diff_1 = serverTime - (endTime + startTime) / 2;
                // if diff in [-600000, 0], considered to be caused by cache
                if (!isNaN(diff_1) && (diff_1 > 0 || diff_1 < -600000)) {
                    client.on('beforeBuild', function (ev) {
                        var _a;
                        return __assign(__assign({}, ev), { extra: __assign(__assign({}, ((_a = ev.extra) !== null && _a !== void 0 ? _a : {})), { sdk_offset: diff_1 !== null && diff_1 !== void 0 ? diff_1 : 0 }) });
                    });
                }
            }
        });
    });
};

var addConfigToReportEvent = function (ev, config) {
    var extra = {};
    extra.bid = config.bid;
    extra.user_id = config.userId;
    extra.device_id = config.deviceId;
    extra.session_id = config.sessionId;
    extra.release = config.release;
    extra.env = config.env;
    return __assign(__assign({}, ev), { extra: __assign(__assign({}, extra), (ev.extra || {})) });
};
var InjectConfigPlugin = function (client) {
    client.on('beforeBuild', function (ev) {
        return addConfigToReportEvent(ev, client.config());
    });
};

var InjectQueryPlugin = function (client) {
    client.on('start', function () {
        var bid = client.config().bid;
        var sender = client.getSender();
        sender.setEndpoint(sender.getEndpoint() + ("?biz_id=" + bid));
    });
};

var getDefaultConfig = function (c) {
    var storageExpires = formatStorageExpires(c.storageExpires);
    var storageInfo = getDefaultUserIdAndDeviceId(c.bid, storageExpires);
    return {
        bid: '',
        pid: '',
        viewId: getViewId('_'),
        userId: storageInfo.userId,
        deviceId: storageInfo.deviceId,
        storageExpires: storageExpires,
        sessionId: getDefaultSessionId(),
        domain: REPORT_DOMAIN,
        pluginBundle: {
            name: 'commonMonitors',
            plugins: ['breadcrumb', 'jsError', 'performance', 'resourceError', 'resource'],
        },
        pluginPathPrefix: PLUGINS_LOAD_PREFIX,
        plugins: {
            ajax: { ignoreUrls: DEFAULT_IGNORE_PATHS },
            fetch: { ignoreUrls: DEFAULT_IGNORE_PATHS },
            breadcrumb: {},
            pageview: {},
            jsError: {},
            resource: {},
            resourceError: {},
            performance: {},
            tti: {},
            fmp: {},
            blankScreen: false,
            heatmap: false,
        },
        release: '',
        env: 'production',
        sample: DEFAULT_SAMPLE_CONFIG,
        transport: getXhrTransport(),
    };
};
var createMinimalBrowserClient = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.createSender, createSender = _c === void 0 ? function (config) {
        return createBrowserSender({
            size: DEFAULT_SENDER_SIZE,
            endpoint: getReportUrl(config.domain),
            transport: config.transport,
        });
    } : _c, _d = _b.builder, builder = _d === void 0 ? browserBuilder : _d, _e = _b.createDefaultConfig, createDefaultConfig = _e === void 0 ? getDefaultConfig : _e;
    var client = createClient({
        validateInitConfig: validateInitConfig,
        initConfigNormalizer: normalizeInitConfig,
        userConfigNormalizer: normalizeUserConfig,
        createSender: createSender,
        builder: builder,
        createDefaultConfig: createDefaultConfig,
        createConfigManager: createBrowserConfigManager,
    });
    ObserveErrorPlugin(client);
    ContextPlugin(client);
    var subjectMap = getGlobalRegistry(getDefaultBrowser());
    SubjectPlugin(client, subjectMap && subjectMap.subject);
    TimeCalibrationPlugin(client);
    InjectConfigPlugin(client);
    InjectEnvPlugin(client);
    InjectNetworkTypePlugin(client);
    InjectQueryPlugin(client);
    var commandClient = withCommandArray(client, captureCurrentContext, function (c, ctx, args) {
        return syncReportWithCapturedContext(c, ctx)(function () {
            var _a = __read(args), method = _a[0], others = _a.slice(1);
            client[method].apply(client, __spreadArray([], __read(others), false));
        });
    });
    // add plugin after with command array
    IntegrationPlugin(commandClient, register);
    return commandClient;
};

export { createMinimalBrowserClient, getDefaultConfig };//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/web/oci/minimal.esm.js.map
