import { __assign } from "tslib";
import { noop, omit } from '@slardar/sdk-template';
export var PAUSE_INTEGRATION_NAME = 'pause';
var DEFAULT_CAPACITY = 100;
var defaultStopOptions = {
    isReportAll: true,
};
var defaultPauseOptions = {
    capacity: DEFAULT_CAPACITY,
    isResume: false,
};
export var pause = function () { return ({
    name: PAUSE_INTEGRATION_NAME,
    setup: function (client) {
        var controller = createController(client.report.bind(client));
        client.on('init', function () {
            client.provide(PAUSE_INTEGRATION_NAME, omit(controller, 'preReport'));
        });
        client.on('beforeReport', function (ev) {
            return controller.preReport(ev);
        });
        // stop but not report if its state is pause
        client.destroyAgent.set(PAUSE_INTEGRATION_NAME, PAUSE_INTEGRATION_NAME, [
            function () {
                controller.stopAction({ isReportAll: false });
            },
        ]);
    },
}); };
export function createController(report, options) {
    if (options === void 0) { options = {
        onTransition: noop,
        initState: 'running',
    }; }
    var _state = options.initState;
    var _queue;
    var _transCb = options.onTransition;
    var _isCheckState = true;
    function _flush() {
        while (_queue === null || _queue === void 0 ? void 0 : _queue.getSize()) {
            report(_queue.dequeue());
        }
    }
    function startAction() {
        var nextState = 'running';
        var allowStates = ['stop', 'pause'];
        var isTransSuc = allowStates.includes(_state);
        if (isTransSuc) {
            _transCb(_state, nextState);
            _state = nextState;
            // The queue is empty by default in stop state.
            _flush();
        }
        return isTransSuc;
    }
    function stopAction(options) {
        var isReportAll = __assign(__assign({}, defaultStopOptions), options).isReportAll;
        var nextState = 'stop';
        var allowStates = ['running', 'pause'];
        var isTransSuc = allowStates.includes(_state);
        if (isTransSuc) {
            _transCb(_state, nextState);
            _state = nextState;
            if (isReportAll) {
                // set _isCheckoutState to false is used to skip the check state of preReport function.
                _isCheckState = false;
                _flush();
                // reset immediately
                _isCheckState = true;
            }
            _queue === null || _queue === void 0 ? void 0 : _queue.clear();
        }
        return isTransSuc;
    }
    function pauseAction(options) {
        var _a = __assign(__assign({}, defaultPauseOptions), options), capacity = _a.capacity, isResume = _a.isResume;
        var nextState = 'pause';
        var allowStates = ['running'];
        var isTransSuc = allowStates.includes(_state);
        if (_state === 'running') {
            _queue = createQueue(capacity, function () {
                if (isResume) {
                    startAction();
                }
            });
        }
        if (isTransSuc) {
            _transCb(_state, nextState);
            _state = nextState;
        }
        return isTransSuc;
    }
    function onTransition(cb) {
        _transCb = cb;
    }
    function getState() {
        return _state;
    }
    function getQueueSize() {
        return _queue ? _queue.getSize() : 0;
    }
    function preReport(e) {
        if (_state === 'pause') {
            _queue.enqueue(e);
            return false;
        }
        if (_state === 'running' || !_isCheckState) {
            return e;
        }
        return false;
    }
    return { startAction: startAction, stopAction: stopAction, pauseAction: pauseAction, onTransition: onTransition, getState: getState, getQueueSize: getQueueSize, preReport: preReport };
}
export function createQueue(capacity, fullCallback) {
    var _queue = [];
    var _capacity = capacity;
    function enqueue(ele) {
        _queue.push(ele);
        if (getSize() >= _capacity) {
            fullCallback === null || fullCallback === void 0 ? void 0 : fullCallback();
        }
        _shrink();
    }
    function dequeue() {
        return _queue.shift();
    }
    function clear() {
        _queue = [];
    }
    function getSize() {
        return _queue.length;
    }
    function setCapacity(capacity) {
        _capacity = capacity;
        _shrink();
    }
    function getCapacity() {
        return _capacity;
    }
    function _shrink() {
        while (getSize() > _capacity) {
            dequeue();
        }
    }
    return { enqueue: enqueue, dequeue: dequeue, clear: clear, getSize: getSize, setCapacity: setCapacity, getCapacity: getCapacity };
}//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/esm/pause.js.map