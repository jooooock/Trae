'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
var objProto = Object.prototype;
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
function isNumber(o) {
    return typeof o === 'number';
}

var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}

function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client);
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = __assign(__assign({}, getOverrides(client)), getViewOverrides(newConfig));
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
function onPageLoad(callback) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    if (document.readyState === 'complete') {
        callback();
        return;
    }
    addListenerToWindow(window, 'load', function () {
        setTimeout(function () {
            callback();
        }, 0);
    }, false);
}

var HEATMAP_EV_TYPE = 'heatmap';

/* eslint-disable @typescript-eslint/no-implied-eval */
var HEATMAP_INTEGRATION_NAME = 'heatmap';
var DRAW_MARK = 'slardar_heatmap_draw';
var urlMatch = function (url) {
    var _a;
    var re = new RegExp(url, 'i');
    if ((_a = re.test) === null || _a === void 0 ? void 0 : _a.call(re, location.href)) {
        return true;
    }
    return false;
};
var getMatchList = function (openList) {
    return openList.filter(function (item) {
        return urlMatch(item.monitor_url);
    });
};
// throttle interval is recommended to be within 250 ms
var throttle = function (callback, interval) {
    if (interval === void 0) { interval = 200; }
    var time;
    return function (event) {
        var nowTime = now();
        if (!time || nowTime - time > interval) {
            callback(event);
            time = nowTime;
        }
    };
};
// debounce interval is recommended to set within the range of 500 to 1000 ms
var debounce = function (callback, interval) {
    if (interval === void 0) { interval = 800; }
    var timers;
    return function (event) {
        // 清除之前的定时器
        if (timers !== undefined) {
            clearTimeout(timers);
        }
        // 设置新的定时器
        timers = setTimeout(function () {
            callback(event);
        }, interval);
    };
};
var getLocationSearch = function (location) {
    if (location === void 0) { location = window.location; }
    var search = location.search, hash = location.hash;
    // support hash router like: '/path/#hash?draw=1', which location is: { search: '', hash: '#hash?draw=1'}
    var searchIndexInHash = hash.indexOf('?');
    if (!search.length && searchIndexInHash > 0) {
        return hash.slice(searchIndexInHash);
    }
    return search;
};
var getXPath = function (elem) {
    var nodeElem = elem;
    if (nodeElem.id) {
        return "//*[@id=\"" + nodeElem.id + "\"]";
    }
    var parts = [];
    while (nodeElem && nodeElem.nodeType === Node.ELEMENT_NODE) {
        var nbOfPreviousSiblings = 0;
        var hasNextSiblings = false;
        var sibling = nodeElem.previousSibling;
        while (sibling) {
            if (sibling.nodeType !== Node.DOCUMENT_TYPE_NODE && sibling.nodeName === nodeElem.nodeName) {
                nbOfPreviousSiblings++;
            }
            sibling = sibling.previousSibling;
        }
        sibling = nodeElem.nextSibling;
        while (sibling) {
            if (sibling.nodeName === nodeElem.nodeName) {
                hasNextSiblings = true;
                break;
            }
            sibling = sibling.nextSibling;
        }
        var prefix = nodeElem.prefix ? nodeElem.prefix + ':' : '';
        var nth = nbOfPreviousSiblings || hasNextSiblings ? "[" + (nbOfPreviousSiblings + 1) + "]" : '';
        parts.unshift(prefix + nodeElem.localName + nth);
        nodeElem = nodeElem.parentNode;
    }
    return parts.length ? '/' + parts.join('/') : '';
};
var handleScrollData = function (event, _b) {
    var _c, _d;
    var trackRootScroll = _b.trackRootScroll;
    var xpath;
    var target = event.target;
    try {
        xpath = target ? getXPath(target) : getXPath(event);
        // handle the document element with special consideration during scroll event
        if (target && trackRootScroll && target.nodeType === Node.DOCUMENT_NODE) {
            xpath = '/html';
            target = document.documentElement;
        }
    }
    catch (e) {
        xpath = '<unknown>';
    }
    if (xpath.length === 0) {
        return;
    }
    var startY = (_c = target === null || target === void 0 ? void 0 : target.scrollTop) !== null && _c !== void 0 ? _c : 0;
    var scrollX = (_d = target === null || target === void 0 ? void 0 : target.scrollLeft) !== null && _d !== void 0 ? _d : 0;
    // when startY === 0 &  scrollX > 0, it is considered horizontal scrolling and needs to be discarded.
    if (startY === 0 && scrollX > 0) {
        return;
    }
    return {
        xpath: xpath,
        start_y: startY,
        end_y: target ? (target.clientHeight || 0) + startY : 0,
    };
};
var handleMouseData = function (event) {
    var _b, _c;
    var xpath;
    try {
        xpath = event.target ? getXPath(event.target) : getXPath(event);
    }
    catch (e) {
        xpath = '<unknown>';
    }
    if (xpath.length === 0) {
        return;
    }
    var _d = event.target.getBoundingClientRect(), left = _d.left, top = _d.top;
    if (isNumber(event.pageX) && isNumber(event.pageY)) {
        return {
            xpath: xpath,
            offset_x: (_b = Math.round(event.pageX - document.documentElement.scrollLeft - left)) !== null && _b !== void 0 ? _b : 0,
            offset_y: (_c = Math.round(event.pageY - document.documentElement.scrollTop - top)) !== null && _c !== void 0 ? _c : 0,
        };
    }
    else {
        return undefined;
    }
};
var heatmapMonitor = function (report, flags) {
    var monitorList = [];
    var tearDown = [];
    var handleEvent = function (eventData, evtType) {
        if (eventData && eventData.xpath) {
            monitorList.forEach(function (_b) {
                var _c;
                var heat_map_id = _b.heat_map_id;
                report({
                    // @ts-expect-error
                    ev_type: 'heat_map',
                    payload: (_c = {
                            type: 'post',
                            name: 'HeatmapMonitor',
                            heat_map_id: heat_map_id
                        },
                        _c[evtType] = eventData,
                        _c),
                });
            });
        }
    };
    var collectMouseEvent = function () {
        // click and mousemove events prefer to use throttle to collect continuous data
        var throttleEventList = ['click', 'mousemove'];
        throttleEventList.forEach(function (evtType) {
            var handler = function (event) {
                var eventData = handleMouseData(event);
                handleEvent(eventData, evtType);
            };
            tearDown.push(addListenerToWindow(window, evtType, throttle(handler), false));
        });
        // mouseover events prefer to use debounce to reflect the user's focus on page elements
        var handleMouseOver = function (event) {
            var eventData = handleMouseData(event);
            handleEvent(eventData, 'mouseover');
        };
        tearDown.push(addListenerToWindow(window, 'mouseover', debounce(handleMouseOver), false));
    };
    var collectScrollEvent = function () {
        var evtType = 'scroll';
        var handler = function (event) {
            var eventData = handleScrollData(event, flags);
            handleEvent(eventData, evtType);
        };
        tearDown.push(addListenerToWindow(window, evtType, throttle(handler), true));
    };
    var collectEvent = function (list) {
        monitorList = list;
        onPageLoad(function () {
            collectMouseEvent();
            collectScrollEvent();
        });
    };
    var stopCollect = function () {
        tearDown.forEach(function (fn) { return fn(); });
        tearDown = [];
        monitorList = [];
    };
    return { collectEvent: collectEvent, stopCollect: stopCollect };
};
var setupHeatmapDraw = function (config, getPVObserver, drawUrl) {
    var _b;
    if (!window || !document) {
        return;
    }
    var scriptOnload = function () {
        window.setTimeout(function () {
            if (!window.drawHeatmap)
                return;
            window.drawHeatmap(config, getPVObserver);
        }, 0);
    };
    if (window.drawHeatmap) {
        scriptOnload();
    }
    var script = document.createElement('script');
    script.src = drawUrl;
    // eslint-disable-next-line compat/compat
    (_b = document.head) === null || _b === void 0 ? void 0 : _b.appendChild(script);
    script.onload = scriptOnload;
};
var setupHeatmap = function (flags, config, report, getPVObserver, tearDown) {
    var open_list = config.open_list;
    var _b = heatmapMonitor(report, flags), collectEvent = _b.collectEvent, stopCollect = _b.stopCollect;
    // setup heatmap
    var originList = getMatchList(open_list);
    originList.length > 0 && collectEvent(originList);
    // re-setup heatmap if needed when pid change
    var onPidChange = function () {
        stopCollect();
        // wait 100ms to make sure location.href have changed
        setTimeout(function () {
            var monitorList = getMatchList(open_list);
            monitorList.length > 0 && collectEvent(monitorList);
        }, 100);
    };
    var pvObserver = getPVObserver();
    tearDown.push(pvObserver[0](function () {
        onPidChange();
    }));
    tearDown.push(function () {
        stopCollect();
    });
};
var heatmap = function (flags) {
    if (flags === void 0) { flags = { trackRootScroll: false }; }
    return {
        name: HEATMAP_INTEGRATION_NAME,
        setup: function (client) {
            // on start lifecycle to make sure can get server config
            client.on('start', function () {
                var _b;
                var heatmapConfig = (_b = client.config()) === null || _b === void 0 ? void 0 : _b.plugins[HEATMAP_INTEGRATION_NAME];
                if (!heatmapConfig) {
                    return;
                }
                // identify DrawMode or MonitorMode
                var isDrawMode = getLocationSearch().indexOf(DRAW_MARK) !== -1;
                if (isDrawMode) {
                    var drawUrl = client.config().pluginPathPrefix + "/heatmap-draw.js";
                    setupHeatmapDraw(heatmapConfig, function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); }, drawUrl);
                    return;
                }
                // open_list.length === 0 means there are no ongoing heatmap experiments, so don't need to setup heatmap monitor
                var _c = heatmapConfig.open_list, open_list = _c === void 0 ? [] : _c;
                if (!open_list.length) {
                    return;
                }
                // startup heatmap monitor
                var tearDown = [];
                setupHeatmap(flags, { open_list: open_list }, function (args) { return client.report(args); }, function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); }, tearDown);
                client.destroyAgent.set(HEATMAP_INTEGRATION_NAME, HEATMAP_EV_TYPE, tearDown);
            });
        },
    };
};

exports.getLocationSearch = getLocationSearch;
exports.heatmap = heatmap;//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@byted-icube/devtools-base/node_modules/@slardar/integrations/dist/heatmap.js.map
