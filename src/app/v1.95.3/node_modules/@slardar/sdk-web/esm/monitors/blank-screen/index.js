import { __read } from "tslib";
import { noop } from '@slardar/sdk-template';
import { BLANK_SCREEN_EV_TYPE } from '../../constants';
import { applyPerformance, applyMutationObserver, getDefaultBrowser, getDefaultDocument, getDefaultMutationObserver, now, } from '../../utils';
import { screenshot, measure, MAX_RELATED_TIME, blankErrorCompare, MAX_RENDER_TIME, DEFAULT_CHECK_TIME, MAX_CHECK_TIME, isSkipBeforeCheck, getElementByRootSelector, serializeDom2String, } from './util';
export var blankScreenGetterWithObserver = function (report, tearDownGroup, _a, _b) {
    var _c = __read(_a, 4), domContentLoadObserver = _c[0], getLongtaskObserver = _c[1], getResourceObserver = _c[2], unloadObserver = _c[3];
    var threshold = _b.threshold, takeScreenshot = _b.screenshot, rootSelector = _b.rootSelector, autoDetect = _b.autoDetect, ssUrl = _b.ssUrl, quality = _b.quality, mask = _b.mask, partialShot = _b.partialShot;
    var win = getDefaultBrowser();
    var document = getDefaultDocument();
    var rAF = win.requestAnimationFrame || noop;
    var cAF = win.cancelAnimationFrame || noop;
    var _d = __read(applyPerformance(performance), 2), relativeNow = _d[1];
    var blankInfo;
    var errorInfo;
    var otherReportedTimestamp = 0;
    var reported = false;
    var timer;
    var rAFTimer;
    var checkTimer;
    var pureReport = function (reportTimestamp, base64) {
        // tear down all observer in pure report function to mark sure blankInfo correctly
        tearDownGroup.forEach(function (e) { return e(); });
        tearDownGroup.length = 0;
        blankInfo &&
            report({
                ev_type: BLANK_SCREEN_EV_TYPE,
                payload: {
                    timestamp: blankInfo[0],
                    score: blankInfo[1],
                    screenshot: base64,
                    error: errorInfo,
                    serialized_dom: serializeDom2String(getElementByRootSelector(rootSelector)),
                },
                overrides: {
                    timestamp: reportTimestamp || blankInfo[0],
                },
            });
    };
    var reportBlankScreen = function () {
        if (!blankInfo || reported) {
            return;
        }
        // set flag here to make sure that only take screenshot once
        reported = true;
        takeScreenshot
            ? screenshot({
                cb: pureReport.bind(null, now()),
                screenshotUrl: ssUrl,
                window: win,
                document: document,
                mask: mask,
                partialShot: partialShot,
                quality: quality,
                rootSelector: rootSelector,
            })
            : pureReport();
    };
    var applyOtherReport = function (ev) {
        if (reported || isSkipBeforeCheck(ev))
            return;
        otherReportedTimestamp = now();
        if (errorInfo && otherReportedTimestamp - errorInfo.timestamp > MAX_RELATED_TIME) {
            errorInfo = undefined;
        }
        errorInfo = blankErrorCompare(errorInfo, ev);
    };
    var schedule = function () {
        timer && clearTimeout(timer);
        timer = win.setTimeout(function () {
            rAFTimer = rAF(function () {
                var element = getElementByRootSelector(rootSelector);
                if (!element) {
                    return;
                }
                var score = measure(element, 0, 0, threshold);
                if (score < threshold) {
                    blankInfo = [now(), score];
                    checkAndReport();
                }
                else {
                    blankInfo = undefined;
                }
            });
        }, 1000);
    };
    var applyCheck = function (cb) {
        var checkTimestamp;
        return function () {
            if (checkTimer) {
                return;
            }
            checkTimestamp = now();
            checkTimer = win.setTimeout(function () {
                checkTimer = 0;
                if (otherReportedTimestamp > checkTimestamp) {
                    schedule();
                    return;
                }
                cb();
            }, relativeNow() > MAX_RENDER_TIME ? DEFAULT_CHECK_TIME : MAX_CHECK_TIME);
        };
    };
    var checkAndReport = applyCheck(reportBlankScreen);
    tearDownGroup.push(unloadObserver[0](function () {
        !reported && errorInfo && pureReport();
    }));
    if (autoDetect)
        // start observe blank screen after DOMContentLoaded
        tearDownGroup.push(domContentLoadObserver[0](function () {
            var _a;
            // observe dom and schedule
            var _b = __read(applyMutationObserver(getDefaultMutationObserver(), schedule), 2), mutObserve = _b[0], mutDisconnect = _b[1];
            tearDownGroup.push(function () {
                clearTimeout(timer);
                clearTimeout(checkTimer);
                cAF(rAFTimer);
                mutDisconnect && mutDisconnect();
            });
            mutObserve((_a = getDefaultDocument()) === null || _a === void 0 ? void 0 : _a.body, { subtree: true, childList: true });
            // observe resource & longtask and schedule
            tearDownGroup.push(getLongtaskObserver()[0](function () {
                timer && schedule();
            }));
            tearDownGroup.push(getResourceObserver()[0](function () {
                timer && schedule();
            }));
            // start first schedule by default
            schedule();
        }));
    return [applyOtherReport, schedule];
};//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/sdk-web/esm/monitors/blank-screen/index.js.map