/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_SIZE = 10;
var DEFAULT_WAIT = 1000;
var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};
function createBatchSender(config) {
    var transport = config.transport;
    var endpoint = config.endpoint, _a = config.size, size = _a === void 0 ? DEFAULT_SIZE : _a, _b = config.wait, wait = _b === void 0 ? DEFAULT_WAIT : _b;
    var batch = [];
    var tid = 0;
    var fail;
    var sender = {
        getSize: function () {
            return size;
        },
        getWait: function () {
            return wait;
        },
        setSize: function (v) {
            size = v;
        },
        setWait: function (v) {
            wait = v;
        },
        getEndpoint: function () {
            return endpoint;
        },
        setEndpoint: function (v) {
            endpoint = v;
        },
        send: function (e) {
            batch.push(e);
            if (batch.length >= size) {
                sendBatch.call(this);
            }
            clearTimeout(tid);
            tid = setTimeout(sendBatch.bind(this), wait);
        },
        flush: function () {
            clearTimeout(tid);
            sendBatch.call(this);
        },
        getBatchData: function () {
            return batch.length ? stringifyBatch(batch) : '';
        },
        clear: function () {
            clearTimeout(tid);
            batch = [];
        },
        fail: function (cb) {
            fail = cb;
        },
    };
    function sendBatch() {
        if (!batch.length) {
            return;
        }
        var data = this.getBatchData();
        transport.post({
            url: endpoint,
            data: data,
            fail: function (err) {
                fail && fail(err, data);
            },
        });
        batch = [];
    }
    return sender;
}

var noop = function () { return ({}); };

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
var objProto = Object.prototype;
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}

// eslint-disable-next-line @typescript-eslint/ban-types
function omit(object) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    if (isObject(object)) {
        var res_1 = {};
        objectForIn(object, function (k, v) {
            if (!arrayIncludes(keys, k)) {
                res_1[k] = v;
            }
        });
        return res_1;
    }
    return object;
}
function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
function objectForIn(object, callback) {
    if (isObject(object)) {
        for (var i in object) {
            if (hasKey(object, i)) {
                callback.call(null, i, object[i]);
            }
        }
    }
}
// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};
var applyRecord = function () {
    var record = {};
    var set = function (key, val) { return (record[key] = val); };
    var del = function (key) { return delete record[key]; };
    return [record, set, del];
};

function safeJoin(input, delimiter) {
    if (!isArray(input)) {
        return '';
    }
    var output = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < input.length; i++) {
        try {
            output.push(String(input[i]));
        }
        catch (e) {
            output.push('[value cannot be serialized]');
        }
    }
    return output.join(delimiter);
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

/*
 * @Author: pengli.coder
 * @Date: 2021-10-27 20:04:51
 * @LastEditTime: 2021-10-27 20:30:06
 * @LastEditors: Please set LastEditors
 * @Description: refresh the context of the pre-start queue with the context at start
 */
var REFRESH_PRE_START_CONTEXT_INTEGRATION_NAME = 'refreshPreStartContext';
var refreshPreStartContext = function () {
    var tearDownFn = noop;
    return {
        name: REFRESH_PRE_START_CONTEXT_INTEGRATION_NAME,
        setup: function (client) {
            var onStart = function () {
                var preStartQueue = client.getPreStartQueue();
                preStartQueue.forEach(function (ev, index) {
                    var _a, _b;
                    preStartQueue[index] = __assign(__assign({}, ev), { overrides: __assign(__assign({}, ((_a = ev.overrides) !== null && _a !== void 0 ? _a : {})), { 
                            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                            context: ((_b = client === null || client === void 0 ? void 0 : client.context) === null || _b === void 0 ? void 0 : _b.toString()) || {} }) });
                });
            };
            client.on('start', onStart);
            tearDownFn = function () { return client.off('start', onStart); };
        },
        tearDown: function () { return tearDownFn(); },
    };
};

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultPromise() {
    if (getDefaultBrowser() && 'Promise' in window)
        return Promise;
}
function getDefaultXMLHttpRequest() {
    if (typeof XMLHttpRequest === 'function' && isFunction(XMLHttpRequest))
        return XMLHttpRequest;
}
function getDefaultFetch() {
    try {
        // eslint-disable-next-line compat/compat
        new Headers();
        // eslint-disable-next-line compat/compat
        new Request('');
        // eslint-disable-next-line compat/compat
        new Response();
        // eslint-disable-next-line compat/compat
        return window.fetch;
    }
    catch (_a) {
        //
    }
}
function getDefaultMutationObserver() {
    if (getDefaultBrowser() && isFunction(window.MutationObserver))
        return window.MutationObserver;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}

function getFullUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url)
        return '';
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}
function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var reportWithCurrentContext = function (client, timeRequiresAdjustment) {
    if (timeRequiresAdjustment === void 0) { timeRequiresAdjustment = false; }
    var overrides = getOverrides(client);
    timeRequiresAdjustment && (overrides.timestamp = now());
    return function (ev) {
        client.report(__assign(__assign({}, ev), { overrides: overrides }));
    };
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client);
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = __assign(__assign({}, getOverrides(client)), getViewOverrides(newConfig));
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};

var applyMutationObserver = function (MutationObserver, callback) {
    // eslint-disable-next-line compat/compat
    var observer = MutationObserver && new MutationObserver(callback);
    var observe = function (target, options) {
        observer && target && observer.observe(target, options);
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
var applyPerformance = function (performance) {
    // eslint-disable-next-line compat/compat
    var timing = (performance && performance.timing) || undefined;
    var now = function () {
        if (performance && performance.now)
            return performance.now();
        var time = Date.now ? Date.now() : +new Date();
        var start = (timing && timing.navigationStart) || 0;
        return time - start;
    };
    var getEntriesByType = function (type) {
        var getEntriesByType = (performance || {}).getEntriesByType;
        return (isFunction(getEntriesByType) && getEntriesByType.call(performance, type)) || [];
    };
    var getEntriesByName = function (name) {
        var getEntriesByName = (performance || {}).getEntriesByName;
        return (isFunction(getEntriesByName) && getEntriesByName.call(performance, name)) || [];
    };
    var clearResourceTiming = function () {
        var clearResourceTimings = (performance || {}).clearResourceTimings;
        isFunction(clearResourceTimings) && clearResourceTimings.call(performance);
    };
    return [timing, now, getEntriesByType, clearResourceTiming, getEntriesByName];
};
var applyRequestIdleCallback = function (win) {
    return (win.requestIdleCallback ||
        function (cb) {
            return win.setTimeout(cb, 1);
        });
};

/**
 * from sentry https://github.com/getsentry/sentry-javascript/blob/5.30.0/packages/utils/src/browser.ts
 */
var UNKNOWN_PATH = '<unknown>';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 256; // be matched with the filtering rules of data reporting
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return UNKNOWN_PATH;
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el) {
    var elem = el;
    var out = [];
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        out.push("#" + elem.id);
    }
    var className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
        }
    }
    var attrlist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrlist.length; i++) {
        key = attrlist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    return out.join('');
}

var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};
var onPageUnload = function (cb) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var _a = __read(invokeCallbackOnce(cb), 1), invokeCbOnce = _a[0];
    ['unload', 'beforeunload', 'pagehide'].forEach(function (ev) {
        window.addEventListener(ev, invokeCbOnce);
    });
};
var onPageNextShow = function (cb) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var removeListener = noop;
    var onVisibilityChange = function () {
        if (document.visibilityState === 'visible') {
            cb();
            removeListener();
        }
    };
    removeListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChange, true);
};

var XHR_SUBJECT_NAME = 'xhr_0';
var getReportPathRegExp = function () {
    var SELF_REPORT_PATH_REGEXP = new RegExp('\\/monitor_web\\/collect|\\/monitor_browser\\/collect\\/batch', 'i');
    return function (url) { return SELF_REPORT_PATH_REGEXP.test(url); };
};
var hookOpen = function (open) {
    return function () {
        var _a;
        var openOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            openOptions[_i] = arguments[_i];
        }
        _a = __read(openOptions, 2), this._method = _a[0], this._url = _a[1];
        return open.apply(this, openOptions);
    };
};
var hookSetHeader = function (setRequestHeader) {
    return function () {
        var setOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            setOptions[_i] = arguments[_i];
        }
        this._reqHeaders = this._reqHeaders || {};
        var _a = __read(setOptions, 2), name = _a[0], value = _a[1];
        this._reqHeaders[name] = value;
        return setRequestHeader && setRequestHeader.apply(this, setOptions);
    };
};
var hookOnreadystatechange = function (xhr, endNext) {
    return hookMethodDangerously(xhr, 'onreadystatechange', function (origin) {
        return function () {
            var ev = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ev[_i] = arguments[_i];
            }
            // @ts-expect-error
            this.readyState === 4 && endNext(xhr);
            return origin && origin.apply(this, ev);
        };
    });
};
var hookSend = function (send, next) {
    var hitReportPath = getReportPathRegExp();
    return function () {
        var sendOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sendOptions[_i] = arguments[_i];
        }
        this._start = now();
        this._data = sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions[0];
        // not trigger the xhr subject if hit the report path
        if (!hitReportPath(this._url)) {
            var endNext = next([this._method, this._url, this._start, this]);
            hookOnreadystatechange(this, endNext)();
        }
        return send.apply(this, sendOptions);
    };
};
var applyXHR = function (xhr) {
    return function (next, tearDown) {
        if (!xhr)
            return;
        var tearDownGroup = [];
        tearDownGroup.push(hookMethodDangerously(xhr, 'open', hookOpen)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'setRequestHeader', hookSetHeader)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'send', hookSend)(next));
        tearDown(function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    };
};
var FETCH_SUBJECT_NAME = 'fetch_0';
var hookFetch = function (_fetch, next) {
    return function (req, options) {
        if (options === void 0) { options = {}; }
        var endNext = next([req, options]);
        var fetchPromise = _fetch(req, options);
        fetchPromise.then(function (res) {
            // @ts-expect-error
            endNext(res);
        }, function () {
            // @ts-expect-error
            endNext(undefined);
        });
        return fetchPromise;
    };
};
var observeFetch = function (next, tearDown) {
    var global = getDefaultBrowser();
    if (!global || !fetch)
        return;
    var tearDownGroup = [];
    tearDownGroup.push(hookMethodDangerously(global, 'fetch', hookFetch)(next));
    tearDown(function () {
        tearDownGroup.forEach(function (e) { return e(); });
    });
};
var fetchSubject = [FETCH_SUBJECT_NAME, observeFetch];

var RESOURCE_TYPE = ['resource']; // used by resourceMonitor / resourceErrorMonitor / HttpMonitor
var LONGTASK_TYPE = ['longtask']; // used by ttiMonitor / longtaskMonitor / actionMonitor / mpfidMonitor
var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ type: type, buffered: true });
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerf = function (Ob, pipe, types) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), observe = _a[0], disconnect = _a[2];
    observe(types);
    return disconnect;
};
var LONGTASK_SUBJECT_NAME = 'longtask_0';
var observeLongtask = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, LONGTASK_TYPE));
};
var longtaskSubject = [LONGTASK_SUBJECT_NAME, observeLongtask];
var RESOURCE_SUBJECT_NAME = 'resource_0';
var observeResource = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, RESOURCE_TYPE));
};
var resourceSubject = [RESOURCE_SUBJECT_NAME, observeResource];

var PAGEVIEW_EV_TYPE = 'pageview';
var JS_ERROR_EV_TYPE = 'js_error';
var HTTP_EV_TYPE = 'http';
var RESOURCE_EV_TYPE = 'resource';
var PERFORMANCE_METRIC_EV_TYPE = 'performance';
var LONG_TASK_EV_TYPE = 'performance_longtask';
var ACTION_EV_TYPE = 'action';
var HEATMAP_EV_TYPE = 'heatmap';

var CLICK_EVENT_NAME = 'click';
var CLICK_SUBJECT_NAME = CLICK_EVENT_NAME + "_0";
var observeClick = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    document.addEventListener(CLICK_EVENT_NAME, next, true);
    tearDown(function () {
        document.removeEventListener(CLICK_EVENT_NAME, next, true);
    });
};
var clickSubject = [CLICK_SUBJECT_NAME, observeClick];

var defaultMetricContext = {
    isSupport: true,
    isPolyfill: false,
    isBounced: false,
    isCustom: false,
    type: 'perf',
};
var initMetric = function (name, value) {
    return __assign({ name: name, value: value }, defaultMetricContext);
};

var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: PERFORMANCE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
var applyReportMetric = function (report) {
    return function (metric, overrides) {
        report(wrapPerformanceMetric(metric, overrides));
    };
};
var SPA_LOAD_METRIC_NAME = 'spa_load';

var PAGE_ACTIVITY_DELAY = 100;
var MAX_PAGE_ACTIVITY_DELAY = 10000;
var ROOT_TAGS = ['BODY', 'HTML', 'HEAD'];
var SVG_TAG = 'SVG';
var DEFAULT_ATTR_NAME = 'data-apm-action';
/**
 * 控制等待策略和强制结算
 * 结算策略: 没有进行中的请求, 没有dom变更, 没有resource or longTask
 */
var waitActionComplete = function (cb, forceClear, win) {
    var idleTimer;
    var maxIdleTimer;
    var started = false;
    var notify = function () {
        win.clearTimeout(idleTimer);
        started &&
            (idleTimer = win.setTimeout(function () {
                cb();
            }, PAGE_ACTIVITY_DELAY));
    };
    var start = function () {
        started = true;
        win.clearTimeout(maxIdleTimer);
        maxIdleTimer = win.setTimeout(function () {
            cb();
            forceClear();
        }, MAX_PAGE_ACTIVITY_DELAY);
        notify();
    };
    var complete = function () {
        started = false;
        win.clearTimeout(idleTimer);
        win.clearTimeout(maxIdleTimer);
    };
    return [start, notify, complete];
};
var isSupportsElementClosest = (function () {
    var supportsElementClosest;
    return function () {
        return supportsElementClosest === undefined
            ? (supportsElementClosest = 'closest' in HTMLElement.prototype)
            : supportsElementClosest;
    };
})();
var findElementWithAttributeByParents = function (target, attribute, maxParentLoops) {
    if (maxParentLoops === void 0) { maxParentLoops = 10; }
    var element = target;
    for (var i = 0; i < maxParentLoops && element; i++) {
        if (~ROOT_TAGS.indexOf(element.nodeName))
            return;
        if (element.hasAttribute(attribute)) {
            return element;
        }
        element = element.parentElement;
    }
};
var getActionNameByAttribute = function (target, attribute) {
    var elementWithAttribute;
    if (isSupportsElementClosest()) {
        elementWithAttribute = target.closest("[" + attribute + "]");
    }
    else {
        elementWithAttribute = findElementWithAttributeByParents(target, attribute);
    }
    if (!elementWithAttribute)
        return;
    var name = elementWithAttribute.getAttribute(attribute);
    // Possibly length of name is too long to be stored on backend.Let it go for now.Add truncation if someone oncalled
    return name.trim();
};
var getActionName = function (target, attribute) {
    return getActionNameByAttribute(target, attribute) || target.innerText;
};
var isSVGTarget = function (element) {
    var current = element;
    var flag = false;
    while (current) {
        if (current.tagName.toUpperCase() === SVG_TAG) {
            current = null;
            flag = true;
        }
        else {
            current = current.parentElement;
        }
    }
    return flag;
};
var isElementWithinTwoLevels = function (element) {
    var childElement = element.children;
    return childElement.length ? ![].slice.call(childElement).some(function (c) { return c.children.length > 0; }) : true;
};
var isValidTarget = function (element) {
    // if not element node or is root element or is svg
    var tagName = element.tagName.toUpperCase();
    if (element.nodeType !== 1 || ROOT_TAGS.includes(tagName) || isSVGTarget(element)) {
        return false;
    }
    // if element display none
    if (element.style && element.style.display === 'none') {
        return false;
    }
    // if is allowed TagName or has special attribute
    if (['A', 'BUTTON', 'INPUT', 'TEXTAREA'].includes(tagName) || getActionNameByAttribute(element, DEFAULT_ATTR_NAME)) {
        return true;
    }
    // if element not within two levels
    if (!isElementWithinTwoLevels(element)) {
        return false;
    }
    return true;
};

var SUPPORT_TYPES = ["click" /* CLICK */];
var EVENT_LISTENER_OPTIONS = { capture: true };
var MIN_LONG_TASK = 50;
/**
 * Hook XHR & fetch to monitor the number of incomplete requests on the current page.
 */
var applyIncompleteReq = function (tearDownGroup, _a, notify) {
    var _b = __read(_a, 2), xhrObserver = _b[0], fetchObserver = _b[1];
    var _c = __read(applyRecord(), 3), incompleteReq = _c[0], before = _c[1], after = _c[2];
    var uniqId = 0;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 1); _b[0];
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    tearDownGroup.push(fetchObserver[0](function () {
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    return incompleteReq;
};
var actionGetterWithFetchObserver = function (setCurrentContext, tearDownGroup, _a, config) {
    var _b = __read(_a, 4), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3];
    var types = config.types, pure = config.pure;
    var currentPayload = null;
    var lastPayload = null;
    var reportWithContext = undefined;
    var requestStartAndEnd = [];
    var longtaskDuration = 0;
    var _c = __read(applyPerformance(performance), 2), now = _c[1];
    var reportActionIfAllowed = function (force) {
        // no action metrics || no payload || not force but there are still pending requests
        if (!currentPayload ||
            (!pure && !Object.keys(currentPayload.metrics).length) ||
            (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        // set long task duration
        currentPayload.metrics[LONG_TASK_EV_TYPE] &&
            (currentPayload.metrics[LONG_TASK_EV_TYPE].duration = longtaskDuration);
        // set request duration
        var requestDuration = requestStartAndEnd.length > 0 ? Math.max.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) - Math.min.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) : 0;
        currentPayload.metrics[HTTP_EV_TYPE] && (currentPayload.metrics[HTTP_EV_TYPE].duration = requestDuration);
        // end time
        var actionDuration = now() - currentPayload.start_time;
        reportWithContext &&
            reportWithContext({
                ev_type: ACTION_EV_TYPE,
                payload: __assign(__assign({}, currentPayload), { duration: actionDuration, frontend_time: actionDuration - requestDuration }),
            });
        // reset action after report current action
        resetAction();
    };
    var resetAction = function () {
        complete();
        // refresh lastPayload so that delay-type events can be correctly attach action id
        currentPayload &&
            (lastPayload = {
                start_time: currentPayload.start_time,
                id: currentPayload.id,
            });
        currentPayload = null;
        requestStartAndEnd = [];
        longtaskDuration = 0;
    };
    var calculateMetric = function (ev_type) {
        var _a, _b;
        currentPayload &&
            (currentPayload.metrics[ev_type] = {
                count: ((_b = (_a = currentPayload.metrics[ev_type]) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0) + 1,
            });
    };
    var _d = __read(waitActionComplete(reportActionIfAllowed, resetAction, window), 3), start = _d[0], notify = _d[1], complete = _d[2];
    // notify if meet xhr and fetch
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    // notify if meet mutation change
    var _e = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _e[0], disconnect = _e[1];
    observe();
    tearDownGroup.push(disconnect);
    tearDownGroup.push(complete);
    // notify if meet longtask
    tearDownGroup.push(longtaskObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration;
        notify();
        // calculate longtask
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (currentPayload && currentPayload.start_time <= startTime + MIN_LONG_TASK) {
            longtaskDuration = longtaskDuration + duration;
            calculateMetric(LONG_TASK_EV_TYPE);
        }
    }));
    // notify if meet resource
    tearDownGroup.push(resourceObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration, initiatorType = _a.initiatorType;
        notify();
        if (currentPayload && currentPayload.start_time < startTime) {
            // calculate http
            if (['xmlhttprequest', 'fetch'].includes(initiatorType)) {
                // the reason for calculating HTTP duration here is that incompleteReq cannot get the correct start and end times
                requestStartAndEnd.push(startTime, startTime + duration);
                calculateMetric(HTTP_EV_TYPE);
            }
            // calculate resource
            if (!['xmlhttprequest', 'fetch', 'beacon'].includes(initiatorType)) {
                calculateMetric(RESOURCE_EV_TYPE);
            }
        }
    }));
    // attach action id to other data
    var applyOtherReport = function (ev) {
        // if there is a new Page View, forcefully settle the current action
        if (ev.ev_type === PAGEVIEW_EV_TYPE) {
            reportActionIfAllowed(true);
            resetAction();
            return;
        }
        // because http needs to wait timing so http event belongs to the delay-type events, need special correction.
        if (ev.ev_type === HTTP_EV_TYPE) {
            var startTime = ev.payload.response.timing && ev.payload.response.timing.startTime;
            if (!startTime)
                return;
            if (currentPayload && startTime > currentPayload.start_time)
                return currentPayload.id;
            if (lastPayload && startTime > lastPayload.start_time)
                return lastPayload.id;
            return;
        }
        // due to the event loop, the starting time of long task will be earlier than the time of interactive trigger.
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (ev.ev_type === LONG_TASK_EV_TYPE) {
            var startTime = ev.payload.longtasks.length && ev.payload.longtasks[0].startTime + MIN_LONG_TASK;
            if (currentPayload && startTime && startTime > currentPayload.start_time)
                return currentPayload.id;
            return;
        }
        if (!currentPayload) {
            return;
        }
        // calculate js error and resource
        // because JS error and resource error are synchronous events, they can be attached here.
        if (ev.ev_type === JS_ERROR_EV_TYPE || ev.ev_type === RESOURCE_EV_TYPE) {
            calculateMetric(ev.ev_type);
        }
        return currentPayload.id;
    };
    var initAction = function (target, type) {
        // refresh action id in common
        var actionId = uuid();
        var _a = __read(applyPerformance(performance), 2), now = _a[1];
        // init payload
        currentPayload = {
            start_time: now(),
            id: actionId,
            type: type,
            target: target,
            metrics: {},
        };
        reportWithContext = setCurrentContext();
        start();
    };
    var handleEvent = function (e) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        if (!(e.target instanceof HTMLElement) || !isValidTarget(e.target)) {
            return;
        }
        var name = getActionName(e.target, DEFAULT_ATTR_NAME);
        if (!name) {
            return;
        }
        initAction({ name: name, path: htmlTreeAsString(e.target) }, e.type);
    };
    types &&
        types.forEach(function (t) {
            if (arrayIncludes(SUPPORT_TYPES, t)) {
                document.addEventListener(t, handleEvent, EVENT_LISTENER_OPTIONS);
                tearDownGroup.push(function () { return document.removeEventListener(t, handleEvent, EVENT_LISTENER_OPTIONS); });
            }
        });
    var startAction = function (name, type) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        initAction({ name: name }, type);
    };
    return [applyOtherReport, startAction];
};

var ACTION_MONITOR_PLUGIN_NAME = 'action';
var defaultConfig = {
    types: ["click" /* CLICK */],
    pure: true,
};
function ActionMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig; }
    var tearDownGroup = [];
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var _a = __read(actionGetterWithFetchObserver(function () { return reportWithCurrentContext(client, true); }, tearDownGroup, [
        initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
        initSubjectInGlobal(client, fetchSubject),
        initSubjectInGlobal(client, longtaskSubject),
        initSubjectInGlobal(client, resourceSubject),
    ], config), 2), applyOtherReport = _a[0], startAction = _a[1];
    var listenOtherReport = function (ev) {
        var actionId = applyOtherReport(ev);
        actionId && ev.extra && (ev.extra.action_id = actionId);
        return ev;
    };
    client.on('report', listenOtherReport);
    tearDownGroup.push(function () {
        client.off('report', listenOtherReport);
    });
    client.provide('startAction', startAction);
    registerTearDownGroup(client, ACTION_MONITOR_PLUGIN_NAME, ACTION_EV_TYPE, tearDownGroup);
}

var getSPA = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 7), pvObserver = _b[0], clickObserver = _b[1], xhrObserver = _b[2], fetchObserver = _b[3], resourceObserver = _b[4], longtaskObserver = _b[5], MutationObserver = _b[6];
    var spa_load_start = 0;
    var reportMetric = applyReportMetric(report);
    var startSPA = function () {
        spa_load_start = now();
        observe(document, {
            childList: true,
            subtree: true,
        });
        start();
    };
    var reportSPAIfAllowed = function (force) {
        // no spa start || not force but there are still pending requests
        if (!spa_load_start || (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        reportMetric(initMetric(SPA_LOAD_METRIC_NAME, now() - spa_load_start));
        endSPA();
    };
    var endSPA = function () {
        complete();
        spa_load_start = 0;
    };
    // get schedule function and set an empty forceClear
    var _c = __read(waitActionComplete(reportSPAIfAllowed, noop, window), 3), start = _c[0], notify = _c[1], complete = _c[2];
    // request
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    // resource
    tearDownGroup.push(resourceObserver[0](notify));
    // longtask
    tearDownGroup.push(longtaskObserver[0](notify));
    // dom
    var _d = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _d[0], disconnect = _d[1];
    tearDownGroup.push(disconnect);
    var isFirstPV = true;
    // start SPA when PV change
    tearDownGroup.push(pvObserver[0](function () {
        if (isFirstPV) {
            isFirstPV = false;
            return;
        }
        // force report last SPA
        reportSPAIfAllowed(true);
        // clear status
        endSPA();
        // start a new SPA metric
        startSPA();
    }));
    // force report last SPA and clear status when the click is triggered
    tearDownGroup.push(clickObserver[0](function () {
        // force report last SPA
        reportSPAIfAllowed(true);
        // clear status
        endSPA();
    }));
    // reset SPA status when tear down
    tearDownGroup.push(endSPA);
};

function SPALoadMonitorPlugin(client) {
    client.on('init', function () {
        var tearDownGroup = [];
        var document = getDefaultDocument();
        var MutationObserver = getDefaultMutationObserver();
        if (!document || !MutationObserver)
            return;
        getSPA(client.report.bind(client), tearDownGroup, [
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
            initSubjectInGlobal(client, clickSubject),
            initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
            initSubjectInGlobal(client, fetchSubject),
            initSubjectInGlobal(client, resourceSubject),
            initSubjectInGlobal(client, longtaskSubject),
            MutationObserver,
        ]);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

/* eslint-disable @typescript-eslint/prefer-optional-chain */
var getBeaconTransport = function () {
    var window = getDefaultBrowser();
    // eslint-disable-next-line compat/compat
    return window && window.navigator.sendBeacon
        ? {
            get: function () { },
            post: function (url, data) {
                // eslint-disable-next-line compat/compat
                window.navigator.sendBeacon(url, data);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

var request = function (method, options, XMLHttpRequest) {
    var url = options.url, data = options.data, _a = options.success, success = _a === void 0 ? noop : _a, _b = options.fail, fail = _b === void 0 ? noop : _b, _c = options.getResponseText, getResponseText = _c === void 0 ? noop : _c, _d = options.withCredentials, withCredentials = _d === void 0 ? false : _d;
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = withCredentials;
    xhr.open(method, url, true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onload = function () {
        getResponseText === null || getResponseText === void 0 ? void 0 : getResponseText(this.responseText);
        try {
            if (this.responseText) {
                var result = JSON.parse(this.responseText);
                success(result);
            }
            else {
                success({});
            }
        }
        catch (e) {
            fail(e);
        }
    };
    xhr.onerror = function () {
        fail(new Error('Network request failed'));
    };
    xhr.onabort = function () {
        /* istanbul ignore next */
        fail(new Error('Network request aborted'));
    };
    xhr.send(data);
};
var getXhrTransport = function () {
    var XMLHttpRequest = getDefaultXMLHttpRequest();
    return XMLHttpRequest
        ? {
            useBeacon: true,
            get: function (options) {
                request('GET', options, XMLHttpRequest);
            },
            post: function (options) {
                request('POST', options, XMLHttpRequest);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

// createSender has side effects(register onClose behavior)
// so it must be create lazily
function createBrowserSender(config) {
    var sender = createBatchSender(config);
    var originSend = sender.send;
    // send the cached data immediately upon unload
    onPageUnload(function () {
        // use sendBeacon if allowed
        if (config.transport.useBeacon) {
            var beaconTransport_1 = getBeaconTransport();
            var data = sender.getBatchData();
            if (data) {
                beaconTransport_1.post(sender.getEndpoint(), data);
                sender.clear();
            }
            // some data may still be generated during unload
            sender.send = function (data) {
                beaconTransport_1.post(sender.getEndpoint(), stringifyBatch([data]));
            };
            // in webview, page can still be resurrected even after the `unload` event has been triggered
            onPageNextShow(function () {
                sender.send = originSend;
            });
        }
        else {
            // if not use sendBeacon, flush the data list by default
            sender.flush();
        }
    });
    return sender;
}

var HEATMAP_INTEGRATION_NAME = 'heatmap';
var heatmap = function () {
    var heatmap;
    return {
        name: HEATMAP_INTEGRATION_NAME,
        setup: function (client) {
            var getExports = function (code) {
                var module = { exports: {} };
                // eslint-disable-next-line
                var fn = new Function('module', 'exports', code);
                try {
                    fn(module, module.exports);
                    return module.exports;
                }
                catch (err) {
                    return {};
                }
            };
            function request(url, callback) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function (e) {
                    var response = e.target.response;
                    response && callback(response);
                };
                xhr.send();
            }
            client.on('start', function () {
                var _a;
                var heatmapConfig = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[HEATMAP_INTEGRATION_NAME];
                if (!heatmapConfig) {
                    return;
                }
                var open_list = heatmapConfig.open_list, url = heatmapConfig.url;
                if (!url) {
                    return;
                }
                var callback = function (res) {
                    var createHeatmap = getExports(res).createHeatmap;
                    if (!createHeatmap) {
                        return;
                    }
                    var config = {
                        open_list: open_list,
                    };
                    heatmap = createHeatmap({
                        config: config,
                        sendEvent: function (args) { return client.report(args); },
                    });
                    heatmap.init();
                    client.destroyAgent.set(HEATMAP_INTEGRATION_NAME, HEATMAP_EV_TYPE, [function () { return heatmap === null || heatmap === void 0 ? void 0 : heatmap.destroy(); }]);
                };
                request(url, callback);
            });
        },
    };
};

var CAPTURE_CONSOLE_INTEGRATION_NAME = 'captureConsole';
var captureConsole = function (_a) {
    var _b = _a.levels, levels = _b === void 0 ? ['log', 'info', 'warn', 'error', 'debug', 'assert'] : _b;
    return ({
        name: CAPTURE_CONSOLE_INTEGRATION_NAME,
        setup: function (client) {
            var global = getDefaultBrowser();
            if (!global || !global.console)
                return;
            var tearDownGroup = [];
            levels.forEach(function (level) {
                if (!(level in global.console)) {
                    return;
                }
                var hookConsoleLevel = function (origin) {
                    return function () {
                        var params = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            params[_i] = arguments[_i];
                        }
                        try {
                            origin && origin.call.apply(origin, __spreadArray([global.console], __read(params), false));
                        }
                        finally {
                            client('captureException', safeJoin(params, ' '));
                        }
                    };
                };
                tearDownGroup.push(hookMethodDangerously(global.console, level, hookConsoleLevel)());
            });
            // it have to set JS_ERROR_EV_TYPE,because that is depend on the client('captureException')
            client.destroyAgent.set(CAPTURE_CONSOLE_INTEGRATION_NAME, JS_ERROR_EV_TYPE, tearDownGroup);
        },
    });
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var MODIFY_PAGEVIEW_CONTEXT_INTEGRATION_NAME = 'modifyPageviewContext';
var modifyPageviewContext = function () {
    var tearDownFn = noop;
    return {
        name: MODIFY_PAGEVIEW_CONTEXT_INTEGRATION_NAME,
        setup: function (client) {
            var onReport = function (ev) {
                if (ev.ev_type === 'pageview') {
                    var config = client.config();
                    var currentPid = ev.payload.pid;
                    config.pid !== currentPid &&
                        client.set({
                            pid: currentPid,
                            viewId: currentPid + '_' + Date.now(),
                        });
                }
                return ev;
            };
            client.on('report', onReport);
            tearDownFn = function () { return client.off('report', onReport); };
        },
        tearDown: function () { return tearDownFn(); },
    };
};

var DOUBLE_REPORT_INTEGRATION_NAME = 'doubleReport';
var doubleReportPlugin = function (_a) {
    var bid = _a.bid;
    var tearDownFn = noop;
    return {
        name: DOUBLE_REPORT_INTEGRATION_NAME,
        setup: function (client) {
            var _a = __read(doubleReport(client, bid), 2); _a[0]; var tearDown = _a[1];
            tearDownFn = tearDown;
        },
        tearDown: function () { return tearDownFn(); },
    };
};
var BATCH_REPORT_PATH = "/monitor_browser/collect/batch/";
var REPORT_DOMAIN = "mon.zijieapi.com";
var getReportUrl = function (domain, path) {
    if (path === void 0) { path = BATCH_REPORT_PATH; }
    return "" + (domain && domain.indexOf('//') >= 0 ? '' : 'https://') + domain + path;
};
function doubleReport(client, bid) {
    var sender = createBrowserSender({
        size: 20,
        endpoint: getReportUrl(REPORT_DOMAIN),
        transport: getXhrTransport(),
    });
    var slardarConfig = {};
    var onStart = function () {
        var config = client.config();
        if (!config)
            return;
        var session_id = config.sessionId, device_id = config.deviceId, env = config.env, release = config.release, user_id = config.userId, sdk_offset = config.offset;
        slardarConfig = {
            session_id: session_id,
            device_id: device_id,
            env: env,
            release: release,
            user_id: user_id,
        };
        sdk_offset && (slardarConfig['sdk_offset'] = sdk_offset);
    };
    client.on('start', onStart);
    var onSend = function (e) {
        var _a = e.common; _a.aid; var params = __rest(_a, ["aid"]);
        sender.send(__assign(__assign({}, e), { common: __assign(__assign(__assign({}, params), slardarConfig), { bid: bid }) }));
        return e;
    };
    client.on('send', onSend);
    var tearDownFn = function () {
        client.off('start', onStart);
        client.off('send', onSend);
    };
    return [sender, tearDownFn];
}

var SRI_INTEGRATION_NAME = 'SriPlugin';
var SRI_EV_TYPE = 'sri';
var sriPlugin = function (onError) {
    var tearDownFn = noop;
    return {
        name: SRI_INTEGRATION_NAME,
        setup: function (client) {
            var window = getDefaultBrowser();
            var fetch = getDefaultFetch();
            var promise = getDefaultPromise();
            if (!window || !fetch || !promise) {
                return;
            }
            var loadScript = createLoadScript(function (payload) {
                client.report({ ev_type: SRI_EV_TYPE, payload: payload });
            }, promise, fetch, onError);
            var sriErrorLog = staticSRIErrorLog(loadScript, window);
            window.addEventListener('error', sriErrorLog, true);
            tearDownFn = function () { return window.removeEventListener('error', sriErrorLog, true); };
        },
        tearDown: function () { return tearDownFn(); },
    };
};
var staticSRIErrorLog = function (loadScript, window) { return function (event) {
    var _a, _b, _c;
    var e = event || window.event || {};
    var target;
    try {
        target = ((_b = (_a = e.target) !== null && _a !== void 0 ? _a : e.srcElement) !== null && _b !== void 0 ? _b : {});
    }
    catch (e) {
        return;
    }
    if (!checkHasIntegrity(target)) {
        return;
    }
    var url = getSrc(target);
    var tagName = ((_c = target.tagName) === null || _c === void 0 ? void 0 : _c.toLowerCase()) || '';
    if (!url || !tagName || url === location.href) {
        return;
    }
    loadScript(url);
}; };
var checkHasIntegrity = function (target) {
    if (isFunction(target.getAttribute)) {
        return Boolean(target.getAttribute('integrity'));
    }
    else if (target.integrity) {
        return true;
    }
    return false;
};
var getSrc = function (target) {
    if (isFunction(target.getAttribute)) {
        return target.getAttribute('src');
    }
    return target.src || target.href || '';
};
var createLoadScript = function (cb, promise, _fetch, onError) {
    return function (src) {
        promise
            .all([loadScript(src, _fetch), loadScript(src + "?vt=" + Date.now(), _fetch, false)])
            .then(function (_a) {
            var _b = __read(_a, 2), errorFileRes = _b[0], realFileRes = _b[1];
            if (errorFileRes.status === 200 && realFileRes.status === 200) {
                return promise.all([errorFileRes.text(), realFileRes.text()]).then(function (contexts) {
                    var errorFileContext = contexts[0] || errorFileRes.status + "," + realFileRes.status;
                    var errorFileSize = errorFileContext.length;
                    var realFileSize = contexts[1].length;
                    return [errorFileSize, realFileSize, errorFileContext, src];
                });
            }
        })
            .then(function (ret) {
            if (!ret || !cb) {
                return;
            }
            var _a = __read(ret, 3), errorFileSize = _a[0], realFileSize = _a[1], errorFileContext = _a[2];
            if (errorFileContext && errorFileSize !== realFileSize) {
                cb(getSourceData.apply(void 0, __spreadArray([], __read(ret), false)));
            }
        })
            .catch(function (e) {
            if (onError) {
                onError(e);
            }
        });
    };
};
// 加载文件
var loadScript = function (url, fetch, cache) {
    if (cache === void 0) { cache = true; }
    return fetch(url, cache ? { cache: 'force-cache' } : { cache: 'no-store' }).then(function (res) {
        return res.ok ? res : new Response();
    });
};
var getSourceData = function (error_file_size, real_file_size, error_file_context, static_file_src) { return ({
    error_file_size: error_file_size,
    real_file_size: real_file_size,
    error_file_context: error_file_context,
    static_file_src: static_file_src,
    static_file_url: getFullUrl(static_file_src) || '',
}); };

function promisifyRequest(request) {
    return new Promise((resolve, reject) => {
        // @ts-ignore - file size hacks
        request.oncomplete = request.onsuccess = () => resolve(request.result);
        // @ts-ignore - file size hacks
        request.onabort = request.onerror = () => reject(request.error);
    });
}
function createStore(dbName, storeName) {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    const dbp = promisifyRequest(request);
    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
    if (!defaultGetStoreFunc) {
        defaultGetStoreFunc = createStore('keyval-store', 'keyval');
    }
    return defaultGetStoreFunc;
}
/**
 * Update a value. This lets you see the old value and update it as an atomic operation.
 *
 * @param key
 * @param updater A callback that takes the old value and returns a new value.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */
function update(key, updater, customStore = defaultGetStore()) {
    return customStore('readwrite', (store) => 
    // Need to create the promise manually.
    // If I try to chain promises, the transaction closes in browsers
    // that use a promise polyfill (IE10/11).
    new Promise((resolve, reject) => {
        store.get(key).onsuccess = function () {
            try {
                store.put(updater(this.result), key);
                resolve(promisifyRequest(store.transaction));
            }
            catch (err) {
                reject(err);
            }
        };
    }));
}

var OFFLINE_INTEGRATION_NAME = 'offline';
var IndexedDB_Name = "__" + OFFLINE_INTEGRATION_NAME + "__db__";
var IndexedDB_Store_Name = "__" + OFFLINE_INTEGRATION_NAME + "__store__";
var MaxSendSize = 60;
var MaxStoreEvents = 60;
var SendIntervalTime = 2000;
var CONTEXT_FLAG = "_is_" + OFFLINE_INTEGRATION_NAME + "_";
var offlineIntegration = function (props) {
    var tearDownGroup = [];
    return {
        name: OFFLINE_INTEGRATION_NAME,
        setup: function (client) {
            var win = getDefaultBrowser();
            if (!win || !indexedDB)
                return;
            var maxStoreEvents = (props && props.maxStoreEvents) || MaxStoreEvents;
            var maxSendSize = (props && props.maxSendSize) || MaxSendSize;
            var isPostDataFailed = false;
            var _a = client.config(), transport = _a.transport, bid = _a.bid;
            var storeKey = bid;
            var sender = client.getSender();
            var isOffline = getOffline();
            var requestIdleCallback = applyRequestIdleCallback(win);
            /**
             * report the data where cached on indexedDB
             * @param data
             * @param fail
             */
            var postData = function (data, success, fail) {
                transport.post({
                    url: sender.getEndpoint(),
                    data: data,
                    success: success,
                    fail: function (err) {
                        fail(err, data);
                    },
                });
            };
            var initialization = function () {
                var offlineStore = createStore(IndexedDB_Name, IndexedDB_Store_Name);
                var handleFailCallback = function (_err, batchStringData) {
                    var data;
                    try {
                        var batchData = JSON.parse(batchStringData);
                        data = batchData.list;
                    }
                    catch (_a) {
                        // do nothing
                    }
                    isPostDataFailed = true;
                    if (data) {
                        data.forEach(function (event) { return (event.common.context[CONTEXT_FLAG] = '1'); });
                        void insertData(offlineStore, storeKey, data, maxStoreEvents);
                    }
                };
                var sendEvents = function () { return __awaiter(void 0, void 0, void 0, function () {
                    var events;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, spliceStore(offlineStore, storeKey, maxSendSize)];
                            case 1:
                                events = _a.sent();
                                if (events.length && !isPostDataFailed) {
                                    postData(stringifyBatch(events), function () { return setTimeout(function () { return void sendEvents(); }, SendIntervalTime); }, handleFailCallback);
                                }
                                return [2 /*return*/];
                        }
                    });
                }); };
                sender.fail && sender.fail(handleFailCallback);
                tearDownGroup.push(onlineListener(sendEvents));
                // send events immediately as soon as initialization completes
                if (!isOffline())
                    void sendEvents();
            };
            var onStart = function () {
                return requestIdleCallback(function () {
                    void initialization();
                });
            };
            client.on('start', onStart);
            tearDownGroup.push(function () { return client.off('start', onStart); });
        },
        tearDown: function () { return tearDownGroup.forEach(function (fn) { return fn(); }); },
    };
};
function insertData(store, storeKey, events, maxStoreEvents) {
    if (maxStoreEvents === void 0) { maxStoreEvents = MaxStoreEvents; }
    return __awaiter(this, void 0, void 0, function () {
        var error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, update(storeKey, function (oldData) {
                            if (!Array.isArray(oldData))
                                return events;
                            var mergedData = oldData.concat(events);
                            return mergedData.length > maxStoreEvents
                                ? mergedData.slice(mergedData.length - maxStoreEvents, mergedData.length)
                                : mergedData;
                        }, store)];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    // may be throw error like an object can't be cloned
                    console.info('indexedDB update error', error_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function spliceStore(store, storeKey, deleteCount) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = [];
                    return [4 /*yield*/, update(storeKey, function (val) {
                            if (val) {
                                result = val.splice(0, deleteCount);
                                return val;
                            }
                            return [];
                        }, store)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
/**
 * return false if window or navigator.onLine is undefined
 * @returns
 */
function getOffline() {
    var window = getDefaultBrowser();
    if (!(window && 'navigator' in window && 'onLine' in window.navigator))
        return function () { return false; };
    return function () { return !window.navigator.onLine; };
}
function onlineListener(callback) {
    var window = getDefaultBrowser();
    if (window && 'addEventListener' in window) {
        window.addEventListener('online', callback);
        return function () { return window.removeEventListener('online', callback); };
    }
    return function () { };
}

var SPA_LOAD_INTEGRATION_NAME = 'spa_load';
var SPALoadPlugin = function () { return ({
    name: SPA_LOAD_INTEGRATION_NAME,
    setup: function (client) {
        SPALoadMonitorPlugin(client);
    },
}); };

var ACTION_INTEGRATION_NAME = ACTION_MONITOR_PLUGIN_NAME;
var actionPlugin = function (config) { return ({
    name: ACTION_INTEGRATION_NAME,
    setup: function (client) {
        ActionMonitorBasePlugin(client, config);
    },
}); };

var PAUSE_INTEGRATION_NAME = 'pause';
var DEFAULT_CAPACITY$1 = 100;
var defaultStopOptions = {
    isReportAll: true,
};
var defaultPauseOptions = {
    capacity: DEFAULT_CAPACITY$1,
    isResume: false,
};
var pause = function () { return ({
    name: PAUSE_INTEGRATION_NAME,
    setup: function (client) {
        var controller = createController(client.report.bind(client));
        client.on('init', function () {
            client.provide(PAUSE_INTEGRATION_NAME, omit(controller, 'preReport'));
        });
        client.on('beforeReport', function (ev) {
            return controller.preReport(ev);
        });
        // stop but not report if its state is pause
        client.destroyAgent.set(PAUSE_INTEGRATION_NAME, PAUSE_INTEGRATION_NAME, [
            function () {
                controller.stopAction({ isReportAll: false });
            },
        ]);
    },
}); };
function createController(report, options) {
    if (options === void 0) { options = {
        onTransition: noop,
        initState: 'running',
    }; }
    var _state = options.initState;
    var _queue;
    var _transCb = options.onTransition;
    var _isCheckState = true;
    function _flush() {
        while (_queue === null || _queue === void 0 ? void 0 : _queue.getSize()) {
            report(_queue.dequeue());
        }
    }
    function startAction() {
        var nextState = 'running';
        var allowStates = ['stop', 'pause'];
        var isTransSuc = allowStates.includes(_state);
        if (isTransSuc) {
            _transCb(_state, nextState);
            _state = nextState;
            // The queue is empty by default in stop state.
            _flush();
        }
        return isTransSuc;
    }
    function stopAction(options) {
        var isReportAll = __assign(__assign({}, defaultStopOptions), options).isReportAll;
        var nextState = 'stop';
        var allowStates = ['running', 'pause'];
        var isTransSuc = allowStates.includes(_state);
        if (isTransSuc) {
            _transCb(_state, nextState);
            _state = nextState;
            if (isReportAll) {
                // set _isCheckoutState to false is used to skip the check state of preReport function.
                _isCheckState = false;
                _flush();
                // reset immediately
                _isCheckState = true;
            }
            _queue === null || _queue === void 0 ? void 0 : _queue.clear();
        }
        return isTransSuc;
    }
    function pauseAction(options) {
        var _a = __assign(__assign({}, defaultPauseOptions), options), capacity = _a.capacity, isResume = _a.isResume;
        var nextState = 'pause';
        var allowStates = ['running'];
        var isTransSuc = allowStates.includes(_state);
        if (_state === 'running') {
            _queue = createQueue(capacity, function () {
                if (isResume) {
                    startAction();
                }
            });
        }
        if (isTransSuc) {
            _transCb(_state, nextState);
            _state = nextState;
        }
        return isTransSuc;
    }
    function onTransition(cb) {
        _transCb = cb;
    }
    function getState() {
        return _state;
    }
    function getQueueSize() {
        return _queue ? _queue.getSize() : 0;
    }
    function preReport(e) {
        if (_state === 'pause') {
            _queue.enqueue(e);
            return false;
        }
        if (_state === 'running' || !_isCheckState) {
            return e;
        }
        return false;
    }
    return { startAction: startAction, stopAction: stopAction, pauseAction: pauseAction, onTransition: onTransition, getState: getState, getQueueSize: getQueueSize, preReport: preReport };
}
function createQueue(capacity, fullCallback) {
    var _queue = [];
    var _capacity = capacity;
    function enqueue(ele) {
        _queue.push(ele);
        if (getSize() >= _capacity) {
            fullCallback === null || fullCallback === void 0 ? void 0 : fullCallback();
        }
        _shrink();
    }
    function dequeue() {
        return _queue.shift();
    }
    function clear() {
        _queue = [];
    }
    function getSize() {
        return _queue.length;
    }
    function setCapacity(capacity) {
        _capacity = capacity;
        _shrink();
    }
    function getCapacity() {
        return _capacity;
    }
    function _shrink() {
        while (getSize() > _capacity) {
            dequeue();
        }
    }
    return { enqueue: enqueue, dequeue: dequeue, clear: clear, getSize: getSize, setCapacity: setCapacity, getCapacity: getCapacity };
}

var DEFAULT_PREFIX = 'libra_';
var DEFAULT_CAPACITY = 30;
var LIBRA_INTEGRATION_NAME = 'libra';
var defaultLibraOptions = {
    prefix: DEFAULT_PREFIX,
    isHook: true,
    isPause: true,
    capacity: DEFAULT_CAPACITY,
    isResume: true,
};
// dependent on pause integration
var libra = function (tea, options) {
    var restoreFns = [];
    return {
        name: LIBRA_INTEGRATION_NAME,
        setup: function (client) {
            var _a = __assign(__assign({}, defaultLibraOptions), options), prefix = _a.prefix, isHook = _a.isHook, isPause = _a.isPause, capacity = _a.capacity, isResume = _a.isResume;
            if (isPause && !client.pause)
                return;
            // hook tea getVar, when user invoke it, we will add its test.
            if (isHook && tea.getVar) {
                restoreFns.push(hookObjectProperty(tea, 'getVar', function (origin) {
                    return function (name, defaultValue, callback) {
                        try {
                            addTest(name);
                            // eslint-disable-next-line no-empty
                        }
                        catch (error) { }
                        origin.apply(tea, [name, defaultValue, callback]);
                    };
                })());
            }
            // invoke tea.getAllVars to get the vid of ab test
            function _waitTeaValues(cb) {
                var _a, _b;
                // pause client utils getAllVars invoke callback to avoid sending event with out-of-date context.
                isPause && ((_a = client.pause) === null || _a === void 0 ? void 0 : _a.pauseAction({ capacity: capacity, isResume: isResume }));
                //  make sure getAllVars invoke before any getVar in the new page
                (_b = tea.getAllVars) === null || _b === void 0 ? void 0 : _b.call(tea, function (values) {
                    var _a;
                    cb(values);
                    // resume client
                    isPause && ((_a = client.pause) === null || _a === void 0 ? void 0 : _a.startAction());
                });
            }
            function _getKey(testName) {
                return prefix + testName;
            }
            function addTest(testName) {
                _waitTeaValues(function (testValues) {
                    var _a;
                    if (!testValues[testName] || !testValues[testName].vid) {
                        return;
                    }
                    // context plugin is loaded synchronously
                    (_a = client.context) === null || _a === void 0 ? void 0 : _a.set(_getKey(testName), testValues[testName].vid);
                });
            }
            function removeTest(testName) {
                var _a;
                (_a = client.context) === null || _a === void 0 ? void 0 : _a.delete(_getKey(testName));
            }
            function getAllTests() {
                if (client.context) {
                    return Object.keys(client.context.toString())
                        .filter(function (key) { return key.startsWith(prefix); })
                        .map(function (key) { return key.substring(prefix.length); });
                }
            }
            function clearTest() {
                if (client.context) {
                    Object.keys(client.context.toString()).forEach(function (key) {
                        var _a;
                        if (key.startsWith(prefix)) {
                            (_a = client.context) === null || _a === void 0 ? void 0 : _a.delete(key);
                        }
                    });
                }
            }
            client.on('init', function () {
                client.provide(LIBRA_INTEGRATION_NAME, { addTest: addTest, removeTest: removeTest, getAllTests: getAllTests, clearTest: clearTest });
            });
            restoreFns.push(clearTest);
        },
        tearDown: function () { return restoreFns.forEach(function (fn) { return fn(); }); },
    };
};

export { BATCH_REPORT_PATH, LIBRA_INTEGRATION_NAME, PAUSE_INTEGRATION_NAME, SPALoadPlugin, actionPlugin, captureConsole, createController, createQueue, doubleReportPlugin, heatmap, libra, modifyPageviewContext, offlineIntegration, pause, refreshPreStartContext, sriPlugin };//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/integrations/dist/index.esm.js.map
