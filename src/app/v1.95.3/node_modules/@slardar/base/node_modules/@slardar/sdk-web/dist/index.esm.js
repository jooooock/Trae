/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_SIZE = 10;
var DEFAULT_WAIT = 1000;
var stringifyBatch = function (list) {
    return JSON.stringify({
        ev_type: 'batch',
        list: list,
    });
};
function createBatchSender(config) {
    var transport = config.transport;
    var endpoint = config.endpoint, _a = config.size, size = _a === void 0 ? DEFAULT_SIZE : _a, _b = config.wait, wait = _b === void 0 ? DEFAULT_WAIT : _b;
    var batch = [];
    var tid = 0;
    var fail;
    var sender = {
        getSize: function () {
            return size;
        },
        getWait: function () {
            return wait;
        },
        setSize: function (v) {
            size = v;
        },
        setWait: function (v) {
            wait = v;
        },
        getEndpoint: function () {
            return endpoint;
        },
        setEndpoint: function (v) {
            endpoint = v;
        },
        send: function (e) {
            batch.push(e);
            if (batch.length >= size) {
                sendBatch.call(this);
            }
            clearTimeout(tid);
            tid = setTimeout(sendBatch.bind(this), wait);
        },
        flush: function () {
            clearTimeout(tid);
            sendBatch.call(this);
        },
        getBatchData: function () {
            return batch.length ? stringifyBatch(batch) : '';
        },
        clear: function () {
            clearTimeout(tid);
            batch = [];
        },
        fail: function (cb) {
            fail = cb;
        },
    };
    function sendBatch() {
        if (!batch.length) {
            return;
        }
        var data = this.getBatchData();
        transport.post({
            url: endpoint,
            data: data,
            fail: function (err) {
                fail && fail(err, data);
            },
        });
        batch = [];
    }
    return sender;
}

var noop = function () { return ({}); };
function id(v) {
    return v;
}

// eslint-disable-next-line @typescript-eslint/ban-types
function isObject(o) {
    return typeof o === 'object' && o !== null;
}
function isUndefined(o) {
    return o === undefined;
}
function isInstanceOf(wat, base) {
    try {
        return wat instanceof base;
    }
    catch (_e) {
        return false;
    }
}
var objProto = Object.prototype;
// https://stackoverflow.com/a/5878101
function isPlainObject(o) {
    if (isObject(o)) {
        if (typeof Object.getPrototypeOf === 'function') {
            var proto = Object.getPrototypeOf(o);
            return proto === objProto || proto === null;
        }
        // cannot test, requires ES3
        /* istanbul ignore next */
        return objProto.toString.call(o) === '[object Object]';
    }
    return false;
}
function isArray(o) {
    return objProto.toString.call(o) === '[object Array]';
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(o) {
    return typeof o === 'function';
}
function isBoolean(o) {
    return typeof o === 'boolean';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isString(o) {
    return typeof o === 'string';
}
function isError(wat) {
    switch (Object.prototype.toString.call(wat)) {
        case '[object Error]':
            return true;
        case '[object Exception]':
            /* istanbul ignore next */
            return true;
        case '[object DOMError]':
            return true;
        case '[object DOMException]':
            /* istanbul ignore next */
            return true;
        default:
            /* istanbul ignore next */
            return wat instanceof Error;
    }
}
function isEvent(wat) {
    return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
}
function isErrorEvent(what) {
    return Object.prototype.toString.call(what) === '[object ErrorEvent]';
}
function isPromiseRejectionEvent(what) {
    return Object.prototype.toString.call(what) === '[object PromiseRejectionEvent]';
}

function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
// 把source对象中的内容深度赋给target, 数组合并
function mergeDeepConcatArray() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    var result = {};
    var k = 0;
    while (k < source.length) {
        result = _mergeDeepMergeArray(result, source[k++]);
    }
    return result;
}
// 递归赋值
function _mergeDeepMergeArray(target, source) {
    var result = __assign({}, target);
    for (var key in source) {
        if (hasKey(source, key) && source[key] !== undefined) {
            if (isObject(source[key]) && isPlainObject(source[key])) {
                result[key] = _mergeDeepMergeArray(isObject(target[key]) ? target[key] : {}, source[key]);
            }
            else if (isArray(source[key]) && isArray(target[key])) {
                result[key] = _mergeDeepArray(target[key], source[key]);
            }
            else {
                result[key] = source[key];
            }
        }
    }
    return result;
}
function _mergeDeepArray(target, source) {
    var _target = isArray(target) ? target : [];
    var _source = isArray(source) ? source : [];
    return Array.prototype.concat.call(_target, _source).map(function (v) {
        if (v instanceof RegExp) {
            return v;
        }
        else if (isObject(v) && isPlainObject(v)) {
            return _mergeDeepMergeArray({}, v);
        }
        else if (isArray(v)) {
            return _mergeDeepArray([], v);
        }
        else {
            return v;
        }
    });
}
// 检查数组中是否有元素
function arrayIncludes(array, value) {
    if (!isArray(array)) {
        return false;
    }
    if (array.length === 0) {
        return false;
    }
    var k = 0;
    while (k < array.length) {
        if (array[k] === value) {
            return true;
        }
        k++;
    }
    return false;
}
var arrayRemove = function (arr, e) {
    if (!isArray(arr)) {
        return arr;
    }
    var i = arr.indexOf(e);
    if (i >= 0) {
        var arr_ = arr.slice();
        arr_.splice(i, 1);
        return arr_;
    }
    return arr;
};
/**
 * 按路径访问对象属性
 * @param target 待访问对象
 * @param property 访问属性路径
 * @param { (target: any, property: string): any } visitor 访问器
 */
var safeVisit = function (target, path, visitor) {
    var _a, _b;
    var paths = path.split('.');
    var _c = __read(paths), method = _c[0], rest = _c.slice(1);
    while (target && rest.length > 0) {
        target = target[method];
        _a = rest, _b = __read(_a), method = _b[0], rest = _b.slice(1);
    }
    if (!target) {
        return undefined;
    }
    return visitor(target, method);
};
var applyRecord = function () {
    var record = {};
    var set = function (key, val) { return (record[key] = val); };
    var del = function (key) { return delete record[key]; };
    return [record, set, del];
};
var pick = function (obj, keys) {
    if (!obj || !isObject(obj))
        return obj;
    return keys.reduce(function (prev, cur) {
        prev[cur] = obj[cur];
        return prev;
    }, {});
};

function getRegexp(ignore) {
    if (!isArray(ignore)) {
        return null;
    }
    return ignore.length ? joinRegExp(ignore) : null;
}
function joinRegExp(patterns) {
    var sources = [];
    var len = patterns.length;
    for (var i = 0; i < len; i++) {
        var pattern = patterns[i];
        if (isString(pattern)) {
            sources.push(pattern.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1'));
        }
        else if (pattern && pattern.source) {
            sources.push(pattern.source);
        }
    }
    return new RegExp(sources.join('|'), 'i');
}
var checkIfHit = function (rules, url) {
    var Rgx = getRegexp(rules || []);
    return !!Rgx && Rgx.test(url);
};
function safeStringify(a) {
    try {
        return isString(a) ? a : JSON.stringify(a);
    }
    catch (err) {
        return '[FAILED_TO_STRINGIFY]:' + String(err);
    }
}

// eslint-disable-next-line @typescript-eslint/ban-types
/**
 * You can feel free to restore when you hook a function.
 * But you ought to restore 「in order」 if you hooked a value reference or a real obj reference.Because we not store the last value referent for now.
 * eg: obj.a = 1;
 * const r_1 = hookObjectProperty(obj, 'a',() =>2)()
 * const r_2 = hookObjectProperty(obj, 'a',() =>3)()
 * r_2() // obj.a === 2
 * r_1() // obj.a === 1
 *
 * @template T
 * @template K
 * @template P
 * @param {T} obj
 * @param {K} key
 * @param {(origin: T[K], ...params: P) => T[K]} hookFunc
 * @param {boolean} isCatchError When an error occurs after calling a hooked function, we want to suppress the errors and try to call the original function by default.
 * @return {*}
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookObjectProperty = function (obj, key, hookFunc, isCatchError) {
    if (isCatchError === void 0) { isCatchError = true; }
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        // 给所有 hook 之后的方法包一层 try catch
        if (isFunction(hooked) && isCatchError) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                try {
                    return hookedUnsafe.apply(this, args);
                }
                catch (_a) {
                    return isFunction(origin) && origin.apply(this, args);
                }
            };
        }
        obj[key] = hooked;
        // strict: is break
        return function (strict) {
            if (!strict) {
                hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
            }
        };
    };
};
/**
 * 劫持对象方法
 * 必须记得给 hookFunc 劫持的方法包 try catch ！
 * 不在本方法里包是为了避免对象原方法被调用两次
 */
// eslint-disable-next-line @typescript-eslint/ban-types
var hookMethodDangerously = function (obj, key, hookFunc) {
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (!obj) {
            return noop;
        }
        var origin = obj[key];
        var hookedUnsafe = hookFunc.apply(void 0, __spreadArray([origin], __read(params), false));
        var hooked = hookedUnsafe;
        if (isFunction(hooked)) {
            hooked = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return hookedUnsafe.apply(this, args);
            };
        }
        obj[key] = hooked;
        return function () {
            hooked === obj[key] ? (obj[key] = origin) : (hookedUnsafe = origin);
        };
    };
};

var getPrintString = function () {
    // @ts-expect-error
    if (''.padStart) {
        return function (str, prefixLength) {
            if (prefixLength === void 0) { prefixLength = 8; }
            return str.padStart(prefixLength, ' ');
        };
    }
    return function (str) { return str; };
};
var printString = getPrintString();
var count = 0;
var log = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // eslint-disable-next-line no-console
    console.log.apply(console, __spreadArray(['[SDK]', Date.now(), printString("" + count++)], __read(args), false));
};

var isHitBySampleRate = function (sampleRate) {
    if (Math.random() < Number(sampleRate)) {
        return true;
    }
    return false;
};
var isHitByRandom = function (random, sampleRate) {
    if (random < Number(sampleRate)) {
        return true;
    }
    return false;
};

/**
 * 生成uuid
 * stolen from https://github.com/kelektiv/node-uuid#readme uuid/v4
 *
 * @returns
 */
function mathRNG() {
    var rnds = new Array(16);
    var r = 0;
    for (var i = 0; i < 16; i++) {
        if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
        }
        rnds[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
    }
    return rnds;
}
function bytesToUuid(buf) {
    var byteToHex = [];
    for (var index = 0; index < 256; ++index) {
        byteToHex[index] = (index + 0x100).toString(16).substr(1);
    }
    var i = 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        '-',
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
        bth[buf[i++]],
    ].join('');
}
function uuid() {
    var rnds = mathRNG();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return bytesToUuid(rnds);
}

var BUFFER_TIME = 300000; // 5分钟
var applyBufferTimer = function (checkIfNeedCancel, cb, bufferTime) {
    var tid = 0;
    if (bufferTime === -1)
        return noop;
    return function () {
        if (checkIfNeedCancel()) {
            tid && clearTimeout(tid);
            tid = 0;
            return;
        }
        tid === 0 && (tid = setTimeout(cb, bufferTime));
    };
};

var nextLink = function (args, cb) {
    var nextCbs = [];
    try {
        nextCbs = cb.reduce(function (sum, s) {
            try {
                var nextCb = s(args);
                typeof nextCb === 'function' && sum.push(nextCb);
            }
            catch (_a) {
                // do nothing
            }
            return sum;
        }, []);
    }
    catch (_a) {
        // do nothing
    }
    return function (nextArgs) { return nextLink(nextArgs, nextCbs); };
};
var toObservable = function (bufferTime) {
    if (bufferTime === void 0) { bufferTime = BUFFER_TIME; }
    var subscribers = [];
    var __complete = [];
    var closed = false;
    var attachCb;
    // 暂缓的自动销毁机制，比如5min 没有人订阅就自动销毁
    var setCloseIfNeed = applyBufferTimer(function () { return !!subscribers.length; }, function () {
        closed = true;
        attachCb && attachCb[0]();
        __complete.forEach(function (e) { return e(); });
        __complete.length = 0;
        attachCb = undefined;
    }, bufferTime);
    var unsubscribe = function (o) {
        subscribers = arrayRemove(subscribers, o);
        !closed && setCloseIfNeed();
    };
    return {
        next: function (args) {
            return nextLink(args, subscribers);
        },
        complete: function (cb) {
            __complete.push(cb);
        },
        attach: function (disconnect, onSubscribe) {
            attachCb = [disconnect, onSubscribe];
        },
        subscribe: function (o) {
            if (closed)
                throw new Error('Observer is closed');
            subscribers.push(o);
            attachCb && attachCb[1] && attachCb[1](o);
            setCloseIfNeed();
            return function () { return unsubscribe(o); };
        },
        unsubscribe: unsubscribe,
    };
};
var createSafeObserver = function (observer, completeCb, bufferTime) {
    var cur = toObservable(bufferTime);
    try {
        observer(cur.next, cur.attach);
        completeCb && cur.complete(completeCb);
    }
    catch (_a) {
        //
    }
    return [cur.subscribe, cur.unsubscribe];
};

/**
 * 将tearDownGroup 注册到 destroyAgent，destroyAgent会在实例销毁时自动销毁tearDownGroup
 */
var registerTearDownGroup = function (client, pluginName, evType, tearDownGroup) {
    return client.destroyAgent.set(pluginName, evType, tearDownGroup);
};

/**
 * 由于 Observer 带有自动销毁机制，意味着subject 只支持同步注册并使用
 */
function initSubjectInGlobal(client, args) {
    return client.initSubject(args);
}
/**
 * 此方法不会挂载到全局对象上，同时只支持同步注册并使用
 */
function initPrivateSubject(client, _a, bufferTime) {
    var _b = __read(_a, 2), subjectKey = _b[0], observer = _b[1];
    var subjectMap = client.privateSubject || {};
    if (!subjectMap[subjectKey])
        subjectMap[subjectKey] = createSafeObserver(observer, function () {
            subjectMap[subjectKey] = undefined;
        }, bufferTime);
    return subjectMap[subjectKey];
}

var now = function () { return Date.now(); };

function getDefaultBrowser() {
    if (typeof window === 'object' && isObject(window))
        return window;
}
function getDefaultDocument() {
    if (typeof document === 'object' && isObject(document))
        return document;
}
function getDefaultLocation() {
    return getDefaultBrowser() && window.location;
}
function getDefaultHistory() {
    // eslint-disable-next-line compat/compat
    return getDefaultBrowser() && window.history;
}
function getDefaultPerformance() {
    if (getDefaultBrowser() && isObject(window.performance))
        return window.performance;
}
function getDefaultPromise() {
    if (getDefaultBrowser() && 'Promise' in window)
        return Promise;
}
function getDefaultXMLHttpRequest() {
    if (typeof XMLHttpRequest === 'function' && isFunction(XMLHttpRequest))
        return XMLHttpRequest;
}
function getDefaultFetch() {
    try {
        // eslint-disable-next-line compat/compat
        new Headers();
        // eslint-disable-next-line compat/compat
        new Request('');
        // eslint-disable-next-line compat/compat
        new Response();
        // eslint-disable-next-line compat/compat
        return window.fetch;
    }
    catch (_a) {
        //
    }
}
function getDefaultMutationObserver() {
    if (getDefaultBrowser() && isFunction(window.MutationObserver))
        return window.MutationObserver;
}
function getDefaultPerformanceObserver() {
    if (getDefaultBrowser() && isFunction(window.PerformanceObserver))
        return window.PerformanceObserver;
}
function getDefaultPerformanceEventTiming() {
    if (getDefaultBrowser() && isFunction(window.PerformanceEventTiming))
        return window.PerformanceEventTiming;
}
function getDefaultPerformanceTiming() {
    var performance = getDefaultPerformance();
    if (performance && isObject(performance.timing))
        return performance.timing;
}
function getDefaultRaf() {
    if (getDefaultBrowser() && 'requestAnimationFrame' in window) {
        return window.requestAnimationFrame;
    }
}
function getDefaultCaf() {
    if (getDefaultBrowser() && 'cancelAnimationFrame' in window) {
        return window.cancelAnimationFrame;
    }
}
function getDefaultNavigator() {
    if (getDefaultBrowser() && 'navigator' in window) {
        return window.navigator;
    }
}
function getDefaultNetworkInformation() {
    var navigator = getDefaultNavigator();
    if (navigator) {
        return navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    }
}
function getCurrentScript() {
    if (!document)
        return null;
    if (document.currentScript)
        return document.currentScript;
    // IE 8-10 support script readyState
    // IE 11+ support stack trace
    try {
        throw new Error();
    }
    catch (err) {
        // Find the second match for the "at" string to get file src url from stack.
        // Specifically works with the format of stack traces in IE.
        var i = 0;
        var stackDetails = /at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i.exec(err.stack);
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        var scriptLocation = (stackDetails && stackDetails[2]) || false;
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        var line = (stackDetails && stackDetails[3]) || 0;
        var currentLocation = document.location.href.replace(document.location.hash, '');
        var inlineScriptSource = '';
        var scripts = document.getElementsByTagName('script'); // Live NodeList collection
        if (scriptLocation === currentLocation) {
            var pageSource = document.documentElement.outerHTML;
            var inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
            inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
        }
        for (; i < scripts.length; i++) {
            // If ready state is interactive, return the script tag
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            if (scripts[i].readyState === 'interactive') {
                return scripts[i];
            }
            // If src matches, return the script tag
            if (scripts[i].src === scriptLocation) {
                return scripts[i];
            }
            // If inline source matches, return the script tag
            if (scriptLocation === currentLocation &&
                scripts[i].innerHTML &&
                scripts[i].innerHTML.trim() === inlineScriptSource) {
                return scripts[i];
            }
        }
        // If no match, return null
        return null;
    }
}

function getFullUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url)
        return '';
    var a = document.createElement('a');
    a.href = url;
    return a.href;
}
function parseUrl(url) {
    var document = getDefaultDocument();
    if (!document || !url) {
        return {
            url: url,
            protocol: '',
            domain: '',
            query: '',
            path: '',
            hash: '',
        };
    }
    var a = document.createElement('a');
    a.href = url;
    var path = a.pathname || '/';
    /* istanbul ignore next */
    if (path[0] !== '/') {
        path = '/' + path;
    }
    return {
        url: a.href,
        protocol: a.protocol.slice(0, -1),
        domain: a.hostname,
        query: a.search.substring(1),
        path: path,
        hash: a.hash,
    };
}
function getLocationUrl() {
    var location = getDefaultBrowser() && getDefaultLocation();
    return location ? location.href : '';
}

var getViewOverrides = function (config) {
    return {
        pid: config.pid,
        view_id: config.viewId,
        url: getLocationUrl(),
    };
};
var getOverrides = function (client) {
    var clientConfig = client.config();
    var overrides = getViewOverrides(clientConfig);
    overrides.context = client.context ? client.context.toString() : {};
    return overrides;
};
var reportWithCurrentContext = function (client, timeRequiresAdjustment) {
    if (timeRequiresAdjustment === void 0) { timeRequiresAdjustment = false; }
    var overrides = getOverrides(client);
    timeRequiresAdjustment && (overrides.timestamp = now());
    return function (ev) {
        client.report(__assign(__assign({}, ev), { overrides: overrides }));
    };
};
var PV_SUBJECT_NAME = 'view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyPV = function (client) {
    return function (next, tearDown) {
        var currentOverrides = getOverrides(client);
        var handleConfig = function (newConfig) {
            var _a;
            if (newConfig.viewId && newConfig.viewId !== ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.viewId)) {
                next(currentOverrides);
                currentOverrides = __assign(__assign({}, getOverrides(client)), getViewOverrides(newConfig));
            }
        };
        client.on('beforeConfig', handleConfig);
        tearDown(function () {
            client.off('beforeConfig', handleConfig);
        });
    };
};
var FIRST_PV_SUBJECT_NAME = 'f_view_0';
/**
 * 由于跟当前实例强相关 所以不能挂在global上
 */
var applyFirstPV = function (client) {
    return function (_, tearDown) {
        var firstOverrides = getOverrides(client);
        tearDown(noop, function (subscriber) {
            firstOverrides && subscriber(firstOverrides);
        });
    };
};

// 获取全局注册表
var getGlobalRegistry = function (global) {
    if (!global)
        return;
    if (!global.__SLARDAR_REGISTRY__) {
        global.__SLARDAR_REGISTRY__ = {
            Slardar: {
                plugins: [],
                errors: [],
                subject: {},
            },
        };
    }
    return global.__SLARDAR_REGISTRY__.Slardar;
};
var reportSelfError = function () {
    var errorInfo = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        errorInfo[_i] = arguments[_i];
    }
    var registry = getGlobalRegistry(getDefaultBrowser());
    if (!registry)
        return;
    if (!registry.errors) {
        registry.errors = [];
    }
    registry.errors.push(errorInfo);
};

var applyMutationObserver = function (MutationObserver, callback) {
    // eslint-disable-next-line compat/compat
    var observer = MutationObserver && new MutationObserver(callback);
    var observe = function (target, options) {
        observer && target && observer.observe(target, options);
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
var applyAnimationFrame = function (document, originRAF, originCAF, force) {
    var requestAnimationFrame = 
    // eslint-disable-next-line compat/compat
    !isFunction(originRAF) || (force && document && document.hidden)
        ? function (cb) {
            cb(0);
            return 0;
        }
        : originRAF;
    var cancelAnimationFrame = isFunction(originCAF) ? originCAF : noop;
    /**
     * 以 animationFrame 调用函数，如果一帧内多次调用，则会取消前面的调用
     */
    var af;
    var scheduleAnimationFrame = function (cb) {
        af && cancelAnimationFrame(af);
        af = requestAnimationFrame(cb);
    };
    return [scheduleAnimationFrame, requestAnimationFrame, cancelAnimationFrame];
};
var applyPerformance = function (performance) {
    // eslint-disable-next-line compat/compat
    var timing = (performance && performance.timing) || undefined;
    var now = function () {
        if (performance && performance.now)
            return performance.now();
        var time = Date.now ? Date.now() : +new Date();
        var start = (timing && timing.navigationStart) || 0;
        return time - start;
    };
    var getEntriesByType = function (type) {
        var getEntriesByType = (performance || {}).getEntriesByType;
        return (isFunction(getEntriesByType) && getEntriesByType.call(performance, type)) || [];
    };
    var getEntriesByName = function (name) {
        var getEntriesByName = (performance || {}).getEntriesByName;
        return (isFunction(getEntriesByName) && getEntriesByName.call(performance, name)) || [];
    };
    var clearResourceTiming = function () {
        var clearResourceTimings = (performance || {}).clearResourceTimings;
        isFunction(clearResourceTimings) && clearResourceTimings.call(performance);
    };
    return [timing, now, getEntriesByType, clearResourceTiming, getEntriesByName];
};
var applyPerformanceObserver$1 = function (PerformanceObserver, callback, once, onFail) {
    var observer = PerformanceObserver &&
        // eslint-disable-next-line compat/compat
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
            once && ob.disconnect();
        });
    var observe = function () {
        var types = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            types[_i] = arguments[_i];
        }
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            types.forEach(function (type) {
                if (PerformanceObserver.supportedEntryTypes.indexOf(type) > -1) {
                    observer.observe({ type: type, buffered: false });
                }
            });
        }
        catch (_a) {
            try {
                observer.observe({ entryTypes: types });
            }
            catch (_b) {
                return onFail && onFail();
            }
        }
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, disconnect];
};
// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
var applyMonitor = function (monitorCtor, props, cb, deps) {
    if (props === void 0) { props = {}; }
    if (deps === void 0) { deps = []; }
    try {
        var monitor = monitorCtor.apply(void 0, __spreadArray([], __read(deps), false));
        return (monitor && monitor(props, cb)) || [];
    }
    catch (e) {
        reportSelfError(e);
        return [];
    }
};
// eslint-disable-next-line @typescript-eslint/ban-types
var applyUpdate = function (init) {
    var state = init;
    var result = {};
    var defineGetter = function () {
        return Object.keys(state).forEach(function (key) {
            return !(key in result) &&
                Object.defineProperty(result, key, {
                    get: function () {
                        return state[key];
                    },
                });
        });
    };
    var update = function (newObj) {
        state = mergeDeepConcatArray(state, newObj);
        defineGetter();
    };
    defineGetter();
    return [result, update];
};
var applyRequestIdleCallback = function (win) {
    return (win.requestIdleCallback ||
        function (cb) {
            return win.setTimeout(cb, 1);
        });
};

var captureCurrentContext = function (client) {
    var capturedContext = {
        url: getLocationUrl(),
        timestamp: now(),
    };
    var config = client.config();
    if (config === null || config === void 0 ? void 0 : config.pid) {
        capturedContext.pid = config.pid;
    }
    if (client === null || client === void 0 ? void 0 : client['context']) {
        capturedContext.context = client['context'].toString();
    }
    return capturedContext;
};
// only works for sync report
// async report won't trigger 'report' immediately, es.g. sri
var syncReportWithCapturedContext = function (client, ctx) {
    return function (fn) {
        var inject = function (ev) {
            ev.overrides = ctx;
            return ev;
        };
        client.on('report', inject);
        fn();
        client.off('report', inject);
    };
};

/**
 * from sentry https://github.com/getsentry/sentry-javascript/blob/5.30.0/packages/utils/src/browser.ts
 */
var UNKNOWN_PATH = '<unknown>';
/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function htmlTreeAsString(elem) {
    // try/catch both:
    // - accessing event.target (see getsentry/raven-js#838, #768)
    // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
    // - can throw an exception in some circumstances.
    try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 256; // be matched with the filtering rules of data reporting
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
            nextStr = _htmlElementAsString(currentElem);
            // bail out if
            // - nextStr is the 'html' element
            // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
            //   (ignore this limit if we are on the first iteration)
            if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                break;
            }
            out.push(nextStr);
            len += nextStr.length;
            currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
    }
    catch (_oO) {
        return UNKNOWN_PATH;
    }
}
/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @returns generated DOM path
 */
function _htmlElementAsString(el) {
    var _a, _b;
    var elem = el;
    var out = [];
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
        return '';
    }
    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
        return "#" + elem.id;
    }
    var className = elem.className;
    if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
        }
    }
    var attrlist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrlist.length; i++) {
        key = attrlist[i];
        attr = elem.getAttribute(key);
        if (attr) {
            out.push("[" + key + "=\"" + attr + "\"]");
        }
    }
    // Check for siblings with the same selector
    var sibling = elem;
    var siblingIndex = 1;
    var isUnique = true;
    while ((sibling = sibling.previousElementSibling)) {
        if (((_a = sibling.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = elem.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            if (sibling.className === elem.className &&
                attrlist.every(function (attr) { return elem.getAttribute(attr) === (sibling === null || sibling === void 0 ? void 0 : sibling.getAttribute(attr)); })) {
                isUnique = false;
            }
            siblingIndex++;
        }
    }
    if (siblingIndex > 1 && !isUnique) {
        out.push(":nth-of-type(" + siblingIndex + ")");
    }
    return out.join('');
}

var addListenerToWindow = function (w, type, listener, options) {
    if (options === void 0) { options = false; }
    w.addEventListener(type, listener, options);
    return function () {
        w.removeEventListener(type, listener, options);
    };
};
var addListenerToDocument = function (d, type, listener, options) {
    if (options === void 0) { options = false; }
    d.addEventListener(type, listener, options);
    return function () {
        d.removeEventListener(type, listener, options);
    };
};
function clearTimerWithTearDowns(timer, tearDowns) {
    timer && tearDowns.push(function () { return clearTimeout(timer); });
}
function onPageLoad(callback) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    if (document.readyState === 'complete') {
        callback();
        return;
    }
    addListenerToWindow(window, 'load', function () {
        setTimeout(function () {
            callback();
        }, 0);
    }, false);
}
var invokeCallbackOnce = function (cb) {
    var hasInvoked = false;
    var invoke = function (params) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb && cb(params);
    };
    return [invoke];
};
var onPageUnload = function (cb) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var _a = __read(invokeCallbackOnce(cb), 1), invokeCbOnce = _a[0];
    ['unload', 'beforeunload', 'pagehide'].forEach(function (ev) {
        addListenerToWindow(window, ev, invokeCbOnce, false);
    });
};
var onPageNextShow = function (cb) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var removeListener = noop;
    var onVisibilityChange = function () {
        if (document.visibilityState === 'visible') {
            cb();
            removeListener();
        }
    };
    removeListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChange, true);
};
var loadScript = function (url, callback) {
    var _a;
    /* istanbul ignore next */
    var document = getDefaultDocument();
    // untestable for now
    /* istanbul ignore next */
    if (document) {
        var script = document.createElement('script');
        script.src = url;
        script.crossOrigin = 'anonymous';
        script.onload = callback;
        (_a = document.head) === null || _a === void 0 ? void 0 : _a.appendChild(script);
    }
};
var getConfig = function (c, defaultConfig) {
    if (isObject(c)) {
        return __assign(__assign({}, defaultConfig), c);
    }
    else {
        return c ? defaultConfig : false;
    }
};

var isSupportEncrypt = function () { return !!btoa && !!atob; };
function encodeToBase64(content) {
    if (!isSupportEncrypt())
        return content;
    return btoa(encodeURI(content));
}
function decodeWithBase64(base64) {
    if (!isSupportEncrypt())
        return base64;
    return decodeURI(atob(base64));
}

var getStorageWithDecoding = function (name) {
    try {
        var value = localStorage.getItem(name);
        var ret = value;
        if (value && typeof value === 'string') {
            ret = JSON.parse(decodeWithBase64(value));
        }
        // get 时无需刷新 expires，在后续的 configManager 中的 set 会刷新
        var _a = ret, expires = _a.expires, content = __rest(_a, ["expires"]);
        return expires >= now() ? content : undefined;
    }
    catch (_e) {
        return undefined;
    }
};
var setStorageWithEncoding = function (key, value, expires) {
    if (expires <= 0)
        return;
    try {
        localStorage.setItem(key, encodeToBase64(JSON.stringify(__assign(__assign({}, value), { expires: now() + expires }))));
    }
    catch (_o) {
        // do nothing
    }
};
var removeStorageItem = function (key) {
    try {
        localStorage.removeItem(key);
    }
    catch (_o) {
        // do nothing
    }
};
var DEFAULT_STORAGE_EXPIRES = 90 * 24 * 60 * 60 * 1000;
var formatStorageExpires = function (storageExpires) {
    if (storageExpires === false)
        return 0;
    if (storageExpires === true || storageExpires === undefined || !isNumber(storageExpires))
        return DEFAULT_STORAGE_EXPIRES;
    return storageExpires;
};

var XHR_SUBJECT_NAME = 'xhr_0';
var getReportPathRegExp = function () {
    var SELF_REPORT_PATH_REGEXP = new RegExp('\\/monitor_web\\/collect|\\/monitor_browser\\/collect\\/batch', 'i');
    return function (url) { return SELF_REPORT_PATH_REGEXP.test(url); };
};
var hookOpen = function (open) {
    return function () {
        var _a;
        var openOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            openOptions[_i] = arguments[_i];
        }
        _a = __read(openOptions, 2), this._method = _a[0], this._url = _a[1];
        return open.apply(this, openOptions);
    };
};
var hookSetHeader = function (setRequestHeader) {
    return function () {
        var setOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            setOptions[_i] = arguments[_i];
        }
        this._reqHeaders = this._reqHeaders || {};
        var _a = __read(setOptions, 2), name = _a[0], value = _a[1];
        this._reqHeaders[name] = value;
        return setRequestHeader && setRequestHeader.apply(this, setOptions);
    };
};
var hookOnreadystatechange = function (xhr, endNext) {
    return hookMethodDangerously(xhr, 'onreadystatechange', function (origin) {
        return function () {
            var ev = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ev[_i] = arguments[_i];
            }
            // @ts-expect-error
            this.readyState === 4 && endNext(xhr);
            return origin && origin.apply(this, ev);
        };
    });
};
var hookSend = function (send, next) {
    var hitReportPath = getReportPathRegExp();
    return function () {
        var sendOptions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sendOptions[_i] = arguments[_i];
        }
        this._start = now();
        this._data = sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions[0];
        // not trigger the xhr subject if hit the report path
        if (!hitReportPath(this._url)) {
            var endNext = next([this._method, this._url, this._start, this]);
            hookOnreadystatechange(this, endNext)();
        }
        return send.apply(this, sendOptions);
    };
};
var applyXHR = function (xhr) {
    return function (next, tearDown) {
        if (!xhr)
            return;
        var tearDownGroup = [];
        tearDownGroup.push(hookMethodDangerously(xhr, 'open', hookOpen)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'setRequestHeader', hookSetHeader)());
        tearDownGroup.push(hookMethodDangerously(xhr, 'send', hookSend)(next));
        tearDown(function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    };
};
var FETCH_SUBJECT_NAME = 'fetch_0';
var hookFetch = function (_fetch, next) {
    return function (req, options) {
        if (options === void 0) { options = {}; }
        var endNext = next([req, options]);
        var fetchPromise = _fetch(req, options);
        fetchPromise.then(function (res) {
            // @ts-expect-error
            endNext(res);
        }, function () {
            // @ts-expect-error
            endNext(undefined);
        });
        return fetchPromise;
    };
};
var observeFetch = function (next, tearDown) {
    var global = getDefaultBrowser();
    if (!global || !fetch)
        return;
    var tearDownGroup = [];
    tearDownGroup.push(hookMethodDangerously(global, 'fetch', hookFetch)(next));
    tearDown(function () {
        tearDownGroup.forEach(function (e) { return e(); });
    });
};
var fetchSubject = [FETCH_SUBJECT_NAME, observeFetch];

var RESOURCE_TYPE = ['resource']; // used by resourceMonitor / resourceErrorMonitor / HttpMonitor
var LONGTASK_TYPE = ['longtask']; // used by ttiMonitor / longtaskMonitor / actionMonitor / mpfidMonitor
var applyPerformanceObserver = function (PerformanceObserver, callback, onFail) {
    var observer = PerformanceObserver &&
        new PerformanceObserver(function (list, ob) {
            if (list.getEntries) {
                list.getEntries().forEach(function (val, i, arr) { return callback(val, i, arr, ob); });
            }
            else {
                onFail && onFail();
            }
        });
    var observe = function (types) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            observer.observe({ entryTypes: types });
        }
        catch (_a) {
            return onFail && onFail();
        }
    };
    var bufferedObserver = function (type, durationThreshold) {
        if (!PerformanceObserver || !observer)
            return onFail && onFail();
        try {
            var options = { type: type, buffered: true };
            !isUndefined(durationThreshold) && (options.durationThreshold = durationThreshold);
            observer.observe(options);
        }
        catch (_a) {
            return onFail && onFail();
        }
        observer.observe({ type: type, buffered: false });
    };
    var disconnect = function () { return observer && observer.disconnect(); };
    return [observe, bufferedObserver, disconnect];
};
var observePerf = function (Ob, pipe, types) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), observe = _a[0], disconnect = _a[2];
    observe(types);
    return disconnect;
};
var observePerfWithBuffer = function (Ob, pipe, type, durationThreshold) {
    var _a = __read(applyPerformanceObserver(Ob, pipe), 3), bufferedObserver = _a[1], disconnect = _a[2];
    bufferedObserver(type, durationThreshold);
    return disconnect;
};
var LONGTASK_SUBJECT_NAME = 'longtask_0';
var observeLongtask = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, LONGTASK_TYPE));
};
var longtaskSubject = [LONGTASK_SUBJECT_NAME, observeLongtask];
var RESOURCE_SUBJECT_NAME = 'resource_0';
var observeResource = function (next, tearDown) {
    var PerformanceObserver = getDefaultPerformanceObserver();
    if (!PerformanceObserver)
        return;
    tearDown(observePerf(PerformanceObserver, next, RESOURCE_TYPE));
};
var resourceSubject = [RESOURCE_SUBJECT_NAME, observeResource];

var PAGEVIEW_EV_TYPE = 'pageview';
var SESSION_EV_TYPE = 'session';
var JS_ERROR_EV_TYPE = 'js_error';
var HTTP_EV_TYPE = 'http';
var RESOURCE_ERROR_EV_TYPE = 'resource_error';
var RESOURCE_EV_TYPE = 'resource';
var CUSTOM_EV_TYPE = 'custom';
var PERFORMANCE_METRIC_EV_TYPE = 'performance';
var PERFORMANCE_TIMING_EV_TYPE = 'performance_timing';
var LONG_TASK_EV_TYPE = 'performance_longtask';
var BLANK_SCREEN_EV_TYPE = 'blank_screen';
var ACTION_EV_TYPE = 'action';
var HEATMAP_EV_TYPE = 'heatmap';

var VERSION = '03';
var SAMPLED = '01';
var TRACEPARENT = 'traceparent';
var DEFAULT_TRACE_CONFIG = {
    sampleRate: 1,
    origins: [],
};
var uuid4 = function () {
    var crypto = window && (window.crypto || window.msCrypto);
    if (crypto !== void 0 && crypto.getRandomValues) {
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        var pad = function (num) {
            var v = num.toString(16);
            while (v.length < 4) {
                v = "0" + v;
            }
            return v;
        };
        return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'.replace(/[x]/g, function () {
        var r = (Math.random() * 16) | 0;
        return r.toString(16);
    });
};
var setTraceContext = function (traceConfig) {
    var config = getConfig(traceConfig, DEFAULT_TRACE_CONFIG);
    if (!config)
        return;
    var sampled = isHitBySampleRate(config.sampleRate);
    if (!sampled)
        return;
    return function (url, cb) {
        var origins = config.origins;
        if (origins.length && checkIfHit(origins, url)) {
            cb(TRACEPARENT, VERSION + "-" + uuid4() + "-" + uuid4().substring(16) + "-" + SAMPLED);
        }
    };
};
var setVolTraceContext = function (traceConfig, tracestate) {
    var config = getConfig(traceConfig, DEFAULT_TRACE_CONFIG);
    if (!config)
        return;
    var sampled = isHitBySampleRate(config.sampleRate);
    if (!sampled)
        return;
    return function (url, cb) {
        var origins = config.origins;
        if (origins.length && checkIfHit(origins, url)) {
            cb('x-rum-traceparent', "00-" + uuid4() + "-" + uuid4().substring(16) + "-" + SAMPLED);
            cb('x-rum-tracestate', tracestate);
        }
    };
};

var headerKeyRe = new RegExp('(cookie|auth|jwt|token|key|ticket|secret|credential|session|password)', 'i');
var headerValueRe = new RegExp('(bearer|session)', 'i');
var isSensitiveHeader = function (key, value) {
    if (!key || !value)
        return true;
    return headerKeyRe.test(key) || headerValueRe.test(value);
};
var applySendOnce = function (cb) {
    var hasInvoked = false;
    return function (metric) {
        if (hasInvoked)
            return;
        hasInvoked = true;
        cb(metric);
    };
};
/**
 * Handles the full URL and payload with optional URL extraction.
 *
 * @param {string} fullUrl - The full URL to handle.
 * @param {HttpPayload} payload - The payload object to handle. Will be mutated in function inside.
 * @param {function} extractUrl - (Optional) A function to extract the URL from the full URL.
 */
var handleWithExtractUrl = function (payload, extractUrl) {
    try {
        if (extractUrl) {
            var original_url = payload.request.url;
            payload.request.url = extractUrl(original_url);
            payload.extra = __assign(__assign({}, payload.extra), { original_url: original_url });
            // Since PerformanceResourceTiming.toJSON only works for >= Chrome V45,
            // back-end will assign payload.response.timing.name to payload.request.url after data reported
        }
    }
    catch (_e) {
        // do nothing
    }
};

var httpGetterWithXhrObserver = function (tearDownGroup, _a, xhrConfig) {
    var _b = __read(_a, 2), xhrObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = xhrConfig.setTraceHeader, ignoreUrls = xhrConfig.ignoreUrls, setContextAtReq = xhrConfig.setContextAtReq, extractUrl = xhrConfig.extractUrl;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 4); _b[0]; var _url = _b[1]; _b[2]; var xhr = _b[3];
        if (!_url)
            return noop;
        var fullUrl = getFullUrl(_url);
        if (checkIfHit(ignoreUrls, fullUrl))
            return noop;
        setTraceHeader && setTraceHeader(fullUrl, function (key, value) { return xhr.setRequestHeader(key, value); });
        var reportWithContext = setContextAtReq();
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            fullUrl === entry.name && !timing && (timing = entry);
        });
        return function (xhrAfterReady) {
            var payload = getEventParams$1(xhrAfterReady, xhrConfig);
            setTimeout(function () {
                timing && (payload.response.timing = timing);
                handleWithExtractUrl(payload, extractUrl);
                reportWithContext && reportWithContext({ ev_type: HTTP_EV_TYPE, payload: payload });
                resourceTearDown();
            }, 100);
        };
    }));
};
function formatXHRAllResponseHeaders(headers) {
    if (isString(headers) && headers) {
        return headers.split('\r\n').reduce(function (result, line) {
            if (isString(line)) {
                var _a = __read(line.split(': '), 2), name_1 = _a[0], value = _a[1];
                !isSensitiveHeader(name_1, value) && (result[name_1.toLowerCase()] = value);
            }
            return result;
        }, {});
    }
    return {};
}
function formatRequestHeaders(headers) {
    return Object.keys(headers).reduce(function (result, name) {
        !isSensitiveHeader(name, headers[name]) && (result[name.toLowerCase()] = headers[name]);
        return result;
    }, {});
}
var getEventParams$1 = function (xhr, props) {
    var _method = xhr._method, _reqHeaders = xhr._reqHeaders, _url = xhr._url, _start = xhr._start, _data = xhr._data;
    var fullUrl = getFullUrl(_url);
    var params = {
        api: 'xhr',
        request: {
            url: fullUrl,
            method: (_method || '').toLowerCase(),
            headers: _reqHeaders && formatRequestHeaders(_reqHeaders),
            timestamp: _start,
        },
        response: {
            status: xhr.status || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    if (typeof xhr.getAllResponseHeaders === 'function') {
        params.response.headers = formatXHRAllResponseHeaders(xhr.getAllResponseHeaders());
    }
    var status = params.response.status;
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    try {
        var extra = extraExtractor === null || extraExtractor === void 0 ? void 0 : extraExtractor(xhr.response, params, _data);
        extra && (params.extra = extra);
        extra && (params.response.is_custom_error = true);
        // 非 2xx , 3xx 请求，上传request body
        if (collectBodyOnError && (extra || status >= 400)) {
            params.request.body = _data ? "" + _data : undefined;
            params.response.body = xhr.response ? "" + xhr.response : undefined;
        }
    }
    catch (_o) {
        // do nothing
    }
    return params;
};

function getPluginConfig(client, pluginName, defaultConfig) {
    var _a;
    var c = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[pluginName];
    return getConfig(c, defaultConfig);
}

var AJAX_MONITOR_PLUGIN_NAME = 'ajax';
var defaultConfig$8 = {
    autoWrap: true,
    setContextAtReq: function () { return id; },
    ignoreUrls: [],
    collectBodyOnError: false,
};
function AjaxMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig$8);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var xhrConfig = __assign(__assign({}, config), { setContextAtReq: function () { return reportWithCurrentContext(client, true); }, setTraceHeader: setTraceContext(config.trace) });
    var getResourceSubject = function () { return initSubjectInGlobal(client, resourceSubject); };
    xhrConfig.autoWrap &&
        httpGetterWithXhrObserver(tearDownGroup, [
            initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
            getResourceSubject,
        ], xhrConfig);
    registerTearDownGroup(client, AJAX_MONITOR_PLUGIN_NAME, HTTP_EV_TYPE, tearDownGroup);
    client.provide('wrapXhr', function (Xhr) {
        function Ctor() {
            var xhr = new Xhr();
            httpGetterWithXhrObserver(tearDownGroup, [createSafeObserver(applyXHR(xhr)), getResourceSubject], xhrConfig);
            return xhr;
        }
        Ctor.prototype = new Xhr();
        ['DONE', 'HEADERS_RECIEVED', 'LOADING', 'OPENED', 'UNSENT'].forEach(function (key) {
            Ctor[key] = Xhr[key];
        });
        return Ctor;
    });
}
function AjaxMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[AJAX_MONITOR_PLUGIN_NAME];
        AjaxMonitorBasePlugin(client, config);
    });
}
function AjaxMonitorVolPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = getPluginConfig(client, AJAX_MONITOR_PLUGIN_NAME, defaultConfig$8);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var xhrConfig = __assign(__assign({}, config), { setContextAtReq: function () { return reportWithCurrentContext(client, true); }, setTraceHeader: setVolTraceContext(config.trace, "app_id=" + ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.aid) + ",origin=web") });
        var getResourceSubject = function () { return initSubjectInGlobal(client, resourceSubject); };
        xhrConfig.autoWrap &&
            httpGetterWithXhrObserver(tearDownGroup, [
                initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
                getResourceSubject,
            ], xhrConfig);
        registerTearDownGroup(client, AJAX_MONITOR_PLUGIN_NAME, HTTP_EV_TYPE, tearDownGroup);
    });
}

var CLICK_EVENT_NAME = 'click';
var CLICK_SUBJECT_NAME = CLICK_EVENT_NAME + "_0";
var DOM_EVENT_TYPE = 'dom';
var observeClick = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var removeListener = addListenerToDocument(document, CLICK_EVENT_NAME, next, true);
    tearDown(function () {
        removeListener();
    });
};
var clickSubject = [CLICK_SUBJECT_NAME, observeClick];
var KEYPRESS_EVENT_NAME = 'keypress';
var KEYPRESS_SUBJECT_NAME = KEYPRESS_EVENT_NAME + "_0";
var observeKeypress = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var removeListener = addListenerToDocument(document, KEYPRESS_EVENT_NAME, next, true);
    tearDown(function () {
        removeListener();
    });
};
var keypressSubject = [KEYPRESS_SUBJECT_NAME, observeKeypress];

/**
 * Creates breadcrumbs from DOM API calls
 */
var domBreadcrumb = function (addBreadcrumb) { return function (handlerData) {
    var target;
    // Accessing event.target can throw (see getsentry/raven-js#838, #768)
    try {
        target = handlerData.event.target
            ? htmlTreeAsString(handlerData.event.target)
            : htmlTreeAsString(handlerData.event);
    }
    catch (e) {
        target = UNKNOWN_PATH;
    }
    if (target.length === 0) {
        return;
    }
    addBreadcrumb({
        type: 'dom',
        category: "ui." + handlerData.name,
        message: target,
    });
}; };
var triggerHandlers = function (addBreadcrumb, type) {
    return function (data) {
        if (!type) {
            return;
        }
        try {
            addBreadcrumb(data);
        }
        catch (e) {
            // ignore
        }
    };
};
var applyDomAndKeyPress = function (debounceDuration) {
    var keypressTimeout;
    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param name the event name (e.g. "click")
     * @param handler function that will be triggered
     * @param debounce decides whether it should wait till another event loop
     * @returns wrapped breadcrumb events handler
     * @hidden
     */
    var domEventHandler = function (name, handler) {
        var lastCapturedEvent;
        return function (event) {
            // reset keypress timeout; e.g. triggering a 'click' after
            // a 'keypress' will reset the keypress debounce so that a new
            // set of keypress can be recorded
            keypressTimeout = undefined;
            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors). Ignore if we've
            // already captured the event.
            if (!event || lastCapturedEvent === event) {
                return;
            }
            lastCapturedEvent = event;
            handler({ event: event, name: name });
        };
    };
    /**
     * Wraps addEventListener to capture keypress UI events
     * @param handler function that will be triggered
     * @returns wrapped keypress events handler
     * @hidden
     */
    var keypressEventHandler = function (handler) {
        // debounce timeout is triggered, we will only capture
        // a single breadcrumb from the FIRST target (acceptable?)
        return function (event) {
            var target;
            try {
                target = event.target;
            }
            catch (e) {
                // just accessing event properties can throw an exception in some rare circumstances
                // see: https://github.com/getsentry/raven-js/issues/838
                return;
            }
            var tagName = target && target.tagName;
            // only consider keypress events on actual input elements
            // this will disregard keypress targeting body (e.g. tabbing
            // through elements, hotkeys, etc)
            if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)) {
                return;
            }
            // record first keypress in a series, but ignore subsequent
            // keypress until debounce clears
            !keypressTimeout && domEventHandler('input', handler)(event);
            clearTimeout(keypressTimeout);
            keypressTimeout = window.setTimeout(function () {
                keypressTimeout = undefined;
            }, debounceDuration);
        };
    };
    return [domEventHandler, keypressEventHandler];
};
var applyBreadcrumb = function (maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs) {
    if (maxBreadcrumbs === void 0) { maxBreadcrumbs = 20; }
    if (onAddBreadcrumb === void 0) { onAddBreadcrumb = id; }
    if (onMaxBreadcrumbs === void 0) { onMaxBreadcrumbs = function (bs, max) { return bs.slice(-max); }; }
    var breadcrumbs = [];
    var addBreadcrumb = function (breadcrumb) {
        var processed = onAddBreadcrumb(breadcrumb);
        if (processed) {
            var mergedBreadcrumb = __assign(__assign({}, processed), { timestamp: breadcrumb.timestamp || now() });
            breadcrumbs =
                maxBreadcrumbs >= 0 && breadcrumbs.length + 1 > maxBreadcrumbs
                    ? onMaxBreadcrumbs(__spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false), maxBreadcrumbs)
                    : __spreadArray(__spreadArray([], __read(breadcrumbs), false), [mergedBreadcrumb], false);
        }
    };
    return [function () { return breadcrumbs; }, addBreadcrumb];
};

var breadcrumbGetterWithDomObserver = function (tearDownGroup, _a, config) {
    var _b = __read(_a, 2), clickObserver = _b[0], keypressObserver = _b[1];
    var maxBreadcrumbs = config.maxBreadcrumbs, onAddBreadcrumb = config.onAddBreadcrumb, onMaxBreadcrumbs = config.onMaxBreadcrumbs, dom = config.dom;
    var _c = __read(applyDomAndKeyPress(100), 2), domEventHandler = _c[0], keypressHandler = _c[1];
    var _d = __read(applyBreadcrumb(maxBreadcrumbs, onAddBreadcrumb, onMaxBreadcrumbs), 2), getBreadcrumbs = _d[0], addBreadcrumb = _d[1];
    if (dom) {
        var createDomBreadcrumb = domBreadcrumb(addBreadcrumb);
        tearDownGroup.push(clickObserver[0](domEventHandler(CLICK_EVENT_NAME, triggerHandlers(createDomBreadcrumb, DOM_EVENT_TYPE))));
        tearDownGroup.push(keypressObserver[0](keypressHandler(triggerHandlers(createDomBreadcrumb, DOM_EVENT_TYPE))));
    }
    return [getBreadcrumbs, addBreadcrumb];
};

var BREADCRUMB_MONITOR_PLUGIN_NAME = 'breadcrumb';
var defaultConfig$7 = {
    maxBreadcrumbs: 20,
    dom: true,
};
function BreadcrumbMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig$7);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var _a = __read(breadcrumbGetterWithDomObserver(tearDownGroup, [initSubjectInGlobal(client, clickSubject), initSubjectInGlobal(client, keypressSubject)], config), 2), getBreadcrumbs = _a[0], addBreadcrumb = _a[1];
    var listenOtherReport = function (ev) {
        if (ev.ev_type === HTTP_EV_TYPE) {
            addBreadcrumb({
                type: HTTP_EV_TYPE,
                category: ev.payload.api,
                message: '',
                data: {
                    method: ev.payload.request.method,
                    url: ev.payload.request.url,
                    status_code: String(ev.payload.response.status),
                },
                timestamp: ev.payload.request.timestamp,
            });
        }
        return ev;
    };
    client.on('report', listenOtherReport);
    tearDownGroup.push(function () {
        client.off('report', listenOtherReport);
    });
    registerTearDownGroup(client, BREADCRUMB_MONITOR_PLUGIN_NAME, JS_ERROR_EV_TYPE, tearDownGroup);
    client.provide('getBreadcrumbs', getBreadcrumbs);
    client.provide('addBreadcrumb', addBreadcrumb);
}
function BreadcrumbMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[BREADCRUMB_MONITOR_PLUGIN_NAME];
        BreadcrumbMonitorBasePlugin(client, config);
    });
}

var httpGetterWithFetchObserver = function (tearDownGroup, _a, fetchConfig) {
    var _b = __read(_a, 2), fetchObserver = _b[0], getResourceObserver = _b[1];
    var setTraceHeader = fetchConfig.setTraceHeader, ignoreUrls = fetchConfig.ignoreUrls, setContextAtReq = fetchConfig.setContextAtReq, extractUrl = fetchConfig.extractUrl;
    // eslint-disable-next-line compat/compat
    var Headers = window.Headers;
    // eslint-disable-next-line compat/compat
    var Request = window.Request;
    if (!Request || !Headers)
        return;
    tearDownGroup.push(fetchObserver[0](function (_a) {
        var _b = __read(_a, 2), req = _b[0], options = _b[1];
        var url = getFullUrl(req instanceof Request ? req.url : req);
        if (!isHttpURL(url) || checkIfHit(ignoreUrls, url)) {
            return noop;
        }
        setTraceHeader &&
            setTraceHeader(url, function (key, value) { return addHeader(key, value, req, options, Request, Headers); });
        var reportWithContext = setContextAtReq();
        var _start = now();
        var timing = undefined;
        var resourceTearDown = getResourceObserver()[0](function (entry) {
            url === entry.name && !timing && (timing = entry);
        });
        return function (res) {
            var payload = getEventParams(req, options, res, Request, Headers, fetchConfig, _start);
            var reportFetchData = applySendOnce(function (data) {
                timing && (data.response.timing = timing);
                handleWithExtractUrl(data, extractUrl);
                reportWithContext && reportWithContext({ ev_type: HTTP_EV_TYPE, payload: data });
                resourceTearDown();
            });
            setTimeout(function () {
                reportFetchData(payload);
            }, 1000);
        };
    }));
};
var isHttpURL = function (url) {
    if (!isString(url)) {
        return false;
    }
    var _a = __read(url.split(':'), 2), protocol = _a[0], path = _a[1];
    return !path || protocol === 'http' || protocol === 'https';
};
var isRequest = function (req, Request) {
    return req instanceof Request;
};
var addHeader = function (key, value, req, options, Request, Headers) {
    var _a;
    if (isRequest(req, Request)) {
        req.headers.set(key, value);
    }
    else if (options.headers instanceof Headers) {
        options.headers.set(key, value);
    }
    else {
        options.headers = __assign(__assign({}, options.headers), (_a = {}, _a[key] = value, _a));
    }
};
var getFetchMethod = function (req, options, Request) {
    var method = (options && options.method) || 'get';
    if (isRequest(req, Request)) {
        method = req.method || method;
    }
    return method.toLowerCase();
};
var mergeHeaders = function (Headers) {
    var headers = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        headers[_i - 1] = arguments[_i];
    }
    try {
        return headers.reduce(function (sum, cur) {
            // eslint-disable-next-line compat/compat
            new Headers(cur || {}).forEach(function (val, key) { return !isSensitiveHeader(key, val) && (sum[key] = val); });
            return sum;
        }, {});
    }
    catch (_a) {
        return {};
    }
};
var getFetchBody = function (req, options, Request) {
    if (isRequest(req, Request)) {
        return req.body;
    }
    else {
        return options === null || options === void 0 ? void 0 : options.body;
    }
};
var getEventParams = function (req, options, res, Request, Headers, props, _start) {
    var params = {
        api: 'fetch',
        request: {
            method: getFetchMethod(req, options, Request),
            timestamp: _start,
            url: getFullUrl(req instanceof Request ? req.url : req),
            headers: mergeHeaders(Headers, req.headers, options.headers),
        },
        response: {
            status: (res && res.status) || 0,
            is_custom_error: false,
            timestamp: now(),
        },
        duration: now() - _start,
    };
    var collectBodyOnError = props.collectBodyOnError, extraExtractor = props.extraExtractor;
    var setRequestBodyIfAllowed = function () {
        var _a;
        collectBodyOnError && (params.request.body = (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString());
    };
    if (res) {
        try {
            var resHeaders = mergeHeaders(Headers, res.headers);
            params.response.headers = resHeaders;
            try {
                // only when the content-type includes 'application/json' can convert to JSON.
                ;
                (resHeaders['content-type'] || '').indexOf('application/json') !== -1 &&
                    extraExtractor &&
                    res
                        .clone()
                        .json()
                        .then(function (o) {
                        var _a;
                        var extra = extraExtractor(o, params, (_a = getFetchBody(req, options, Request)) === null || _a === void 0 ? void 0 : _a.toString());
                        if (extra) {
                            params.extra = extra;
                            params.response.is_custom_error = true;
                            setRequestBodyIfAllowed();
                        }
                    })
                        .catch(noop);
            }
            catch (_o) {
                // do nothing
            }
            res.status >= 400 && setRequestBodyIfAllowed();
        }
        catch (_a) {
            // do nothing
        }
    }
    else {
        setRequestBodyIfAllowed();
    }
    return params;
};

var FETCH_MONITOR_PLUGIN_NAME = 'fetch';
var defaultConfig$6 = {
    autoWrap: true,
    setContextAtReq: function () { return id; },
    ignoreUrls: [],
    collectBodyOnError: false,
};
function FetchMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig$6);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var fetchConfig = __assign(__assign({}, config), { setContextAtReq: function () { return reportWithCurrentContext(client, true); }, setTraceHeader: setTraceContext(config.trace) });
    var getResourceObserver = function () { return initSubjectInGlobal(client, resourceSubject); };
    fetchConfig.autoWrap &&
        httpGetterWithFetchObserver(tearDownGroup, [initSubjectInGlobal(client, fetchSubject), getResourceObserver], fetchConfig);
    registerTearDownGroup(client, FETCH_MONITOR_PLUGIN_NAME, HTTP_EV_TYPE, tearDownGroup);
    client.provide('wrapFetch', function (f) {
        var newFetch = undefined;
        httpGetterWithFetchObserver(tearDownGroup, [
            createSafeObserver(function (next) {
                newFetch = hookFetch(f, next);
            }),
            getResourceObserver,
        ], fetchConfig);
        return newFetch;
    });
}
function FetchMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[FETCH_MONITOR_PLUGIN_NAME];
        FetchMonitorBasePlugin(client, config);
    });
}
function FetchMonitorVolPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = getPluginConfig(client, FETCH_MONITOR_PLUGIN_NAME, defaultConfig$6);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var fetchConfig = __assign(__assign({}, config), { setContextAtReq: function () { return reportWithCurrentContext(client, true); }, setTraceHeader: setVolTraceContext(config.trace, "app_id=" + ((_a = client.config()) === null || _a === void 0 ? void 0 : _a.aid) + ",origin=web") });
        fetchConfig.autoWrap &&
            httpGetterWithFetchObserver(tearDownGroup, [initSubjectInGlobal(client, fetchSubject), function () { return initSubjectInGlobal(client, resourceSubject); }], fetchConfig);
        registerTearDownGroup(client, FETCH_MONITOR_PLUGIN_NAME, HTTP_EV_TYPE, tearDownGroup);
    });
}

var ERROR_FIELDS = ['name', 'message', 'stack', 'filename', 'lineno', 'colno'];
var normalize = function (ex) {
    var error;
    if (!isError(ex)) {
        if (isPlainObject(ex) || isEvent(ex) || isString(ex)) {
            error = {
                message: safeStringify(ex),
            };
        }
    }
    else {
        error = pick(ex, ERROR_FIELDS);
    }
    return error;
};
var normalizeError = function (event) {
    return normalize(event.error);
};
var normalizeException = function (event) {
    var _a;
    // dig the object of the rejection out of known event types
    try {
        var error = void 0;
        // PromiseRejectionEvents store the object of the rejection under 'reason'
        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
        if ('reason' in event) {
            error = event.reason;
        }
        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
        // https://github.com/getsentry/sentry-javascript/issues/2380
        else if ('detail' in event && 'reason' in event.detail) {
            error = event.detail.reason;
        }
        if (error) {
            var rejectionError = normalize(error);
            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
            return __assign(__assign({}, rejectionError), { name: (_a = (rejectionError && rejectionError.name)) !== null && _a !== void 0 ? _a : 'UnhandledRejection' });
        }
    }
    catch (_oO) {
        // no-empty
    }
};
var normalizeUnknownError = function (exception) {
    if (isErrorEvent(exception)) {
        return normalizeError(exception);
    }
    else if (isPromiseRejectionEvent(exception)) {
        return normalizeException(exception);
    }
    else {
        return normalize(exception);
    }
};

var DEFAULT_EVENT_TARGET = [
    'EventTarget',
    'Window',
    'Node',
    'ApplicationCache',
    'ChannelMergerNode',
    'EventSource',
    'FileReader',
    'HTMLUnknownElement',
    'IDBDatabase',
    'IDBRequest',
    'IDBTransaction',
    'MessagePort',
    'Notification',
    'SVGElementInstance',
    'Screen',
    'TextTrack',
    'TextTrackCue',
    'TextTrackList',
    'WebSocket',
    'Worker',
    'XMLHttpRequest',
    'XMLHttpRequestEventTarget',
    'XMLHttpRequestUpload',
];
var DEFAULT_TIME_FUNCTION = [
    'setTimeout',
    'setInterval',
    'requestAnimationFrame',
    'requestIdleCallback',
];
var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
var ADD_EVENT_LISTENER = 'addEventListener';
var REMOVE_EVENT_LISTENER = 'removeEventListener';
var DEFAULT_SOURCE_TYPE = 'capture-global';
var observeAsyncErrorWithSource = function (next, tearDown) {
    var window = getDefaultBrowser();
    var xhr = getDefaultXMLHttpRequest();
    var restoreFns = [];
    var wrap = function (fn, sourceData) {
        if (!isFunction(fn))
            return fn;
        var source = {
            type: DEFAULT_SOURCE_TYPE,
            data: __assign({}, sourceData),
        };
        var hookFn = (fn._w_ || (fn._w_ = function () {
            try {
                // NOTE: If you are a Slardar user, and you are seeing this stack frame, it
                //       means the Slardar SDK caught an error invoking your application code. This
                //       is expected behavior and NOT indicative of a bug with Slardar SDK.
                return (fn.handleEvent && isFunction(fn.handleEvent) ? fn.handleEvent : fn).apply(this, [].map.call(arguments, function (arg) { return wrap(arg, sourceData); }));
            }
            catch (e) {
                var error = normalize(e);
                error && next({ source: source, error: error });
                throw e;
            }
        }));
        hookFn._hook_ = true;
        return hookFn;
    };
    window && restoreFns.push.apply(restoreFns, __spreadArray([], __read(DEFAULT_TIME_FUNCTION.filter(function (timeFunc) { return window[timeFunc]; }).map(function (timeFunc) {
        return hookObjectProperty(window, timeFunc, function (origin) {
            return function (handler) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return (origin && origin.call.apply(origin, __spreadArray([this,
                    wrap(handler, {
                        function: timeFunc,
                    })], __read(params), false)));
            };
        }, false)();
    })), false));
    xhr &&
        xhr.prototype &&
        restoreFns.push(hookObjectProperty(xhr.prototype, 'send', function (origin) {
            return function () {
                var _this = this;
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                // filter 防御一个 xhr 实例被多次 send 导致 wrap 多次的情况
                xmlHttpRequestProps
                    .filter(function (prop) { return _this[prop] && !_this[prop]._hook_; })
                    .forEach(function (prop) {
                    // never restore xhr instance callback
                    _this[prop] = wrap(_this[prop], { function: prop });
                });
                return origin.apply(this, params);
            };
        }, false)());
    DEFAULT_EVENT_TARGET.forEach(function (target) {
        var proto = window && window[target] && window[target].prototype;
        if (!proto || !proto[ADD_EVENT_LISTENER]) {
            return;
        }
        restoreFns.push(hookObjectProperty(proto, ADD_EVENT_LISTENER, function (origin) {
            return function (evName, fn, options) {
                try {
                    var handleEventFn = fn.handleEvent;
                    if (isFunction(handleEventFn)) {
                        fn.handleEvent = wrap(handleEventFn, { function: 'handleEvent', target: target });
                    }
                }
                catch (_a) {
                    //
                }
                return origin && origin.call(this, evName, wrap(fn, { function: ADD_EVENT_LISTENER, target: target }), options);
            };
        }, false)());
        restoreFns.push(hookObjectProperty(proto, REMOVE_EVENT_LISTENER, function (origin) {
            return function (eventName, fn, options) {
                if (fn === null || fn === void 0 ? void 0 : fn._w_) {
                    origin.call(this, eventName, fn._w_, options);
                }
                return origin.call(this, eventName, fn, options);
            };
        }, false)());
    });
    tearDown(function () { return restoreFns.forEach(function (fn) { return fn(); }); });
};
var ASYNC_ERROR_SUBJECT_NAME = 'async_error_0';
var asyncErrorWithSourceSubject = [
    ASYNC_ERROR_SUBJECT_NAME,
    observeAsyncErrorWithSource,
];

var ERROR_SUBJECT_NAME = 'err_0';
var observeError = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var removeListener = addListenerToWindow(window, 'error', next, true);
    tearDown(function () {
        removeListener();
    });
};
var errorSubject = [ERROR_SUBJECT_NAME, observeError];
var PROMISE_REJECTION_SUBJECT_NAME = 'perr_0';
var observePromiseRejection = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var removeListener = addListenerToWindow(window, 'unhandledrejection', next, true);
    tearDown(function () {
        removeListener();
    });
};
var promiseRejectionSubject = [
    PROMISE_REJECTION_SUBJECT_NAME,
    observePromiseRejection,
];

var isSameErrorString = function (current, previous) {
    return current && previous && current === previous;
};
var shouldDropEvent = function (currentError, previousError) {
    if (!currentError || !previousError) {
        return false;
    }
    if (isSameErrorString(currentError.message, previousError.message) &&
        isSameErrorString(currentError.stack, previousError.stack)) {
        return true;
    }
    return false;
};
var dedupe = function () {
    var __previousError;
    return function (currentError) {
        // just in case something goes wrong
        try {
            if (shouldDropEvent(currentError, __previousError)) {
                __previousError = currentError;
                return undefined;
            }
        }
        catch (e) {
            reportSelfError(e);
        }
        __previousError = currentError;
        return currentError;
    };
};

var jsErrorGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 3), errorObserver = _b[0], promiseRejectionObserver = _b[1], getAsyncErrorWithSourceObserver = _b[2];
    var ignoreErrors = config.ignoreErrors, onerror = config.onerror, onunhandledrejection = config.onunhandledrejection, dedupeFlag = config.dedupe, captureGlobalAsync = config.captureGlobalAsync;
    var ignoreRegExp = getRegexp(ignoreErrors);
    var dedupeFn = dedupe();
    var reportJsError = function (_a) {
        var error = _a.error, extra = _a.extra, react = _a.react, source = _a.source;
        var err = dedupeFlag ? dedupeFn(error) : error;
        if (!err || !err.message || (ignoreRegExp && ignoreRegExp.test(err.message))) {
            return;
        }
        report({
            ev_type: JS_ERROR_EV_TYPE,
            payload: {
                error: err,
                breadcrumbs: [],
                extra: extra,
                react: react,
                source: source,
            },
        });
    };
    onerror &&
        tearDownGroup.push(errorObserver[0](function (ev) { return reportJsError({ error: normalizeError(ev), source: { type: 'onerror' } }); }));
    onunhandledrejection &&
        tearDownGroup.push(promiseRejectionObserver[0](function (ev) {
            return reportJsError({ error: normalizeException(ev), source: { type: 'onunhandledrejection' } });
        }));
    captureGlobalAsync &&
        tearDownGroup.push(getAsyncErrorWithSourceObserver()[0](function (jsErrorPayload) {
            reportJsError(jsErrorPayload);
        }));
    return function (err, extra, react) {
        return reportJsError({ error: normalizeUnknownError(err), extra: extra, react: react, source: { type: 'manual' } });
    };
};

var JS_ERROR_MONITOR_PLUGIN_NAME = 'jsError';
var defaultConfig$5 = {
    ignoreErrors: [],
    onerror: true,
    onunhandledrejection: true,
    captureGlobalAsync: false,
    dedupe: true,
};
function JsErrorMonitorBasePlugin(client, c) {
    // stop precollect listener no matter what is configured
    window.removeEventListener('error', client.pcErr, true);
    window.removeEventListener('unhandledrejection', client.pcRej, true);
    var config = getConfig(c, defaultConfig$5);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    var reportJsError = jsErrorGetterWithContext(function (ev) {
        client.getBreadcrumbs && (ev.payload.breadcrumbs = client.getBreadcrumbs());
        client.report(ev);
    }, tearDownGroup, [
        initSubjectInGlobal(client, errorSubject),
        initSubjectInGlobal(client, promiseRejectionSubject),
        function () { return initSubjectInGlobal(client, asyncErrorWithSourceSubject); },
    ], config);
    registerTearDownGroup(client, JS_ERROR_MONITOR_PLUGIN_NAME, JS_ERROR_EV_TYPE, tearDownGroup);
    client.provide('captureException', reportJsError);
}
function JsErrorMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[JS_ERROR_MONITOR_PLUGIN_NAME];
        JsErrorMonitorBasePlugin(client, config);
    });
}

var HIDDEN_SUBJECT_NAME = 'hidden_3';
var visibilityStateIsHidden = function (d) { return d.visibilityState === 'hidden'; };
var observeHidden = function (next, tearDown) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    // some browsers have buggy implementations of visibilitychange,
    // so we use pagehide in addition, just to be safe.
    var onVisibilityChangeOrPageHide = function (event) {
        next(event.type === 'pagehide' || visibilityStateIsHidden(document));
    };
    var removeVisibilityListener = addListenerToDocument(document, 'visibilitychange', onVisibilityChangeOrPageHide, true);
    var removePageHideListener = addListenerToWindow(window, 'pagehide', onVisibilityChangeOrPageHide, true);
    tearDown(function () {
        removeVisibilityListener();
        removePageHideListener();
    }, function (subscriber) {
        subscriber(visibilityStateIsHidden(document));
    });
};
/**
 * When subscribing to hiddenSubject, it's important to note that it may immediately and synchronously trigger.
 */
var hiddenSubject = [HIDDEN_SUBJECT_NAME, observeHidden];
var LOAD_SUBJECT_NAME = 'load_1';
var readyStateIsComplete = function (d) { return d.readyState === 'complete'; };
var observeLoad = function (next, tearDown) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onLoad = function () {
        // queue a task so the callback runs after `loadEventEnd`
        setTimeout(function () {
            next();
            onceTriggered = true;
        }, 0);
    };
    if (readyStateIsComplete(document)) {
        onLoad();
    }
    else {
        removeListener = addListenerToWindow(window, 'load', onLoad, false);
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to loadSubject, it's important to note that it may immediately and synchronously trigger.
 */
var loadSubject = [LOAD_SUBJECT_NAME, observeLoad];
var UNLOAD_SUBJECT_NAME = 'unload_0';
var observeUnload = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    var _a = __read(invokeCallbackOnce(next), 1), invokeCbOnce = _a[0];
    var unloadEventList = ['unload', 'beforeunload', 'pagehide'];
    var handler = function () {
        invokeCbOnce();
    };
    var tearDowns = [];
    unloadEventList.forEach(function (ev) {
        tearDowns.push(addListenerToWindow(window, ev, handler, false));
    });
    tearDown(function () {
        tearDowns.forEach(function (e) { return e(); });
    });
};
var unloadSubject = [UNLOAD_SUBJECT_NAME, observeUnload];
var DOM_CONTENT_LOAD_SUBJECT_NAME = 'domLoad_1';
var observeDOMContentLoad = function (next, tearDown) {
    var window = getDefaultBrowser();
    var document = getDefaultDocument();
    if (!window || !document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onDOMContentLoad = function () {
        setTimeout(function () {
            next();
            onceTriggered = true;
        }, 0);
    };
    if (document.readyState !== 'loading') {
        onDOMContentLoad();
    }
    else {
        removeListener = addListenerToDocument(document, 'DOMContentLoaded', onDOMContentLoad, false);
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to DOMContentLoadSubject, it's important to note that it may immediately and synchronously trigger.
 */
var DOMContentLoadSubject = [
    DOM_CONTENT_LOAD_SUBJECT_NAME,
    observeDOMContentLoad,
];
var ACTIVATED_SUBJECT_NAME = 'activated_0';
var observeActivated = function (next, tearDown) {
    var document = getDefaultDocument();
    if (!document)
        return;
    var onceTriggered = false;
    var removeListener = noop;
    var onActivated = function () {
        next();
        onceTriggered = true;
    };
    // @ts-expect-error
    if (document && document.prerendering) {
        removeListener = addListenerToDocument(document, 'prerenderingchange', onActivated, true);
    }
    else {
        onActivated();
    }
    tearDown(function () {
        removeListener();
    }, function (subscriber) {
        onceTriggered && subscriber();
    });
};
/**
 * When subscribing to activatedSubject, it's important to note that it may immediately and synchronously trigger.
 */
var activatedSubject = [ACTIVATED_SUBJECT_NAME, observeActivated];

var HISTORY_SUBJECT_NAME = 'history_0';
var HASH_SUBJECT_NAME = 'hash_0';
var observeHistory = function (next, tearDown) {
    var history = getDefaultHistory();
    var window = getDefaultBrowser();
    if (!history || !window)
        return;
    var restoreFns = [];
    var historyChangeListener = function () { return next(location.href); };
    var hookStateChange = function (origin) {
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            try {
                origin.apply(history, params);
            }
            finally {
                historyChangeListener();
            }
        };
    };
    restoreFns.push(hookObjectProperty(history, 'pushState', hookStateChange)(), hookObjectProperty(history, 'replaceState', hookStateChange)());
    restoreFns.push(addListenerToWindow(window, 'popstate', historyChangeListener, true));
    tearDown(function () {
        restoreFns.forEach(function (fn) { return fn(); });
    });
};
var observeHash = function (next, tearDown) {
    var window = getDefaultBrowser();
    if (!window)
        return;
    var hashChangeListener = function () { return next(location.href); };
    var removeListener = addListenerToWindow(window, 'hashchange', hashChangeListener, true);
    tearDown(function () {
        removeListener();
    });
};
var hashSubject = [HASH_SUBJECT_NAME, observeHash];
var historySubject = [HISTORY_SUBJECT_NAME, observeHistory];

var getDefaultExtractor = function (routeMode) { return function (url) {
    var _a;
    if (routeMode === 'hash') {
        return ((_a = parseUrl(url).hash) === null || _a === void 0 ? void 0 : _a.replace(/^#/, '')) || '/';
    }
    else {
        return parseUrl(url).path;
    }
}; };
var getViewId = function (pid) { return joinWithSeparator(pid, now()); };
var joinWithSeparator = function (a, b) { return a + "_" + b; };
var applyOnPidChange = function (cb, initPid, firstOriginPid, onPidUpdate) {
    // store originalPid from url
    var originalPid = firstOriginPid;
    // store finalPid send to server
    var finalPid = initPid;
    // set init pid in config
    onPidUpdate && onPidUpdate(initPid);
    var onPidChange = function (source, newPid, customPid) {
        // newPid is extractPid from url, should send pageview if changed, no matter customPid changed
        if (source !== "user_set" /* user_set */ && newPid !== originalPid) {
            originalPid = newPid;
            finalPid = customPid !== null && customPid !== void 0 ? customPid : originalPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
            // newPid is by user set, should send pageview if not equal to finalPid
        }
        else if (source === "user_set" /* user_set */ && newPid !== finalPid) {
            finalPid = newPid;
            onPidUpdate && onPidUpdate(finalPid); // update pid in common
            cb(source, finalPid);
        }
    };
    var sendInit = function () {
        initPid && cb("init" /* init */, initPid);
    };
    return [onPidChange, sendInit];
};
var applyOnUrlChange = function (cb, initUrl) {
    var url = initUrl;
    var onUrlChange = function (source, newUrl) {
        if (newUrl !== url) {
            url = newUrl;
            cb(source, url);
        }
    };
    return [onUrlChange];
};
var wrapPageview = function (source, pid) { return ({
    ev_type: PAGEVIEW_EV_TYPE,
    payload: {
        pid: pid,
        source: source,
    },
}); };
var applyReportPageview = function (report) {
    return function (source, pid) {
        report(wrapPageview(source, pid));
    };
};
var isManualMode = function (routeMode) { return routeMode === 'manual'; };
var ERROR_WEIGHT = 'error_weight';
var DURATION_APDEX = 'duration_apdex';
var PREF_APDEX = 'perf_apdex';
var ACTION_KEY = 'action';
var getDefaultApdexDetail = function () {
    var _a;
    return _a = {
            error_count: [0, 0, 0, 0],
            duration_count: [0, 0, 0]
        },
        _a[PREF_APDEX] = {},
        _a;
};
var getRank = function (apdex, setting) {
    var total = apdex[0 /* satisfying */] + apdex[1 /* tolerable */] + apdex[2 /* frustrating */];
    var s_percent = apdex[0 /* satisfying */] / total;
    var f_percent = apdex[2 /* frustrating */] / total;
    return f_percent > setting.frustrating_threshold
        ? 2 /* frustrating */
        : s_percent > setting.satisfying_threshold || total === 0
            ? 0 /* satisfying */
            : 1 /* tolerable */;
};
var calculateSpentTime = function () {
    // record spent time
    var spentTime = 0;
    var lastShowTimeStamp = undefined;
    var handleHidden = function (isHidden) {
        if (isHidden) {
            if (!lastShowTimeStamp)
                return;
            // set spentTime and reset last show timestamp
            spentTime += now() - lastShowTimeStamp;
            lastShowTimeStamp = undefined;
        }
        else {
            lastShowTimeStamp = now();
        }
    };
    var getSpentTime = function () {
        // correct the value of the last spent
        lastShowTimeStamp && (spentTime += now() - lastShowTimeStamp);
        var time = spentTime;
        // reset status
        spentTime = 0;
        lastShowTimeStamp = now();
        return time;
    };
    return [handleHidden, getSpentTime];
};
var applyCalculateWight = function (calculateDuration, calculateError) {
    return function (ev, apdexSetting) {
        var payload = ev.payload;
        switch (ev.ev_type) {
            case PERFORMANCE_METRIC_EV_TYPE:
                var name_1 = payload.name;
                if (payload.isSupport) {
                    calculateDuration(apdexSetting[PREF_APDEX], name_1, payload.value);
                }
                break;
            case ACTION_EV_TYPE:
                calculateDuration(apdexSetting[PREF_APDEX], ACTION_KEY, payload.duration || 0);
                break;
            case JS_ERROR_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 0);
                break;
            case HTTP_EV_TYPE:
                if (payload.response.is_custom_error || payload.response.status >= 400) {
                    calculateError(apdexSetting[ERROR_WEIGHT], 1);
                }
                else {
                    var timing = payload.response.timing;
                    timing && calculateDuration(apdexSetting[DURATION_APDEX], 0, timing.duration);
                }
                break;
            case RESOURCE_ERROR_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 2);
                break;
            case BLANK_SCREEN_EV_TYPE:
                calculateError(apdexSetting[ERROR_WEIGHT], 3);
                break;
            case RESOURCE_EV_TYPE:
                calculateDuration(apdexSetting[DURATION_APDEX], 1, payload.duration);
                break;
            case LONG_TASK_EV_TYPE:
                payload.longtasks.forEach(function (l) {
                    calculateDuration(apdexSetting[DURATION_APDEX], 2, l.duration);
                });
                break;
        }
    };
};
var calculateApdex = function () {
    var apdexWeight;
    var apdexDetail;
    var initApdex = function () {
        apdexWeight = [0, 0, 0];
        apdexDetail = getDefaultApdexDetail();
    };
    // init apdex first
    initApdex();
    var calculateDurationWeight = function (weight, nameOrIndex, value) {
        var rules = weight && weight[nameOrIndex];
        // make sure all value is valuable
        if (!rules || value <= 0)
            return;
        var level = value < (rules[0 /* satisfying */].threshold || 0)
            ? 0 /* satisfying */
            : value > (rules[1 /* tolerable */].threshold || 0)
                ? 2 /* frustrating */
                : 1 /* tolerable */;
        apdexWeight[level] += rules[level].weight;
        if (typeof nameOrIndex === 'string') {
            var name_2 = joinWithSeparator(nameOrIndex, level);
            var value_1 = apdexDetail[PREF_APDEX][name_2];
            apdexDetail[PREF_APDEX][name_2] = (value_1 || 0) + 1;
        }
        else {
            level === 2 /* frustrating */ && (apdexDetail.duration_count[nameOrIndex] += 1);
        }
    };
    var calculateErrorWeight = function (weight, index) {
        if (!weight)
            return;
        apdexWeight[2 /* frustrating */] += weight[index];
        apdexDetail.error_count[index] += 1;
    };
    var getApdex = function () {
        return [apdexWeight, apdexDetail];
    };
    return [calculateDurationWeight, calculateErrorWeight, getApdex, initApdex];
};
var calculateSession = function () {
    var sessionPayload = {
        // use the current initialized time as start is more appropriate than navigationStart
        start: now(),
        end: 0,
        time_spent: 0,
        is_bounced: false,
        entry: '',
        exit: '',
        p_count: 0,
        a_count: 0,
    };
    var handleUnload = function (sessionApdexInfo, lastPage) {
        var _a = __read(sessionApdexInfo, 3), rank = _a[0], apdex = _a[1], apdex_detail = _a[2];
        sessionPayload.end = now();
        sessionPayload.time_spent += (lastPage && lastPage.time_spent) || 0;
        sessionPayload.last_page = lastPage;
        sessionPayload.p_count += 1;
        sessionPayload.rank = rank;
        sessionPayload.apdex = apdex;
        sessionPayload.apdex_detail = apdex_detail;
        var d = getDefaultDocument();
        d && (sessionPayload.is_bounced = !readyStateIsComplete(d));
    };
    var handlePageview = function (lastPage, newPid) {
        sessionPayload.time_spent += lastPage.time_spent;
        sessionPayload.p_count += 1;
        sessionPayload.exit = newPid;
    };
    var handleAction = function () {
        sessionPayload.a_count += 1;
    };
    var setEntry = function (entry) {
        sessionPayload.entry = entry;
        sessionPayload.exit = entry;
    };
    var getSessionPayload = function () { return sessionPayload; };
    return [handleUnload, handlePageview, handleAction, setEntry, getSessionPayload];
};

var pvGetterWithRouteObserver = function (report, tearDownGroup, routeObservers, config) {
    var sendInitFlag = config.sendInit, initPid = config.initPid, routeMode = config.routeMode, extractPid = config.extractPid, onPidUpdate = config.onPidUpdate;
    var extractPidFromUrl = isManualMode(routeMode) ? function () { return ''; } : getDefaultExtractor(routeMode);
    var customPidFromUrl = extractPid || (function () { return undefined; });
    var getFinalPid = function (url) { var _a; return (_a = customPidFromUrl(url)) !== null && _a !== void 0 ? _a : extractPidFromUrl(url); };
    var _a = __read(applyOnPidChange(applyReportPageview(report), initPid || getFinalPid(location.href), extractPidFromUrl(location.href), onPidUpdate), 2), onPidChange = _a[0], sendInit = _a[1];
    if (!isManualMode(routeMode)) {
        var _b = __read(applyOnUrlChange(function (sources, url) { return onPidChange(sources, extractPidFromUrl(url), customPidFromUrl(url)); }, ''), 1), onUrlChange_1 = _b[0];
        routeObservers.length &&
            routeObservers.forEach(function (routeObserver) {
                return tearDownGroup.push(routeObserver[0](function (value) { return onUrlChange_1(routeMode, value); }));
            });
    }
    if (sendInitFlag) {
        sendInit();
    }
    return [onPidChange.bind(null, "user_set" /* user_set */)];
};

var apdexGetterWithHiddenObserver = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), hiddenObserver = _b[0], unloadObserver = _b[1];
    var onlyPageApdex = config.apdex === 2;
    // record last page detail and current page info
    var currentPageInfo = undefined;
    var lastPidPayload = undefined;
    // apdex setting get from server, and not report any thing if not setting
    var apdexSetting = undefined;
    var apdexStarted = false;
    var _c = __read(calculateApdex(), 4), calculateDurationWeight = _c[0], calculateErrorWeight = _c[1], getApdex = _c[2], resetApdex = _c[3];
    var _d = __read(calculateApdex(), 4), calculateSessionDurationWeight = _d[0], calculateSessionErrorWeight = _d[1], getSessionApdex = _d[2], resetSessionApdex = _d[3];
    var _e = __read(calculateSession(), 5), handleUnload = _e[0], handlePageview = _e[1], handleAction = _e[2], setEntry = _e[3], getSessionPayload = _e[4];
    // record spent time
    var _f = __read(calculateSpentTime(), 2), handleHidden = _f[0], getSpentTime = _f[1];
    tearDownGroup.push(hiddenObserver[0](handleHidden));
    // send session event if need
    !onlyPageApdex &&
        tearDownGroup.push(unloadObserver[0](function () {
            if (!apdexStarted)
                return;
            var _a = __read(getSessionApdex(), 2), apdex = _a[0], detail = _a[1];
            var sessionRank = getRank(apdex, apdexSetting);
            handleUnload([sessionRank, apdex, detail], getPagePayload());
            report({
                ev_type: SESSION_EV_TYPE,
                payload: getSessionPayload(),
            });
            resetSessionApdex();
        }));
    var handlePageviewWeight = applyCalculateWight(calculateDurationWeight, calculateErrorWeight);
    var handleSessionWeight = applyCalculateWight(calculateSessionDurationWeight, calculateSessionErrorWeight);
    var handleSend = function (ev) {
        // make sure already have apdex setting and currentPid
        if (!apdexStarted)
            return;
        // always handle session weight if session flag is open
        if (!onlyPageApdex) {
            handleSessionWeight(ev, apdexSetting);
            ev.ev_type === ACTION_EV_TYPE && handleAction();
        }
        // discard asynchronous data to avoid affecting the apdex of the current pid.
        if (ev.common.pid !== currentPageInfo[1])
            return;
        handlePageviewWeight(ev, apdexSetting);
    };
    var getPagePayload = function () {
        var _a = __read(getApdex(), 2), apdex = _a[0], detail = _a[1];
        return {
            start: currentPageInfo[0],
            pid: currentPageInfo[1],
            view_id: currentPageInfo[2],
            end: now(),
            time_spent: getSpentTime(),
            apdex: apdex,
            rank: getRank(apdex, apdexSetting),
            detail: detail,
        };
    };
    var handlePageviewChange = function (newPid, newViewId) {
        // if no current page info, init current page, else settle current page and reset status
        if (!currentPageInfo) {
            currentPageInfo = [now(), newPid, newViewId];
            // set entry to session
            setEntry(newPid);
            // set started status
            apdexStarted = !!(apdexSetting && currentPageInfo);
            return;
        }
        if (apdexStarted) {
            // set last pid payload
            lastPidPayload = getPagePayload();
            // send last pid payload to session
            handlePageview(lastPidPayload, newPid);
        }
        // reset status
        currentPageInfo = [now(), newPid, newViewId];
        resetApdex();
    };
    var reportPageviewWithApdex = function (ev) {
        apdexStarted && (ev.payload.last = lastPidPayload);
        report(ev);
    };
    var setApdexSetting = function (apdex) {
        if (!apdex) {
            // teardown all effect
            tearDownGroup.forEach(function (e) { return e(); });
            tearDownGroup.length = 0;
            return;
        }
        apdexSetting = apdex;
        apdexStarted = !!(apdexSetting && currentPageInfo);
    };
    tearDownGroup.push(function () {
        apdexStarted = false;
    });
    return [handlePageviewChange, handleSend, reportPageviewWithApdex, setApdexSetting];
};

var PAGEVIEW_MONITOR_PLUGIN_NAME = 'pageview';
var defaultConfig$4 = {
    sendInit: true,
    routeMode: 'history',
    apdex: 2,
};
function PageviewMonitorBasePlugin(client, c) {
    var _a;
    var config = getConfig(c, defaultConfig$4);
    if (!config || !getDefaultLocation()) {
        return;
    }
    var routeMode = config.routeMode, apdex = config.apdex;
    var report = client.report.bind(client);
    var handlePageviewChange = noop;
    // apdex start
    if (apdex) {
        var apdexTearDownGroup = [];
        var _b = __read(apdexGetterWithHiddenObserver(client.report.bind(client), apdexTearDownGroup, [initSubjectInGlobal(client, hiddenSubject), initSubjectInGlobal(client, unloadSubject)], config), 4), handlePageview = _b[0], handleSend_1 = _b[1], reportWithApdex = _b[2], setApdexSetting_1 = _b[3];
        report = reportWithApdex;
        handlePageviewChange = handlePageview;
        client.on('send', handleSend_1);
        apdexTearDownGroup.push(function () { return client.off('send', handleSend_1); });
        client.on('start', function () {
            setApdexSetting_1(client.config().apdex);
        });
        registerTearDownGroup(client, PAGEVIEW_MONITOR_PLUGIN_NAME, SESSION_EV_TYPE, apdexTearDownGroup);
    }
    // apdex end
    var tearDownGroup = [];
    var _c = __read(pvGetterWithRouteObserver(report, tearDownGroup, isManualMode(routeMode) ? [] : [client.initSubject(hashSubject), client.initSubject(historySubject)], __assign(__assign({}, config), { initPid: (_a = client.config()) === null || _a === void 0 ? void 0 : _a.pid, onPidUpdate: function (pid) {
            var viewId = getViewId(pid);
            // the apdex score must be settled when reporting, needs to know the change before reporting
            handlePageviewChange(pid, viewId);
            client.set({ pid: pid, viewId: viewId, actionId: undefined });
        } })), 1), sendPageview = _c[0];
    initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
    var onConfig = function () {
        sendPageview(client.config().pid);
    };
    client.on('config', onConfig);
    tearDownGroup.push(function () { return client.off('config', onConfig); });
    registerTearDownGroup(client, PAGEVIEW_MONITOR_PLUGIN_NAME, PAGEVIEW_EV_TYPE, tearDownGroup);
    client.provide('sendPageview', sendPageview);
}
function PageviewMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[PAGEVIEW_MONITOR_PLUGIN_NAME];
        PageviewMonitorBasePlugin(client, config);
    });
}

var RESOURCE_PERFORMANCE_ENTRY_TYPE = 'resource';
var RESOURCE_IGNORE_TYPES = ['xmlhttprequest', 'fetch', 'beacon'];
var resourceGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 2), loadObserver = _b[0], getResourceObserver = _b[1];
    var performance = getDefaultPerformance();
    if (!performance)
        return;
    var ignoreUrls = config.ignoreUrls, slowSessionThreshold = config.slowSessionThreshold, ignoreTypes = config.ignoreTypes;
    var ignoreRegExp = getRegexp(ignoreUrls);
    var reportResource = function (entry, isSlowSession) {
        if (isSlowSession === void 0) { isSlowSession = false; }
        if (arrayIncludes(ignoreTypes || RESOURCE_IGNORE_TYPES, entry.initiatorType) ||
            (ignoreRegExp && ignoreRegExp.test(entry.name)))
            return;
        var data = { ev_type: RESOURCE_EV_TYPE, payload: entry };
        isSlowSession && (data.extra = { sample_rate: 1 });
        report(data);
    };
    tearDownGroup.push(loadObserver[0](function () {
        var _a = __read(applyPerformance(performance), 3), timing = _a[0], getEntriesByType = _a[2];
        // make sure all resource of slow session can be reported
        var checkSlowSession = function () {
            if (!timing) {
                return false;
            }
            var loadTime = timing.loadEventEnd - timing.navigationStart;
            return loadTime > slowSessionThreshold;
        };
        var isSlowSession = checkSlowSession();
        var cacheEntries = getEntriesByType(RESOURCE_PERFORMANCE_ENTRY_TYPE);
        cacheEntries.forEach(function (e) { return reportResource(e, isSlowSession); });
        tearDownGroup.push(getResourceObserver()[0](function (entry) {
            reportResource(entry);
        }));
    }));
};

var RESOURCE_MONITOR_PLUGIN_NAME = 'resource';
var defaultConfig$3 = {
    ignoreUrls: [],
    slowSessionThreshold: 4000,
};
function ResourceMonitorBasePlugin(client, c) {
    var config = getConfig(c, defaultConfig$3);
    if (!config) {
        return;
    }
    var tearDownGroup = [];
    resourceGetterWithContext(client.report.bind(client), tearDownGroup, [initSubjectInGlobal(client, loadSubject), function () { return initSubjectInGlobal(client, resourceSubject); }], config);
    registerTearDownGroup(client, RESOURCE_MONITOR_PLUGIN_NAME, RESOURCE_EV_TYPE, tearDownGroup);
}
function ResourceMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var config = (_a = client.config()) === null || _a === void 0 ? void 0 : _a.plugins[RESOURCE_MONITOR_PLUGIN_NAME];
        ResourceMonitorBasePlugin(client, config);
    });
}

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
function isHTMLLinkElement(target) {
    return target.tagName.toLowerCase() === 'link';
}
function getElementAttr(target, attr) {
    if (isFunction(target.getAttribute)) {
        // returns what was in the HTML. It may be a relative URL.
        return target.getAttribute(attr) || '';
    }
    // target.src returns absoulute path
    return target[attr] || '';
}
var getSrc = function (target) {
    return getElementAttr(target, isHTMLLinkElement(target) ? 'href' : 'src');
};
var getDataFromEvent = function (e, gatherPath) {
    var target = (e.target || e.srcElement);
    if (!target) {
        return;
    }
    var tagName = target.tagName;
    if (!tagName || !isString(tagName)) {
        return;
    }
    return {
        url: getSrc(target),
        tagName: tagName,
        xpath: gatherPath ? htmlTreeAsString(target) : undefined,
    };
};
var buildPayload = function (data, getEntriesByName) {
    var url = data.url, tagName = data.tagName, xpath = data.xpath;
    var fullUrl = getFullUrl(url);
    var timing = getEntriesByName(fullUrl)[0];
    return {
        type: tagName.toLowerCase(),
        url: fullUrl,
        xpath: xpath,
        timing: timing,
    };
};

var resourceErrorGetterWithContext = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 1), errorObserver = _b[0];
    var window = getDefaultBrowser();
    if (!window)
        return;
    var ignoreUrls = config.ignoreUrls, includeUrls = config.includeUrls, dedupe = config.dedupe, gatherPath = config.gatherPath;
    var includeRegExp = getRegexp(includeUrls);
    var ignoreRegExp = getRegexp(ignoreUrls);
    var _c = __read(applyPerformance(getDefaultPerformance()), 5), getEntriesByName = _c[4];
    var lastErrPath = undefined;
    var reportResourceError = function (data) {
        var locationHref = location && location.href;
        if (locationHref && data.url === locationHref)
            return;
        if ((includeRegExp && !includeRegExp.test(data.url)) || (ignoreRegExp && ignoreRegExp.test(data.url)))
            return;
        if (!data.url)
            return;
        if (dedupe && data.url === lastErrPath)
            return;
        lastErrPath = data.url;
        // when the error occurs, the timing has been pushed into the buffer pool
        // so use getEntriesByName instead of resourceObserver
        var payload = buildPayload(data, getEntriesByName);
        if (payload) {
            report({
                ev_type: RESOURCE_ERROR_EV_TYPE,
                payload: payload,
            });
        }
    };
    tearDownGroup.push(errorObserver[0](function (event) {
        var e = event || window.event;
        if (!e) {
            return;
        }
        var data = getDataFromEvent(e, gatherPath);
        data && reportResourceError(data);
    }));
    return reportResourceError;
};

var RESOURCE_ERROR_MONITOR_PLUGIN_NAME = 'resourceError';
var defaultConfig$2 = {
    includeUrls: [],
    ignoreUrls: [],
    dedupe: true,
    gatherPath: false,
};
function ResourceErrorMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, RESOURCE_ERROR_MONITOR_PLUGIN_NAME, defaultConfig$2);
        if (!config) {
            return;
        }
        var tearDownGroup = [];
        var reportResourceError = resourceErrorGetterWithContext(client.report.bind(client), tearDownGroup, [initSubjectInGlobal(client, errorSubject)], config);
        registerTearDownGroup(client, RESOURCE_ERROR_MONITOR_PLUGIN_NAME, RESOURCE_ERROR_EV_TYPE, tearDownGroup);
        reportResourceError && client.provide('reportResourceError', reportResourceError);
    });
}

var defaultMetricContext = {
    isSupport: true,
    isPolyfill: false,
    isBounced: false,
    isCustom: false,
    type: 'perf',
};
var initMetric = function (name, value) {
    return __assign({ name: name, value: value }, defaultMetricContext);
};

var applySendOnceAndTearDown = function (wrapPerformanceMetric, report, tearDownGroup) {
    var hasInvoked = false;
    return function (metric) {
        tearDownGroup.length &&
            tearDownGroup.forEach(function (v) {
                v();
            });
        tearDownGroup.length = 0;
        if (hasInvoked)
            return;
        hasInvoked = true;
        report && report(wrapPerformanceMetric(metric));
    };
};
var wrapPerformanceMetric = function (metric, overrides) { return ({
    ev_type: PERFORMANCE_METRIC_EV_TYPE,
    payload: metric,
    overrides: overrides,
}); };
var wrapLongtask = function (entry) { return ({
    ev_type: LONG_TASK_EV_TYPE,
    payload: {
        type: 'perf',
        longtasks: [entry],
    },
}); };
var applyReportMetric = function (report) {
    return function (metric, overrides) {
        report(wrapPerformanceMetric(metric, overrides));
    };
};
var SPA_LOAD_METRIC_NAME = 'spa_load';
var getSPA$1 = function (report) {
    var startTime = 0;
    var metric = initMetric(SPA_LOAD_METRIC_NAME, 0);
    var invokeCb = function (load_time) {
        metric.value = load_time;
        report && report(wrapPerformanceMetric(metric));
    };
    var performanceInit = function () {
        startTime = now();
    };
    var performanceSend = function () {
        invokeCb(now() - startTime);
        startTime = 0;
    };
    return [performanceInit, performanceSend];
};
var getNavigationEntry = function () {
    var performance = getDefaultPerformance();
    var _a = __read(applyPerformance(performance), 3), getEntriesByType = _a[2];
    return getEntriesByType('navigation')[0];
};
var getActivationStart = function () {
    var navEntry = getNavigationEntry();
    // @ts-expect-error
    return (navEntry && navEntry.activationStart) || 0;
};

var FCP_ENTRY_NAME = 'first-contentful-paint';
var FP_ENTRY_NAME = 'first-paint';
var FP_METRIC_NAME = "fp" /* fp */;
var FCP_METRIC_NAME = "fcp" /* fcp */;
var Paint_Type = 'paint';
var getFP = function (report, tearDownGroup, context) {
    return getPaint(FP_ENTRY_NAME, FP_METRIC_NAME, report, tearDownGroup, context);
};
var getFCP = function (report, tearDownGroup, context) {
    return getPaint(FCP_ENTRY_NAME, FCP_METRIC_NAME, report, tearDownGroup, context);
};
var getPaint = function (entryName, metricName, report, tearDownGroup, _a) {
    var _b = __read(_a, 3), activatedObserver = _b[0], getHiddenObserver = _b[1], getUnloadObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var document = getDefaultDocument();
    var metric = initMetric(metricName, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!performance || !PerformanceObserver || !document) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var handleActivated = function () {
        // if the page is initially hidden or still hidden after prerendering
        // that means the tab was activated in a background state, so it is marked as unsupported
        if (visibilityStateIsHidden(document)) {
            metric.isSupport = false;
            sendOnceAndTearDown(metric);
            return;
        }
        var invokePaint = function (_a) {
            var startTime = _a.startTime;
            // should be relative to page activation rather than navigation start if the page was pre-rendered.
            // but in cases where `activationStart` occurs after the FP or FCP, this time should be clamped at 0.
            var activatedTimeStamp = getActivationStart();
            metric.value = startTime < activatedTimeStamp ? 0 : startTime - activatedTimeStamp;
            sendOnceAndTearDown(metric);
        };
        var _a = __read(applyPerformance(performance), 5), getEntriesByName = _a[4];
        var paint = getEntriesByName(entryName)[0];
        if (paint) {
            invokePaint(paint);
            return;
        }
        tearDownGroup.push(observePerf(PerformanceObserver, function (entry) {
            entry.name === entryName && invokePaint(entry);
        }, [Paint_Type]));
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            metric.isBounced = true;
            sendOnceAndTearDown(metric);
        }));
        var hiddenCallback = function (isHidden) {
            if (isHidden) {
                // if initially not hidden but suddenly becomes hidden, then the metric can be settle.
                sendOnceAndTearDown(metric);
            }
        };
        // hiddenObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        var hiddenObserver = getHiddenObserver();
        tearDownGroup.push(function () { return hiddenObserver[1](hiddenCallback); });
        hiddenObserver[0](hiddenCallback);
    };
    // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return activatedObserver[1](handleActivated); });
    activatedObserver[0](handleActivated);
};
var FP = [FP_METRIC_NAME, getFP];
var FCP = [FCP_METRIC_NAME, getFCP];

var TTI_METRIC_NAME = 'tti';
var GET_METHOD = 'get';
var QUIET_TIME_LIMIT = 5000;
/**
 * start 方法开启一个调度器，传入回调和调度时间
 * reschedule 重新以一个更长的时间调度
 * stop 停止调度
 */
var applyScheduler = function (now) {
    var timerActiveTime = -Infinity;
    var timerId = undefined;
    var callback;
    var clearTime = function () { return window.clearTimeout(timerId); };
    var reschedule = function (futureTime) {
        if (timerActiveTime > futureTime || !callback) {
            return;
        }
        clearTime();
        timerId = window.setTimeout(callback, futureTime - now());
        timerActiveTime = futureTime;
    };
    var start = function (cb, futureTime) {
        callback = cb;
        reschedule(futureTime);
    };
    var stop = function () {
        clearTime();
        callback = undefined;
    };
    return [start, stop, reschedule];
};
/**
 * Computes the time (in milliseconds since requestStart) that the network was
 * last known to have >2 requests in-flight.
 */
var calcLastNet2Busy = function (undoneReqStarts, observedResReqs, now) {
    if (undoneReqStarts.length > 2) {
        return now();
    }
    var endpoints = [];
    for (var i = 0; i < observedResReqs.length; i++) {
        endpoints.push([observedResReqs[i].start, 0 /* S */], [observedResReqs[i].end, 1 /* E */]);
    }
    for (var i = 0; i < undoneReqStarts.length; i++) {
        endpoints.push([undoneReqStarts[i], 0 /* S */]);
    }
    endpoints.sort(function (a, b) { return a[0] - b[0]; });
    var currentActive = undoneReqStarts.length;
    for (var i = endpoints.length - 1; i >= 0; i--) {
        var _a = __read(endpoints[i], 2), timestamp = _a[0], type = _a[1];
        switch (type) {
            case 0 /* S */:
                currentActive--;
                break;
            case 1 /* E */:
                currentActive++;
                if (currentActive > 2) {
                    return timestamp;
                }
                break;
        }
    }
    // If we reach here, we were never network 2-busy.
    return 0;
};
var getRequestTimes = function (requestTimes) {
    var keys = Object.keys(requestTimes);
    var result = [];
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (var i = 0; i < keys.length; i++) {
        var val = requestTimes[keys[i]];
        if (typeof val === 'number') {
            result.push(val);
        }
    }
    return result;
};
/**
 * 监听包含 ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'] 标签的 dom 变更
 */
var observeResFetchMutations = function (MutationObserver, callback) {
    var requestCreatingNodeNames = ['img', 'script', 'iframe', 'link', 'audio', 'video', 'source'];
    function subtreeContainsNodeName(nodes, nodeNames) {
        for (var i = 0; i < nodes.length; i++) {
            if (arrayIncludes(nodeNames, nodes[i].nodeName.toLowerCase()) ||
                (nodes[i].children &&
                    subtreeContainsNodeName(nodes[i].children, nodeNames))) {
                return true;
            }
        }
        return false;
    }
    var _a = __read(applyMutationObserver(MutationObserver, function (mutations) {
        for (var i = 0; i < mutations.length; i++) {
            if ((mutations[i].type === 'childList' &&
                subtreeContainsNodeName(mutations[i].addedNodes, requestCreatingNodeNames)) ||
                (mutations[i].type === 'attributes' &&
                    arrayIncludes(requestCreatingNodeNames, mutations[i].target.nodeName.toLowerCase()))) {
                callback(mutations[i]);
            }
        }
    }), 2), observe = _a[0], disconnect = _a[1];
    return [
        function () {
            return observe(document, {
                attributes: true,
                childList: true,
                subtree: true,
                attributeFilter: ['href', 'src'],
            });
        },
        disconnect,
    ];
};
/**
 * Returns either a manually set min value or the time since
 * domContentLoadedEventEnd and navigationStart. If the
 * domContentLoadedEventEnd data isn't available, `null` is returned.
 * @return {number|null}
 */
var getMinValue = function (timing) {
    var _a = timing || {}, domContentLoadedEventEnd = _a.domContentLoadedEventEnd, _b = _a.navigationStart, navigationStart = _b === void 0 ? 0 : _b;
    return domContentLoadedEventEnd ? domContentLoadedEventEnd - navigationStart : null;
};
/**
 * Computes the TTI value...
 * @param {number} searchStart
 * @param {number} minValue
 * @param {number} lastKnownNetwork2Busy
 * @param {number} currentTime
 * @param {!Array<{start: (number), end: (number)}>} longTasks
 * @return {number|null}
 */
var computeTTI = function (searchStart, minValue, lastKnownNetwork2Busy, currentTime, longTasks) {
    // Have not reached network 2-quiet yet.
    if (currentTime - lastKnownNetwork2Busy < QUIET_TIME_LIMIT) {
        return null;
    }
    var maybeFCI = longTasks.length === 0 ? searchStart : longTasks[longTasks.length - 1].end;
    // Main thread has not been quiet for long enough.
    if (currentTime - maybeFCI < QUIET_TIME_LIMIT) {
        return null;
    }
    return Math.max(maybeFCI, minValue);
};
var pushLongTaskIntoList = function (entry, list) {
    var startTime = entry.startTime, duration = entry.duration;
    entry.start = startTime;
    entry.end = startTime + duration;
    list.push(entry);
};
var getLastBusyAndLongTasks = function (tearDownGroup, _a, entries) {
    var _b = __read(_a, 5), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3], MutationObserver = _b[4];
    return function (reschedule, now$1) {
        var longTasks = [];
        var networkRequests = [];
        var _a = __read(applyRecord(), 3), incompleteInitReqStartTimes = _a[0], before = _a[1], after = _a[2];
        entries.forEach(function (entry) {
            if (entry.entryType === LONGTASK_TYPE[0]) {
                pushLongTaskIntoList(entry, longTasks);
            }
        });
        var uniqId = 0;
        tearDownGroup.push(xhrObserver[0](function (_a) {
            var _b = __read(_a, 1), _method = _b[0];
            if ((_method || '').toLowerCase() !== GET_METHOD)
                return noop;
            var requestId = (uniqId += 1);
            before(requestId, now());
            return function () {
                after(requestId);
            };
        }));
        tearDownGroup.push(fetchObserver[0](function (_a) {
            var _b = __read(_a, 2), req = _b[0], options = _b[1];
            if (!window.Request || getFetchMethod(req, options, window.Request) !== GET_METHOD)
                return noop;
            var requestId = (uniqId += 1);
            before(requestId, now());
            return function () {
                after(requestId);
            };
        }));
        var _b = __read((MutationObserver && observeResFetchMutations(MutationObserver, function () { return reschedule(now$1() + QUIET_TIME_LIMIT); })) || [], 2), observeRes = _b[0], stopObserveRes = _b[1];
        observeRes && observeRes();
        var getLastBusy = function () { return calcLastNet2Busy(getRequestTimes(incompleteInitReqStartTimes), networkRequests, now$1); };
        stopObserveRes && tearDownGroup.push(stopObserveRes);
        tearDownGroup.push(longtaskObserver[0](function (entry) {
            pushLongTaskIntoList(entry, longTasks);
            var startTime = entry.startTime, duration = entry.duration;
            // 遇到 longTask 则在 longTask 5秒后 checkTTI
            reschedule(startTime + duration + QUIET_TIME_LIMIT);
        }));
        tearDownGroup.push(resourceObserver[0](function (_a) {
            var fetchStart = _a.fetchStart, responseEnd = _a.responseEnd;
            networkRequests.push({
                start: fetchStart,
                end: responseEnd,
            });
            // 遇到 resource 加载，则在最后一次 busy 5 秒后 checkTTI
            reschedule(getLastBusy() + QUIET_TIME_LIMIT);
        }));
        tearDownGroup.push(function () {
            longTasks.length = 0;
            networkRequests.length = 0;
        });
        return [longTasks, getLastBusy];
    };
};
var getTTI = function (report, tearDownGroup, _a, config) {
    var _b = __read(_a, 5), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3], pvObserver = _b[4];
    var metric = initMetric(TTI_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    var performance = getDefaultPerformance();
    var PerformanceObserver = getDefaultPerformanceObserver();
    var _c = config || {}, _d = _c.entries, entries = _d === void 0 ? [] : _d, snippetObserver = _c.observer;
    tearDownGroup.push(function () {
        snippetObserver && snippetObserver.disconnect();
        entries.length = 0;
    });
    if (!window ||
        !XMLHttpRequest ||
        !performance ||
        !PerformanceObserver ||
        (PerformanceObserver.supportedEntryTypes &&
            !arrayIncludes(PerformanceObserver.supportedEntryTypes || [], LONGTASK_TYPE[0]))) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var _e = __read(applyPerformance(performance), 5), timing = _e[0], now = _e[1], getEntriesByName = _e[4];
    var _f = __read(applyScheduler(now), 3), startSchedule = _f[0], stopSchedule = _f[1], reschedule = _f[2];
    var _g = __read(getLastBusyAndLongTasks(tearDownGroup, [xhrObserver, fetchObserver, longtaskObserver, resourceObserver, getDefaultMutationObserver()], entries)(reschedule, now), 2), longTasks = _g[0], getLastBusy = _g[1];
    tearDownGroup.push(stopSchedule);
    var checkTTI = function (ttiCallback) {
        var firstContentfulPaint = getEntriesByName(FCP_ENTRY_NAME)[0];
        var maybeFCI = computeTTI((firstContentfulPaint ? firstContentfulPaint.startTime : getMinValue(timing)) || 0, getMinValue(timing) || 0, getLastBusy(), now(), longTasks);
        if (!maybeFCI)
            return reschedule(now() + 1000);
        ttiCallback(maybeFCI);
    };
    var reportTTI = function (value) {
        metric.value = value;
        sendOnceAndTearDown(metric);
    };
    var lastLongTask = longTasks[longTasks.length - 1];
    startSchedule(function () { return checkTTI(reportTTI); }, Math.max(getLastBusy() + QUIET_TIME_LIMIT, lastLongTask ? lastLongTask.end : 0));
    tearDownGroup.push(pvObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
};

/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */
var TTI_MONITOR_PLUGIN_NAME = 'tti';
function TTIMonitorBasePlugin(client) {
    var tearDownGroup = [];
    getTTI(reportWithCurrentContext(client), tearDownGroup, [
        initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
        initSubjectInGlobal(client, fetchSubject),
        initSubjectInGlobal(client, longtaskSubject),
        initSubjectInGlobal(client, resourceSubject),
        initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
    ], client.pp);
    registerTearDownGroup(client, TTI_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDownGroup);
}
function TTIMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, TTI_MONITOR_PLUGIN_NAME, {});
        if (!config) {
            return;
        }
        TTIMonitorBasePlugin(client);
    });
}

var FMP_METRIC_NAME = 'fmp';
var DEFAULT_IGNORE_TAGS$1 = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var getScore = function (element, depth, exist, ignoreTags) {
    if (!element || ignoreTags.indexOf(element.tagName) > -1) {
        return 0;
    }
    var _a = element.children, children = _a === void 0 ? [] : _a;
    var score = [].slice
        .call(children)
        .reduceRight(function (sum, child) { return sum + getScore(child, depth + 1, sum > 0, ignoreTags); }, 0);
    if (score <= 0 && !exist) {
        if (!isFunction(element.getBoundingClientRect)) {
            return 0;
        }
        var _b = element.getBoundingClientRect() || {}, top_1 = _b.top, height = _b.height;
        if (top_1 > window.innerHeight || height <= 0) {
            return 0;
        }
    }
    return score + 1 + 0.5 * depth;
};
var getFMPInternal = function (_a) {
    var _b = _a === void 0 ? [] : _a, _c = __read(_b), first = _c[0], rest = _c.slice(1);
    return ((rest &&
        rest.reduce(function (_a, cur) {
            var _b = __read(_a, 2), prev = _b[0], target = _b[1];
            var diff = cur.score - prev.score;
            return [cur, cur.time >= prev.time && target.rate < diff ? { time: cur.time, rate: diff } : target];
        }, [first, { time: first === null || first === void 0 ? void 0 : first.time, rate: 0 }])[1].time) ||
        0);
};
var getFMP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), loadObserver = _b[0], pvObserver = _b[1];
    var document = getDefaultDocument();
    var MutationObserver = getDefaultMutationObserver();
    var performance = getDefaultPerformance();
    var navigationStart = (performance && performance.timing && performance.timing.navigationStart) || undefined;
    var metric = initMetric(FMP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!document || !MutationObserver || !navigationStart) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var startTime = now();
    var list = [];
    var record = function () {
        return list.push({
            time: now() - startTime,
            // eslint-disable-next-line compat/compat
            score: getScore(document && document.body, 1, false, DEFAULT_IGNORE_TAGS$1),
        });
    };
    var raf = getDefaultRaf();
    var caf = getDefaultCaf();
    var _c = __read(applyAnimationFrame(document, raf, caf, true), 1), scheduleAF = _c[0];
    // 持续监听 dom 变化，记录下时间和得分
    // scheduleAF 可以避免强制回流，同时真正的变更是在animationFrame 中
    var _d = __read(applyMutationObserver(MutationObserver, function () { return scheduleAF(record); }), 2), observe = _d[0], disconnect = _d[1];
    var triggerFMP = function (timeGap) {
        if (timeGap === void 0) { timeGap = 0; }
        var fmp = getFMPInternal(list);
        metric.value = fmp ? fmp + timeGap : 0;
        sendOnceAndTearDown(metric);
        list.length = 0;
    };
    var timeGap = startTime - (navigationStart || 0);
    observe(document, { subtree: true, childList: true });
    tearDownGroup.push(disconnect);
    tearDownGroup.push(pvObserver[0](function () {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
    }));
    tearDownGroup.push(loadObserver[0](function () {
        clearTimerWithTearDowns(window.setTimeout(function () {
            triggerFMP(timeGap);
        }, 200), tearDownGroup);
    }));
};

var FMP_MONITOR_PLUGIN_NAME = 'fmp';
var defaultConfig$1 = {
    renderType: 'CSR',
};
function FMPMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig$1; }
    var tearDownGroup = [];
    if (config.renderType === 'SSR') {
        // @ts-expect-error
        getPaint(FP_ENTRY_NAME, FMP_MONITOR_PLUGIN_NAME, reportWithCurrentContext(client), tearDownGroup, [
            initSubjectInGlobal(client, activatedSubject),
            function () { return initSubjectInGlobal(client, hiddenSubject); },
            function () { return initSubjectInGlobal(client, unloadSubject); },
        ]);
    }
    else {
        getFMP(reportWithCurrentContext(client), tearDownGroup, [
            initSubjectInGlobal(client, loadSubject),
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
        ]);
    }
    registerTearDownGroup(client, FMP_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDownGroup);
}
function FMPMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, FMP_MONITOR_PLUGIN_NAME, defaultConfig$1);
        if (!config) {
            return;
        }
        FMPMonitorBasePlugin(client, config);
    });
}

var LCP_ENTRY_NAME = 'largest-contentful-paint';
var LCP_METRIC_NAME = "lcp" /* lcp */;
var LCPListenerEventTypes = ['keydown', 'click'];
var getLCP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), activatedObserver = _b[0], getHiddenObserver = _b[1], getUnloadObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var document = getDefaultDocument();
    var metric = initMetric(LCP_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!PerformanceObserver || !document) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var handleActivated = function () {
        // if the page is initially hidden or still hidden after prerendering
        // that means the tab was activated in a background state, so it is marked as unsupported
        if (visibilityStateIsHidden(document)) {
            metric.isSupport = false;
            sendOnceAndTearDown(metric);
            return;
        }
        tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, 
        // @ts-expect-error
        function (_a) {
            var startTime = _a.startTime, element = _a.element;
            // should be relative to page activation rather than navigation start if the page was pre-rendered.
            // but in cases where `activationStart` occurs after the LCP, this time should be clamped at 0.
            var activatedTimeStamp = getActivationStart();
            metric.value = startTime < activatedTimeStamp ? 0 : startTime - activatedTimeStamp;
            if (element) {
                try {
                    metric.extra = {
                        element: htmlTreeAsString(element),
                    };
                }
                catch (_b) {
                    // do nothing
                }
            }
        }, LCP_ENTRY_NAME));
        var inputEventHandler = function () {
            // wrap in a setTimeout so the callback is run in a separate task
            // to avoid extending the keyboard/click handler to reduce INP impact
            setTimeout(function () {
                sendOnceAndTearDown(metric);
            }, 0);
        };
        LCPListenerEventTypes.forEach(function (type) {
            tearDownGroup.push(addListenerToDocument(document, type, inputEventHandler, true));
        });
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            metric.isBounced = true;
            sendOnceAndTearDown(metric);
        }));
        var hiddenCallback = function (isHidden) {
            if (isHidden) {
                // if initially not hidden but suddenly becomes hidden, then the metric can be settle.
                sendOnceAndTearDown(metric);
            }
        };
        // hiddenObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        var hiddenObserver = getHiddenObserver();
        tearDownGroup.push(function () { return hiddenObserver[1](hiddenCallback); });
        hiddenObserver[0](hiddenCallback);
    };
    // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return activatedObserver[1](handleActivated); });
    activatedObserver[0](handleActivated);
};
var LCP = [LCP_METRIC_NAME, getLCP];

var FI_ENTRY_NAME = 'first-input';
var FID_METRIC_NAME = "fid" /* fid */;
var getFID = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 2), activatedObserver = _b[0], getHiddenObserver = _b[1];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var metric = initMetric(FID_METRIC_NAME, 0);
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!performance || !PerformanceObserver) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    var invokePaint = function (_a) {
        var processingStart = _a.processingStart, startTime = _a.startTime;
        metric.value = processingStart - startTime;
        sendOnceAndTearDown(metric);
    };
    var handleActivated = function () {
        // if the page is initially hidden or still hidden after prerendering
        // that means the tab was activated in a background state, so it is marked as unsupported
        if (visibilityStateIsHidden(document)) {
            metric.isSupport = false;
            sendOnceAndTearDown(metric);
            return;
        }
        // report immediately if have FI entry
        var _a = __read(applyPerformance(performance), 3), getEntriesByType = _a[2];
        var paint = getEntriesByType(FI_ENTRY_NAME)[0];
        if (paint) {
            invokePaint(paint);
            return;
        }
        // observer performance if don't have FI entry
        tearDownGroup.push(observePerf(PerformanceObserver, invokePaint, [FI_ENTRY_NAME]));
        var hiddenCallback = function (isHidden) {
            if (isHidden) {
                // if initially not hidden but suddenly becomes hidden, then the metric can be settle.
                sendOnceAndTearDown(metric);
            }
        };
        // hiddenObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        var hiddenObserver = getHiddenObserver();
        tearDownGroup.push(function () { return hiddenObserver[1](hiddenCallback); });
        hiddenObserver[0](hiddenCallback);
    };
    // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return activatedObserver[1](handleActivated); });
    activatedObserver[0](handleActivated);
};
var FID = [FID_METRIC_NAME, getFID];

var LS_ENTRY_NAME = 'layout-shift';
var CLS_METRIC_NAME = "cls" /* cls */;
var applyHandleEntries = function () {
    var sessionValue = 0;
    var sessionTimes = [];
    var resetSessionValue = function () {
        sessionValue = 0;
    };
    var handleEntriesWithMetric = function (callback, entry) {
        // Only count layout shifts without recent user input.
        if (!entry.hadRecentInput) {
            var firstSessionTime = sessionTimes[0];
            var lastSessionTime = sessionTimes[sessionTimes.length - 1];
            if (sessionValue && entry.startTime - lastSessionTime < 1000 && entry.startTime - firstSessionTime < 5000) {
                sessionValue += entry.value;
                sessionTimes.push(entry.startTime);
            }
            else {
                sessionValue = entry.value;
                sessionTimes = [entry.startTime];
            }
            callback(sessionValue);
        }
    };
    return [resetSessionValue, handleEntriesWithMetric];
};
var getCLS = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 4), getHiddenObserver = _b[1], getUnloadObserver = _b[2], getPVObserver = _b[3];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var metric = initMetric(CLS_METRIC_NAME, 0);
    var reportMetric = applyReportMetric(report);
    if (!PerformanceObserver) {
        metric.isSupport = false;
        reportMetric(metric);
        return;
    }
    var _c = __read(applyHandleEntries(), 2), resetSessionValue = _c[0], handleEntriesWithMetric = _c[1];
    var handleEntries = handleEntriesWithMetric.bind(null, function (sessionValue) {
        sessionValue > metric.value && (metric.value = sessionValue);
    });
    tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, handleEntries, LS_ENTRY_NAME));
    var hiddenObserver = getHiddenObserver();
    tearDownGroup.push(hiddenObserver[0](function (isHidden) {
        isHidden && resetSessionValue();
    }));
    var pvObserver = getPVObserver();
    tearDownGroup.push(pvObserver[0](function (overrides) {
        reportMetric(metric, overrides);
        resetSessionValue();
        metric = initMetric(CLS_METRIC_NAME, 0);
    }));
    var unloadObserver = getUnloadObserver();
    tearDownGroup.push(unloadObserver[0](function () {
        reportMetric(metric);
    }));
};
var CLS = [CLS_METRIC_NAME, getCLS];

var EVENT_TIMING_TYPE = 'event';
var INP_METRIC_NAME = "inp" /* inp */;
var MAX_INTERACTIONS_TO_CONSIDER = 10;
var initInteractionCountPolyfill = function (po, tearDownGroup) {
    var interactionCountEstimate = 0;
    var minKnownInteractionId = Infinity;
    var maxKnownInteractionId = 0;
    var updateEstimate = function (e) {
        if (e.interactionId) {
            minKnownInteractionId = Math.min(minKnownInteractionId, e.interactionId);
            maxKnownInteractionId = Math.max(maxKnownInteractionId, e.interactionId);
            interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0;
        }
    };
    tearDownGroup.push(observePerfWithBuffer(po, updateEstimate, EVENT_TIMING_TYPE, 0));
    return [
        function () {
            return interactionCountEstimate;
        },
    ];
};
var getINP = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), activatedObserver = _b[0], getPVObserver = _b[1], getUnloadObserver = _b[2];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var PerformanceEventTiming = getDefaultPerformanceEventTiming();
    var performance = getDefaultPerformance();
    var metric = initMetric(INP_METRIC_NAME, 0);
    var reportMetric = applyReportMetric(report);
    if (!PerformanceObserver || !PerformanceEventTiming || !performance) {
        metric.isSupport = false;
        reportMetric(metric);
        return;
    }
    var prevInteractionCount = 0;
    // top 10 longest interactionList and the first one is the longest
    var longestInteractionList = [];
    // a mapping of longest interactions by their interaction ID.
    var longestInteractionMap = {};
    var resetStatus = function () {
        prevInteractionCount = getInteractionCount();
        longestInteractionList = [];
        longestInteractionMap = {};
    };
    var processEntry = function (entry) {
        var minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];
        var existingInteraction = longestInteractionMap[entry.interactionId];
        // update longestInteractionList info if necessary: if the interaction already exists, update it, otherwise create one.
        if (existingInteraction ||
            longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||
            entry.duration > minLongestInteraction.latency) {
            if (existingInteraction) {
                existingInteraction.entries.push(entry);
                existingInteraction.latency = Math.max(existingInteraction.latency, entry.duration);
            }
            else {
                var interaction = {
                    id: entry.interactionId,
                    latency: entry.duration,
                    entries: [entry],
                };
                longestInteractionMap[interaction.id] = interaction;
                longestInteractionList.push(interaction);
            }
            // sort the longestInteractionList again.
            longestInteractionList.sort(function (a, b) { return b.latency - a.latency; });
            longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach(function (i) {
                delete longestInteractionMap[i.id];
            });
        }
    };
    var _c = __read(initInteractionCountPolyfill(PerformanceObserver, tearDownGroup), 1), getInteractionCount = _c[0];
    var getInteractionCountForNavigation = function () {
        return getInteractionCount() - prevInteractionCount;
    };
    var estimateP98LongestInteraction = function () {
        var candidateInteractionIndex = Math.min(longestInteractionList.length - 1, Math.floor(getInteractionCountForNavigation() / 50));
        return longestInteractionList[candidateInteractionIndex];
    };
    var updateMetric = function () {
        var inp = estimateP98LongestInteraction();
        if (inp) {
            metric.value = inp.latency;
            // add element if have
            var target = inp.entries[0].target;
            target && (metric.extra = { element: htmlTreeAsString(target) });
        }
    };
    var handleEntry = function (entry) {
        if (entry.interactionId) {
            processEntry(entry);
        }
        if (entry.entryType === 'first-input') {
            var noMatchingEntry = !longestInteractionList.some(function (interaction) {
                return interaction.entries.some(function (prevEntry) {
                    return entry.duration === prevEntry.duration && entry.startTime === prevEntry.startTime;
                });
            });
            // only consider if no matching entry
            if (noMatchingEntry) {
                processEntry(entry);
            }
        }
    };
    tearDownGroup.push(activatedObserver[0](function () {
        // observe event
        tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, handleEntry, EVENT_TIMING_TYPE, 40));
        // observe FI if support interactionId
        if ('interactionId' in PerformanceEventTiming.prototype) {
            tearDownGroup.push(observePerfWithBuffer(PerformanceObserver, handleEntry, FI_ENTRY_NAME));
        }
        var pvObserver = getPVObserver();
        tearDownGroup.push(pvObserver[0](function (overrides) {
            updateMetric();
            reportMetric(metric, overrides);
            resetStatus();
            // set new metric
            metric = initMetric(INP_METRIC_NAME, 0);
        }));
        var unloadObserver = getUnloadObserver();
        tearDownGroup.push(unloadObserver[0](function () {
            updateMetric();
            reportMetric(metric);
        }));
        tearDownGroup.push(resetStatus);
    }));
};
var INP = [INP_METRIC_NAME, getINP];

var LONGTASK_METRIC_NAME = "longtask" /* longtask */;
var getLongtask = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 4), longtaskObserver = _b[3];
    tearDownGroup.push(longtaskObserver[0](function (entry) {
        report(wrapLongtask(entry));
    }));
};
var LONGTASK = [LONGTASK_METRIC_NAME, getLongtask];

var TIMING_METRIC_NAME = "timing" /* timing */;
var getTiming = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 3), loadObserver = _b[0], getActivatedObserver = _b[1], unloadObserver = _b[2];
    var performance = getDefaultPerformance();
    var _c = __read(applyPerformance(performance), 3), timing = _c[0], now = _c[1], getEntriesByType = _c[2];
    var wrapTiming = function (isBounced) {
        var navigation = getEntriesByType('navigation')[0];
        var responseStart = navigation && navigation.responseStart;
        // In some cases no value is reported by the browser (for privacy/security reasons)
        // and in other cases (bugs) the value is negative or is larger than the current page time
        if (!responseStart || responseStart <= 0 || responseStart > now()) {
            navigation = undefined;
        }
        return {
            ev_type: PERFORMANCE_TIMING_EV_TYPE,
            payload: {
                isBounced: isBounced,
                timing: timing,
                navigation_timing: navigation,
            },
        };
    };
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapTiming, report, tearDownGroup);
    tearDownGroup.push(unloadObserver[0](function () {
        sendOnceAndTearDown(true);
    }));
    var loadCallback = function () {
        // need to dynamic get activatedObserver because it is executed asynchronously
        var activatedObserver = getActivatedObserver();
        var activatedCallback = function () {
            sendOnceAndTearDown(false);
        };
        // activatedObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
        tearDownGroup.push(function () { return activatedObserver[1](activatedCallback); });
        activatedObserver[0](activatedCallback);
    };
    // loadObserver may execute immediately, so unsubscribe function needs to be pushed to tearDownGroup first.
    tearDownGroup.push(function () { return loadObserver[1](loadCallback); });
    loadObserver[0](loadCallback);
};
var TIMING = [TIMING_METRIC_NAME, getTiming];

var MPFID_METRIC_NAME = "mpfid" /* mpfid */;
var getMPFID = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 4), loadObserver = _b[0], longtaskObserver = _b[3];
    var PerformanceObserver = getDefaultPerformanceObserver();
    var performance = getDefaultPerformance();
    var metric = initMetric(MPFID_METRIC_NAME, 0);
    var list = [];
    var sendOnceAndTearDown = applySendOnceAndTearDown(wrapPerformanceMetric, report, tearDownGroup);
    if (!PerformanceObserver) {
        metric.isSupport = false;
        sendOnceAndTearDown(metric);
        return;
    }
    tearDownGroup.push(longtaskObserver[0](function (entry) {
        list.push(entry);
    }));
    var calculateAndSendMetric = function () {
        var _a = __read(applyPerformance(performance), 5), getEntriesByName = _a[4];
        var paint = getEntriesByName(FCP_ENTRY_NAME)[0];
        var FCPStartTime = (paint && paint.startTime) || 0;
        metric.value = list.reduce(function (res, _a) {
            var duration = _a.duration, startTime = _a.startTime;
            return (res < duration && startTime > FCPStartTime ? duration : res);
        }, 0);
        list.length = 0;
        sendOnceAndTearDown(metric);
    };
    tearDownGroup.push(loadObserver[0](function () {
        clearTimerWithTearDowns(window.setTimeout(calculateAndSendMetric, 200), tearDownGroup);
    }));
};
var MPFID = [MPFID_METRIC_NAME, getMPFID];

var FID_MONITOR_PLUGIN_NAME = FID[0];
function FIDMonitorPlugin(client) {
    client.on('init', function () {
        var activatedObserver = initSubjectInGlobal(client, activatedSubject);
        var getHiddenObserver = function () { return initSubjectInGlobal(client, hiddenSubject); };
        var overrides = undefined;
        var firstPVObserver = initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
        firstPVObserver[0](function (o) {
            overrides = o;
        })();
        var reportMetric = function (data) {
            // every first screen metrics needs to be associated with the context when client init
            client.report(__assign(__assign({}, data), { overrides: overrides }));
        };
        var tearDown = [];
        FID[1](reportMetric, tearDown, [activatedObserver, getHiddenObserver]);
        registerTearDownGroup(client, FID_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDown);
    });
}

var INP_MONITOR_PLUGIN_NAME = INP[0];
function INPMonitorPlugin(client) {
    client.on('init', function () {
        var activatedObserver = initSubjectInGlobal(client, activatedSubject);
        var getUnloadObserver = function () { return initSubjectInGlobal(client, unloadSubject); };
        var getPVObserver = function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); };
        var tearDown = [];
        INP[1](client.report.bind(client), tearDown, [activatedObserver, getPVObserver, getUnloadObserver]);
        registerTearDownGroup(client, INP_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDown);
    });
}

var MPFID_MONITOR_PLUGIN_NAME = MPFID[0];
function MPFIDMonitorPlugin(client) {
    client.on('init', function () {
        var getActivatedObserver = function () { return initSubjectInGlobal(client, activatedSubject); };
        var unloadObserver = initSubjectInGlobal(client, unloadSubject);
        var loadObserver = initSubjectInGlobal(client, loadSubject);
        var longtaskObserver = initSubjectInGlobal(client, longtaskSubject);
        var overrides = undefined;
        var firstPVObserver = initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
        firstPVObserver[0](function (o) {
            overrides = o;
        })();
        var reportMetric = function (data) {
            // every first screen metrics needs to be associated with the context when client init
            client.report(__assign(__assign({}, data), { overrides: overrides }));
        };
        var tearDown = [];
        MPFID[1](reportMetric, tearDown, [loadObserver, getActivatedObserver, unloadObserver, longtaskObserver]);
        registerTearDownGroup(client, MPFID_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDown);
    });
}

var DEFAULT_IGNORE_TAGS = ['SCRIPT', 'STYLE', 'META', 'HEAD'];
var ERROR_RELATED_TYPE = [JS_ERROR_EV_TYPE, HTTP_EV_TYPE, RESOURCE_ERROR_EV_TYPE];
var DEFAULT_THRESHOLD = 1.5;
var MAX_RENDER_TIME = 10000;
var MAX_CHECK_TIME = 8000;
var DEFAULT_CHECK_TIME = 4000;
var MAX_RELATED_TIME = 10000;
var DEFAULT_T0_DATA_URL_QUALITY = 0.1;
var DEFAULT_MAX_DEPTH = 4;
var CHECK_EXCLUSIVE_EV_TYPES = [
    PERFORMANCE_METRIC_EV_TYPE,
    LONG_TASK_EV_TYPE,
    PERFORMANCE_TIMING_EV_TYPE,
    CUSTOM_EV_TYPE,
];
var isSkipBeforeCheck = function (ev) { return ~CHECK_EXCLUSIVE_EV_TYPES.indexOf(ev.ev_type); };
var blankErrorCompare = function (relatedError, ev) {
    if (ERROR_RELATED_TYPE.indexOf(ev.ev_type) === -1)
        return relatedError;
    if (ev.ev_type === HTTP_EV_TYPE && ev.payload.response.status < 400) {
        return relatedError;
    }
    if (relatedError && ERROR_RELATED_TYPE.indexOf(relatedError.type) < ERROR_RELATED_TYPE.indexOf(ev.ev_type)) {
        return relatedError;
    }
    var message = '';
    switch (ev.ev_type) {
        case JS_ERROR_EV_TYPE:
            message = ev.payload.error.message;
            break;
        case HTTP_EV_TYPE:
            message = ev.payload.request.url;
            break;
        case RESOURCE_ERROR_EV_TYPE:
            message = ev.payload.url;
            break;
    }
    return { type: ev.ev_type, message: message, timestamp: now() };
};
var isSkipMeasure = function (element, depth) {
    return ~DEFAULT_IGNORE_TAGS.indexOf(element.tagName) || depth > DEFAULT_MAX_DEPTH;
};
var getBounding = function (element) {
    var _a = element.getBoundingClientRect(), width = _a.width, height = _a.height, top = _a.top;
    return { width: width, height: height, top: top };
};
var getElementByRootSelector = function (rootSelector) {
    return rootSelector ? document.querySelector(rootSelector) : document.body;
};
var measure = function (element, depth, sum, threshold) {
    if (depth === void 0) { depth = 0; }
    if (sum === void 0) { sum = 0; }
    if (threshold === void 0) { threshold = DEFAULT_THRESHOLD; }
    if (!element || isSkipMeasure(element, depth) || sum >= threshold) {
        return sum;
    }
    var score = (function () {
        // skip the first level element
        if (!depth)
            return 0;
        var _a = getBounding(element), top = _a.top, height = _a.height;
        // (1 << (depth - 1)) === Math.pow(2, depth - 1)
        return top > innerHeight || height <= 0 ? 0 : 1 / (1 << (depth - 1));
    })();
    return [].reduceRight.call(element.children, function (all, child) { return measure(child, depth + 1, all, threshold); }, sum + score);
};
/**
 * Serializes an HTML element and its children to a string representation.
 *
 * @param {Element | undefined | null} element - The element to serialize.
 * @param {number} [depth=0] - The depth of the element in the DOM tree.
 * @param {boolean} [onceAttributeFlag=true] - Whether to include the innerHeight attribute.
 * @return {string} The serialized string representation of the HTML element and its children.
 */
function serializeDom2String(element, depth, onceAttributeFlag) {
    if (depth === void 0) { depth = 0; }
    if (onceAttributeFlag === void 0) { onceAttributeFlag = true; }
    if (!element || isSkipMeasure(element, depth))
        return '';
    var attributeGathering = __assign(__assign({}, getBounding(element)), { id: element.getAttribute('id'), class: element.getAttribute('class') });
    var attrString = Object.keys(attributeGathering).reduce(function (accumulator, key) {
        return "" + accumulator + (isNumber(attributeGathering[key]) || attributeGathering[key] ? " " + key + "=\"" + attributeGathering[key] + "\"" : '');
    }, '');
    var tagName = element.tagName.toLowerCase();
    var children = [].reduce.call(element.children, function (acc, child) { return acc + serializeDom2String(child, depth + 1, false); }, '');
    return "<" + tagName + attrString + (onceAttributeFlag ? " innerHeight=\"" + innerHeight + "\"" : '') + ">" + children + "</" + tagName + ">";
}
/* c8 ignore start */
var screenshot = function (_a) {
    var _b;
    var cb = _a.cb, screenshotUrl = _a.screenshotUrl, window = _a.window, document = _a.document, mask = _a.mask, partialShot = _a.partialShot, quality = _a.quality, rootSelector = _a.rootSelector;
    if (!getDefaultPromise() || !window || !document) {
        return;
    }
    function onload() {
        var requestIdleCallback = applyRequestIdleCallback(window);
        requestIdleCallback(function () {
            window.html2canvas &&
                window.html2canvas((partialShot && rootSelector && document.querySelector(rootSelector)) || document.body, {
                    scale: 360 / window.innerWidth,
                    mask: mask,
                })
                    .then(function (canvas) {
                    cb(handleBase64(canvas.toDataURL('image/jpeg', quality)));
                })
                    .catch(function () {
                    cb(getBlankImageBase64());
                });
        });
    }
    if (window.html2canvas) {
        return onload();
    }
    var script = document.createElement('script');
    script.src = screenshotUrl;
    // eslint-disable-next-line compat/compat
    (_b = document.head) === null || _b === void 0 ? void 0 : _b.appendChild(script);
    script.onload = onload;
    script.onerror = function () {
        cb();
    };
};
/* c8 ignore end */
/**
 *
 * @param base64
 * @see https://html2canvas.hertzen.com/faq#why-is-the-produced-canvas-empty-or-cuts-off-half-way-through
 * @returns
 */
function handleBase64(base64) {
    // if element's width or height is 0 or greater than maximum canvas size, html2canvas will return "data:," in base64
    return base64.slice(0, 10) === 'data:image' ? base64 : getBlankImageBase64();
}
/**
 * Creates a blank image of the specified width and height and returns it as a
 * base64-encoded JPEG data URL.
 *
 * @param {number} width - The desired width of the image in pixels.
 * @param {number} height - The desired height of the image in pixels.
 * @returns {string} The base64-encoded JPEG data URL of the blank image.
 */
/* c8 ignore start */
function getBlankImageBase64(width, height) {
    if (width === void 0) { width = 192; }
    if (height === void 0) { height = 108; }
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    if (ctx) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
    }
    return canvas.toDataURL('image/jpeg');
}
/* c8 ignore stop */

var blankScreenGetterWithObserver = function (report, tearDownGroup, _a, _b) {
    var _c = __read(_a, 5), activatedObserver = _c[0], getDomContentLoadObserver = _c[1], getLongtaskObserver = _c[2], getResourceObserver = _c[3], unloadObserver = _c[4];
    var threshold = _b.threshold, takeScreenshot = _b.screenshot, rootSelector = _b.rootSelector, autoDetect = _b.autoDetect, ssUrl = _b.ssUrl, quality = _b.quality, mask = _b.mask, partialShot = _b.partialShot, initDetTime = _b.initDetTime, runDetTime = _b.runDetTime;
    var win = getDefaultBrowser();
    var document = getDefaultDocument();
    var rAF = win.requestAnimationFrame || noop;
    var cAF = win.cancelAnimationFrame || noop;
    var _d = __read(applyPerformance(performance), 2), relativeNow = _d[1];
    var blankInfo;
    var errorInfo;
    var otherReportedTimestamp = 0;
    var reported = false;
    var timer;
    var rAFTimer;
    var checkTimer;
    var hasTakeScreenshot = !takeScreenshot;
    var calculateBlankInfo = function () {
        var element = getElementByRootSelector(rootSelector);
        if (!element) {
            return;
        }
        var score = measure(element, 0, 0, threshold);
        if (score < threshold) {
            return [now(), score];
        }
    };
    var sendOnceAndTearDown = function (reportTimestamp, base64) {
        if (reported)
            return;
        // calculate blank info once more to make sure blank info is matched with serialized_dom
        blankInfo = calculateBlankInfo();
        if (!blankInfo) {
            return;
        }
        // set flag here to make sure that only take screenshot once
        reported = true;
        // tear down all observer in pure report function to mark sure blankInfo correctly
        tearDownGroup.forEach(function (e) { return e(); });
        tearDownGroup.length = 0;
        report({
            ev_type: BLANK_SCREEN_EV_TYPE,
            payload: {
                timestamp: blankInfo[0],
                score: blankInfo[1],
                screenshot: base64,
                error: errorInfo,
                serialized_dom: serializeDom2String(getElementByRootSelector(rootSelector)),
            },
            overrides: {
                timestamp: reportTimestamp || blankInfo[0],
            },
        });
    };
    var reportIfAllowed = function () {
        if (!blankInfo || reported) {
            return;
        }
        if (hasTakeScreenshot) {
            sendOnceAndTearDown();
        }
        else {
            hasTakeScreenshot = true;
            screenshot({
                cb: sendOnceAndTearDown.bind(null, now()),
                screenshotUrl: ssUrl,
                window: win,
                document: document,
                mask: mask,
                partialShot: partialShot,
                quality: quality,
                rootSelector: rootSelector,
            });
        }
    };
    var applyOtherReport = function (ev) {
        if (reported || isSkipBeforeCheck(ev))
            return;
        otherReportedTimestamp = now();
        if (errorInfo && otherReportedTimestamp - errorInfo.timestamp > MAX_RELATED_TIME) {
            errorInfo = undefined;
        }
        errorInfo = blankErrorCompare(errorInfo, ev);
    };
    var schedule = function () {
        checkTimer && clearTimeout(checkTimer);
        timer && clearTimeout(timer);
        timer = win.setTimeout(function () {
            rAFTimer = rAF(function () {
                blankInfo = calculateBlankInfo();
                blankInfo && checkAndReport();
            });
        }, 1000);
    };
    var applyCheck = function (cb) {
        var checkTimestamp;
        return function () {
            checkTimer && clearTimeout(checkTimer);
            checkTimestamp = now();
            checkTimer = win.setTimeout(function () {
                if (otherReportedTimestamp > checkTimestamp) {
                    schedule();
                    return;
                }
                cb();
            }, relativeNow() > MAX_RENDER_TIME ? runDetTime : initDetTime);
        };
    };
    var checkAndReport = applyCheck(reportIfAllowed);
    tearDownGroup.push(unloadObserver[0](function () {
        errorInfo && sendOnceAndTearDown();
    }));
    if (autoDetect)
        // start observe blank screen after DOMContentLoaded and prerendering
        tearDownGroup.push(activatedObserver[0](function () {
            var domContentLoadObserver = getDomContentLoadObserver();
            tearDownGroup.push(domContentLoadObserver[0](function () {
                var _a;
                // observe dom and schedule
                var _b = __read(applyMutationObserver(getDefaultMutationObserver(), schedule), 2), mutObserve = _b[0], mutDisconnect = _b[1];
                tearDownGroup.push(function () {
                    clearTimeout(timer);
                    clearTimeout(checkTimer);
                    cAF(rAFTimer);
                    mutDisconnect && mutDisconnect();
                });
                mutObserve((_a = getDefaultDocument()) === null || _a === void 0 ? void 0 : _a.body, { subtree: true, childList: true });
                // observe resource & longtask and schedule
                tearDownGroup.push(getLongtaskObserver()[0](function () {
                    timer && schedule();
                }));
                tearDownGroup.push(getResourceObserver()[0](function () {
                    timer && schedule();
                }));
                // start first schedule by default
                schedule();
            }));
        }));
    return [applyOtherReport, schedule];
};

var BLANK_SCREEN_MONITOR_PLUGIN_NAME = 'blankScreen';
var SCREEN_SHOT_FILE_NAME = 'screenshot.min.js';
function BlankScreenMonitorBasePlugin(client, config) {
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var tearDownGroup = [];
    var _a = __read(blankScreenGetterWithObserver(client.report.bind(client), tearDownGroup, [
        initSubjectInGlobal(client, activatedSubject),
        function () { return initSubjectInGlobal(client, DOMContentLoadSubject); },
        function () { return initSubjectInGlobal(client, longtaskSubject); },
        function () { return initSubjectInGlobal(client, resourceSubject); },
        initSubjectInGlobal(client, unloadSubject),
    ], config), 2), applyOtherReport = _a[0], detectBlankScreen = _a[1];
    var listenOtherReport = function (ev) {
        applyOtherReport(ev);
        return ev;
    };
    client.on('report', listenOtherReport);
    tearDownGroup.push(function () {
        client.off('report', listenOtherReport);
    });
    registerTearDownGroup(client, BLANK_SCREEN_MONITOR_PLUGIN_NAME, BLANK_SCREEN_EV_TYPE, tearDownGroup);
    client.provide('detectBlankScreen', detectBlankScreen);
}
function BlankScreenMonitorPlugin(client, overrideConfig) {
    client.on('init', function () {
        var defaultConfig = {
            autoDetect: true,
            threshold: DEFAULT_THRESHOLD,
            screenshot: true,
            mask: false,
            ssUrl: client.config().pluginPathPrefix + "/" + SCREEN_SHOT_FILE_NAME,
            partialShot: true,
            quality: DEFAULT_T0_DATA_URL_QUALITY,
            initDetTime: MAX_CHECK_TIME,
            runDetTime: DEFAULT_CHECK_TIME,
        };
        var config = overrideConfig
            ? getConfig(overrideConfig, defaultConfig)
            : getPluginConfig(client, BLANK_SCREEN_MONITOR_PLUGIN_NAME, defaultConfig);
        if (!config) {
            return;
        }
        BlankScreenMonitorBasePlugin(client, config);
    });
}
function BlankScreenMonitorVolPlugin(client, overrideConfig) {
    client.on('init', function () {
        var defaultConfig = {
            autoDetect: true,
            threshold: DEFAULT_THRESHOLD,
            screenshot: true,
            ssUrl: 'https://apm.volccdn.com/mars-web/apmplus/web/html2canvas.min.js',
            mask: false,
            partialShot: true,
            quality: DEFAULT_T0_DATA_URL_QUALITY,
            initDetTime: MAX_CHECK_TIME,
            runDetTime: DEFAULT_CHECK_TIME,
        };
        var config = overrideConfig
            ? getConfig(overrideConfig, defaultConfig)
            : getPluginConfig(client, BLANK_SCREEN_MONITOR_PLUGIN_NAME, defaultConfig);
        if (!config) {
            return;
        }
        BlankScreenMonitorBasePlugin(client, config);
    });
}

var PAGE_ACTIVITY_DELAY = 100;
var ROOT_TAGS = ['BODY', 'HTML', 'HEAD'];
var SVG_TAG = 'SVG';
var DEFAULT_ATTR_NAME = 'data-apm-action';
/**
 * 控制等待策略和强制结算
 * 结算策略: 没有进行中的请求, 没有dom变更, 没有resource or longTask
 */
var waitActionComplete = function (win, cb, forceClear, maxTimeOut) {
    var idleTimer;
    var maxIdleTimer;
    var started = false;
    var notify = function () {
        win.clearTimeout(idleTimer);
        started &&
            (idleTimer = win.setTimeout(function () {
                cb();
            }, PAGE_ACTIVITY_DELAY));
    };
    var start = function () {
        started = true;
        win.clearTimeout(maxIdleTimer);
        maxIdleTimer = win.setTimeout(function () {
            cb(true);
            forceClear();
        }, maxTimeOut);
        notify();
    };
    var complete = function () {
        started = false;
        win.clearTimeout(idleTimer);
        win.clearTimeout(maxIdleTimer);
    };
    return [start, notify, complete];
};
var isSupportsElementClosest = (function () {
    var supportsElementClosest;
    return function () {
        return supportsElementClosest === undefined
            ? (supportsElementClosest = 'closest' in HTMLElement.prototype)
            : supportsElementClosest;
    };
})();
var findElementWithAttributeByParents = function (target, attribute, maxParentLoops) {
    if (maxParentLoops === void 0) { maxParentLoops = 10; }
    var element = target;
    for (var i = 0; i < maxParentLoops && element; i++) {
        if (~ROOT_TAGS.indexOf(element.nodeName))
            return;
        if (element.hasAttribute(attribute)) {
            return element;
        }
        element = element.parentElement;
    }
};
var getActionNameByAttribute = function (target, attribute) {
    var elementWithAttribute;
    if (isSupportsElementClosest()) {
        elementWithAttribute = target.closest("[" + attribute + "]");
    }
    else {
        elementWithAttribute = findElementWithAttributeByParents(target, attribute);
    }
    if (!elementWithAttribute)
        return;
    var name = elementWithAttribute.getAttribute(attribute);
    // Possibly length of name is too long to be stored on backend.Let it go for now.Add truncation if someone oncalled
    return name.trim();
};
var getActionName = function (target, attribute) {
    return getActionNameByAttribute(target, attribute) || target.innerText;
};
var isSVGTarget = function (element) {
    var current = element;
    var flag = false;
    while (current) {
        if (current.tagName.toUpperCase() === SVG_TAG) {
            current = null;
            flag = true;
        }
        else {
            current = current.parentElement;
        }
    }
    return flag;
};
var isElementWithinTwoLevels = function (element) {
    var childElement = element.children;
    return childElement.length ? ![].slice.call(childElement).some(function (c) { return c.children.length > 0; }) : true;
};
var isValidTarget = function (element) {
    // if not element node or is root element or is svg
    var tagName = element.tagName.toUpperCase();
    if (element.nodeType !== 1 || ROOT_TAGS.includes(tagName) || isSVGTarget(element)) {
        return false;
    }
    // if element display none
    if (element.style && element.style.display === 'none') {
        return false;
    }
    // if is allowed TagName or has special attribute
    if (['A', 'BUTTON', 'INPUT', 'TEXTAREA'].includes(tagName) || getActionNameByAttribute(element, DEFAULT_ATTR_NAME)) {
        return true;
    }
    // if element not within two levels
    if (!isElementWithinTwoLevels(element)) {
        return false;
    }
    return true;
};

var SUPPORT_TYPES = ["click" /* CLICK */];
var EVENT_LISTENER_OPTIONS = { capture: true };
var MIN_LONG_TASK = 50;
var MAX_ACTIVITY_DELAY = 10000;
/**
 * Hook XHR & fetch to monitor the number of incomplete requests on the current page.
 */
var applyIncompleteReq = function (tearDownGroup, _a, notify) {
    var _b = __read(_a, 2), xhrObserver = _b[0], fetchObserver = _b[1];
    var _c = __read(applyRecord(), 3), incompleteReq = _c[0], before = _c[1], after = _c[2];
    var uniqId = 0;
    tearDownGroup.push(xhrObserver[0](function (_a) {
        var _b = __read(_a, 1); _b[0];
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    tearDownGroup.push(fetchObserver[0](function () {
        var requestId = (uniqId += 1);
        before(requestId, now());
        notify();
        return function () {
            after(requestId);
            notify();
        };
    }));
    return incompleteReq;
};
var actionGetterWithFetchObserver = function (setCurrentContext, tearDownGroup, _a, config) {
    var _b = __read(_a, 4), xhrObserver = _b[0], fetchObserver = _b[1], longtaskObserver = _b[2], resourceObserver = _b[3];
    var types = config.types, pure = config.pure;
    var currentPayload = null;
    var lastPayload = null;
    var reportWithContext = undefined;
    var requestStartAndEnd = [];
    var longtaskDuration = 0;
    var _c = __read(applyPerformance(performance), 2), now = _c[1];
    var reportActionIfAllowed = function (force) {
        // no action metrics || no payload || not force but there are still pending requests
        if (!currentPayload ||
            (!pure && !Object.keys(currentPayload.metrics).length) ||
            (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        // set long task duration
        currentPayload.metrics[LONG_TASK_EV_TYPE] &&
            (currentPayload.metrics[LONG_TASK_EV_TYPE].duration = longtaskDuration);
        // set request duration
        var requestDuration = requestStartAndEnd.length > 0 ? Math.max.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) - Math.min.apply(Math, __spreadArray([], __read(requestStartAndEnd), false)) : 0;
        currentPayload.metrics[HTTP_EV_TYPE] && (currentPayload.metrics[HTTP_EV_TYPE].duration = requestDuration);
        // end time
        var actionDuration = now() - currentPayload.start_time;
        reportWithContext &&
            reportWithContext({
                ev_type: ACTION_EV_TYPE,
                payload: __assign(__assign({}, currentPayload), { duration: actionDuration, frontend_time: actionDuration - requestDuration }),
            });
        // reset action after report current action
        resetAction();
    };
    var resetAction = function () {
        complete();
        // refresh lastPayload so that delay-type events can be correctly attach action id
        currentPayload &&
            (lastPayload = {
                start_time: currentPayload.start_time,
                id: currentPayload.id,
            });
        currentPayload = null;
        requestStartAndEnd = [];
        longtaskDuration = 0;
    };
    var calculateMetric = function (ev_type) {
        var _a, _b;
        currentPayload &&
            (currentPayload.metrics[ev_type] = {
                count: ((_b = (_a = currentPayload.metrics[ev_type]) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0) + 1,
            });
    };
    var _d = __read(waitActionComplete(window, reportActionIfAllowed, resetAction, MAX_ACTIVITY_DELAY), 3), start = _d[0], notify = _d[1], complete = _d[2];
    // notify if meet xhr and fetch
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    // notify if meet mutation change
    var _e = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _e[0], disconnect = _e[1];
    observe();
    tearDownGroup.push(disconnect);
    tearDownGroup.push(complete);
    // notify if meet longtask
    tearDownGroup.push(longtaskObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration;
        notify();
        // calculate longtask
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (currentPayload && currentPayload.start_time <= startTime + MIN_LONG_TASK) {
            longtaskDuration = longtaskDuration + duration;
            calculateMetric(LONG_TASK_EV_TYPE);
        }
    }));
    // notify if meet resource
    tearDownGroup.push(resourceObserver[0](function (_a) {
        var startTime = _a.startTime, duration = _a.duration, initiatorType = _a.initiatorType;
        notify();
        if (currentPayload && currentPayload.start_time < startTime) {
            // calculate http
            if (['xmlhttprequest', 'fetch'].includes(initiatorType)) {
                // the reason for calculating HTTP duration here is that incompleteReq cannot get the correct start and end times
                requestStartAndEnd.push(startTime, startTime + duration);
                calculateMetric(HTTP_EV_TYPE);
            }
            // calculate resource
            if (!['xmlhttprequest', 'fetch', 'beacon'].includes(initiatorType)) {
                calculateMetric(RESOURCE_EV_TYPE);
            }
        }
    }));
    // attach action id to other data
    var applyOtherReport = function (ev) {
        // if there is a new Page View, forcefully settle the current action
        if (ev.ev_type === PAGEVIEW_EV_TYPE) {
            reportActionIfAllowed(true);
            resetAction();
            return;
        }
        // because http needs to wait timing so http event belongs to the delay-type events, need special correction.
        if (ev.ev_type === HTTP_EV_TYPE) {
            var startTime = ev.payload.response.timing && ev.payload.response.timing.startTime;
            if (!startTime)
                return;
            if (currentPayload && startTime > currentPayload.start_time)
                return currentPayload.id;
            if (lastPayload && startTime > lastPayload.start_time)
                return lastPayload.id;
            return;
        }
        // due to the event loop, the starting time of long task will be earlier than the time of interactive trigger.
        // if there is already a minimum long task blocking before the event occurs
        // it means that this long task does not belong to this action.
        if (ev.ev_type === LONG_TASK_EV_TYPE) {
            var startTime = ev.payload.longtasks.length && ev.payload.longtasks[0].startTime + MIN_LONG_TASK;
            if (currentPayload && startTime && startTime > currentPayload.start_time)
                return currentPayload.id;
            return;
        }
        if (!currentPayload) {
            return;
        }
        // calculate js error and resource
        // because JS error and resource error are synchronous events, they can be attached here.
        if (ev.ev_type === JS_ERROR_EV_TYPE || ev.ev_type === RESOURCE_EV_TYPE) {
            calculateMetric(ev.ev_type);
        }
        return currentPayload.id;
    };
    var initAction = function (target, type) {
        // refresh action id in common
        var actionId = uuid();
        var _a = __read(applyPerformance(performance), 2), now = _a[1];
        // init payload
        currentPayload = {
            start_time: now(),
            id: actionId,
            type: type,
            target: target,
            metrics: {},
        };
        reportWithContext = setCurrentContext();
        start();
    };
    var handleEvent = function (e) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        if (!(e.target instanceof HTMLElement) || !isValidTarget(e.target)) {
            return;
        }
        var name = getActionName(e.target, DEFAULT_ATTR_NAME);
        if (!name) {
            return;
        }
        initAction({ name: name, path: htmlTreeAsString(e.target) }, e.type);
    };
    types &&
        types.forEach(function (t) {
            if (arrayIncludes(SUPPORT_TYPES, t)) {
                tearDownGroup.push(addListenerToDocument(document, t, handleEvent, EVENT_LISTENER_OPTIONS));
            }
        });
    var startAction = function (name, type) {
        // force report last action
        reportActionIfAllowed(true);
        resetAction();
        initAction({ name: name }, type);
    };
    return [applyOtherReport, startAction];
};

var ACTION_MONITOR_PLUGIN_NAME = 'action';
var defaultConfig = {
    types: ["click" /* CLICK */],
    pure: true,
};
function ActionMonitorBasePlugin(client, config) {
    if (config === void 0) { config = defaultConfig; }
    var tearDownGroup = [];
    var document = getDefaultDocument();
    var window = getDefaultBrowser();
    if (!document || !window)
        return;
    var _a = __read(actionGetterWithFetchObserver(function () { return reportWithCurrentContext(client, true); }, tearDownGroup, [
        initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
        initSubjectInGlobal(client, fetchSubject),
        initSubjectInGlobal(client, longtaskSubject),
        initSubjectInGlobal(client, resourceSubject),
    ], config), 2), applyOtherReport = _a[0], startAction = _a[1];
    var listenOtherReport = function (ev) {
        var actionId = applyOtherReport(ev);
        actionId && ev.extra && (ev.extra.action_id = actionId);
        return ev;
    };
    client.on('report', listenOtherReport);
    tearDownGroup.push(function () {
        client.off('report', listenOtherReport);
    });
    client.provide('startAction', startAction);
    registerTearDownGroup(client, ACTION_MONITOR_PLUGIN_NAME, ACTION_EV_TYPE, tearDownGroup);
}
function ActionMonitorPlugin(client) {
    client.on('init', function () {
        var config = getPluginConfig(client, ACTION_MONITOR_PLUGIN_NAME, defaultConfig);
        if (!config) {
            return;
        }
        ActionMonitorBasePlugin(client, config);
    });
}

var HEATMAP_MONITOR_PLUGIN_NAME = 'heatmap';

var defaultPerformancePrecollect = {
    entries: [],
    observer: undefined,
};
var PERFORMANCE_MONITOR_PLUGIN_NAME = 'performance';
function PerformanceMonitorPlugin(client) {
    client.on('init', function () {
        var _a;
        var precollect = client.pp || defaultPerformancePrecollect;
        // clear precollect observer no matter what is configured
        (_a = precollect.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
        var config = getPluginConfig(client, PERFORMANCE_MONITOR_PLUGIN_NAME, {});
        if (!config)
            return;
        var getActivatedObserver = function () { return initSubjectInGlobal(client, activatedSubject); };
        var getHiddenObserver = function () { return initSubjectInGlobal(client, hiddenSubject); };
        var getUnloadObserver = function () { return initSubjectInGlobal(client, unloadSubject); };
        var loadObserver = initSubjectInGlobal(client, loadSubject);
        var longtaskObserver = initSubjectInGlobal(client, longtaskSubject);
        var overrides = undefined;
        var firstPVObserver = initPrivateSubject(client, [FIRST_PV_SUBJECT_NAME, applyFirstPV(client)], -1);
        firstPVObserver[0](function (o) {
            overrides = o;
        })();
        var reportMetric = function (data) {
            // every first screen metrics needs to be associated with the context when client init, but CLS and long task are not included
            var payloadWithOverrides = (data.ev_type === PERFORMANCE_METRIC_EV_TYPE && data.payload.name === CLS[0]) ||
                data.ev_type === LONG_TASK_EV_TYPE
                ? data
                : __assign(__assign({}, data), { overrides: overrides });
            client.report(payloadWithOverrides);
        };
        var getPVObserver = function () { return initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]); };
        [FP, FCP, LCP, FID, CLS].forEach(function (cur) {
            if (config[cur[0]] !== false) {
                var tearDown = [];
                cur[1](reportMetric, tearDown, [getActivatedObserver(), getHiddenObserver, getUnloadObserver, getPVObserver]);
                registerTearDownGroup(client, PERFORMANCE_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, tearDown);
            }
        });
        [LONGTASK, TIMING, MPFID].forEach(function (cur) {
            if (config[cur[0]] !== false) {
                var tearDown = [];
                cur[1](reportMetric, tearDown, [loadObserver, getActivatedObserver, getUnloadObserver(), longtaskObserver]);
                var evType = cur[0] === LONGTASK_METRIC_NAME
                    ? LONG_TASK_EV_TYPE
                    : cur[0] === TIMING_METRIC_NAME
                        ? PERFORMANCE_TIMING_EV_TYPE
                        : PERFORMANCE_METRIC_EV_TYPE;
                registerTearDownGroup(client, PERFORMANCE_MONITOR_PLUGIN_NAME, evType, tearDown);
            }
        });
        // spa_load
        var _b = __read(getSPA$1(client.report.bind(client)), 2), performanceInit = _b[0], performanceSend = _b[1];
        client.provide('performanceInit', performanceInit);
        client.provide('performanceSend', performanceSend);
        // clear precollect data after consumed
        precollect.entries.length = 0;
        // provide custom performance API
        var sendPref = function (customMetric) {
            var payload = __assign(__assign(__assign({}, defaultMetricContext), customMetric), { isCustom: true });
            client.report(wrapPerformanceMetric(payload));
        };
        client.provide('sendCustomPerfMetric', sendPref);
    });
}

var MAX_PAGE_DELAY = 30000;
var getSPA = function (report, tearDownGroup, _a) {
    var _b = __read(_a, 7), pvObserver = _b[0], clickObserver = _b[1], xhrObserver = _b[2], fetchObserver = _b[3], resourceObserver = _b[4], longtaskObserver = _b[5], MutationObserver = _b[6];
    var spa_load_start = 0;
    var reportMetric = applyReportMetric(report);
    var startSPA = function () {
        spa_load_start = now();
        observe(document, {
            childList: true,
            subtree: true,
        });
        start();
    };
    var reportSPAIfAllowed = function (force) {
        // no spa start || not force but there are still pending requests
        if (!spa_load_start || (Object.keys(incompleteReq).length && !force)) {
            return;
        }
        reportMetric(initMetric(SPA_LOAD_METRIC_NAME, now() - spa_load_start));
        endSPA();
    };
    var endSPA = function () {
        complete();
        spa_load_start = 0;
    };
    // get schedule function and set an empty forceClear
    var _c = __read(waitActionComplete(window, reportSPAIfAllowed, noop, MAX_PAGE_DELAY), 3), start = _c[0], notify = _c[1], complete = _c[2];
    // request
    var incompleteReq = applyIncompleteReq(tearDownGroup, [xhrObserver, fetchObserver], notify);
    // resource
    tearDownGroup.push(resourceObserver[0](notify));
    // longtask
    tearDownGroup.push(longtaskObserver[0](notify));
    // dom
    var _d = __read(applyMutationObserver(MutationObserver, notify), 2), observe = _d[0], disconnect = _d[1];
    tearDownGroup.push(disconnect);
    var isFirstPV = true;
    // start SPA when PV change
    tearDownGroup.push(pvObserver[0](function () {
        if (isFirstPV) {
            isFirstPV = false;
            return;
        }
        // force report last SPA
        reportSPAIfAllowed(true);
        // clear status
        endSPA();
        // start a new SPA metric
        startSPA();
    }));
    // force report last SPA and clear status when the click is triggered
    tearDownGroup.push(clickObserver[0](function () {
        // force report last SPA
        reportSPAIfAllowed(true);
        // clear status
        endSPA();
    }));
    // reset SPA status when tear down
    tearDownGroup.push(endSPA);
};

function SPALoadMonitorPlugin(client) {
    client.on('init', function () {
        var tearDownGroup = [];
        var document = getDefaultDocument();
        var MutationObserver = getDefaultMutationObserver();
        if (!document || !MutationObserver)
            return;
        getSPA(client.report.bind(client), tearDownGroup, [
            initPrivateSubject(client, [PV_SUBJECT_NAME, applyPV(client)]),
            initSubjectInGlobal(client, clickSubject),
            initSubjectInGlobal(client, [XHR_SUBJECT_NAME, applyXHR(XMLHttpRequest && XMLHttpRequest.prototype)]),
            initSubjectInGlobal(client, fetchSubject),
            initSubjectInGlobal(client, resourceSubject),
            initSubjectInGlobal(client, longtaskSubject),
            MutationObserver,
        ]);
        client.on('beforeDestroy', function () {
            tearDownGroup.forEach(function (e) { return e(); });
        });
    });
}

var CUSTOM_EVENT_TYPE = 'event';
var CUSTOM_LOG_TYPE = 'log';
var normalizeCustomEventData = function (raw) {
    if (!raw || !isObject(raw)) {
        return;
    }
    // name is required
    if (!raw['name'] || !isString(raw['name'])) {
        return;
    }
    var res = {
        name: raw['name'],
        type: CUSTOM_EVENT_TYPE,
    };
    if ('metrics' in raw && isObject(raw['metrics'])) {
        var rMetrics = raw['metrics'];
        var metrics = {};
        for (var k in rMetrics) {
            if (isNumber(rMetrics[k])) {
                metrics[k] = rMetrics[k];
            }
        }
        res.metrics = metrics;
    }
    if ('categories' in raw && isObject(raw['categories'])) {
        var rCategories = raw['categories'];
        var categories = {};
        for (var k in rCategories) {
            categories[k] = safeStringify(rCategories[k]);
        }
        res.categories = categories;
    }
    return res;
};
var normalizeCustomLogData = function (raw) {
    if (!raw || !isObject(raw)) {
        return;
    }
    // content is required
    if (!raw['content'] || !isString(raw['content'])) {
        return;
    }
    var rContent = raw['content'];
    var res = {
        content: safeStringify(rContent),
        type: CUSTOM_LOG_TYPE,
        level: 'info',
    };
    if ('level' in raw) {
        res.level = raw['level'];
    }
    if ('extra' in raw && isObject(raw['extra'])) {
        var rExtra = raw['extra'];
        var metrics = {};
        var categories = {};
        for (var k in rExtra) {
            if (isNumber(rExtra[k])) {
                metrics[k] = rExtra[k];
            }
            else {
                categories[k] = safeStringify(rExtra[k]);
            }
        }
        res.metrics = metrics;
        res.categories = categories;
    }
    return res;
};
var CustomPlugin = function (client) {
    var sendEvent = function (data) {
        var normalized = normalizeCustomEventData(data);
        if (normalized) {
            client.report({
                ev_type: CUSTOM_EV_TYPE,
                payload: normalized,
                extra: {
                    timestamp: now(),
                },
            });
        }
    };
    var sendLog = function (data) {
        var normalized = normalizeCustomLogData(data);
        if (normalized) {
            client.report({
                ev_type: CUSTOM_EV_TYPE,
                payload: normalized,
                extra: {
                    timestamp: now(),
                },
            });
        }
    };
    client.provide('sendEvent', sendEvent);
    client.provide('sendLog', sendLog);
};

function getNetworkType(netInfo) {
    return (netInfo === null || netInfo === void 0 ? void 0 : netInfo.effectiveType) || (netInfo === null || netInfo === void 0 ? void 0 : netInfo.type) || '';
}
var InjectNetworkTypePlugin = function (client) {
    var netInfo = getDefaultNetworkInformation();
    var network_type = getNetworkType(netInfo);
    if (netInfo) {
        netInfo.onchange = function () {
            network_type = getNetworkType(netInfo);
        };
    }
    client.on('report', function (ev) {
        return __assign(__assign({}, ev), { extra: __assign(__assign({}, (ev.extra || {})), { network_type: network_type }) });
    });
};

/* eslint-disable @typescript-eslint/prefer-for-of */
var withSampleRate = function (ev, sampleRate) {
    var common = ev.common || {};
    common.sample_rate = sampleRate;
    ev.common = common;
    return ev;
};
var hitFnWithRandom = function (preCalc, sampleRate, isHitBySampleRate, random, isHitByRandom) {
    return preCalc
        ? (function (h) { return function () {
            return h;
        }; })(isHitByRandom(random, sampleRate))
        : function () { return isHitBySampleRate(sampleRate); };
};
var parseValues = function (values, type) {
    return values.map(function (v) {
        switch (type) {
            case 'number':
                return Number(v);
            case 'boolean':
                return v === '1';
            case 'string': // default to string
            default:
                return String(v);
        }
    });
};
var checkVal = function (val, values, op) {
    switch (op) {
        case 'eq':
            return arrayIncludes(values, val);
        case 'neq':
            return !arrayIncludes(values, val);
        case 'gt':
            return val > values[0];
        case 'gte':
            return val >= values[0];
        case 'lt':
            return val < values[0];
        case 'lte':
            return val <= values[0];
        case 'regex':
            return Boolean(val.match(new RegExp(values.join('|'))));
        case 'not_regex':
            return !val.match(new RegExp(values.join('|')));
        default: {
            // unknown op
            return false;
        }
    }
};
var checkFilter = function (ev, field, op, values) {
    var val = safeVisit(ev, field, function (t, p) {
        return t[p];
    });
    if (val === undefined) {
        return false;
    }
    var field_type = isBoolean(val) ? 'bool' : isNumber(val) ? 'number' : 'string';
    return checkVal(val, parseValues(values, field_type), op);
};
var matchFilter = function (ev, filter) {
    try {
        return filter.type === 'rule'
            ? checkFilter(ev, filter.field, filter.op, filter.values)
            : filter.type === 'and'
                ? filter.children.every(function (f) { return matchFilter(ev, f); })
                : filter.children.some(function (f) { return matchFilter(ev, f); });
    }
    catch (e) {
        reportSelfError(e);
        return false;
    }
};
var getHitMap = function (rules, preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom) {
    var hitMap = {};
    Object.keys(rules).forEach(function (name) {
        var _a = rules[name], enable = _a.enable, sample_rate = _a.sample_rate, conditional_sample_rules = _a.conditional_sample_rules;
        if (enable) {
            hitMap[name] = {
                enable: enable,
                sample_rate: sample_rate,
                effectiveSampleRate: sample_rate * baseRate,
                hit: hitFnWithRandom(preCalcHit, sample_rate, isHitBySampleRate, random, isHitByRandom),
            };
            if (conditional_sample_rules) {
                hitMap[name].conditional_hit_rules = conditional_sample_rules.map(function (_a) {
                    var s = _a.sample_rate, filter = _a.filter;
                    return ({
                        sample_rate: s,
                        hit: hitFnWithRandom(preCalcHit, s, isHitBySampleRate, random, isHitByRandom),
                        effectiveSampleRate: s * baseRate,
                        filter: filter,
                    });
                });
            }
        }
        else {
            hitMap[name] = {
                enable: enable,
                hit: function () {
                    /* istanbul ignore next */
                    return false;
                },
                sample_rate: 0,
                effectiveSampleRate: 0,
            };
        }
    });
    return hitMap;
};
var getSampler = function (userId, config, isHitBySampleRate, isHitByRandom, destroyFns) {
    if (!config)
        return id;
    // r的设计是为了允许外部传入随机数，用于彻底实现按用户采样
    var baseRate = config.sample_rate, include_users = config.include_users, sample_granularity = config.sample_granularity, rules = config.rules, _a = config.r, random = _a === void 0 ? Math.random() : _a;
    // 用户名单采样
    var userHit = arrayIncludes(include_users, userId);
    if (userHit) {
        return function (ev) { return withSampleRate(ev, 1); };
    }
    // should pre calculate hit
    var preCalcHit = sample_granularity === 'session';
    var baseHit = hitFnWithRandom(preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom);
    var hitMap = getHitMap(rules, preCalcHit, baseRate, isHitBySampleRate, random, isHitByRandom);
    return function (ev) {
        var _a;
        log('[sample]', ev);
        // 总采样必须命中才有后续
        if (!baseHit()) {
            preCalcHit && destroyFns[0]();
            log('[sample] base miss and destroy client');
            return false;
        }
        // 未配置的事件类型
        if (!(ev.ev_type in hitMap)) {
            log('[sample] base hit');
            return withSampleRate(ev, baseRate);
        }
        // 忽略未开启的事件类型
        if (!hitMap[ev.ev_type].enable) {
            preCalcHit && destroyFns[1](ev.ev_type);
            log('[sample]', ev.ev_type, 'disabled and removed tearDownGroup');
            return false;
        }
        // 跳过采样配置
        if ((_a = ev.common) === null || _a === void 0 ? void 0 : _a.sample_rate) {
            log('[sample] skip');
            return ev;
        }
        var hitConfig = hitMap[ev.ev_type];
        var conditions = hitConfig.conditional_hit_rules;
        if (conditions) {
            // 先判断条件采样
            for (var i = 0; i < conditions.length; i++) {
                if (matchFilter(ev, conditions[i].filter)) {
                    log('[sample] filter matched');
                    if (conditions[i].hit()) {
                        log('[sample] filter hit');
                        return withSampleRate(ev, conditions[i].effectiveSampleRate);
                    }
                    log('[sample] filter miss');
                    // 条件匹配后不再搜索
                    return false;
                }
            }
        }
        // 事件类型采样
        if (!hitConfig.hit()) {
            // not hit ev_type and no condition, destroy side effect
            !(conditions && conditions.length) && preCalcHit && destroyFns[1](ev.ev_type);
            log('[sample]', ev.ev_type, 'miss and removed tearDownGroup');
            return false;
        }
        log('[sample] ev_type hit');
        // 事件类型默认采样已经命中
        return withSampleRate(ev, hitConfig.effectiveSampleRate);
    };
};
var SamplePlugin = function (client) {
    client.on('start', function () {
        var _a = client.config(), userId = _a.userId, sample = _a.sample;
        var destroyFns = [
            function () {
                client.destroy();
            },
            function (ev_type) {
                client.destroyAgent.removeByEvType(ev_type);
            },
        ];
        var sampler = getSampler(userId, sample, isHitBySampleRate, isHitByRandom, destroyFns);
        client.on('build', sampler);
    });
};

/* eslint-disable @typescript-eslint/prefer-optional-chain */
var getBeaconTransport = function () {
    var window = getDefaultBrowser();
    // eslint-disable-next-line compat/compat
    return window && window.navigator.sendBeacon
        ? {
            get: function () { },
            post: function (url, data) {
                // eslint-disable-next-line compat/compat
                window.navigator.sendBeacon(url, data);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

var request = function (method, options, XMLHttpRequest) {
    var url = options.url, data = options.data, _a = options.success, success = _a === void 0 ? noop : _a, _b = options.fail, fail = _b === void 0 ? noop : _b, _c = options.getResponseText, getResponseText = _c === void 0 ? noop : _c, _d = options.withCredentials, withCredentials = _d === void 0 ? false : _d;
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = withCredentials;
    xhr.open(method, url, true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onload = function () {
        getResponseText === null || getResponseText === void 0 ? void 0 : getResponseText(this.responseText);
        try {
            if (this.responseText) {
                var result = JSON.parse(this.responseText);
                success(result);
            }
            else {
                success({});
            }
        }
        catch (e) {
            fail(e);
        }
    };
    xhr.onerror = function () {
        fail(new Error('Network request failed'));
    };
    xhr.onabort = function () {
        /* istanbul ignore next */
        fail(new Error('Network request aborted'));
    };
    xhr.send(data);
};
var getXhrTransport = function () {
    var XMLHttpRequest = getDefaultXMLHttpRequest();
    return XMLHttpRequest
        ? {
            useBeacon: true,
            get: function (options) {
                request('GET', options, XMLHttpRequest);
            },
            post: function (options) {
                request('POST', options, XMLHttpRequest);
            },
        }
        : {
            get: noop,
            post: noop,
        };
};

// createSender has side effects(register onClose behavior)
// so it must be create lazily
function createBrowserSender(config) {
    var sender = createBatchSender(config);
    var originSend = sender.send;
    // send the cached data immediately upon unload
    onPageUnload(function () {
        // use sendBeacon if allowed
        if (config.transport.useBeacon) {
            var beaconTransport_1 = getBeaconTransport();
            var data = sender.getBatchData();
            if (data) {
                beaconTransport_1.post(sender.getEndpoint(), data);
                sender.clear();
            }
            // some data may still be generated during unload
            sender.send = function (data) {
                beaconTransport_1.post(sender.getEndpoint(), stringifyBatch([data]));
            };
            // in webview, page can still be resurrected even after the `unload` event has been triggered
            onPageNextShow(function () {
                sender.send = originSend;
            });
        }
        else {
            // if not use sendBeacon, flush the data list by default
            sender.flush();
        }
    });
    return sender;
}

export { ACTION_EV_TYPE, ACTION_MONITOR_PLUGIN_NAME, ACTIVATED_SUBJECT_NAME, AJAX_MONITOR_PLUGIN_NAME, ActionMonitorBasePlugin, ActionMonitorPlugin, AjaxMonitorBasePlugin, AjaxMonitorPlugin, AjaxMonitorVolPlugin, BLANK_SCREEN_EV_TYPE, BLANK_SCREEN_MONITOR_PLUGIN_NAME, BREADCRUMB_MONITOR_PLUGIN_NAME, BlankScreenMonitorPlugin, BlankScreenMonitorVolPlugin, BreadcrumbMonitorBasePlugin, BreadcrumbMonitorPlugin, CUSTOM_EV_TYPE, CustomPlugin, DEFAULT_STORAGE_EXPIRES, DOMContentLoadSubject, DOM_CONTENT_LOAD_SUBJECT_NAME, FETCH_MONITOR_PLUGIN_NAME, FIDMonitorPlugin, FID_MONITOR_PLUGIN_NAME, FIRST_PV_SUBJECT_NAME, FMPMonitorBasePlugin, FMPMonitorPlugin, FMP_MONITOR_PLUGIN_NAME, FetchMonitorBasePlugin, FetchMonitorPlugin, FetchMonitorVolPlugin, HEATMAP_EV_TYPE, HEATMAP_MONITOR_PLUGIN_NAME, HIDDEN_SUBJECT_NAME, HTTP_EV_TYPE, INPMonitorPlugin, INP_MONITOR_PLUGIN_NAME, InjectNetworkTypePlugin, JS_ERROR_EV_TYPE, JS_ERROR_MONITOR_PLUGIN_NAME, JsErrorMonitorBasePlugin, JsErrorMonitorPlugin, LOAD_SUBJECT_NAME, LONG_TASK_EV_TYPE, MPFIDMonitorPlugin, MPFID_MONITOR_PLUGIN_NAME, PAGEVIEW_EV_TYPE, PAGEVIEW_MONITOR_PLUGIN_NAME, PERFORMANCE_METRIC_EV_TYPE, PERFORMANCE_MONITOR_PLUGIN_NAME, PERFORMANCE_TIMING_EV_TYPE, PV_SUBJECT_NAME, PageviewMonitorBasePlugin, PageviewMonitorPlugin, PerformanceMonitorPlugin, RESOURCE_ERROR_EV_TYPE, RESOURCE_ERROR_MONITOR_PLUGIN_NAME, RESOURCE_EV_TYPE, RESOURCE_MONITOR_PLUGIN_NAME, ResourceErrorMonitorPlugin, ResourceMonitorBasePlugin, ResourceMonitorPlugin, SCREEN_SHOT_FILE_NAME, SESSION_EV_TYPE, SPALoadMonitorPlugin, SamplePlugin, TTIMonitorBasePlugin, TTIMonitorPlugin, TTI_MONITOR_PLUGIN_NAME, UNKNOWN_PATH, UNLOAD_SUBJECT_NAME, activatedSubject, addListenerToDocument, addListenerToWindow, applyAnimationFrame, applyFirstPV, applyMonitor, applyMutationObserver, applyPV, applyPerformance, applyPerformanceObserver$1 as applyPerformanceObserver, applyRequestIdleCallback, applyUpdate, captureCurrentContext, clearTimerWithTearDowns, createBatchSender, createBrowserSender, decodeWithBase64, defaultPerformancePrecollect, encodeToBase64, formatStorageExpires, getBeaconTransport, getConfig, getCurrentScript, getDefaultBrowser, getDefaultCaf, getDefaultDocument, getDefaultFetch, getDefaultHistory, getDefaultLocation, getDefaultMutationObserver, getDefaultNavigator, getDefaultNetworkInformation, getDefaultPerformance, getDefaultPerformanceEventTiming, getDefaultPerformanceObserver, getDefaultPerformanceTiming, getDefaultPromise, getDefaultRaf, getDefaultXMLHttpRequest, getFullUrl, getGlobalRegistry, getLocationUrl, getNetworkType, getOverrides, getPluginConfig, getSampler, getStorageWithDecoding, getViewId, getViewOverrides, getXhrTransport, hiddenSubject, htmlTreeAsString, invokeCallbackOnce, isSupportEncrypt, loadScript, loadSubject, normalizeCustomEventData, normalizeCustomLogData, normalizeUnknownError, now, observeActivated, observeDOMContentLoad, observeHidden, observeLoad, observeUnload, onPageLoad, onPageNextShow, onPageUnload, parseUrl, readyStateIsComplete, removeStorageItem, reportSelfError, reportWithCurrentContext, setStorageWithEncoding, setTraceContext, setVolTraceContext, syncReportWithCapturedContext, unloadSubject, uuid4, visibilityStateIsHidden };//# sourceMappingURL=https://trae.private/sourcemaps/424b4bd987c6c6a4cadf1a08da420593cc6bf75a/node_modules/@slardar/base/node_modules/@slardar/sdk-web/dist/index.esm.js.map
